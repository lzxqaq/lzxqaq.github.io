<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>算法 on 罗泽勋</title>
    <link>/categories/%E7%AE%97%E6%B3%95/</link>
    <description>Recent content in 算法 on 罗泽勋</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Fri, 14 Jan 2022 20:42:19 +0800</lastBuildDate>
    <atom:link href="/categories/%E7%AE%97%E6%B3%95/" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>【转载】C&#43;&#43; 开发必备之算法</title>
      <link>/post/2022/01/14/algorithm/</link>
      <pubDate>Fri, 14 Jan 2022 20:42:19 +0800</pubDate>
      
      <guid>/post/2022/01/14/algorithm/</guid>
      <description>
        <![CDATA[
        <p>转载自<a href="https://github.com/huihut/interview">https://github.com/huihut/interview</a></p>
<h3 id="排序">排序</h3>
<table>
<thead>
<tr>
<th>排序算法</th>
<th>平均时间复杂度</th>
<th>最差时间复杂度</th>
<th>空间复杂度</th>
<th>数据对象稳定性</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="Algorithm/BubbleSort.h">冒泡排序</a></td>
<td>O(n<sup>2</sup>)</td>
<td>O(n<sup>2</sup>)</td>
<td>O(1)</td>
<td>稳定</td>
</tr>
<tr>
<td><a href="Algorithm/SelectionSort.h">选择排序</a></td>
<td>O(n<sup>2</sup>)</td>
<td>O(n<sup>2</sup>)</td>
<td>O(1)</td>
<td>数组不稳定、链表稳定</td>
</tr>
<tr>
<td><a href="Algorithm/InsertSort.h">插入排序</a></td>
<td>O(n<sup>2</sup>)</td>
<td>O(n<sup>2</sup>)</td>
<td>O(1)</td>
<td>稳定</td>
</tr>
<tr>
<td><a href="Algorithm/QuickSort.h">快速排序</a></td>
<td>O(n*log<sub>2</sub>n)</td>
<td>O(n<sup>2</sup>)</td>
<td>O(log<sub>2</sub>n)</td>
<td>不稳定</td>
</tr>
<tr>
<td><a href="Algorithm/HeapSort.cpp">堆排序</a></td>
<td>O(n*log<sub>2</sub>n)</td>
<td>O(n*log<sub>2</sub>n)</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
<tr>
<td><a href="Algorithm/MergeSort.h">归并排序</a></td>
<td>O(n*log<sub>2</sub>n)</td>
<td>O(n*log<sub>2</sub>n)</td>
<td>O(n)</td>
<td>稳定</td>
</tr>
<tr>
<td><a href="Algorithm/ShellSort.h">希尔排序</a></td>
<td>O(n*log<sup>2</sup>n)</td>
<td>O(n<sup>2</sup>)</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
<tr>
<td><a href="Algorithm/CountSort.cpp">计数排序</a></td>
<td>O(n+m)</td>
<td>O(n+m)</td>
<td>O(n+m)</td>
<td>稳定</td>
</tr>
<tr>
<td><a href="Algorithm/BucketSort.cpp">桶排序</a></td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(m)</td>
<td>稳定</td>
</tr>
<tr>
<td><a href="Algorithm/RadixSort.h">基数排序</a></td>
<td>O(k*n)</td>
<td>O(n<sup>2</sup>)</td>
<td></td>
<td>稳定</td>
</tr>
</tbody>
</table>
<blockquote>
<ul>
<li>均按从小到大排列</li>
<li>k：代表数值中的 “数位” 个数</li>
<li>n：代表数据规模</li>
<li>m：代表数据的最大值减最小值</li>
<li>来自：<a href="https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95">wikipedia . 排序算法</a></li>
</ul>
</blockquote>
<h3 id="查找">查找</h3>
<table>
<thead>
<tr>
<th>查找算法</th>
<th>平均时间复杂度</th>
<th>空间复杂度</th>
<th>查找条件</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="Algorithm/SequentialSearch.h">顺序查找</a></td>
<td>O(n)</td>
<td>O(1)</td>
<td>无序或有序</td>
</tr>
<tr>
<td><a href="Algorithm/BinarySearch.h">二分查找（折半查找）</a></td>
<td>O(log<sub>2</sub>n)</td>
<td>O(1)</td>
<td>有序</td>
</tr>
<tr>
<td><a href="Algorithm/InsertionSearch.h">插值查找</a></td>
<td>O(log<sub>2</sub>(log<sub>2</sub>n))</td>
<td>O(1)</td>
<td>有序</td>
</tr>
<tr>
<td><a href="Algorithm/FibonacciSearch.cpp">斐波那契查找</a></td>
<td>O(log<sub>2</sub>n)</td>
<td>O(1)</td>
<td>有序</td>
</tr>
<tr>
<td><a href="DataStructure/HashTable.cpp">哈希查找</a></td>
<td>O(1)</td>
<td>O(n)</td>
<td>无序或有序</td>
</tr>
<tr>
<td><a href="Algorithm/BSTSearch.h">二叉查找树（二叉搜索树查找）</a></td>
<td>O(log<sub>2</sub>n)</td>
<td></td>
<td></td>
</tr>
<tr>
<td><a href="DataStructure/RedBlackTree.cpp">红黑树</a></td>
<td>O(log<sub>2</sub>n)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>2-3树</td>
<td>O(log<sub>2</sub>n - log<sub>3</sub>n)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>B树/B+树</td>
<td>O(log<sub>2</sub>n)</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="图搜索算法">图搜索算法</h3>
<table>
<thead>
<tr>
<th>图搜索算法</th>
<th>数据结构</th>
<th>遍历时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://zh.wikipedia.org/wiki/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2">BFS广度优先搜索</a></td>
<td>邻接矩阵<br/>邻接链表</td>
<td>O(|v|<sup>2</sup>)<br/>O(|v|+|E|)</td>
<td>O(|v|<sup>2</sup>)<br/>O(|v|+|E|)</td>
</tr>
<tr>
<td><a href="https://zh.wikipedia.org/wiki/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2">DFS深度优先搜索</a></td>
<td>邻接矩阵<br/>邻接链表</td>
<td>O(|v|<sup>2</sup>)<br/>O(|v|+|E|)</td>
<td>O(|v|<sup>2</sup>)<br/>O(|v|+|E|)</td>
</tr>
</tbody>
</table>
<h3 id="其他算法">其他算法</h3>
<table>
<thead>
<tr>
<th>算法</th>
<th>思想</th>
<th>应用</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://zh.wikipedia.org/wiki/%E5%88%86%E6%B2%BB%E6%B3%95">分治法</a></td>
<td>把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并</td>
<td><a href="https://github.com/huihut/interview/tree/master/Problems/RoundRobinProblem">循环赛日程安排问题</a>、排序算法（快速排序、归并排序）</td>
</tr>
<tr>
<td><a href="https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92">动态规划</a></td>
<td>通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法，适用于有重叠子问题和最优子结构性质的问题</td>
<td><a href="https://github.com/huihut/interview/tree/master/Problems/KnapsackProblem">背包问题</a>、斐波那契数列</td>
</tr>
<tr>
<td><a href="https://zh.wikipedia.org/wiki/%E8%B4%AA%E5%BF%83%E6%B3%95">贪心法</a></td>
<td>一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是最好或最优的算法</td>
<td>旅行推销员问题（最短路径问题）、最小生成树、哈夫曼编码</td>
</tr>
</tbody>
</table>

        
        ]]>
      </description>
    </item>
    
    
  </channel>
</rss>
