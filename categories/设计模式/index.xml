<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>设计模式 on 糸色先生</title>
    <link>/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link>
    <description>Recent content in 设计模式 on 糸色先生</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Tue, 28 Dec 2021 08:07:08 +0800</lastBuildDate>
    <atom:link href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>【转载】面向对象设计原则之开闭原则</title>
      <link>/post/2021/12/28/oop/</link>
      <pubDate>Tue, 28 Dec 2021 08:07:08 +0800</pubDate>
      <author>糸色先生</author>
      <guid>/post/2021/12/28/oop/</guid>
      <description>
        <![CDATA[
        <p>转载自<a href="https://blog.csdn.net/lovelion/article/details/17517213">https://blog.csdn.net/lovelion/article/details/17517213</a></p>
<p>开闭原则是面向对象的可复用设计的第一块基石，它是最重要的面向对象设计原则。开闭原则由Bertrand  Meyer于1988年提出，其定义如下：</p>
<blockquote>
<p>开闭原则(Open-Closed Principle, OCP)：一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。</p>
</blockquote>
<p>在开闭原则的定义中，软件实体可以指一个软件模块、一个由多个类组成的局部结构或一个独立的类。</p>
<p>任何软件都需要面临一个很重要的问题，即它们的需求会随时间的推移而发生变化。当软件系统需要面对新的需求时，我们应该尽量保证系统的设计框架是稳定的。如果一个软件设计符合开闭原则，那么可以非常方便地对系统进行扩展，而且在扩展时无须修改现有代码，使得软件系统在拥有适应性和灵活性的同时具备较好的稳定性和延续性。随着软件规模越来越大，软件寿命越来越长，软件维护成本越来越高，设计满足开闭原则的软件系统也变得越来越重要。</p>
<p>为了满足开闭原则，需要对系统进行抽象化设计，抽象化是开闭原则的关键。在Java、C#等编程语言中，可以为系统定义一个相对稳定的抽象层，而将不同的实现行为移至具体的实现层中完成。在很多面向对象编程语言中都提供了接口、抽象类等机制，可以通过它们定义系统的抽象层，再通过具体类来进行扩展。如果需要修改系统的行为，无须对抽象层进行任何改动，只需要增加新的具体类来实现新的业务功能即可，实现在不修改已有代码的基础上扩展系统的功能，达到开闭原则的要求。</p>
<blockquote>
<p>Sunny软件公司开发的CRM系统可以显示各种类型的图表，如饼状图和柱状图等，为了支持多种图表显示方式，原始设计方案如图1所示：</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2021-12-28/ocp1.jpg" alt="img"></p>
<p>图1 初始设计方案结构图</p>
<p>在ChartDisplay类的display()方法中存在如下代码片段：</p>
<pre tabindex="0"><code>......
if (type.equals(&quot;pie&quot;)) {
PieChart chart = new PieChart();
chart.display();
}
else if (type.equals(&quot;bar&quot;)) {
BarChart chart = new BarChart();
chart.display();
}
......
</code></pre><p>在该代码中，如果需要增加一个新的图表类，如折线图LineChart，则需要修改ChartDisplay类的display()方法的源代码，增加新的判断逻辑，违反了开闭原则。</p>
<p>现对该系统进行重构，使之符合开闭原则。</p>
<p>在本实例中，由于在ChartDisplay类的display()方法中针对每一个图表类编程，因此增加新的图表类不得不修改源代码。可以通过抽象化的方式对系统进行重构，使之增加新的图表类时无须修改源代码，满足开闭原则。具体做法如下：</p>
<p>(1) 增加一个抽象图表类AbstractChart，将各种具体图表类作为其子类；</p>
<p>(2)  ChartDisplay类针对抽象图表类进行编程，由客户端来决定使用哪种具体图表。</p>
<p>重构后结构如图2所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2021-12-28/ocp2.jpg" alt="img"></p>
<p>图2 重构后的结构图</p>
<p>在图2中，我们引入了抽象图表类AbstractChart，且ChartDisplay针对抽象图表类进行编程，并通过setChart()方法由客户端来设置实例化的具体图表对象，在ChartDisplay的display()方法中调用chart对象的display()方法显示图表。如果需要增加一种新的图表，如折线图LineChart，只需要将LineChart也作为AbstractChart的子类，在客户端向ChartDisplay中注入一个LineChart对象即可，无须修改现有类库的源代码。</p>
<p>注意：因为xml和properties等格式的配置文件是纯文本文件，可以直接通过VI编辑器或记事本进行编辑，且无须编译，因此在软件开发中，一般不把对配置文件的修改认为是对系统源代码的修改。如果一个系统在扩展时只涉及到修改配置文件，而原有的Java代码或C#代码没有做任何修改，该系统即可认为是一个符合开闭原则的系统。</p>

        
        ]]>
      </description>
    </item>
    
    
    
    <item>
      <title>【转载】面向对象设计原则之单一职责原则</title>
      <link>/post/2021/12/28/singleresponsibility/</link>
      <pubDate>Tue, 28 Dec 2021 07:40:16 +0800</pubDate>
      <author>糸色先生</author>
      <guid>/post/2021/12/28/singleresponsibility/</guid>
      <description>
        <![CDATA[
        <p>转载自<a href="https://blog.csdn.net/lovelion/article/details/17517213">https://blog.csdn.net/lovelion/article/details/17517213</a></p>
<p>单一职责原则是最简单的面向对象设计原则，它用于控制类的粒度大小。单一职责原则定义如下：</p>
<p>单一职责原则(Single Responsibility Principle, SRP)：一个类只负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。</p>
<p>单一职责原则告诉我们：一个类不能太“累”！在软件系统中，一个类（大到模块，小到方法）承担的职责越多，它被复用的可能性就越小，而且一个类承担的职责过多，就相当于将这些职责耦合在一起，当其中一个职责变化时，可能会影响其他职责的运作，因此要将这些职责进行分离，将不同的职责封装在不同的类中，即将不同的变化原因封装在不同的类中，如果多个职责总是同时发生改变则可将它们封装在同一类中。</p>
<p>单一职责原则是实现高内聚、低耦合的指导方针，它是最简单但又最难运用的原则，需要设计人员发现类的不同职责并将其分离，而发现类的多重职责需要设计人员具有较强的分析设计能力和相关实践经验。</p>
<p>下面通过一个简单实例来进一步分析单一职责原则：</p>
<blockquote>
<p>Sunny软件公司开发人员针对某CRM（Customer Relationship  Management，客户关系管理）系统中客户信息图形统计模块提出了如图1所示初始设计方案：</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2021-12-28/srp.jpg" alt="img">
图1  初始设计方案结构图</p>
<blockquote>
<p>在图1中，CustomerDataChart类中的方法说明如下：getConnection()方法用于连接数据库，findCustomers()用于查询所有的客户信息，createChart()用于创建图表，displayChart()用于显示图表。</p>
</blockquote>
<p>现使用单一职责原则对其进行重构。</p>
<p>在图1中，CustomerDataChart类承担了太多的职责，既包含与数据库相关的方法，又包含与图表生成和显示相关的方法。如果在其他类中也需要连接数据库或者使用findCustomers()方法查询客户信息，则难以实现代码的重用。无论是修改数据库连接方式还是修改图表显示方式都需要修改该类，它不止一个引起它变化的原因，违背了单一职责原则。因此需要对该类进行拆分，使其满足单一职责原则，类CustomerDataChart可拆分为如下三个类：</p>
<p>(1) DBUtil：负责连接数据库，包含数据库连接方法getConnection()；</p>
<p>(2) CustomerDAO：负责操作数据库中的Customer表，包含对Customer表的增删改查等方法，如findCustomers()；</p>
<p>(3) CustomerDataChart：负责图表的生成和显示，包含方法createChart()和displayChart()。</p>
<p>使用单一职责原则重构后的结构如图2所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2021-12-28/srp2.jpg" alt="img">
图2  重构后的结构图</p>

        
        ]]>
      </description>
    </item>
    
    
    
    <item>
      <title>【转载】面向对象设计原则概述</title>
      <link>/post/2021/12/28/oop/</link>
      <pubDate>Tue, 28 Dec 2021 06:59:01 +0800</pubDate>
      <author>糸色先生</author>
      <guid>/post/2021/12/28/oop/</guid>
      <description>
        <![CDATA[
        <p>转载自<a href="https://blog.csdn.net/lovelion/article/details/17517213">https://blog.csdn.net/lovelion/article/details/17517213</a></p>
<p>对于面向对象软件系统的设计而言，在支持可维护性的同时，提高系统的可复用性是一个至关重要的问题，如何同时提高一个软件系统的可维护性和可复用性是面向对象设计需要解决的核心问题之一。在面向对象设计中，可维护性的复用是以设计原则为基础的。每一个原则都蕴含一些面向对象设计的思想，可以从不同的角度提升一个软件结构的设计水平。</p>
<p>面向对象设计原则为支持可维护性复用而诞生，这些原则蕴含在很多设计模式中，它们是从许多设计方案中总结出的指导性原则。面向对象设计原则也是我们用于评价一个设计模式的使用效果的重要指标之一，在设计模式的学习中，大家经常会看到诸如“XXX模式符合XXX原则”、“XXX模式违反了XXX原则”这样的语句。</p>
<p>最常见的7种面向对象设计原则如下表所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2021-12-28/oop.png" alt="img"></p>

        
        ]]>
      </description>
    </item>
    
    
    
    <item>
      <title>【转载】简单工厂模式</title>
      <link>/post/2021/12/28/singlefactory/</link>
      <pubDate>Tue, 28 Dec 2021 06:50:56 +0800</pubDate>
      <author>糸色先生</author>
      <guid>/post/2021/12/28/singlefactory/</guid>
      <description>
        <![CDATA[
        <p>转载自<a href="https://blog.csdn.net/lovelion/article/details/17517213">https://blog.csdn.net/lovelion/article/details/17517213</a></p>
<p>工厂模式是最常用的一类创建型设计模式，通常我们所说的工厂模式是指工厂方法模式，它也是使用频率最高的工厂模式。本章将要学习的简单工厂模式是工厂方法模式的“小弟”，它不属于GoF 23种设计模式，但在软件开发中应用也较为频繁，通常将它作为学习其他工厂模式的入门。此外，工厂方法模式还有一位“大哥”——抽象工厂模式。这三种工厂模式各具特色，难度也逐个加大，在软件开发中它们都得到了广泛的应用，成为面向对象软件中常用的创建对象的工具。</p>
<h3 id="一图表库的设计">一、图表库的设计</h3>
<blockquote>
<p>Sunny软件公司欲基于Java语言开发一套图表库，该图表库可以为应用系统提供各种不同外观的图表，例如柱状图、饼状图、折线图等。Sunny软件公司图表库设计人员希望为应用系统开发人员提供一套灵活易用的图表库，而且可以较为方便地对图表库进行扩展，以便能够在将来增加一些新类型的图表。</p>
</blockquote>
<p>Sunny软件公司图表库设计人员提出了一个初始设计方案，将所有图表的实现代码封装在一个Chart类中，其框架代码如下所示：</p>
<pre tabindex="0"><code>class Chart {
private String type; //图表类型

public Chart(Object[][] data, String type) {
this.type = type;
if (type.equalsIgnoreCase(&quot;histogram&quot;)) {
    //初始化柱状图
}
else if (type.equalsIgnoreCase(&quot;pie&quot;)) {
    //初始化饼状图
}
else if (type.equalsIgnoreCase(&quot;line&quot;)) {
    //初始化折线图
}
}

public void display() {
if (this.type.equalsIgnoreCase(&quot;histogram&quot;)) {
    //显示柱状图
}
else if (this.type.equalsIgnoreCase(&quot;pie&quot;)) {
    //显示饼状图
}
else if (this.type.equalsIgnoreCase(&quot;line&quot;)) {
    //显示折线图
}	
}
}
</code></pre><p>客户端代码通过调用Chart类的构造函数来创建图表对象，根据参数type的不同可以得到不同类型的图表，然后再调用display()方法来显示相应的图表。</p>
<p>不难看出，Chart类是一个“巨大的”类，在该类的设计中存在如下几个问题：</p>
<p>(1) 在Chart类中包含很多“if…else…”代码块，整个类的代码相当冗长，代码越长，阅读难度、维护难度和测试难度也越大；而且大量条件语句的存在还将影响系统的性能，程序在执行过程中需要做大量的条件判断。</p>
<p>(2) Chart类的职责过重，它负责初始化和显示所有的图表对象，将各种图表对象的初始化代码和显示代码集中在一个类中实现，违反了“单一职责原则”，不利于类的重用和维护；而且将大量的对象初始化代码都写在构造函数中将导致构造函数非常庞大，对象在创建时需要进行条件判断，降低了对象创建的效率。</p>
<p>(3) 当需要增加新类型的图表时，必须修改Chart类的源代码，违反了“开闭原则”。</p>
<p>(4) 客户端只能通过new关键字来直接创建Chart对象，Chart类与客户端类耦合度较高，对象的创建和使用无法分离。</p>
<p>(5) 客户端在创建Chart对象之前可能还需要进行大量初始化设置，例如设置柱状图的颜色、高度等，如果在Chart类的构造函数中没有提供一个默认设置，那就只能由客户端来完成初始设置，这些代码在每次创建Chart对象时都会出现，导致代码的重复。</p>
<p>面对一个如此巨大、职责如此重，且与客户端代码耦合度非常高的类，我们应该怎么办？本章将要介绍的简单工厂模式将在一定程度上解决上述问题。</p>
<h3 id="二简单工厂模式概述">二、简单工厂模式概述</h3>
<p>简单工厂模式并不属于GoF 23个经典设计模式，但通常将它作为学习其他工厂模式的基础，它的设计思想很简单，其基本流程如下：</p>
<p>首先将需要创建的各种不同对象（例如各种不同的Chart对象）的相关代码封装到不同的类中，这些类称为具体产品类，而将它们公共的代码进行抽象和提取后封装在一个抽象产品类中，每一个具体产品类都是抽象产品类的子类；然后提供一个工厂类用于创建各种产品，在工厂类中提供一个创建产品的工厂方法，该方法可以根据所传入的参数不同创建不同的具体产品对象；客户端只需调用工厂类的工厂方法并传入相应的参数即可得到一个产品对象。</p>
<p>简单工厂模式定义如下：</p>
<p>简单工厂模式(Simple Factory Pattern)：定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。因为在简单工厂模式中用于创建实例的方法是静态(static)方法，因此简单工厂模式又被称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。</p>
<p>简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。简单工厂模式结构比较简单，其核心是工厂类的设计，其结构如图1所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2021-12-28/factory1.jpeg" alt="img"></p>
<p>在简单工厂模式结构图中包含如下几个角色：</p>
<ul>
<li>
<p>Factory（工厂角色）：工厂角色即工厂类，它是简单工厂模式的核心，负责实现创建所有产品实例的内部逻辑；工厂类可以被外界直接调用，创建所需的产品对象；在工厂类中提供了静态的工厂方法factoryMethod()，它的返回类型为抽象产品类型Product。</p>
</li>
<li>
<p>Product（抽象产品角色）：它是工厂类所创建的所有对象的父类，封装了各种产品对象的公有方法，它的引入将提高系统的灵活性，使得在工厂类中只需定义一个通用的工厂方法，因为所有创建的具体产品对象都是其子类对象。</p>
</li>
<li>
<p>ConcreteProduct（具体产品角色）：它是简单工厂模式的创建目标，所有被创建的对象都充当这个角色的某个具体类的实例。每一个具体产品角色都继承了抽象产品角色，需要实现在抽象产品中声明的抽象方法。</p>
</li>
</ul>
<p>在简单工厂模式中，客户端通过工厂类来创建一个产品类的实例，而无须直接使用new关键字来创建对象，它是工厂模式家族中最简单的一员。</p>
<p>在使用简单工厂模式时，首先需要对产品类进行重构，不能设计一个包罗万象的产品类，而需根据实际情况设计一个产品层次结构，将所有产品类公共的代码移至抽象产品类，并在抽象产品类中声明一些抽象方法，以供不同的具体产品类来实现，典型的抽象产品类代码如下所示：</p>
<pre tabindex="0"><code>abstract class Product {
//所有产品类的公共业务方法
public void methodSame() {
//公共方法的实现
}

//声明抽象业务方法
public abstract void methodDiff();
}

</code></pre><p>在具体产品类中实现了抽象产品类中声明的抽象业务方法，不同的具体产品类可以提供不同的实现，典型的具体产品类代码如下所示：</p>
<pre tabindex="0"><code>class ConcreteProduct extends Product {
//实现业务方法
public void methodDiff() {
//业务方法的实现
}
}
</code></pre><p>简单工厂模式的核心是工厂类，在没有工厂类之前，客户端一般会使用new关键字来直接创建产品对象，而在引入工厂类之后，客户端可以通过工厂类来创建产品，在简单工厂模式中，工厂类提供了一个静态工厂方法供客户端使用，根据所传入的参数不同可以创建不同的产品对象，典型的工厂类代码如下所示：</p>
<pre tabindex="0"><code>class Factory {
//静态工厂方法
public static Product getProduct(String arg) {
Product product = null;
if (arg.equalsIgnoreCase(&quot;A&quot;)) {
    product = new ConcreteProductA();
    //初始化设置product
}
else if (arg.equalsIgnoreCase(&quot;B&quot;)) {
    product = new ConcreteProductB();
    //初始化设置product
}
return product;
}
}
</code></pre><p>在客户端代码中，我们通过调用工厂类的工厂方法即可得到产品对象，典型代码如下所示：</p>
<pre tabindex="0"><code>class Client {
public static void main(String args[]) {
Product product; 
product = Factory.getProduct(&quot;A&quot;); //通过工厂类创建产品对象
product.methodSame();
product.methodDiff();
}
}
</code></pre><h3 id="三完整解决方案">三、完整解决方案</h3>
<p>为了将Chart类的职责分离，同时将Chart对象的创建和使用分离，Sunny软件公司开发人员决定使用简单工厂模式对图表库进行重构，重构后的结构如图2所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2021-12-28/factory2.jpeg" alt="img"></p>
<p>在上图中，Chart接口充当抽象产品类，其子类HistogramChart、PieChart和LineChart充当具体产品类，ChartFactory充当工厂类。完整代码如下所示：</p>
<pre tabindex="0"><code>//抽象图表接口：抽象产品类
interface Chart {
public void display();
}

//柱状图类：具体产品类
class HistogramChart implements Chart {
public HistogramChart() {
System.out.println(&quot;创建柱状图！&quot;);
}

public void display() {
System.out.println(&quot;显示柱状图！&quot;);
}
}

//饼状图类：具体产品类
class PieChart implements Chart {
public PieChart() {
System.out.println(&quot;创建饼状图！&quot;);
}

public void display() {
System.out.println(&quot;显示饼状图！&quot;);
}
}

//折线图类：具体产品类
class LineChart implements Chart {
public LineChart() {
System.out.println(&quot;创建折线图！&quot;);
}

public void display() {
System.out.println(&quot;显示折线图！&quot;);
}
}

//图表工厂类：工厂类
class ChartFactory {
//静态工厂方法
public static Chart getChart(String type) {
Chart chart = null;
if (type.equalsIgnoreCase(&quot;histogram&quot;)) {
    chart = new HistogramChart();
    System.out.println(&quot;初始化设置柱状图！&quot;);
}
else if (type.equalsIgnoreCase(&quot;pie&quot;)) {
    chart = new PieChart();
    System.out.println(&quot;初始化设置饼状图！&quot;);
}
else if (type.equalsIgnoreCase(&quot;line&quot;)) {
    chart = new LineChart();
    System.out.println(&quot;初始化设置折线图！&quot;);			
}
return chart;
}
}
</code></pre><p>编写如下客户端测试代码：</p>
<pre tabindex="0"><code>class Client {
public static void main(String args[]) {
Chart chart;
chart = ChartFactory.getChart(&quot;histogram&quot;); //通过静态工厂方法创建产品
chart.display();
}
}
</code></pre><p>编译并运行程序，输出结果如下：</p>
<pre tabindex="0"><code>创建柱状图！

初始化设置柱状图！

显示柱状图！
</code></pre><p>在客户端测试类中，我们使用工厂类的静态工厂方法创建产品对象，如果需要更换产品，只需修改静态工厂方法中的参数即可，例如将柱状图改为饼状图，只需将代码：</p>
<pre tabindex="0"><code>chart = ChartFactory.getChart(&quot;histogram&quot;);
</code></pre><p>改为：</p>
<pre tabindex="0"><code>chart = ChartFactory.getChart(&quot;pie&quot;);
</code></pre><p>编译并运行程序，输出结果如下：</p>
<pre tabindex="0"><code>创建饼状图！

初始化设置饼状图！

显示饼状图！
</code></pre><h3 id="四方案的改进">四、方案的改进</h3>
<p>Sunny软件公司开发人员发现在创建具体Chart对象时，每更换一个Chart对象都需要修改客户端代码中静态工厂方法的参数，客户端代码将要重新编译，这对于客户端而言，违反了“开闭原则”，有没有一种方法能够在不修改客户端代码的前提下更换具体产品对象呢？答案是肯定的，下面将介绍一种常用的实现方式。</p>
<p>我们可以将静态工厂方法的参数存储在XML或properties格式的配置文件中，如下config.xml所示：</p>
<pre tabindex="0"><code>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;config&gt;
&lt;chartType&gt;histogram&lt;/chartType&gt;
&lt;/config&gt;
</code></pre><p>再通过一个工具类XMLUtil来读取配置文件中的字符串参数，XMLUtil类的代码如下所示：</p>
<pre tabindex="0"><code>import javax.xml.parsers.*;
import org.w3c.dom.*;
import org.xml.sax.SAXException;
import java.io.*;

public class XMLUtil {
//该方法用于从XML配置文件中提取图表类型，并返回类型名
public static String getChartType() {
try {
    //创建文档对象
    DocumentBuilderFactory dFactory = DocumentBuilderFactory.newInstance();
    DocumentBuilder builder = dFactory.newDocumentBuilder();
    Document doc;							
    doc = builder.parse(new File(&quot;config.xml&quot;)); 

    //获取包含图表类型的文本节点
    NodeList nl = doc.getElementsByTagName(&quot;chartType&quot;);
    Node classNode = nl.item(0).getFirstChild();
    String chartType = classNode.getNodeValue().trim();
    return chartType;
}   
catch(Exception e) {
    e.printStackTrace();
    return null;
}
}
}
</code></pre><p>在引入了配置文件和工具类XMLUtil之后，客户端代码修改如下：</p>
<pre tabindex="0"><code>class Client {
public static void main(String args[]) {
Chart chart;
String type = XMLUtil.getChartType(); //读取配置文件中的参数
chart = ChartFactory.getChart(type); //创建产品对象
chart.display();
}
}
</code></pre><p>不难发现，在上述客户端代码中不包含任何与具体图表对象相关的信息，如果需要更换具体图表对象，只需修改配置文件config.xml，无须修改任何源代码，符合“开闭原则”。</p>
<h3 id="五简单工厂模式的简化">五、简单工厂模式的简化</h3>
<p>有时候，为了简化简单工厂模式，我们可以将抽象产品类和工厂类合并，将静态工厂方法移至抽象产品类中，如图3所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2021-12-28/factory3.jpeg" alt="img"></p>
<p>在图3中，客户端可以通过产品父类的静态工厂方法，根据参数的不同创建不同类型的产品子类对象，这种做法在JDK等类库和框架中也广泛存在。</p>
<h3 id="六简单工厂模式总结">六、简单工厂模式总结</h3>
<p>简单工厂模式提供了专门的工厂类用于创建对象，将对象的创建和对象的使用分离开，它作为一种最简单的工厂模式在软件开发中得到了较为广泛的应用。</p>
<ol>
<li>主要优点</li>
</ol>
<p>简单工厂模式的主要优点如下：</p>
<p>(1) 工厂类包含必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的职责，而仅仅“消费”产品，简单工厂模式实现了对象创建和使用的分离。</p>
<p>(2) 客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以在一定程度减少使用者的记忆量。</p>
<p>(3) 通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。</p>
<ol start="2">
<li>主要缺点</li>
</ol>
<p>简单工厂模式的主要缺点如下：</p>
<p>(1) 由于工厂类集中了所有产品的创建逻辑，职责过重，一旦不能正常工作，整个系统都要受到影响。</p>
<p>(2) 使用简单工厂模式势必会增加系统中类的个数（引入了新的工厂类），增加了系统的复杂度和理解难度。</p>
<p>(3) 系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。</p>
<p>(4) 简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。</p>
<ol start="3">
<li>适用场景</li>
</ol>
<p>在以下情况下可以考虑使用简单工厂模式：</p>
<p>(1) 工厂类负责创建的对象比较少，由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。</p>
<p>(2) 客户端只知道传入工厂类的参数，对于如何创建对象并不关心。</p>

        
        ]]>
      </description>
    </item>
    
    
    
    <item>
      <title>设计模式概述</title>
      <link>/post/2021/12/26/design/</link>
      <pubDate>Sun, 26 Dec 2021 10:10:12 +0800</pubDate>
      <author>糸色先生</author>
      <guid>/post/2021/12/26/design/</guid>
      <description>
        <![CDATA[
        <p>在软件开发生命周期的每一个阶段都存在着一些被认同的模式。</p>
<p>在软件模式中，设计模式是研究最为深入的分支，设计模式用于在特定的调剂爱你下为一些重复出现的软件设计问题提供合理的、有效的解决方案。</p>
<p>一般定义：设计模式（Design Pattern)是一套被反复使用、多数人知晓的、进过分类编目的代码设计经验的总结，使用设计模式是为了可重用代码、让代码更容易被他人理解并且保证代码可靠性。</p>
<p>狭义的设计模式是指 GoF 在《设计模式：可复用面向对象软件的基础》一书中所介绍的23种经典设计模式。不过设计模式并不仅仅只有这23种，越来越多的新模式不断诞生并得以应用。</p>
<p>23 种设计模式根据用途可分为创建型、结构型和行为型三种。其中创建型模式主要用于描述如何创建对象，结构型模式主要用于描述如何实现类或对象的组合，行为型模式主要用于描述类或对象怎样交互以及怎样分配职责。</p>
<p>值得注意的是，简单工厂模式没有在 23 种设计模式里面，但一般都会对它进行说明。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2021-12-26/design1.png" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2021-12-26/design2.png" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2021-12-26/design2.png" alt="img"></p>

        
        ]]>
      </description>
    </item>
    
    
  </channel>
</rss>
