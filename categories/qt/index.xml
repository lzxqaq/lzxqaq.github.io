<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Qt on 罗泽勋</title>
    <link>/categories/qt/</link>
    <description>Recent content in Qt on 罗泽勋</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Mon, 13 Dec 2021 08:08:17 +0800</lastBuildDate><atom:link href="/categories/qt/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>【转载】Qt6 对象模型</title>
      <link>/collection/object/</link>
      <pubDate>Mon, 13 Dec 2021 08:08:17 +0800</pubDate>
      
      <guid>/collection/object/</guid>
      <description>对象模型 标准的 C++ 对象模型为对象范例提供了非常有效的运行时支持。 但是它的静态特性在某些问题领域是不灵活的。 图形用户界面编程是一个需要运行时效率</description>
    </item>
    
    <item>
      <title>【转载】Qt 6 核心内部结构</title>
      <link>/collection/qt-core/</link>
      <pubDate>Mon, 13 Dec 2021 08:00:25 +0800</pubDate>
      
      <guid>/collection/qt-core/</guid>
      <description>Qt 包含一组丰富的基础使能器，主要来自 Qt Core 模块。 Qt 使用这些促成因素来提供更高级别的 UI 和应用程序开发组件。 以下主题解释了最重要的促成因素，并展示</description>
    </item>
    
    <item>
      <title>【转载】Qt6 Qvariant 与自定义 Qt 类型</title>
      <link>/collection/qvariant/</link>
      <pubDate>Mon, 13 Dec 2021 07:29:55 +0800</pubDate>
      
      <guid>/collection/qvariant/</guid>
      <description>概述 在本文档中，我们采用自定义类型并描述如何将其集成到 Qt 的对象模型中，以便可以像标准 Qt 类型一样存储它。 然后我们展示如何注册自定义类型以允许它</description>
    </item>
    
    <item>
      <title>【转载】Qt6 顺序容器 QList</title>
      <link>/collection/qlist/</link>
      <pubDate>Thu, 02 Dec 2021 12:41:29 +0800</pubDate>
      
      <guid>/collection/qlist/</guid>
      <description>介绍 QList 类是提供动态数组的模板类。该类中的所有函数都是可重入的。另外两个常用的顺序容器 QStack 和 QQueue 继承自 Qlist。 详细说明 QList 是 Qt 的通用容器类之一。</description>
    </item>
    
    <item>
      <title>【转载】Qt6 隐式共享</title>
      <link>/collection/implicit-sharing/</link>
      <pubDate>Wed, 01 Dec 2021 22:48:45 +0800</pubDate>
      
      <guid>/collection/implicit-sharing/</guid>
      <description>Qt 中的许多 C++ 类使用隐式数据共享来最大化资源使用并最小化复制。当作为参数传递时，隐式共享类既安全又高效，因为只有一个指向数据的指针被传递，并且</description>
    </item>
    
    <item>
      <title>【转载】Qt6 容器类-概述</title>
      <link>/collection/qt-containers/</link>
      <pubDate>Wed, 01 Dec 2021 22:05:26 +0800</pubDate>
      
      <guid>/collection/qt-containers/</guid>
      <description>介绍 Qt 库提供了一组通用的基于模板的容器类。这些类可用于存储制定类型的项。例如，您需要一个可调整大小的 QString 数组，请使用 QList。 这些容器类被设</description>
    </item>
    
    <item>
      <title>Qt单元测试基础笔记</title>
      <link>/post/2021/10/13/qt%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Wed, 13 Oct 2021 07:01:19 +0800</pubDate>
      
      <guid>/post/2021/10/13/qt%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/</guid>
      <description>一、构建 构建时添加 QT += testlib 。 二、测试类 测试类必须从 QObject 继承，头文件 include &amp;lt;QTest&amp;gt; ，并将测试函数声明 private slot 三、QVERIFY(condition) 宏 检查 con</description>
    </item>
    
    <item>
      <title>【转载】Qt测试最佳实践</title>
      <link>/collection/2021-10-13-2/</link>
      <pubDate>Wed, 13 Oct 2021 07:01:19 +0800</pubDate>
      
      <guid>/collection/2021-10-13-2/</guid>
      <description>Qt 测试最佳实践 我们建议您为错误修复和新功能添加 Qt 测试。在您尝试修复错误之前，添加一个回归测试（理想情况下是自动的），该测试在修复之前失败，表</description>
    </item>
    
  </channel>
</rss>
