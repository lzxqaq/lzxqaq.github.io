<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>C/C&#43;&#43; on 罗泽勋</title>
    <link>/categories/c/c&#43;&#43;/</link>
    <description>Recent content in C/C&#43;&#43; on 罗泽勋</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language><atom:link href="/categories/c/c++/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>【转载】Linux Socket 编程（不限 Linux）</title>
      <link>/collection/linuxsocket/</link>
      <pubDate>Mon, 07 Mar 2022 18:43:02 +0800</pubDate>
      
      <guid>/collection/linuxsocket/</guid>
<<<<<<< HEAD
      <description>
        <![CDATA[
        <p>作者：吴秦<br>
出处：(<a href="http://www.cnblogs.com/skynet/">http://www.cnblogs.com/skynet/</a>)</p>
<h3 id="1网络中进程之间如何通信">1、网络中进程之间如何通信？</h3>
<p>本地的进程间通信（IPC）有很多种方式，但可以总结为下面4类：</p>
<ul>
<li>消息传递（管道、FIFO、消息队列）</li>
<li>同步（互斥量、条件变量、读写锁、文件和写记录锁、信号量）</li>
<li>共享内存（匿名的和具名的）</li>
<li>远程过程调用（Solaris门和Sun RPC）</li>
</ul>
<p>但这些都不是本文的主题！我们要讨论的是网络中进程之间如何通信？首要解决的问题是如何唯一标识一个进程，否则通信无从谈起！在本地可以通过进程PID来唯一标识一个进程，但是在网络中这是行不通的。其实TCP/IP协议族已经帮我们解决了这个问题，网络层的“ip地址”可以唯一标识网络中的主机，而传输层的“协议+端口”可以唯一标识主机中的应用程序（进程）。这样利用三元组（ip地址，协议，端口）就可以标识网络的进程了，网络中的进程通信就可以利用这个标志与其它进程进行交互。</p>
<p>使用TCP/IP协议的应用程序通常采用应用编程接口：UNIX  BSD的套接字（socket）和UNIX System V的TLI（已经被淘汰），来实现网络进程之间的通信。就目前而言，几乎所有的应用程序都是采用socket，而现在又是网络时代，网络中进程通信是无处不在，这就是我为什么说“一切皆socket”。</p>
<h3 id="2什么是socket">2、什么是Socket？</h3>
<p>上面我们已经知道网络中的进程是通过socket来通信的，那什么是socket呢？socket起源于Unix，而Unix/Linux基本哲学之一就是“一切皆文件”，都可以用“打开open –&gt; 读写write/read –&gt; 关闭close”模式来操作。我的理解就是Socket就是该模式的一个实现，socket即是一种特殊的文件，一些socket函数就是对其进行的操作（读/写IO、打开、关闭），这些函数我们在后面进行介绍。</p>
<blockquote>
<p>socket一词的起源
在组网领域的首次使用是在1970年2月12日发布的文献IETF RFC33中发现的，撰写者为Stephen Carr、Steve Crocker和Vint Cerf。根据美国计算机历史博物馆的记载，Croker写道：“命名空间的元素都可称为套接字接口。一个套接字接口构成一个连接的一端，而一个连接可完全由一对套接字接口规定。”计算机历史博物馆补充道：“这比BSD的套接字接口定义早了大约12年。”</p>
</blockquote>
<h3 id="3socket的基本操作">3、socket的基本操作</h3>
<p>既然socket是“open—write/read—close”模式的一种实现，那么socket就提供了这些操作对应的函数接口。下面以TCP为例，介绍几个基本的socket接口函数。</p>
<h4 id="31socket函数">3.1、socket()函数</h4>
<p>int socket(int domain, int type, int protocol);</p>
<p>socket函数对应于普通文件的打开操作。普通文件的打开操作返回一个文件描述字，而socket()用于创建一个socket描述符（socket descriptor），它唯一标识一个socket。这个socket描述字跟文件描述字一样，后续的操作都有用到它，把它作为参数，通过它来进行一些读写操作。</p>
<p>正如可以给fopen的传入不同参数值，以打开不同的文件。创建socket的时候，也可以指定不同的参数创建不同的socket描述符，socket函数的三个参数分别为：</p>
<ul>
<li>
<p>domain：即协议域，又称为协议族（family）。常用的协议族有，AF_INET、AF_INET6、AF_LOCAL（或称AF_UNIX，Unix域socket）、AF_ROUTE等等。协议族决定了socket的地址类型，在通信中必须采用对应的地址，如AF_INET决定了要用ipv4地址（32位的）与端口号（16位的）的组合、AF_UNIX决定了要用一个绝对路径名作为地址。</p>
</li>
<li>
<p>type：指定socket类型。常用的socket类型有，SOCK_STREAM、SOCK_DGRAM、SOCK_RAW、SOCK_PACKET、SOCK_SEQPACKET等等（socket的类型有哪些？）。</p>
</li>
<li>
<p>protocol：故名思意，就是指定协议。常用的协议有，IPPROTO_TCP、IPPTOTO_UDP、IPPROTO_SCTP、IPPROTO_TIPC等，它们分别对应TCP传输协议、UDP传输协议、STCP传输协议、TIPC传输协议（这个协议我将会单独开篇讨论！）。</p>
</li>
</ul>
<p>注意：并不是上面的type和protocol可以随意组合的，如SOCK_STREAM不可以跟IPPROTO_UDP组合。当protocol为0时，会自动选择type类型对应的默认协议。</p>
<p>当我们调用socket创建一个socket时，返回的socket描述字它存在于协议族（address family，AF_XXX）空间中，但没有一个具体的地址。如果想要给它赋值一个地址，就必须调用bind()函数，否则就当调用connect()、listen()时系统会自动随机分配一个端口。</p>
<h4 id="32bind函数">3.2、bind()函数</h4>
<p>正如上面所说bind()函数把一个地址族中的特定地址赋给socket。例如对应AF_INET、AF_INET6就是把一个ipv4或ipv6地址和端口号组合赋给socket。</p>
<pre tabindex="0"><code>int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
</code></pre><p>函数的三个参数分别为：</p>
<ul>
<li>sockfd：即socket描述字，它是通过socket()函数创建了，唯一标识一个socket。bind()函数就是将给这个描述字绑定一个名字。</li>
<li>addr：一个const struct sockaddr *指针，指向要绑定给sockfd的协议地址。这个地址结构根据地址创建socket时的地址协议族的不同而不同，如ipv4对应的是：</li>
</ul>
<pre tabindex="0"><code>struct sockaddr_in {
    sa_family_t    sin_family; /* address family: AF_INET */
    in_port_t      sin_port;   /* port in network byte order */
    struct in_addr sin_addr;   /* internet address */
};

/* Internet address. */
struct in_addr {
    uint32_t       s_addr;     /* address in network byte order */
};

</code></pre><p>ipv6对应的是：</p>
<pre tabindex="0"><code>struct sockaddr_in6 { 
    sa_family_t     sin6_family;   /* AF_INET6 */ 
    in_port_t       sin6_port;     /* port number */ 
    uint32_t        sin6_flowinfo; /* IPv6 flow information */ 
    struct in6_addr sin6_addr;     /* IPv6 address */ 
    uint32_t        sin6_scope_id; /* Scope ID (new in 2.4) */ 
};

struct in6_addr { 
    unsigned char   s6_addr[16];   /* IPv6 address */ 
};
</code></pre><p>Unix域对应的是：</p>
<pre tabindex="0"><code>#define UNIX_PATH_MAX    108

struct sockaddr_un { 
    sa_family_t sun_family;               /* AF_UNIX */ 
    char        sun_path[UNIX_PATH_MAX];  /* pathname */ 
};
</code></pre><ul>
<li>addrlen：对应的是地址的长度。</li>
</ul>
<p>通常服务器在启动的时候都会绑定一个众所周知的地址（如ip地址+端口号），用于提供服务，客户就可以通过它来接连服务器；而客户端就不用指定，有系统自动分配一个端口号和自身的ip地址组合。这就是为什么通常服务器端在listen之前会调用bind()，而客户端就不会调用，而是在connect()时由系统随机生成一个。</p>
<h4 id="网络字节序与主机字节序">网络字节序与主机字节序</h4>
<p>主机字节序就是我们平常说的大端和小端模式：不同的CPU有不同的字节序类型，这些字节序是指整数在内存中保存的顺序，这个叫做主机序。引用标准的Big-Endian和Little-Endian的定义如下：</p>
<ul>
<li>
<p>a) Little-Endian就是低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。</p>
</li>
<li>
<p>b) Big-Endian就是高位字节排放在内存的低地址端，低位字节排放在内存的高地址端。</p>
</li>
</ul>
<p>网络字节序：4个字节的32 bit值以下面的次序传输：首先是0～7bit，其次8～15bit，然后16～23bit，最后是24~31bit。这种传输次序称作大端字节序。由于TCP/IP首部中所有的二进制整数在网络中传输时都要求以这种次序，因此它又称作网络字节序。字节序，顾名思义字节的顺序，就是大于一个字节类型的数据在内存中的存放顺序，一个字节的数据没有顺序的问题了。</p>
<p>所以：在将一个地址绑定到socket的时候，请先将主机字节序转换成为网络字节序，而不要假定主机字节序跟网络字节序一样使用的是Big-Endian。由于这个问题曾引发过血案！公司项目代码中由于存在这个问题，导致了很多莫名其妙的问题，所以请谨记对主机字节序不要做任何假定，务必将其转化为网络字节序再赋给socket。</p>
<h4 id="33listenconnect函数">3.3、listen()、connect()函数</h4>
<p>如果作为一个服务器，在调用socket()、bind()之后就会调用listen()来监听这个socket，如果客户端这时调用connect()发出连接请求，服务器端就会接收到这个请求。</p>
<pre tabindex="0"><code>int listen(int sockfd, int backlog);
int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
</code></pre><p>listen函数的第一个参数即为要监听的socket描述字，第二个参数为相应socket可以排队的最大连接个数。socket()函数创建的socket默认是一个主动类型的，listen函数将socket变为被动类型的，等待客户的连接请求。</p>
<p>connect函数的第一个参数即为客户端的socket描述字，第二参数为服务器的socket地址，第三个参数为socket地址的长度。客户端通过调用connect函数来建立与TCP服务器的连接。</p>
<h4 id="34accept函数">3.4、accept()函数</h4>
<p>TCP服务器端依次调用socket()、bind()、listen()之后，就会监听指定的socket地址了。TCP客户端依次调用socket()、connect()之后就想TCP服务器发送了一个连接请求。TCP服务器监听到这个请求之后，就会调用accept()函数取接收请求，这样连接就建立好了。之后就可以开始网络I/O操作了，即类同于普通文件的读写I/O操作。</p>
<pre tabindex="0"><code>int accept(int sockfd, struct sockaddr *addr, socklen_t *
</code></pre><p>accept函数的第一个参数为服务器的socket描述字，第二个参数为指向struct sockaddr *的指针，用于返回客户端的协议地址，第三个参数为协议地址的长度。如果accpet成功，那么其返回值是由内核自动生成的一个全新的描述字，代表与返回客户的TCP连接。</p>
<p>注意：accept的第一个参数为服务器的socket描述字，是服务器开始调用socket()函数生成的，称为监听socket描述字；而accept函数返回的是已连接的socket描述字。一个服务器通常通常仅仅只创建一个监听socket描述字，它在该服务器的生命周期内一直存在。内核为每个由服务器进程接受的客户连接创建了一个已连接socket描述字，当服务器完成了对某个客户的服务，相应的已连接socket描述字就被关闭。</p>
<h4 id="35readwrite等函数">3.5、read()、write()等函数</h4>
<p>万事具备只欠东风，至此服务器与客户已经建立好连接了。可以调用网络I/O进行读写操作了，即实现了网咯中不同进程之间的通信！网络I/O操作有下面几组：</p>
<ul>
<li>read()/write()</li>
<li>recv()/send()</li>
<li>readv()/writev()</li>
<li>recvmsg()/sendmsg()</li>
<li>recvfrom()/sendto()</li>
</ul>
<p>我推荐使用recvmsg()/sendmsg()函数，这两个函数是最通用的I/O函数，实际上可以把上面的其它函数都替换成这两个函数。它们的声明如下：</p>
<pre tabindex="0"><code>#include &lt;unistd.h&gt;

ssize_t read(int fd, void *buf, size_t count);
ssize_t write(int fd, const void *buf, size_t count);

#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

ssize_t send(int sockfd, const void *buf, size_t len, int flags);
ssize_t recv(int sockfd, void *buf, size_t len, int flags);

ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,
                const struct sockaddr *dest_addr, socklen_t addrlen);
ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,
                struct sockaddr *src_addr, socklen_t *addrlen);

ssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags);
ssize_t recvmsg(int sockfd, struct msghdr *msg, int flags);
</code></pre><p>read函数是负责从fd中读取内容.当读成功时，read返回实际所读的字节数，如果返回的值是0表示已经读到文件的结束了，小于0表示出现了错误。如果错误为EINTR说明读是由中断引起的，如果是ECONNREST表示网络连接出了问题。</p>
<p>write函数将buf中的nbytes字节内容写入文件描述符fd.成功时返回写的字节数。失败时返回-1，并设置errno变量。 在网络程序中，当我们向套接字文件描述符写时有俩种可能。1)write的返回值大于0，表示写了部分或者是全部的数据。2)返回的值小于0，此时出现了错误。我们要根据错误类型来处理。如果错误为EINTR表示在写的时候出现了中断错误。如果为EPIPE表示网络连接出现了问题(对方已经关闭了连接)。</p>
<p>其它的我就不一一介绍这几对I/O函数了，具体参见man文档或者baidu、Google，下面的例子中将使用到send/recv。</p>
<h4 id="36close函数">3.6、close()函数</h4>
<p>在服务器与客户端建立连接之后，会进行一些读写操作，完成了读写操作就要关闭相应的socket描述字，好比操作完打开的文件要调用fclose关闭打开的文件。</p>
<pre tabindex="0"><code>#include &lt;unistd.h&gt;
int close(int fd);
</code></pre><p>close一个TCP socket的缺省行为时把该socket标记为以关闭，然后立即返回到调用进程。该描述字不能再由调用进程使用，也就是说不能再作为read或write的第一个参数。</p>
<p>注意：close操作只是使相应socket描述字的引用计数-1，只有当引用计数为0的时候，才会触发TCP客户端向服务器发送终止连接请求。</p>
<h4 id="4socket中tcp的三次握手建立连接详解">4、socket中TCP的三次握手建立连接详解</h4>
<p>我们知道tcp建立连接要进行“三次握手”，即交换三个分组。大致流程如下：</p>
<ul>
<li>客户端向服务器发送一个SYN J</li>
<li>服务器向客户端响应一个SYN K，并对SYN J进行确认ACK J+1</li>
<li>客户端再想服务器发一个确认ACK K+1</li>
</ul>
<p>只有就完了三次握手，但是这个三次握手发生在socket的那几个函数中呢？请看下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2022-3-7/socket3.png" alt="socket 中发送的 TCP 四次握手"></p>
<p>从图中可以看出，当客户端调用connect时，触发了连接请求，向服务器发送了SYN J包，这时connect进入阻塞状态；服务器监听到连接请求，即收到SYN J包，调用accept函数接收请求向客户端发送SYN K ，ACK J+1，这时accept进入阻塞状态；客户端收到服务器的SYN K ，ACK J+1之后，这时connect返回，并对SYN K进行确认；服务器收到ACK K+1时，accept返回，至此三次握手完毕，连接建立。</p>
<p>总结：客户端的connect在三次握手的第二个次返回，而服务器端的accept在三次握手的第三次返回。</p>
<h3 id="5socket中tcp的四次握手释放连接详解">5、socket中TCP的四次握手释放连接详解</h3>
<p>上面介绍了socket中TCP的三次握手建立过程，及其涉及的socket函数。现在我们介绍socket中的四次握手释放连接的过程，请看下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2022-3-7/socket4.png" alt="socket 中发送的 TCP 四次握手"></p>
<p>图示过程如下：</p>
<ul>
<li>某个应用进程首先调用close主动关闭连接，这时TCP发送一个FIN M；</li>
<li>另一端接收到FIN M之后，执行被动关闭，对这个FIN进行确认。它的接收也作为文件结束符传递给应用进程，因为FIN的接收意味着应用进程在相应的连接上再也接收不到额外数据；</li>
<li>一段时间之后，接收到文件结束符的应用进程调用close关闭它的socket。这导致它的TCP也发送一个FIN N；</li>
<li>接收到这个FIN的源发送端TCP对它进行确认。</li>
</ul>
<p>这样每个方向上都有一个FIN和ACK。</p>
<h3 id="6一个例子实践一下">6、一个例子（实践一下）</h3>
<p>说了这么多了，动手实践一下。下面编写一个简单的服务器、客户端（使用TCP）——服务器端一直监听本机的6666号端口，如果收到连接请求，将接收请求并接收客户端发来的消息；客户端与服务器端建立连接并发送一条消息。</p>
<p>服务器端代码：</p>
<pre tabindex="0"><code>//服务器端
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;string.h&gt;
#include&lt;errno.h&gt;
#include&lt;sys/types.h&gt;
#include&lt;sys/socket.h&gt;
#include&lt;netinet/in.h&gt;

#define MAXLINE 4096

int main(int argc, char** argv)
{
    int    listenfd, connfd;
    struct sockaddr_in     servaddr;
    char    buff[4096];
    int     n;

    if( (listenfd = socket(AF_INET, SOCK_STREAM, 0)) == -1 ){
    printf(&quot;create socket error: %s(errno: %d)\n&quot;,strerror(errno),errno);
    exit(0);
    }

    memset(&amp;servaddr, 0, sizeof(servaddr));
    servaddr.sin_family = AF_INET;
    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);
    servaddr.sin_port = htons(6666);

    if( bind(listenfd, (struct sockaddr*)&amp;servaddr, sizeof(servaddr)) == -1){
    printf(&quot;bind socket error: %s(errno: %d)\n&quot;,strerror(errno),errno);
    exit(0);
    }

    if( listen(listenfd, 10) == -1){
    printf(&quot;listen socket error: %s(errno: %d)\n&quot;,strerror(errno),errno);
    exit(0);
    }

    printf(&quot;======waiting for client's request======\n&quot;);
    while(1){
    if( (connfd = accept(listenfd, (struct sockaddr*)NULL, NULL)) == -1){
        printf(&quot;accept socket error: %s(errno: %d)&quot;,strerror(errno),errno);
        continue;
    }
    n = recv(connfd, buff, MAXLINE, 0);
    buff[n] = '\0';
    printf(&quot;recv msg from client: %s\n&quot;, buff);
    close(connfd);
    }

    close(listenfd);
}
</code></pre><p>客户端代码：</p>
<pre tabindex="0"><code>//客户端
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;string.h&gt;
#include&lt;errno.h&gt;
#include&lt;sys/types.h&gt;
#include&lt;sys/socket.h&gt;
#include&lt;netinet/in.h&gt;

#define MAXLINE 4096

int main(int argc, char** argv)
{
    int    sockfd, n;
    char    recvline[4096], sendline[4096];
    struct sockaddr_in    servaddr;

    if( argc != 2){
    printf(&quot;usage: ./client &lt;ipaddress&gt;\n&quot;);
    exit(0);
    }

    if( (sockfd = socket(AF_INET, SOCK_STREAM, 0)) &lt; 0){
    printf(&quot;create socket error: %s(errno: %d)\n&quot;, strerror(errno),errno);
    exit(0);
    }

    memset(&amp;servaddr, 0, sizeof(servaddr));
    servaddr.sin_family = AF_INET;
    servaddr.sin_port = htons(6666);
    if( inet_pton(AF_INET, argv[1], &amp;servaddr.sin_addr) &lt;= 0){
    printf(&quot;inet_pton error for %s\n&quot;,argv[1]);
    exit(0);
    }

    if( connect(sockfd, (struct sockaddr*)&amp;servaddr, sizeof(servaddr)) &lt; 0){
    printf(&quot;connect error: %s(errno: %d)\n&quot;,strerror(errno),errno);
    exit(0);
    }

    printf(&quot;send msg to server: \n&quot;);
    fgets(sendline, 4096, stdin);
    if( send(sockfd, sendline, strlen(sendline), 0) &lt; 0)
    {
    printf(&quot;send msg error: %s(errno: %d)\n&quot;, strerror(errno), errno);
    exit(0);
    }

    close(sockfd);
    exit(0);
}
</code></pre><p>当然上面的代码很简单，也有很多缺点，这就只是简单的演示socket的基本函数使用。其实不管有多复杂的网络程序，都使用的这些基本函数。上面的服务器使用的是迭代模式的，即只有处理完一个客户端请求才会去处理下一个客户端的请求，这样的服务器处理能力是很弱的，现实中的服务器都需要有并发处理能力！为了需要并发处理，服务器需要fork()一个新的进程或者线程去处理请求等。</p>

        
        ]]>
      </description>
=======
      <description>作者：吴秦 出处：(http://www.cnblogs.com/skynet/) 1、网络中进程之间如何通信？ 本地的进程间通信（IPC）有很多</description>
>>>>>>> 35a30928abf5c3213b754024efc550556652db2d
    </item>
    
    <item>
      <title>【转载】C&#43;&#43; 开发必备之网络编程</title>
      <link>/collection/networkpg/</link>
      <pubDate>Mon, 07 Mar 2022 18:38:17 +0800</pubDate>
      
      <guid>/collection/networkpg/</guid>
<<<<<<< HEAD
      <description>
        <![CDATA[
        <p>转载自<a href="https://github.com/huihut/interview">https://github.com/huihut/interview</a></p>
<h3 id="socket">Socket</h3>
<blockquote>
<p><a href="/post/2022/03/07/linuxsocket/">Linux Socket 编程（不限 Linux）</a></p>
</blockquote>
<p><img src="https://gitee.com/huihut/interview/raw/master/images/socket%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%80%9A%E8%AE%AF.jpg" alt="Socket 客户端服务器通讯"></p>
<h4 id="socket-中的-readwrite-函数">Socket 中的 read()、write() 函数</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">ssize_t <span style="color:#a6e22e">read</span>(<span style="color:#66d9ef">int</span> fd, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>buf, size_t count);
ssize_t <span style="color:#a6e22e">write</span>(<span style="color:#66d9ef">int</span> fd, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>buf, size_t count);
</code></pre></div><h5 id="read">read()</h5>
<ul>
<li>read 函数是负责从 fd 中读取内容。</li>
<li>当读成功时，read 返回实际所读的字节数。</li>
<li>如果返回的值是 0 表示已经读到文件的结束了，小于 0 表示出现了错误。</li>
<li>如果错误为 EINTR 说明读是由中断引起的；如果是 ECONNREST 表示网络连接出了问题。</li>
</ul>
<h5 id="write">write()</h5>
<ul>
<li>write 函数将 buf 中的 nbytes 字节内容写入文件描述符 fd。</li>
<li>成功时返回写的字节数。失败时返回 -1，并设置 errno 变量。</li>
<li>在网络程序中，当我们向套接字文件描述符写时有俩种可能。</li>
<li>（1）write 的返回值大于 0，表示写了部分或者是全部的数据。</li>
<li>（2）返回的值小于 0，此时出现了错误。</li>
<li>如果错误为 EINTR 表示在写的时候出现了中断错误；如果为 EPIPE 表示网络连接出现了问题（对方已经关闭了连接）。</li>
</ul>
<h4 id="socket-中-tcp-的三次握手建立连接">Socket 中 TCP 的三次握手建立连接</h4>
<p>我们知道 TCP 建立连接要进行 “三次握手”，即交换三个分组。大致流程如下：</p>
<ol>
<li>客户端向服务器发送一个 SYN J</li>
<li>服务器向客户端响应一个 SYN K，并对 SYN J 进行确认 ACK J+1</li>
<li>客户端再想服务器发一个确认 ACK K+1</li>
</ol>
<p>只有就完了三次握手，但是这个三次握手发生在 Socket 的那几个函数中呢？请看下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2022-3-7/socket3.png" alt="socket 中发送的 TCP 三次握手"></p>
<p>从图中可以看出：</p>
<ol>
<li>当客户端调用 connect 时，触发了连接请求，向服务器发送了 SYN J 包，这时 connect 进入阻塞状态；</li>
<li>服务器监听到连接请求，即收到 SYN J 包，调用 accept 函数接收请求向客户端发送 SYN K ，ACK J+1，这时 accept 进入阻塞状态；</li>
<li>客户端收到服务器的 SYN K ，ACK J+1 之后，这时 connect 返回，并对 SYN K 进行确认；</li>
<li>服务器收到 ACK K+1 时，accept 返回，至此三次握手完毕，连接建立。</li>
</ol>
<h4 id="socket-中-tcp-的四次握手释放连接">Socket 中 TCP 的四次握手释放连接</h4>
<p>上面介绍了 socket 中 TCP 的三次握手建立过程，及其涉及的 socket 函数。现在我们介绍 socket 中的四次握手释放连接的过程，请看下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2022-3-7/socket4.png" alt="socket 中发送的 TCP 四次握手"></p>
<p>图示过程如下：</p>
<ol>
<li>某个应用进程首先调用 close 主动关闭连接，这时 TCP 发送一个 FIN M；</li>
<li>另一端接收到 FIN M 之后，执行被动关闭，对这个 FIN 进行确认。它的接收也作为文件结束符传递给应用进程，因为 FIN 的接收意味着应用进程在相应的连接上再也接收不到额外数据；</li>
<li>一段时间之后，接收到文件结束符的应用进程调用 close 关闭它的 socket。这导致它的 TCP 也发送一个 FIN N；</li>
<li>接收到这个 FIN 的源发送端 TCP 对它进行确认。</li>
</ol>
<p>这样每个方向上都有一个 FIN 和 ACK。</p>

        
        ]]>
      </description>
=======
      <description>转载自https://github.com/huihut/interview Socket Linux Socket 编程（不限 Linux） Socket 中的 read()、write() 函</description>
>>>>>>> 35a30928abf5c3213b754024efc550556652db2d
    </item>
    
    <item>
      <title>【转载】C&#43;&#43; 开发必备之设计模式</title>
      <link>/collection/design-pattern/</link>
      <pubDate>Sat, 15 Jan 2022 08:14:07 +0800</pubDate>
      
      <guid>/collection/design-pattern/</guid>
      <description>转载自https://github.com/huihut/interview 各大设计模式例子参考：CSDN专栏 . C++ 设计模式 系列博文 设计模式工</description>
    </item>
    
    <item>
      <title>【转载】C&#43;&#43; 开发必备之链接装载库</title>
      <link>/collection/library/</link>
      <pubDate>Sat, 15 Jan 2022 08:10:50 +0800</pubDate>
      
      <guid>/collection/library/</guid>
<<<<<<< HEAD
      <description>
        <![CDATA[
        <p>转载自<a href="https://github.com/huihut/interview">https://github.com/huihut/interview</a></p>
<blockquote>
<p>本节部分知识点来自《程序员的自我修养——链接装载库》</p>
</blockquote>
<h3 id="内存栈堆">内存、栈、堆</h3>
<p>一般应用程序内存空间有如下区域：</p>
<ul>
<li>栈：由操作系统自动分配释放，存放函数的参数值、局部变量等的值，用于维护函数调用的上下文</li>
<li>堆：一般由程序员分配释放，若程序员不释放，程序结束时可能由操作系统回收，用来容纳应用程序动态分配的内存区域</li>
<li>可执行文件映像：存储着可执行文件在内存中的映像，由装载器装载是将可执行文件的内存读取或映射到这里</li>
<li>保留区：保留区并不是一个单一的内存区域，而是对内存中受到保护而禁止访问的内存区域的总称，如通常 C 语言讲无效指针赋值为 0（NULL），因此 0 地址正常情况下不可能有效的访问数据</li>
</ul>
<h4 id="栈">栈</h4>
<p>栈保存了一个函数调用所需要的维护信息，常被称为堆栈帧（Stack Frame）或活动记录（Activate Record），一般包含以下几方面：</p>
<ul>
<li>函数的返回地址和参数</li>
<li>临时变量：包括函数的非静态局部变量以及编译器自动生成的其他临时变量</li>
<li>保存上下文：包括函数调用前后需要保持不变的寄存器</li>
</ul>
<h4 id="堆">堆</h4>
<p>堆分配算法：</p>
<ul>
<li>空闲链表（Free List）</li>
<li>位图（Bitmap）</li>
<li>对象池</li>
</ul>
<h4 id="段错误segment-fault-或-非法操作该内存地址不能-readwrite">“段错误（segment fault）” 或 “非法操作，该内存地址不能 read/write”</h4>
<p>典型的非法指针解引用造成的错误。当指针指向一个不允许读写的内存地址，而程序却试图利用指针来读或写该地址时，会出现这个错误。</p>
<p>普遍原因：</p>
<ul>
<li>将指针初始化为 NULL，之后没有给它一个合理的值就开始使用指针</li>
<li>没用初始化栈中的指针，指针的值一般会是随机数，之后就直接开始使用指针</li>
</ul>
<h3 id="编译链接">编译链接</h3>
<h4 id="各平台文件格式">各平台文件格式</h4>
<table>
<thead>
<tr>
<th>平台</th>
<th>可执行文件</th>
<th>目标文件</th>
<th>动态库/共享对象</th>
<th>静态库</th>
</tr>
</thead>
<tbody>
<tr>
<td>Windows</td>
<td>exe</td>
<td>obj</td>
<td>dll</td>
<td>lib</td>
</tr>
<tr>
<td>Unix/Linux</td>
<td>ELF、out</td>
<td>o</td>
<td>so</td>
<td>a</td>
</tr>
<tr>
<td>Mac</td>
<td>Mach-O</td>
<td>o</td>
<td>dylib、tbd、framework</td>
<td>a、framework</td>
</tr>
</tbody>
</table>
<h4 id="编译链接过程">编译链接过程</h4>
<ol>
<li>预编译（预编译器处理如 <code>#include</code>、<code>#define</code> 等预编译指令，生成 <code>.i</code> 或 <code>.ii</code> 文件）</li>
<li>编译（编译器进行词法分析、语法分析、语义分析、中间代码生成、目标代码生成、优化，生成 <code>.s</code> 文件）</li>
<li>汇编（汇编器把汇编码翻译成机器码，生成 <code>.o</code> 文件）</li>
<li>链接（连接器进行地址和空间分配、符号决议、重定位，生成 <code>.out</code> 文件）</li>
</ol>
<blockquote>
<p>现在版本 GCC 把预编译和编译合成一步，预编译编译程序 cc1、汇编器 as、连接器 ld</p>
</blockquote>
<blockquote>
<p>MSVC 编译环境，编译器 cl、连接器 link、可执行文件查看器 dumpbin</p>
</blockquote>
<h4 id="目标文件">目标文件</h4>
<p>编译器编译源代码后生成的文件叫做目标文件。目标文件从结构上讲，它是已经编译后的可执行文件格式，只是还没有经过链接的过程，其中可能有些符号或有些地址还没有被调整。</p>
<blockquote>
<p>可执行文件（Windows 的 <code>.exe</code> 和 Linux 的 <code>ELF</code>）、动态链接库（Windows 的 <code>.dll</code> 和 Linux 的 <code>.so</code>）、静态链接库（Windows 的 <code>.lib</code> 和 Linux 的 <code>.a</code>）都是按照可执行文件格式存储（Windows 按照 PE-COFF，Linux 按照 ELF）</p>
</blockquote>
<h5 id="目标文件格式">目标文件格式</h5>
<ul>
<li>Windows 的 PE（Portable Executable），或称为 PE-COFF，<code>.obj</code> 格式</li>
<li>Linux 的 ELF（Executable Linkable Format），<code>.o</code> 格式</li>
<li>Intel/Microsoft 的 OMF（Object Module Format）</li>
<li>Unix 的 <code>a.out</code> 格式</li>
<li>MS-DOS 的 <code>.COM</code> 格式</li>
</ul>
<blockquote>
<p>PE 和 ELF 都是 COFF（Common File Format）的变种</p>
</blockquote>
<h5 id="目标文件存储结构">目标文件存储结构</h5>
<table>
<thead>
<tr>
<th>段</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>File Header</td>
<td>文件头，描述整个文件的文件属性（包括文件是否可执行、是静态链接或动态连接及入口地址、目标硬件、目标操作系统等）</td>
</tr>
<tr>
<td>.text section</td>
<td>代码段，执行语句编译成的机器代码</td>
</tr>
<tr>
<td>.data section</td>
<td>数据段，已初始化的全局变量和局部静态变量</td>
</tr>
<tr>
<td>.bss section</td>
<td>BSS 段（Block Started by Symbol），未初始化的全局变量和局部静态变量（因为默认值为 0，所以只是在此预留位置，不占空间）</td>
</tr>
<tr>
<td>.rodata section</td>
<td>只读数据段，存放只读数据，一般是程序里面的只读变量（如 const 修饰的变量）和字符串常量</td>
</tr>
<tr>
<td>.comment section</td>
<td>注释信息段，存放编译器版本信息</td>
</tr>
<tr>
<td>.note.GNU-stack section</td>
<td>堆栈提示段</td>
</tr>
</tbody>
</table>
<blockquote>
<p>其他段略</p>
</blockquote>
<h4 id="链接的接口符号">链接的接口————符号</h4>
<p>在链接中，目标文件之间相互拼合实际上是目标文件之间对地址的引用，即对函数和变量的地址的引用。我们将函数和变量统称为符号（Symbol），函数名或变量名就是符号名（Symbol Name）。</p>
<p>如下符号表（Symbol Table）：</p>
<table>
<thead>
<tr>
<th>Symbol（符号名）</th>
<th>Symbol Value （地址）</th>
</tr>
</thead>
<tbody>
<tr>
<td>main</td>
<td>0x100</td>
</tr>
<tr>
<td>Add</td>
<td>0x123</td>
</tr>
<tr>
<td>&hellip;</td>
<td>&hellip;</td>
</tr>
</tbody>
</table>
<h3 id="linux-的共享库shared-library">Linux 的共享库（Shared Library）</h3>
<p>Linux 下的共享库就是普通的 ELF 共享对象。</p>
<p>共享库版本更新应该保证二进制接口 ABI（Application Binary Interface）的兼容</p>
<h4 id="命名">命名</h4>
<p><code>libname.so.x.y.z</code></p>
<ul>
<li>x：主版本号，不同主版本号的库之间不兼容，需要重新编译</li>
<li>y：次版本号，高版本号向后兼容低版本号</li>
<li>z：发布版本号，不对接口进行更改，完全兼容</li>
</ul>
<h4 id="路径">路径</h4>
<p>大部分包括 Linux 在内的开源系统遵循 FHS（File Hierarchy Standard）的标准，这标准规定了系统文件如何存放，包括各个目录结构、组织和作用。</p>
<ul>
<li><code>/lib</code>：存放系统最关键和最基础的共享库，如动态链接器、C 语言运行库、数学库等</li>
<li><code>/usr/lib</code>：存放非系统运行时所需要的关键性的库，主要是开发库</li>
<li><code>/usr/local/lib</code>：存放跟操作系统本身并不十分相关的库，主要是一些第三方应用程序的库</li>
</ul>
<blockquote>
<p>动态链接器会在 <code>/lib</code>、<code>/usr/lib</code> 和由 <code>/etc/ld.so.conf</code> 配置文件指定的，目录中查找共享库</p>
</blockquote>
<h4 id="环境变量">环境变量</h4>
<ul>
<li><code>LD_LIBRARY_PATH</code>：临时改变某个应用程序的共享库查找路径，而不会影响其他应用程序</li>
<li><code>LD_PRELOAD</code>：指定预先装载的一些共享库甚至是目标文件</li>
<li><code>LD_DEBUG</code>：打开动态链接器的调试功能</li>
</ul>
<h4 id="so-共享库的编写">so 共享库的编写</h4>
<p>使用 CLion 编写共享库</p>
<p>创建一个名为 MySharedLib 的共享库</p>
<p>CMakeLists.txt</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cmake" data-lang="cmake">cmake_minimum_required(<span style="color:#e6db74">VERSION</span> <span style="color:#e6db74">3.10</span>)<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>project(<span style="color:#e6db74">MySharedLib</span>)<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>set(<span style="color:#e6db74">CMAKE_CXX_STANDARD</span> <span style="color:#e6db74">11</span>)<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>add_library(<span style="color:#e6db74">MySharedLib</span> <span style="color:#e6db74">SHARED</span> <span style="color:#e6db74">library.cpp</span> <span style="color:#e6db74">library.h</span>)<span style="color:#960050;background-color:#1e0010">
</span></code></pre></div><p>library.h</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#ifndef MYSHAREDLIB_LIBRARY_H
</span><span style="color:#75715e">#define MYSHAREDLIB_LIBRARY_H
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// 打印 Hello World!
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">hello</span>();

<span style="color:#75715e">// 使用可变模版参数求和
</span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
T sum(T t)
{
    <span style="color:#66d9ef">return</span> t;
}
<span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T, <span style="color:#66d9ef">typename</span> ...Types<span style="color:#f92672">&gt;</span>
T sum(T first, Types ... rest)
{
    <span style="color:#66d9ef">return</span> first <span style="color:#f92672">+</span> sum<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>(rest...);
}

<span style="color:#75715e">#endif
</span></code></pre></div><p>library.cpp</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;library.h&#34;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">hello</span>() {
    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Hello, World!&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
}
</code></pre></div><h4 id="so-共享库的使用被可执行项目调用">so 共享库的使用（被可执行项目调用）</h4>
<p>使用 CLion 调用共享库</p>
<p>创建一个名为 TestSharedLib 的可执行项目</p>
<p>CMakeLists.txt</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cmake" data-lang="cmake">cmake_minimum_required(<span style="color:#e6db74">VERSION</span> <span style="color:#e6db74">3.10</span>)<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>project(<span style="color:#e6db74">TestSharedLib</span>)<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#75715e"># C++11 编译
</span><span style="color:#75715e"></span>set(<span style="color:#e6db74">CMAKE_CXX_STANDARD</span> <span style="color:#e6db74">11</span>)<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#75715e"># 头文件路径
</span><span style="color:#75715e"></span>set(<span style="color:#e6db74">INC_DIR</span> <span style="color:#e6db74">/home/xx/code/clion/MySharedLib</span>)<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#75715e"># 库文件路径
</span><span style="color:#75715e"></span>set(<span style="color:#e6db74">LIB_DIR</span> <span style="color:#e6db74">/home/xx/code/clion/MySharedLib/cmake-build-debug</span>)<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>include_directories(<span style="color:#f92672">${</span>INC_DIR<span style="color:#f92672">}</span>)<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>link_directories(<span style="color:#f92672">${</span>LIB_DIR<span style="color:#f92672">}</span>)<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>link_libraries(<span style="color:#e6db74">MySharedLib</span>)<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>add_executable(<span style="color:#e6db74">TestSharedLib</span> <span style="color:#e6db74">main.cpp</span>)<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#75715e"># 链接 MySharedLib 库
</span><span style="color:#75715e"></span>target_link_libraries(<span style="color:#e6db74">TestSharedLib</span> <span style="color:#e6db74">MySharedLib</span>)<span style="color:#960050;background-color:#1e0010">
</span></code></pre></div><p>main.cpp</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;library.h&#34;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> std<span style="color:#f92672">::</span>cout;
<span style="color:#66d9ef">using</span> std<span style="color:#f92672">::</span>endl;

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {

    hello();
    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;1 + 2 = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> sum(<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>) <span style="color:#f92672">&lt;&lt;</span> endl;
    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;1 + 2 + 3 = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> sum(<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>) <span style="color:#f92672">&lt;&lt;</span> endl;

    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>执行结果</p>
<pre tabindex="0"><code>Hello, World!
1 + 2 = 3
1 + 2 + 3 = 6
</code></pre><h3 id="windows-应用程序入口函数">Windows 应用程序入口函数</h3>
<ul>
<li>GUI（Graphical User Interface）应用，链接器选项：<code>/SUBSYSTEM:WINDOWS</code></li>
<li>CUI（Console User Interface）应用，链接器选项：<code>/SUBSYSTEM:CONSOLE</code></li>
</ul>
<p>_tWinMain 与 _tmain 函数声明</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">Int WINAPI <span style="color:#a6e22e">_tWinMain</span>(
    HINSTANCE hInstanceExe,
    HINSTANCE,
    PTSTR pszCmdLine,
    <span style="color:#66d9ef">int</span> nCmdShow);

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">_tmain</span>(
    <span style="color:#66d9ef">int</span> argc,
    TCHAR <span style="color:#f92672">*</span>argv[],
    TCHAR <span style="color:#f92672">*</span>envp[]);
</code></pre></div><table>
<thead>
<tr>
<th>应用程序类型</th>
<th>入口点函数</th>
<th>嵌入可执行文件的启动函数</th>
</tr>
</thead>
<tbody>
<tr>
<td>处理ANSI字符（串）的GUI应用程序</td>
<td>_tWinMain(WinMain)</td>
<td>WinMainCRTSartup</td>
</tr>
<tr>
<td>处理Unicode字符（串）的GUI应用程序</td>
<td>_tWinMain(wWinMain)</td>
<td>wWinMainCRTSartup</td>
</tr>
<tr>
<td>处理ANSI字符（串）的CUI应用程序</td>
<td>_tmain(Main)</td>
<td>mainCRTSartup</td>
</tr>
<tr>
<td>处理Unicode字符（串）的CUI应用程序</td>
<td>_tmain(wMain)</td>
<td>wmainCRTSartup</td>
</tr>
<tr>
<td>动态链接库（Dynamic-Link Library）</td>
<td>DllMain</td>
<td>_DllMainCRTStartup</td>
</tr>
</tbody>
</table>
<h3 id="windows-的动态链接库dynamic-link-library">Windows 的动态链接库（Dynamic-Link Library）</h3>
<blockquote>
<p>部分知识点来自《Windows 核心编程（第五版）》</p>
</blockquote>
<h4 id="用处">用处</h4>
<ul>
<li>扩展了应用程序的特性</li>
<li>简化了项目管理</li>
<li>有助于节省内存</li>
<li>促进了资源的共享</li>
<li>促进了本地化</li>
<li>有助于解决平台间的差异</li>
<li>可以用于特殊目的</li>
</ul>
<h4 id="注意">注意</h4>
<ul>
<li>创建 DLL，事实上是在创建可供一个可执行模块调用的函数</li>
<li>当一个模块提供一个内存分配函数（malloc、new）的时候，它必须同时提供另一个内存释放函数（free、delete）</li>
<li>在使用 C 和 C++ 混编的时候，要使用 extern &ldquo;C&rdquo; 修饰符</li>
<li>一个 DLL 可以导出函数、变量（避免导出）、C++ 类（导出导入需要同编译器，否则避免导出）</li>
<li>DLL 模块：cpp 文件中的 __declspec(dllexport) 写在 include 头文件之前</li>
<li>调用 DLL 的可执行模块：cpp 文件的 __declspec(dllimport) 之前不应该定义 MYLIBAPI</li>
</ul>
<h4 id="加载-windows-程序的搜索顺序">加载 Windows 程序的搜索顺序</h4>
<ol>
<li>包含可执行文件的目录</li>
<li>Windows 的系统目录，可以通过 GetSystemDirectory 得到</li>
<li>16 位的系统目录，即 Windows 目录中的 System 子目录</li>
<li>Windows 目录，可以通过 GetWindowsDirectory 得到</li>
<li>进程的当前目录</li>
<li>PATH 环境变量中所列出的目录</li>
</ol>
<h4 id="dll-入口函数">DLL 入口函数</h4>
<p>DllMain 函数</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">BOOL WINAPI <span style="color:#a6e22e">DllMain</span>(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
{
    <span style="color:#66d9ef">switch</span>(fdwReason)
    {
    <span style="color:#66d9ef">case</span> DLL_PROCESS_ATTACH:
        <span style="color:#75715e">// 第一次将一个DLL映射到进程地址空间时调用
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// The DLL is being mapped into the process&#39; address space.
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">break</span>;
    <span style="color:#66d9ef">case</span> DLL_THREAD_ATTACH:
        <span style="color:#75715e">// 当进程创建一个线程的时候，用于告诉DLL执行与线程相关的初始化（非主线程执行）
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// A thread is bing created.
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">break</span>;
    <span style="color:#66d9ef">case</span> DLL_THREAD_DETACH:
        <span style="color:#75715e">// 系统调用 ExitThread 线程退出前，即将终止的线程通过告诉DLL执行与线程相关的清理
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// A thread is exiting cleanly.
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">break</span>;
    <span style="color:#66d9ef">case</span> DLL_PROCESS_DETACH:
        <span style="color:#75715e">// 将一个DLL从进程的地址空间时调用
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// The DLL is being unmapped from the process&#39; address space.
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">break</span>;
    }
    <span style="color:#66d9ef">return</span> (TRUE); <span style="color:#75715e">// Used only for DLL_PROCESS_ATTACH
</span><span style="color:#75715e"></span>}
</code></pre></div><h4 id="载入卸载库">载入卸载库</h4>
<p>LoadLibrary、LoadLibraryExA、LoadPackagedLibrary、FreeLibrary、FreeLibraryAndExitThread 函数声明</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// 载入库
</span><span style="color:#75715e"></span>HMODULE WINAPI <span style="color:#a6e22e">LoadLibrary</span>(
  _In_ LPCTSTR lpFileName
);
HMODULE <span style="color:#a6e22e">LoadLibraryExA</span>(
  LPCSTR lpLibFileName,
  HANDLE hFile,
  DWORD  dwFlags
);
<span style="color:#75715e">// 若要在通用 Windows 平台（UWP）应用中加载 Win32 DLL，需要调用 LoadPackagedLibrary，而不是 LoadLibrary 或 LoadLibraryEx
</span><span style="color:#75715e"></span>HMODULE <span style="color:#a6e22e">LoadPackagedLibrary</span>(
  LPCWSTR lpwLibFileName,
  DWORD   Reserved
);

<span style="color:#75715e">// 卸载库
</span><span style="color:#75715e"></span>BOOL WINAPI <span style="color:#a6e22e">FreeLibrary</span>(
  _In_ HMODULE hModule
);
<span style="color:#75715e">// 卸载库和退出线程
</span><span style="color:#75715e"></span>VOID WINAPI <span style="color:#a6e22e">FreeLibraryAndExitThread</span>(
  _In_ HMODULE hModule,
  _In_ DWORD   dwExitCode
);
</code></pre></div><h4 id="显示地链接到导出符号">显示地链接到导出符号</h4>
<p>GetProcAddress 函数声明</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">FARPROC <span style="color:#a6e22e">GetProcAddress</span>(
  HMODULE hInstDll,
  PCSTR pszSymbolName  <span style="color:#75715e">// 只能接受 ANSI 字符串，不能是 Unicode
</span><span style="color:#75715e"></span>);
</code></pre></div><h4 id="dumpbinexe-查看-dll-信息">DumpBin.exe 查看 DLL 信息</h4>
<p>在 <code>VS 的开发人员命令提示符</code> 使用 <code>DumpBin.exe</code> 可查看 DLL 库的导出段（导出的变量、函数、类名的符号）、相对虚拟地址（RVA，relative virtual address）。如：</p>
<pre tabindex="0"><code>DUMPBIN -exports D:\mydll.dll
</code></pre><h4 id="loadlibrary-与-freelibrary-流程图">LoadLibrary 与 FreeLibrary 流程图</h4>
<p>LoadLibrary 与 FreeLibrary 流程图</p>
<h5 id="loadlibrary">LoadLibrary</h5>
<p><img src="https://gitee.com/huihut/interview/raw/master/images/WindowsLoadLibrary.png" alt="WindowsLoadLibrary"></p>
<h5 id="freelibrary">FreeLibrary</h5>
<p><img src="https://gitee.com/huihut/interview/raw/master/images/WindowsFreeLibrary.png" alt="WindowsFreeLibrary"></p>
<h4 id="dll-库的编写导出一个-dll-模块">DLL 库的编写（导出一个 DLL 模块）</h4>
<p>DLL 库的编写（导出一个 DLL 模块）
DLL 头文件</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// MyLib.h
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#ifdef MYLIBAPI
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// MYLIBAPI 应该在全部 DLL 源文件的 include &#34;Mylib.h&#34; 之前被定义
</span><span style="color:#75715e">// 全部函数/变量正在被导出
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#else
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// 这个头文件被一个exe源代码模块包含，意味着全部函数/变量被导入
</span><span style="color:#75715e"></span><span style="color:#75715e">#define MYLIBAPI extern &#34;C&#34; __declspec(dllimport)
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#endif
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// 这里定义任何的数据结构和符号
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// 定义导出的变量（避免导出变量）
</span><span style="color:#75715e"></span>MYLIBAPI <span style="color:#66d9ef">int</span> g_nResult;

<span style="color:#75715e">// 定义导出函数原型
</span><span style="color:#75715e"></span>MYLIBAPI <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">Add</span>(<span style="color:#66d9ef">int</span> nLeft, <span style="color:#66d9ef">int</span> nRight);
</code></pre></div><p>DLL 源文件</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// MyLibFile1.cpp
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// 包含标准Windows和C运行时头文件
</span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;windows.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// DLL源码文件导出的函数和变量
</span><span style="color:#75715e"></span><span style="color:#75715e">#define MYLIBAPI extern &#34;C&#34; __declspec(dllexport)
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// 包含导出的数据结构、符号、函数、变量
</span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;MyLib.h&#34;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// 将此DLL源代码文件的代码放在此处
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> g_nResult;

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">Add</span>(<span style="color:#66d9ef">int</span> nLeft, <span style="color:#66d9ef">int</span> nRight)
{
    g_nResult <span style="color:#f92672">=</span> nLeft <span style="color:#f92672">+</span> nRight;
    <span style="color:#66d9ef">return</span> g_nResult;
}
</code></pre></div><h4 id="dll-库的使用运行时动态链接-dll">DLL 库的使用（运行时动态链接 DLL）</h4>
<p>DLL 库的使用（运行时动态链接 DLL）</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// A simple program that uses LoadLibrary and 
</span><span style="color:#75715e">// GetProcAddress to access myPuts from Myputs.dll. 
</span><span style="color:#75715e"></span> 
<span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;windows.h&gt; </span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt; </span><span style="color:#75715e">
</span><span style="color:#75715e"></span> 
<span style="color:#66d9ef">typedef</span> <span style="color:#a6e22e">int</span> (<span style="color:#66d9ef">__cdecl</span> <span style="color:#f92672">*</span>MYPROC)(LPWSTR); 
 
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>( <span style="color:#66d9ef">void</span> ) 
{ 
    HINSTANCE hinstLib; 
    MYPROC ProcAdd; 
    BOOL fFreeResult, fRunTimeLinkSuccess <span style="color:#f92672">=</span> FALSE; 
 
    <span style="color:#75715e">// Get a handle to the DLL module.
</span><span style="color:#75715e"></span> 
    hinstLib <span style="color:#f92672">=</span> LoadLibrary(TEXT(<span style="color:#e6db74">&#34;MyPuts.dll&#34;</span>)); 
 
    <span style="color:#75715e">// If the handle is valid, try to get the function address.
</span><span style="color:#75715e"></span> 
    <span style="color:#66d9ef">if</span> (hinstLib <span style="color:#f92672">!=</span> NULL) 
    { 
        ProcAdd <span style="color:#f92672">=</span> (MYPROC) GetProcAddress(hinstLib, <span style="color:#e6db74">&#34;myPuts&#34;</span>); 
 
        <span style="color:#75715e">// If the function address is valid, call the function.
</span><span style="color:#75715e"></span> 
        <span style="color:#66d9ef">if</span> (NULL <span style="color:#f92672">!=</span> ProcAdd) 
        {
            fRunTimeLinkSuccess <span style="color:#f92672">=</span> TRUE;
            (ProcAdd) (<span style="color:#e6db74">L</span><span style="color:#e6db74">&#34;Message sent to the DLL function</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>); 
        }
        <span style="color:#75715e">// Free the DLL module.
</span><span style="color:#75715e"></span> 
        fFreeResult <span style="color:#f92672">=</span> FreeLibrary(hinstLib); 
    } 

    <span style="color:#75715e">// If unable to call the DLL function, use an alternative.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span> fRunTimeLinkSuccess) 
        printf(<span style="color:#e6db74">&#34;Message printed from executable</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>); 

    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="运行库runtime-library">运行库（Runtime Library）</h3>
<h4 id="典型程序运行步骤">典型程序运行步骤</h4>
<ol>
<li>操作系统创建进程，把控制权交给程序的入口（往往是运行库中的某个入口函数）</li>
<li>入口函数对运行库和程序运行环境进行初始化（包括堆、I/O、线程、全局变量构造等等）。</li>
<li>入口函数初始化后，调用 main 函数，正式开始执行程序主体部分。</li>
<li>main 函数执行完毕后，返回到入口函数进行清理工作（包括全局变量析构、堆销毁、关闭I/O等），然后进行系统调用结束进程。</li>
</ol>
<blockquote>
<p>一个程序的 I/O 指代程序与外界的交互，包括文件、管程、网络、命令行、信号等。更广义地讲，I/O 指代操作系统理解为 “文件” 的事物。</p>
</blockquote>
<h4 id="glibc-入口">glibc 入口</h4>
<p><code>_start -&gt; __libc_start_main -&gt; exit -&gt; _exit</code></p>
<p>其中 <code>main(argc, argv, __environ)</code> 函数在 <code>__libc_start_main</code> 里执行。</p>
<h4 id="msvc-crt-入口">MSVC CRT 入口</h4>
<p><code>int mainCRTStartup(void)</code></p>
<p>执行如下操作：</p>
<ol>
<li>初始化和 OS 版本有关的全局变量。</li>
<li>初始化堆。</li>
<li>初始化 I/O。</li>
<li>获取命令行参数和环境变量。</li>
<li>初始化 C 库的一些数据。</li>
<li>调用 main 并记录返回值。</li>
<li>检查错误并将 main 的返回值返回。</li>
</ol>
<h4 id="c-语言运行库crt">C 语言运行库（CRT）</h4>
<p>大致包含如下功能：</p>
<ul>
<li>启动与退出：包括入口函数及入口函数所依赖的其他函数等。</li>
<li>标准函数：有 C 语言标准规定的C语言标准库所拥有的函数实现。</li>
<li>I/O：I/O 功能的封装和实现。</li>
<li>堆：堆的封装和实现。</li>
<li>语言实现：语言中一些特殊功能的实现。</li>
<li>调试：实现调试功能的代码。</li>
</ul>
<h4 id="c语言标准库ansi-c">C语言标准库（ANSI C）</h4>
<p>包含：</p>
<ul>
<li>标准输入输出（stdio.h）</li>
<li>文件操作（stdio.h）</li>
<li>字符操作（ctype.h）</li>
<li>字符串操作（string.h）</li>
<li>数学函数（math.h）</li>
<li>资源管理（stdlib.h）</li>
<li>格式转换（stdlib.h）</li>
<li>时间/日期（time.h）</li>
<li>断言（assert.h）</li>
<li>各种类型上的常数（limits.h &amp; float.h）</li>
<li>变长参数（stdarg.h）</li>
<li>非局部跳转（setjmp.h）</li>
</ul>

        
        ]]>
      </description>
=======
      <description>转载自https://github.com/huihut/interview 本节部分知识点来自《程序员的自我修养——链接装载库》 内存、栈、堆</description>
>>>>>>> 35a30928abf5c3213b754024efc550556652db2d
    </item>
    
    <item>
      <title>【转载】C&#43;&#43; 开发必备之数据库</title>
      <link>/collection/database/</link>
      <pubDate>Sat, 15 Jan 2022 08:08:34 +0800</pubDate>
      
      <guid>/collection/database/</guid>
      <description>转载自https://github.com/huihut/interview 本节部分知识点来自《数据库系统概论（第 5 版）》 基本概念 数据（da</description>
    </item>
    
    <item>
      <title>【转载】C&#43;&#43; 开发必备之计算机网络</title>
      <link>/collection/network/</link>
      <pubDate>Sat, 15 Jan 2022 08:06:35 +0800</pubDate>
      
      <guid>/collection/network/</guid>
<<<<<<< HEAD
      <description>
        <![CDATA[
        <p>转载自<a href="https://github.com/huihut/interview">https://github.com/huihut/interview</a></p>
<blockquote>
<p>本节部分知识点来自《计算机网络（第 7 版）》</p>
</blockquote>
<p>计算机网络体系结构：</p>
<p><img src="https://gitee.com/huihut/interview/raw/master/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png" alt="计算机网络体系结构"></p>
<h3 id="各层作用及协议">各层作用及协议</h3>
<table>
<thead>
<tr>
<th>分层</th>
<th>作用</th>
<th>协议</th>
</tr>
</thead>
<tbody>
<tr>
<td>物理层</td>
<td>通过媒介传输比特，确定机械及电气规范（比特 Bit）</td>
<td>RJ45、CLOCK、IEEE802.3（中继器，集线器）</td>
</tr>
<tr>
<td>数据链路层</td>
<td>将比特组装成帧和点到点的传递（帧 Frame）</td>
<td>PPP、FR、HDLC、VLAN、MAC（网桥，交换机）</td>
</tr>
<tr>
<td>网络层</td>
<td>负责数据包从源到宿的传递和网际互连（包 Packet）</td>
<td>IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP（路由器）</td>
</tr>
<tr>
<td>运输层</td>
<td>提供端到端的可靠报文传递和错误恢复（ 段Segment）</td>
<td>TCP、UDP、SPX</td>
</tr>
<tr>
<td>会话层</td>
<td>建立、管理和终止会话（会话协议数据单元 SPDU）</td>
<td>NFS、SQL、NETBIOS、RPC</td>
</tr>
<tr>
<td>表示层</td>
<td>对数据进行翻译、加密和压缩（表示协议数据单元 PPDU）</td>
<td>JPEG、MPEG、ASII</td>
</tr>
<tr>
<td>应用层</td>
<td>允许访问OSI环境的手段（应用协议数据单元 APDU）</td>
<td>FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS</td>
</tr>
</tbody>
</table>
<h3 id="物理层">物理层</h3>
<ul>
<li>传输数据的单位：比特</li>
<li>数据传输系统：源系统（源点、发送器） &ndash;&gt; 传输系统 &ndash;&gt; 目的系统（接收器、终点）</li>
</ul>
<p>通道：</p>
<ul>
<li>单向通道（单工通道）：只有一个方向通信，没有反方向交互，如广播</li>
<li>双向交替通信（半双工通信）：通信双方都可发消息，但不能同时发送或接收</li>
<li>双向同时通信（全双工通信）：通信双方可以同时发送和接收信息</li>
</ul>
<p>通道复用技术：</p>
<ul>
<li>频分复用（FDM，Frequency Division Multiplexing）：不同用户在不同频带，所用用户在同样时间占用不同带宽资源</li>
<li>时分复用（TDM，Time Division Multiplexing）：不同用户在同一时间段的不同时间片，所有用户在不同时间占用同样的频带宽度</li>
<li>波分复用（WDM，Wavelength Division Multiplexing）：光的频分复用</li>
<li>码分复用（CDM，Code Division Multiplexing）：不同用户使用不同的码，可以在同样时间使用同样频带通信</li>
</ul>
<h3 id="数据链路层">数据链路层</h3>
<p>主要信道：</p>
<ul>
<li>点对点信道</li>
<li>广播信道</li>
</ul>
<h4 id="点对点信道">点对点信道</h4>
<ul>
<li>数据单元：帧</li>
</ul>
<p>三个基本问题：</p>
<ul>
<li>封装成帧：把网络层的 IP 数据报封装成帧，<code>SOH - 数据部分 - EOT</code></li>
<li>透明传输：不管数据部分什么字符，都能传输出去；可以通过字节填充方法解决（冲突字符前加转义字符）</li>
<li>差错检测：降低误码率（BER，Bit Error Rate），广泛使用循环冗余检测（CRC，Cyclic Redundancy Check）</li>
</ul>
<p>点对点协议（Point-to-Point Protocol）：</p>
<ul>
<li>点对点协议（Point-to-Point Protocol）：用户计算机和 ISP 通信时所使用的协议</li>
</ul>
<h4 id="广播信道">广播信道</h4>
<p>广播通信：</p>
<ul>
<li>硬件地址（物理地址、MAC 地址）</li>
<li>单播（unicast）帧（一对一）：收到的帧的 MAC 地址与本站的硬件地址相同</li>
<li>广播（broadcast）帧（一对全体）：发送给本局域网上所有站点的帧</li>
<li>多播（multicast）帧（一对多）：发送给本局域网上一部分站点的帧</li>
</ul>
<h3 id="网络层">网络层</h3>
<ul>
<li>IP（Internet Protocol，网际协议）是为计算机网络相互连接进行通信而设计的协议。</li>
<li>ARP（Address Resolution Protocol，地址解析协议）</li>
<li>ICMP（Internet Control Message Protocol，网际控制报文协议）</li>
<li>IGMP（Internet Group Management Protocol，网际组管理协议）</li>
</ul>
<h4 id="ip-网际协议">IP 网际协议</h4>
<p>IP 地址分类：</p>
<ul>
<li><code>IP 地址 ::= {&lt;网络号&gt;,&lt;主机号&gt;}</code></li>
</ul>
<table>
<thead>
<tr>
<th>IP 地址类别</th>
<th>网络号</th>
<th>网络范围</th>
<th>主机号</th>
<th>IP 地址范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>A 类</td>
<td>8bit，第一位固定为 0</td>
<td>0 —— 127</td>
<td>24bit</td>
<td>1.0.0.0 —— 127.255.255.255</td>
</tr>
<tr>
<td>B 类</td>
<td>16bit，前两位固定为  10</td>
<td>128.0 —— 191.255</td>
<td>16bit</td>
<td>128.0.0.0 —— 191.255.255.255</td>
</tr>
<tr>
<td>C  类</td>
<td>24bit，前三位固定为  110</td>
<td>192.0.0 —— 223.255.255</td>
<td>8bit</td>
<td>192.0.0.0 —— 223.255.255.255</td>
</tr>
<tr>
<td>D  类</td>
<td>前四位固定为 1110，后面为多播地址</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>E  类</td>
<td>前五位固定为 11110，后面保留为今后所用</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>IP 数据报格式：</p>
<p><img src="https://gitee.com/huihut/interview/raw/master/images/IP%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%A0%BC%E5%BC%8F.png" alt="IP 数据报格式"></p>
<h4 id="icmp-网际控制报文协议">ICMP 网际控制报文协议</h4>
<p>ICMP 报文格式：</p>
<p><img src="https://gitee.com/huihut/interview/raw/master/images/ICMP%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F.png" alt="ICMP 报文格式"></p>
<p>应用：</p>
<ul>
<li>PING（Packet InterNet Groper，分组网间探测）测试两个主机之间的连通性</li>
<li>TTL（Time To Live，生存时间）该字段指定 IP 包被路由器丢弃之前允许通过的最大网段数量</li>
</ul>
<h4 id="内部网关协议">内部网关协议</h4>
<ul>
<li>RIP（Routing Information Protocol，路由信息协议）</li>
<li>OSPF（Open Sortest Path First，开放最短路径优先）</li>
</ul>
<h4 id="外部网关协议">外部网关协议</h4>
<ul>
<li>BGP（Border Gateway Protocol，边界网关协议）</li>
</ul>
<h4 id="ip多播">IP多播</h4>
<ul>
<li>IGMP（Internet Group Management Protocol，网际组管理协议）</li>
<li>多播路由选择协议</li>
</ul>
<h4 id="vpn-和-nat">VPN 和 NAT</h4>
<ul>
<li>VPN（Virtual Private Network，虚拟专用网）</li>
<li>NAT（Network Address Translation，网络地址转换）</li>
</ul>
<h4 id="路由表包含什么">路由表包含什么？</h4>
<ol>
<li>网络 ID（Network ID, Network number）：就是目标地址的网络 ID。</li>
<li>子网掩码（subnet mask）：用来判断 IP 所属网络</li>
<li>下一跳地址/接口（Next hop / interface）：就是数据在发送到目标地址的旅途中下一站的地址。其中 interface 指向 next hop（即为下一个 route）。一个自治系统（AS, Autonomous system）中的 route 应该包含区域内所有的子网络，而默认网关（Network id: <code>0.0.0.0</code>, Netmask: <code>0.0.0.0</code>）指向自治系统的出口。</li>
</ol>
<p>根据应用和执行的不同，路由表可能含有如下附加信息：</p>
<ol>
<li>花费（Cost）：就是数据发送过程中通过路径所需要的花费。</li>
<li>路由的服务质量</li>
<li>路由中需要过滤的出/入连接列表</li>
</ol>
<h3 id="运输层">运输层</h3>
<p>协议：</p>
<ul>
<li>TCP（Transmission Control Protocol，传输控制协议）</li>
<li>UDP（User Datagram Protocol，用户数据报协议）</li>
</ul>
<p>端口：</p>
<table>
<thead>
<tr>
<th>应用程序</th>
<th>FTP</th>
<th>TELNET</th>
<th>SMTP</th>
<th>DNS</th>
<th>TFTP</th>
<th>HTTP</th>
<th>HTTPS</th>
<th>SNMP</th>
</tr>
</thead>
<tbody>
<tr>
<td>端口号</td>
<td>21</td>
<td>23</td>
<td>25</td>
<td>53</td>
<td>69</td>
<td>80</td>
<td>443</td>
<td>161</td>
</tr>
</tbody>
</table>
<h4 id="tcp">TCP</h4>
<ul>
<li>TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议，其传输的单位是报文段。</li>
</ul>
<p>特征：</p>
<ul>
<li>面向连接</li>
<li>只能点对点（一对一）通信</li>
<li>可靠交互</li>
<li>全双工通信</li>
<li>面向字节流</li>
</ul>
<p>TCP 如何保证可靠传输：</p>
<ul>
<li>确认和超时重传</li>
<li>数据合理分片和排序</li>
<li>流量控制</li>
<li>拥塞控制</li>
<li>数据校验</li>
</ul>
<p>TCP 报文结构</p>
<p><img src="https://gitee.com/huihut/interview/raw/master/images/TCP%E6%8A%A5%E6%96%87.png" alt="TCP 报文"></p>
<p>TCP 首部</p>
<p><img src="https://gitee.com/huihut/interview/raw/master/images/TCP%E9%A6%96%E9%83%A8.png" alt="TCP 首部"></p>
<p>TCP：状态控制码（Code，Control Flag），占 6 比特，含义如下：</p>
<ul>
<li>URG：紧急比特（urgent），当 <code>URG＝1</code> 时，表明紧急指针字段有效，代表该封包为紧急封包。它告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据)， 且上图中的 Urgent Pointer 字段也会被启用。</li>
<li>ACK：确认比特（Acknowledge）。只有当 <code>ACK＝1</code> 时确认号字段才有效，代表这个封包为确认封包。当 <code>ACK＝0</code> 时，确认号无效。</li>
<li>PSH：（Push function）若为 1 时，代表要求对方立即传送缓冲区内的其他对应封包，而无需等缓冲满了才送。</li>
<li>RST：复位比特(Reset)，当 <code>RST＝1</code> 时，表明 TCP 连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接。</li>
<li>SYN：同步比特(Synchronous)，SYN 置为 1，就表示这是一个连接请求或连接接受报文，通常带有 SYN 标志的封包表示『主动』要连接到对方的意思。</li>
<li>FIN：终止比特(Final)，用来释放一个连接。当 <code>FIN＝1</code> 时，表明此报文段的发送端的数据已发送完毕，并要求释放运输连接。</li>
</ul>
<h4 id="udp">UDP</h4>
<ul>
<li>UDP（User Datagram Protocol，用户数据报协议）是 OSI（Open System Interconnection 开放式系统互联） 参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务，其传输的单位是用户数据报。</li>
</ul>
<p>特征：</p>
<ul>
<li>无连接</li>
<li>尽最大努力交付</li>
<li>面向报文</li>
<li>没有拥塞控制</li>
<li>支持一对一、一对多、多对一、多对多的交互通信</li>
<li>首部开销小</li>
</ul>
<p>UDP 报文结构</p>
<p><img src="https://gitee.com/huihut/interview/raw/master/images/UDP%E6%8A%A5%E6%96%87.png" alt="UDP 报文"></p>
<p>UDP 首部</p>
<p><img src="https://gitee.com/huihut/interview/raw/master/images/UDP%E9%A6%96%E9%83%A8.png" alt="UDP 首部"></p>
<blockquote>
<p>TCP/UDP 图片来源于：<a href="https://github.com/JerryC8080/understand-tcp-udp">https://github.com/JerryC8080/understand-tcp-udp</a></p>
</blockquote>
<h4 id="tcp-与-udp-的区别">TCP 与 UDP 的区别</h4>
<ol>
<li>TCP 面向连接，UDP 是无连接的；</li>
<li>TCP 提供可靠的服务，也就是说，通过 TCP 连接传送的数据，无差错，不丢失，不重复，且按序到达；UDP 尽最大努力交付，即不保证可靠交付</li>
<li>TCP 的逻辑通信信道是全双工的可靠信道；UDP 则是不可靠信道</li>
<li>每一条 TCP 连接只能是点到点的；UDP 支持一对一，一对多，多对一和多对多的交互通信</li>
<li>TCP 面向字节流（可能出现黏包问题），实际上是 TCP 把数据看成一连串无结构的字节流；UDP 是面向报文的（不会出现黏包问题）</li>
<li>UDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如 IP 电话，实时视频会议等）</li>
<li>TCP 首部开销20字节；UDP 的首部开销小，只有 8 个字节</li>
</ol>
<h4 id="tcp-黏包问题">TCP 黏包问题</h4>
<h5 id="原因">原因</h5>
<p>TCP 是一个基于字节流的传输服务（UDP 基于报文的），“流” 意味着 TCP 所传输的数据是没有边界的。所以可能会出现两个数据包黏在一起的情况。</p>
<h5 id="解决">解决</h5>
<ul>
<li>发送定长包。如果每个消息的大小都是一样的，那么在接收对等方只要累计接收数据，直到数据等于一个定长的数值就将它作为一个消息。</li>
<li>包头加上包体长度。包头是定长的 4 个字节，说明了包体的长度。接收对等方先接收包头长度，依据包头长度来接收包体。</li>
<li>在数据包之间设置边界，如添加特殊符号 <code>\r\n</code> 标记。FTP 协议正是这么做的。但问题在于如果数据正文中也含有 <code>\r\n</code>，则会误判为消息的边界。</li>
<li>使用更加复杂的应用层协议。</li>
</ul>
<h4 id="tcp-流量控制">TCP 流量控制</h4>
<h5 id="概念">概念</h5>
<p>流量控制（flow control）就是让发送方的发送速率不要太快，要让接收方来得及接收。</p>
<h5 id="方法">方法</h5>
<p>利用可变窗口进行流量控制</p>
<p><img src="https://gitee.com/huihut/interview/raw/master/images/%E5%88%A9%E7%94%A8%E5%8F%AF%E5%8F%98%E7%AA%97%E5%8F%A3%E8%BF%9B%E8%A1%8C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E4%B8%BE%E4%BE%8B.png" alt=""></p>
<h4 id="tcp-拥塞控制">TCP 拥塞控制</h4>
<h5 id="概念-1">概念</h5>
<p>拥塞控制就是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。</p>
<h5 id="方法-1">方法</h5>
<ul>
<li>慢开始( slow-start )</li>
<li>拥塞避免( congestion avoidance )</li>
<li>快重传( fast retransmit )</li>
<li>快恢复( fast recovery )</li>
</ul>
<p>TCP的拥塞控制图</p>
<p><img src="https://gitee.com/huihut/interview/raw/master/images/TCP%E6%8B%A5%E5%A1%9E%E7%AA%97%E5%8F%A3cwnd%E5%9C%A8%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E6%97%B6%E7%9A%84%E5%8F%98%E5%8C%96%E6%83%85%E5%86%B5.png" alt="">
<img src="https://gitee.com/huihut/interview/raw/master/images/%E5%BF%AB%E9%87%8D%E4%BC%A0%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="">
<img src="https://gitee.com/huihut/interview/raw/master/images/TCP%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt=""></p>
<h4 id="tcp-传输连接管理">TCP 传输连接管理</h4>
<blockquote>
<p>因为 TCP 三次握手建立连接、四次挥手释放连接很重要，所以附上《计算机网络（第 7 版）-谢希仁》书中对此章的详细描述：<a href="https://gitee.com/huihut/interview/raw/master/images/TCP-transport-connection-management.png">https://gitee.com/huihut/interview/raw/master/images/TCP-transport-connection-management.png</a></p>
</blockquote>
<h5 id="tcp-三次握手建立连接">TCP 三次握手建立连接</h5>
<p><img src="https://gitee.com/huihut/interview/raw/master/images/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5.png" alt="UDP 报文"></p>
<p>【TCP 建立连接全过程解释】</p>
<ol>
<li>客户端发送 SYN 给服务器，说明客户端请求建立连接；</li>
<li>服务端收到客户端发的 SYN，并回复 SYN+ACK 给客户端（同意建立连接）；</li>
<li>客户端收到服务端的 SYN+ACK 后，回复 ACK 给服务端（表示客户端收到了服务端发的同意报文）；</li>
<li>服务端收到客户端的 ACK，连接已建立，可以数据传输。</li>
</ol>
<h5 id="tcp-为什么要进行三次握手">TCP 为什么要进行三次握手？</h5>
<p>【答案一】因为信道不可靠，而 TCP 想在不可靠信道上建立可靠地传输，那么三次通信是理论上的最小值。（而 UDP 则不需建立可靠传输，因此 UDP 不需要三次握手。）</p>
<blockquote>
<p><a href="https://groups.google.com/forum/#!msg/pongba/kF6O7-MFxM0/5S7zIJ4yqKUJ">Google Groups . TCP 建立连接为什么是三次握手？{技术}{网络通信}</a></p>
</blockquote>
<p>【答案二】因为双方都需要确认对方收到了自己发送的序列号，确认过程最少要进行三次通信。</p>
<blockquote>
<p><a href="https://www.zhihu.com/question/24853633/answer/115173386">知乎 . TCP 为什么是三次握手，而不是两次或四次？</a></p>
</blockquote>
<p>【答案三】为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。</p>
<blockquote>
<p><a href="https://gitee.com/huihut/interview/raw/master/images/TCP-transport-connection-management.png">《计算机网络（第 7 版）-谢希仁》</a></p>
</blockquote>
<h5 id="tcp-四次挥手释放连接">TCP 四次挥手释放连接</h5>
<p><img src="https://gitee.com/huihut/interview/raw/master/images/TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E9%87%8A%E6%94%BE%E8%BF%9E%E6%8E%A5.png" alt="UDP 报文"></p>
<p>【TCP 释放连接全过程解释】</p>
<ol>
<li>客户端发送 FIN 给服务器，说明客户端不必发送数据给服务器了（请求释放从客户端到服务器的连接）；</li>
<li>服务器接收到客户端发的 FIN，并回复 ACK 给客户端（同意释放从客户端到服务器的连接）；</li>
<li>客户端收到服务端回复的 ACK，此时从客户端到服务器的连接已释放（但服务端到客户端的连接还未释放，并且客户端还可以接收数据）；</li>
<li>服务端继续发送之前没发完的数据给客户端；</li>
<li>服务端发送 FIN+ACK 给客户端，说明服务端发送完了数据（请求释放从服务端到客户端的连接，就算没收到客户端的回复，过段时间也会自动释放）；</li>
<li>客户端收到服务端的 FIN+ACK，并回复 ACK 给客户端（同意释放从服务端到客户端的连接）；</li>
<li>服务端收到客户端的 ACK 后，释放从服务端到客户端的连接。</li>
</ol>
<h5 id="tcp-为什么要进行四次挥手">TCP 为什么要进行四次挥手？</h5>
<p>【问题一】TCP 为什么要进行四次挥手？ / 为什么 TCP 建立连接需要三次，而释放连接则需要四次？</p>
<p>【答案一】因为 TCP 是全双工模式，客户端请求关闭连接后，客户端向服务端的连接关闭（一二次挥手），服务端继续传输之前没传完的数据给客户端（数据传输），服务端向客户端的连接关闭（三四次挥手）。所以 TCP 释放连接时服务器的 ACK 和 FIN 是分开发送的（中间隔着数据传输），而 TCP 建立连接时服务器的 ACK 和 SYN 是一起发送的（第二次握手），所以 TCP 建立连接需要三次，而释放连接则需要四次。</p>
<p>【问题二】为什么 TCP 连接时可以 ACK 和 SYN 一起发送，而释放时则 ACK 和 FIN 分开发送呢？（ACK 和 FIN 分开是指第二次和第三次挥手）</p>
<p>【答案二】因为客户端请求释放时，服务器可能还有数据需要传输给客户端，因此服务端要先响应客户端 FIN 请求（服务端发送 ACK），然后数据传输，传输完成后，服务端再提出 FIN 请求（服务端发送 FIN）；而连接时则没有中间的数据传输，因此连接时可以 ACK 和 SYN 一起发送。</p>
<p>【问题三】为什么客户端释放最后需要 TIME-WAIT 等待 2MSL 呢？</p>
<p>【答案三】</p>
<ol>
<li>为了保证客户端发送的最后一个 ACK 报文能够到达服务端。若未成功到达，则服务端超时重传 FIN+ACK 报文段，客户端再重传 ACK，并重新计时。</li>
<li>防止已失效的连接请求报文段出现在本连接中。TIME-WAIT 持续 2MSL 可使本连接持续的时间内所产生的所有报文段都从网络中消失，这样可使下次连接中不会出现旧的连接报文段。</li>
</ol>
<h4 id="tcp-有限状态机">TCP 有限状态机</h4>
<p>TCP 有限状态机图片</p>
<p><img src="https://gitee.com/huihut/interview/raw/master/images/TCP%E7%9A%84%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA.png" alt="TCP 的有限状态机"></p>
<h3 id="应用层">应用层</h3>
<h4 id="dns">DNS</h4>
<ul>
<li>DNS（Domain Name System，域名系统）是互联网的一项服务。它作为将域名和 IP 地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。DNS 使用 TCP 和 UDP 端口 53。当前，对于每一级域名长度的限制是 63 个字符，域名总长度则不能超过 253 个字符。</li>
</ul>
<p>域名：</p>
<ul>
<li><code>域名 ::= {&lt;三级域名&gt;.&lt;二级域名&gt;.&lt;顶级域名&gt;}</code>，如：<code>blog.huihut.com</code></li>
</ul>
<h4 id="ftp">FTP</h4>
<ul>
<li>FTP（File Transfer Protocol，文件传输协议）是用于在网络上进行文件传输的一套标准协议，使用客户/服务器模式，使用 TCP 数据报，提供交互式访问，双向传输。</li>
<li>TFTP（Trivial File Transfer Protocol，简单文件传输协议）一个小且易实现的文件传输协议，也使用客户-服务器方式，使用UDP数据报，只支持文件传输而不支持交互，没有列目录，不能对用户进行身份鉴定</li>
</ul>
<h4 id="telnet">TELNET</h4>
<ul>
<li>
<p>TELNET 协议是 TCP/IP 协议族中的一员，是 Internet 远程登陆服务的标准协议和主要方式。它为用户提供了在本地计算机上完成远程主机工作的能力。</p>
</li>
<li>
<p>HTTP（HyperText Transfer Protocol，超文本传输协议）是用于从 WWW（World Wide Web，万维网）服务器传输超文本到本地浏览器的传送协议。</p>
</li>
<li>
<p>SMTP（Simple Mail Transfer Protocol，简单邮件传输协议）是一组用于由源地址到目的地址传送邮件的规则，由它来控制信件的中转方式。SMTP 协议属于 TCP/IP 协议簇，它帮助每台计算机在发送或中转信件时找到下一个目的地。</p>
</li>
<li>
<p>Socket 建立网络通信连接至少要一对端口号（Socket）。Socket 本质是编程接口（API），对 TCP/IP 的封装，TCP/IP 也要提供可供程序员做网络开发所用的接口，这就是 Socket 编程接口。</p>
</li>
</ul>
<h4 id="www">WWW</h4>
<ul>
<li>WWW（World Wide Web，环球信息网，万维网）是一个由许多互相链接的超文本组成的系统，通过互联网访问</li>
</ul>
<h5 id="url">URL</h5>
<ul>
<li>URL（Uniform Resource Locator，统一资源定位符）是因特网上标准的资源的地址（Address）</li>
</ul>
<p>标准格式：</p>
<ul>
<li><code>协议类型:[//服务器地址[:端口号]][/资源层级UNIX文件路径]文件名[?查询][#片段ID]</code></li>
</ul>
<p>完整格式：</p>
<ul>
<li><code>协议类型:[//[访问资源需要的凭证信息@]服务器地址[:端口号]][/资源层级UNIX文件路径]文件名[?查询][#片段ID]</code></li>
</ul>
<blockquote>
<p>其中【访问凭证信息@；:端口号；?查询；#片段ID】都属于选填项<br>
如：<code>https://github.com/huihut/interview#cc</code></p>
</blockquote>
<h5 id="http">HTTP</h5>
<p>HTTP（HyperText Transfer Protocol，超文本传输协议）是一种用于分布式、协作式和超媒体信息系统的应用层协议。HTTP 是万维网的数据通信的基础。</p>
<p>请求方法</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>OPTIONS</td>
<td>请求一些选项信息，允许客户端查看服务器的性能</td>
</tr>
<tr>
<td>GET</td>
<td>请求指定的页面信息，并返回实体主体</td>
</tr>
<tr>
<td>HEAD</td>
<td>类似于 get 请求，只不过返回的响应中没有具体的内容，用于获取报头</td>
</tr>
<tr>
<td>POST</td>
<td>向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改</td>
</tr>
<tr>
<td>PUT</td>
<td>从客户端向服务器传送的数据取代指定的文档的内容</td>
</tr>
<tr>
<td>DELETE</td>
<td>请求服务器删除指定的页面</td>
</tr>
<tr>
<td>TRACE</td>
<td>回显服务器收到的请求，主要用于测试或诊断</td>
</tr>
</tbody>
</table>
<p>状态码（Status-Code）</p>
<ul>
<li>1xx：表示通知信息，如请求收到了或正在进行处理
<ul>
<li>100 Continue：继续，客户端应继续其请求</li>
<li>101 Switching Protocols 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到 HTTP 的新版本协议</li>
</ul>
</li>
<li>2xx：表示成功，如接收或知道了
<ul>
<li>200 OK: 请求成功</li>
</ul>
</li>
<li>3xx：表示重定向，如要完成请求还必须采取进一步的行动
<ul>
<li>301 Moved Permanently: 永久移动。请求的资源已被永久的移动到新 URL，返回信息会包括新的 URL，浏览器会自动定向到新 URL。今后任何新的请求都应使用新的 URL 代替</li>
</ul>
</li>
<li>4xx：表示客户的差错，如请求中有错误的语法或不能完成
<ul>
<li>400 Bad Request: 客户端请求的语法错误，服务器无法理解</li>
<li>401 Unauthorized: 请求要求用户的身份认证</li>
<li>403 Forbidden: 服务器理解请求客户端的请求，但是拒绝执行此请求（权限不够）</li>
<li>404 Not Found: 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置 “您所请求的资源无法找到” 的个性页面</li>
<li>408 Request Timeout: 服务器等待客户端发送的请求时间过长，超时</li>
</ul>
</li>
<li>5xx：表示服务器的差错，如服务器失效无法完成请求
<ul>
<li>500 Internal Server Error: 服务器内部错误，无法完成请求</li>
<li>503 Service Unavailable: 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的 Retry-After 头信息中</li>
<li>504 Gateway Timeout: 充当网关或代理的服务器，未及时从远端服务器获取请求</li>
</ul>
</li>
</ul>
<blockquote>
<p>更多状态码：<a href="http://www.runoob.com/http/http-status-codes.html">菜鸟教程 . HTTP状态码</a></p>
</blockquote>
<h5 id="其他协议">其他协议</h5>
<ul>
<li>SMTP（Simple Main Transfer Protocol，简单邮件传输协议）是在 Internet 传输 Email 的标准，是一个相对简单的基于文本的协议。在其之上指定了一条消息的一个或多个接收者（在大多数情况下被确认是存在的），然后消息文本会被传输。可以很简单地通过 Telnet 程序来测试一个 SMTP 服务器。SMTP 使用 TCP 端口 25。</li>
<li>DHCP（Dynamic Host Configuration Protocol，动态主机设置协议）是一个局域网的网络协议，使用 UDP 协议工作，主要有两个用途：
<ul>
<li>用于内部网络或网络服务供应商自动分配 IP 地址给用户</li>
<li>用于内部网络管理员作为对所有电脑作中央管理的手段</li>
</ul>
</li>
<li>SNMP（Simple Network Management Protocol，简单网络管理协议）构成了互联网工程工作小组（IETF，Internet Engineering Task Force）定义的 Internet 协议族的一部分。该协议能够支持网络管理系统，用以监测连接到网络上的设备是否有任何引起管理上关注的情况。</li>
</ul>
<p><a id="network-programming"></a></p>
<h2 id="-网络编程">🌩 网络编程</h2>
<h3 id="socket">Socket</h3>
<blockquote>
<p><a href="https://www.cnblogs.com/skynet/archive/2010/12/12/1903949.html">Linux Socket 编程（不限 Linux）</a></p>
</blockquote>
<p><img src="https://gitee.com/huihut/interview/raw/master/images/socket%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%80%9A%E8%AE%AF.jpg" alt="Socket 客户端服务器通讯"></p>
<h4 id="socket-中的-readwrite-函数">Socket 中的 read()、write() 函数</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">ssize_t <span style="color:#a6e22e">read</span>(<span style="color:#66d9ef">int</span> fd, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>buf, size_t count);
ssize_t <span style="color:#a6e22e">write</span>(<span style="color:#66d9ef">int</span> fd, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>buf, size_t count);
</code></pre></div><h5 id="read">read()</h5>
<ul>
<li>read 函数是负责从 fd 中读取内容。</li>
<li>当读成功时，read 返回实际所读的字节数。</li>
<li>如果返回的值是 0 表示已经读到文件的结束了，小于 0 表示出现了错误。</li>
<li>如果错误为 EINTR 说明读是由中断引起的；如果是 ECONNREST 表示网络连接出了问题。</li>
</ul>
<h5 id="write">write()</h5>
<ul>
<li>write 函数将 buf 中的 nbytes 字节内容写入文件描述符 fd。</li>
<li>成功时返回写的字节数。失败时返回 -1，并设置 errno 变量。</li>
<li>在网络程序中，当我们向套接字文件描述符写时有俩种可能。</li>
<li>（1）write 的返回值大于 0，表示写了部分或者是全部的数据。</li>
<li>（2）返回的值小于 0，此时出现了错误。</li>
<li>如果错误为 EINTR 表示在写的时候出现了中断错误；如果为 EPIPE 表示网络连接出现了问题（对方已经关闭了连接）。</li>
</ul>
<h4 id="socket-中-tcp-的三次握手建立连接">Socket 中 TCP 的三次握手建立连接</h4>
<p>我们知道 TCP 建立连接要进行 “三次握手”，即交换三个分组。大致流程如下：</p>
<ol>
<li>客户端向服务器发送一个 SYN J</li>
<li>服务器向客户端响应一个 SYN K，并对 SYN J 进行确认 ACK J+1</li>
<li>客户端再想服务器发一个确认 ACK K+1</li>
</ol>
<p>只有就完了三次握手，但是这个三次握手发生在 Socket 的那几个函数中呢？请看下图：</p>
<p><img src="http://images.cnblogs.com/cnblogs_com/skynet/201012/201012122157467258.png" alt="socket 中发送的 TCP 三次握手"></p>
<p>从图中可以看出：</p>
<ol>
<li>当客户端调用 connect 时，触发了连接请求，向服务器发送了 SYN J 包，这时 connect 进入阻塞状态；</li>
<li>服务器监听到连接请求，即收到 SYN J 包，调用 accept 函数接收请求向客户端发送 SYN K ，ACK J+1，这时 accept 进入阻塞状态；</li>
<li>客户端收到服务器的 SYN K ，ACK J+1 之后，这时 connect 返回，并对 SYN K 进行确认；</li>
<li>服务器收到 ACK K+1 时，accept 返回，至此三次握手完毕，连接建立。</li>
</ol>
<h4 id="socket-中-tcp-的四次握手释放连接">Socket 中 TCP 的四次握手释放连接</h4>
<p>上面介绍了 socket 中 TCP 的三次握手建立过程，及其涉及的 socket 函数。现在我们介绍 socket 中的四次握手释放连接的过程，请看下图：</p>
<p><img src="http://images.cnblogs.com/cnblogs_com/skynet/201012/201012122157487616.png" alt="socket 中发送的 TCP 四次握手"></p>
<p>图示过程如下：</p>
<ol>
<li>某个应用进程首先调用 close 主动关闭连接，这时 TCP 发送一个 FIN M；</li>
<li>另一端接收到 FIN M 之后，执行被动关闭，对这个 FIN 进行确认。它的接收也作为文件结束符传递给应用进程，因为 FIN 的接收意味着应用进程在相应的连接上再也接收不到额外数据；</li>
<li>一段时间之后，接收到文件结束符的应用进程调用 close 关闭它的 socket。这导致它的 TCP 也发送一个 FIN N；</li>
<li>接收到这个 FIN 的源发送端 TCP 对它进行确认。</li>
</ol>
<p>这样每个方向上都有一个 FIN 和 ACK。</p>

        
        ]]>
      </description>
=======
      <description>转载自https://github.com/huihut/interview 本节部分知识点来自《计算机网络（第 7 版）》 计算机网络体系结构： 各</description>
>>>>>>> 35a30928abf5c3213b754024efc550556652db2d
    </item>
    
    <item>
      <title>【转载】C&#43;&#43; 开发必备之操作系统</title>
      <link>/collection/os/</link>
      <pubDate>Fri, 14 Jan 2022 21:02:05 +0800</pubDate>
      
      <guid>/collection/os/</guid>
<<<<<<< HEAD
      <description>
        <![CDATA[
        <p>转载自<a href="https://github.com/huihut/interview">https://github.com/huihut/interview</a></p>
<h3 id="进程与线程">进程与线程</h3>
<p>对于有线程系统：</p>
<ul>
<li>进程是资源分配的独立单位</li>
<li>线程是资源调度的独立单位</li>
</ul>
<p>对于无线程系统：</p>
<ul>
<li>进程是资源调度、分配的独立单位</li>
</ul>
<h4 id="进程之间的通信方式以及优缺点">进程之间的通信方式以及优缺点</h4>
<ul>
<li>管道（PIPE）
<ul>
<li>有名管道：一种半双工的通信方式，它允许无亲缘关系进程间的通信
<ul>
<li>优点：可以实现任意关系的进程间的通信</li>
<li>缺点：
<ol>
<li>长期存于系统中，使用不当容易出错</li>
<li>缓冲区有限</li>
</ol>
</li>
</ul>
</li>
<li>无名管道：一种半双工的通信方式，只能在具有亲缘关系的进程间使用（父子进程）
<ul>
<li>优点：简单方便</li>
<li>缺点：
<ol>
<li>局限于单向通信</li>
<li>只能创建在它的进程以及其有亲缘关系的进程之间</li>
<li>缓冲区有限</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li>信号量（Semaphore）：一个计数器，可以用来控制多个线程对共享资源的访问
<ul>
<li>优点：可以同步进程</li>
<li>缺点：信号量有限</li>
</ul>
</li>
<li>信号（Signal）：一种比较复杂的通信方式，用于通知接收进程某个事件已经发生</li>
<li>消息队列（Message Queue）：是消息的链表，存放在内核中并由消息队列标识符标识
<ul>
<li>优点：可以实现任意进程间的通信，并通过系统调用函数来实现消息发送和接收之间的同步，无需考虑同步问题，方便</li>
<li>缺点：信息的复制需要额外消耗 CPU 的时间，不适宜于信息量大或操作频繁的场合</li>
</ul>
</li>
<li>共享内存（Shared Memory）：映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问
<ul>
<li>优点：无须复制，快捷，信息量大</li>
<li>缺点：
<ol>
<li>通信是通过将共享空间缓冲区直接附加到进程的虚拟地址空间中来实现的，因此进程间的读写操作的同步问题</li>
<li>利用内存缓冲区直接交换信息，内存的实体存在于计算机中，只能同一个计算机系统中的诸多进程共享，不方便网络通信</li>
</ol>
</li>
</ul>
</li>
<li>套接字（Socket）：可用于不同计算机间的进程通信
<ul>
<li>优点：
<ol>
<li>传输数据为字节级，传输数据可自定义，数据量小效率高</li>
<li>传输数据时间短，性能高</li>
<li>适合于客户端和服务器端之间信息实时交互</li>
<li>可以加密,数据安全性强</li>
</ol>
</li>
<li>缺点：需对传输的数据进行解析，转化成应用级的数据。</li>
</ul>
</li>
</ul>
<h4 id="线程之间的通信方式">线程之间的通信方式</h4>
<ul>
<li>锁机制：包括互斥锁/量（mutex）、读写锁（reader-writer lock）、自旋锁（spin lock）、条件变量（condition）
<ul>
<li>互斥锁/量（mutex）：提供了以排他方式防止数据结构被并发修改的方法。</li>
<li>读写锁（reader-writer lock）：允许多个线程同时读共享数据，而对写操作是互斥的。</li>
<li>自旋锁（spin lock）与互斥锁类似，都是为了保护共享资源。互斥锁是当资源被占用，申请者进入睡眠状态；而自旋锁则循环检测保持者是否已经释放锁。</li>
<li>条件变量（condition）：可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。</li>
</ul>
</li>
<li>信号量机制(Semaphore)
<ul>
<li>无名线程信号量</li>
<li>命名线程信号量</li>
</ul>
</li>
<li>信号机制(Signal)：类似进程间的信号处理</li>
<li>屏障（barrier）：屏障允许每个线程等待，直到所有的合作线程都达到某一点，然后从该点继续执行。</li>
</ul>
<p>线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制</p>
<blockquote>
<p>进程之间的通信方式以及优缺点来源于：<a href="http://blog.csdn.net/wujiafei_njgcxy/article/details/77098977">进程线程面试题总结</a></p>
</blockquote>
<h4 id="进程之间私有和共享的资源">进程之间私有和共享的资源</h4>
<ul>
<li>私有：地址空间、堆、全局变量、栈、寄存器</li>
<li>共享：代码段，公共数据，进程目录，进程 ID</li>
</ul>
<h4 id="线程之间私有和共享的资源">线程之间私有和共享的资源</h4>
<ul>
<li>私有：线程栈，寄存器，程序计数器</li>
<li>共享：堆，地址空间，全局变量，静态变量</li>
</ul>
<h4 id="多进程与多线程间的对比优劣与选择">多进程与多线程间的对比、优劣与选择</h4>
<h5 id="对比">对比</h5>
<table>
<thead>
<tr>
<th>对比维度</th>
<th>多进程</th>
<th>多线程</th>
<th>总结</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据共享、同步</td>
<td>数据共享复杂，需要用 IPC；数据是分开的，同步简单</td>
<td>因为共享进程数据，数据共享简单，但也是因为这个原因导致同步复杂</td>
<td>各有优势</td>
</tr>
<tr>
<td>内存、CPU</td>
<td>占用内存多，切换复杂，CPU 利用率低</td>
<td>占用内存少，切换简单，CPU 利用率高</td>
<td>线程占优</td>
</tr>
<tr>
<td>创建销毁、切换</td>
<td>创建销毁、切换复杂，速度慢</td>
<td>创建销毁、切换简单，速度很快</td>
<td>线程占优</td>
</tr>
<tr>
<td>编程、调试</td>
<td>编程简单，调试简单</td>
<td>编程复杂，调试复杂</td>
<td>进程占优</td>
</tr>
<tr>
<td>可靠性</td>
<td>进程间不会互相影响</td>
<td>一个线程挂掉将导致整个进程挂掉</td>
<td>进程占优</td>
</tr>
<tr>
<td>分布式</td>
<td>适应于多核、多机分布式；如果一台机器不够，扩展到多台机器比较简单</td>
<td>适应于多核分布式</td>
<td>进程占优</td>
</tr>
</tbody>
</table>
<h5 id="优劣">优劣</h5>
<table>
<thead>
<tr>
<th>优劣</th>
<th>多进程</th>
<th>多线程</th>
</tr>
</thead>
<tbody>
<tr>
<td>优点</td>
<td>编程、调试简单，可靠性较高</td>
<td>创建、销毁、切换速度快，内存、资源占用小</td>
</tr>
<tr>
<td>缺点</td>
<td>创建、销毁、切换速度慢，内存、资源占用大</td>
<td>编程、调试复杂，可靠性较差</td>
</tr>
</tbody>
</table>
<h5 id="选择">选择</h5>
<ul>
<li>需要频繁创建销毁的优先用线程</li>
<li>需要进行大量计算的优先使用线程</li>
<li>强相关的处理用线程，弱相关的处理用进程</li>
<li>可能要扩展到多机分布的用进程，多核分布的用线程</li>
<li>都满足需求的情况下，用你最熟悉、最拿手的方式</li>
</ul>
<blockquote>
<p>多进程与多线程间的对比、优劣与选择来自：<a href="https://blog.csdn.net/lishenglong666/article/details/8557215">多线程还是多进程的选择及区别</a></p>
</blockquote>
<h3 id="linux-内核的同步方式">Linux 内核的同步方式</h3>
<h4 id="原因">原因</h4>
<p>在现代操作系统里，同一时间可能有多个内核执行流在执行，因此内核其实像多进程多线程编程一样也需要一些同步机制来同步各执行单元对共享数据的访问。尤其是在多处理器系统上，更需要一些同步机制来同步不同处理器上的执行单元对共享的数据的访问。</p>
<h4 id="同步方式">同步方式</h4>
<ul>
<li>原子操作</li>
<li>信号量（semaphore）</li>
<li>读写信号量（rw_semaphore）</li>
<li>自旋锁（spinlock）</li>
<li>大内核锁（BKL，Big Kernel Lock）</li>
<li>读写锁（rwlock）</li>
<li>大读者锁（brlock-Big Reader Lock）</li>
<li>读-拷贝修改(RCU，Read-Copy Update)</li>
<li>顺序锁（seqlock）</li>
</ul>
<blockquote>
<p>来自：<a href="https://www.ibm.com/developerworks/cn/linux/l-synch/part1/">Linux 内核的同步机制，第 1 部分</a>、<a href="https://www.ibm.com/developerworks/cn/linux/l-synch/part2/">Linux 内核的同步机制，第 2 部分</a></p>
</blockquote>
<h3 id="死锁">死锁</h3>
<h4 id="原因-1">原因</h4>
<ul>
<li>系统资源不足</li>
<li>资源分配不当</li>
<li>进程运行推进顺序不合适</li>
</ul>
<h4 id="产生条件">产生条件</h4>
<ul>
<li>互斥</li>
<li>请求和保持</li>
<li>不剥夺</li>
<li>环路</li>
</ul>
<h4 id="预防">预防</h4>
<ul>
<li>打破互斥条件：改造独占性资源为虚拟资源，大部分资源已无法改造。</li>
<li>打破不可抢占条件：当一进程占有一独占性资源后又申请一独占性资源而无法满足，则退出原占有的资源。</li>
<li>打破占有且申请条件：采用资源预先分配策略，即进程运行前申请全部资源，满足则运行，不然就等待，这样就不会占有且申请。</li>
<li>打破循环等待条件：实现资源有序分配策略，对所有设备实现分类编号，所有进程只能采用按序号递增的形式申请资源。</li>
<li>有序资源分配法</li>
<li>银行家算法</li>
</ul>
<h3 id="文件系统">文件系统</h3>
<ul>
<li>Windows：FCB 表 + FAT + 位图</li>
<li>Unix：inode + 混合索引 + 成组链接</li>
</ul>
<h3 id="主机字节序与网络字节序">主机字节序与网络字节序</h3>
<h4 id="主机字节序cpu-字节序">主机字节序（CPU 字节序）</h4>
<h5 id="概念">概念</h5>
<p>主机字节序又叫 CPU 字节序，其不是由操作系统决定的，而是由 CPU 指令集架构决定的。主机字节序分为两种：</p>
<ul>
<li>大端字节序（Big Endian）：高序字节存储在低位地址，低序字节存储在高位地址</li>
<li>小端字节序（Little Endian）：高序字节存储在高位地址，低序字节存储在低位地址</li>
</ul>
<h5 id="存储方式">存储方式</h5>
<p>32 位整数 <code>0x12345678</code> 是从起始位置为 <code>0x00</code> 的地址开始存放，则：</p>
<table>
<thead>
<tr>
<th>内存地址</th>
<th>0x00</th>
<th>0x01</th>
<th>0x02</th>
<th>0x03</th>
</tr>
</thead>
<tbody>
<tr>
<td>大端</td>
<td>12</td>
<td>34</td>
<td>56</td>
<td>78</td>
</tr>
<tr>
<td>小端</td>
<td>78</td>
<td>56</td>
<td>34</td>
<td>12</td>
</tr>
</tbody>
</table>
<p>大端小端图片</p>
<p><img src="https://gitee.com/huihut/interview/raw/master/images/CPU-Big-Endian.svg.png" alt="大端序">
<img src="https://gitee.com/huihut/interview/raw/master/images/CPU-Little-Endian.svg.png" alt="小端序"></p>
<h5 id="判断大端小端">判断大端小端</h5>
<p>判断大端小端</p>
<p>可以这样判断自己 CPU 字节序是大端还是小端：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
	<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x12345678</span>;

	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">*</span>((<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>)<span style="color:#f92672">&amp;</span>i) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0x12</span>)
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;大端&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	<span style="color:#66d9ef">else</span>	
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;小端&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;

	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h5 id="各架构处理器的字节序">各架构处理器的字节序</h5>
<ul>
<li>x86（Intel、AMD）、MOS Technology 6502、Z80、VAX、PDP-11 等处理器为小端序；</li>
<li>Motorola 6800、Motorola 68000、PowerPC 970、System/370、SPARC（除 V9 外）等处理器为大端序；</li>
<li>ARM（默认小端序）、PowerPC（除 PowerPC 970 外）、DEC Alpha、SPARC V9、MIPS、PA-RISC 及 IA64 的字节序是可配置的。</li>
</ul>
<h4 id="网络字节序">网络字节序</h4>
<p>网络字节顺序是 TCP/IP 中规定好的一种数据表示格式，它与具体的 CPU 类型、操作系统等无关，从而可以保证数据在不同主机之间传输时能够被正确解释。</p>
<p>网络字节顺序采用：大端（Big Endian）排列方式。</p>
<h3 id="页面置换算法">页面置换算法</h3>
<p>在地址映射过程中，若在页面中发现所要访问的页面不在内存中，则产生缺页中断。当发生缺页中断时，如果操作系统内存中没有空闲页面，则操作系统必须在内存选择一个页面将其移出内存，以便为即将调入的页面让出空间。而用来选择淘汰哪一页的规则叫做页面置换算法。</p>
<h4 id="分类">分类</h4>
<ul>
<li>全局置换：在整个内存空间置换</li>
<li>局部置换：在本进程中进行置换</li>
</ul>
<h4 id="算法">算法</h4>
<p>全局：</p>
<ul>
<li>工作集算法</li>
<li>缺页率置换算法</li>
</ul>
<p>局部：</p>
<ul>
<li>最佳置换算法（OPT）</li>
<li>先进先出置换算法（FIFO）</li>
<li>最近最久未使用（LRU）算法</li>
<li>时钟（Clock）置换算法</li>
</ul>

        
        ]]>
      </description>
=======
      <description>转载自https://github.com/huihut/interview 进程与线程 对于有线程系统： 进程是资源分配的独立单位 线程是资源调度</description>
>>>>>>> 35a30928abf5c3213b754024efc550556652db2d
    </item>
    
    <item>
      <title>【转载】C&#43;&#43; 开发必备之算法</title>
      <link>/collection/algorithm/</link>
      <pubDate>Fri, 14 Jan 2022 20:42:19 +0800</pubDate>
      
      <guid>/collection/algorithm/</guid>
      <description>转载自https://github.com/huihut/interview 排序 排序算法 平均时间复杂度 最差时间复杂度 空间复杂度 数据对象稳定性</description>
    </item>
    
    <item>
      <title>【转载】C&#43;&#43; 开发必备之数据结构</title>
      <link>/collection/data-structure/</link>
      <pubDate>Fri, 14 Jan 2022 20:28:54 +0800</pubDate>
      
      <guid>/collection/data-structure/</guid>
<<<<<<< HEAD
      <description>
        <![CDATA[
        <p>转载自<a href="https://github.com/huihut/interview">https://github.com/huihut/interview</a></p>
<h3 id="顺序结构">顺序结构</h3>
<h4 id="顺序栈sequence-stack">顺序栈（Sequence Stack）</h4>
<p><a href="https://github.com/huihut/interview/blob/master/DataStructure/SqStack.cpp">SqStack.cpp</a></p>
<p>顺序栈数据结构和图片</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> {
	ElemType <span style="color:#f92672">*</span>elem;
	<span style="color:#66d9ef">int</span> top;
	<span style="color:#66d9ef">int</span> size;
	<span style="color:#66d9ef">int</span> increment;
} SqStack;
</code></pre></div><p><img src="https://gitee.com/huihut/interview/raw/master/images/SqStack.png" alt=""></p>
<h4 id="队列sequence-queue">队列（Sequence Queue）</h4>
<p>队列数据结构</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> {
	ElemType <span style="color:#f92672">*</span> elem;
	<span style="color:#66d9ef">int</span> front;
	<span style="color:#66d9ef">int</span> rear;
	<span style="color:#66d9ef">int</span> maxSize;
}SqQueue;
</code></pre></div><h5 id="非循环队列">非循环队列</h5>
<p>非循环队列图片</p>
<p><img src="https://gitee.com/huihut/interview/raw/master/images/SqQueue.png" alt=""></p>
<p><code>SqQueue.rear++</code></p>
<h5 id="循环队列">循环队列</h5>
<p>循环队列图片</p>
<p><img src="https://gitee.com/huihut/interview/raw/master/images/SqLoopStack.png" alt=""></p>
<p><code>SqQueue.rear = (SqQueue.rear + 1) % SqQueue.maxSize</code></p>
<h4 id="顺序表sequence-list">顺序表（Sequence List）</h4>
<p><a href="https://github.com/huihut/interview/blob/master/DataStructure/SqList.cpp">SqList.cpp</a></p>
<p>顺序表数据结构和图片</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> {
	ElemType <span style="color:#f92672">*</span>elem;
	<span style="color:#66d9ef">int</span> length;
	<span style="color:#66d9ef">int</span> size;
	<span style="color:#66d9ef">int</span> increment;
} SqList;
</code></pre></div><p><img src="https://gitee.com/huihut/interview/raw/master/images/SqList.png" alt=""></p>
<h3 id="链式结构">链式结构</h3>
<p><a href="https://github.com/huihut/interview/blob/master/DataStructure/LinkList.cpp">LinkList.cpp</a></p>
<p><a href="https://github.com/huihut/interview/blob/master/DataStructure/LinkList_with_head.cpp">LinkList_with_head.cpp</a></p>
<p>链式数据结构</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">LNode</span> {
    ElemType data;
    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">LNode</span> <span style="color:#f92672">*</span>next;
} LNode, <span style="color:#f92672">*</span>LinkList; 
</code></pre></div><h4 id="链队列link-queue">链队列（Link Queue）</h4>
<p>链队列图片</p>
<p><img src="https://gitee.com/huihut/interview/raw/master/images/LinkQueue.png" alt=""></p>
<h4 id="线性表的链式表示">线性表的链式表示</h4>
<h5 id="单链表link-list">单链表（Link List）</h5>
<p>单链表图片</p>
<p><img src="https://gitee.com/huihut/interview/raw/master/images/LinkList.png" alt=""></p>
<h5 id="双向链表du-link-list">双向链表（Du-Link-List）</h5>
<p>双向链表图片</p>
<p><img src="https://gitee.com/huihut/interview/raw/master/images/DuLinkList.png" alt=""></p>
<h5 id="循环链表cir-link-list">循环链表（Cir-Link-List）</h5>
<p>循环链表图片</p>
<p><img src="https://gitee.com/huihut/interview/raw/master/images/CirLinkList.png" alt=""></p>
<h3 id="哈希表">哈希表</h3>
<p><a href="https://github.com/huihut/interview/blob/master/DataStructure/HashTable.cpp">HashTable.cpp</a></p>
<h4 id="概念">概念</h4>
<p>哈希函数：<code>H(key): K -&gt; D , key ∈ K</code></p>
<h4 id="构造方法">构造方法</h4>
<ul>
<li>直接定址法</li>
<li>除留余数法</li>
<li>数字分析法</li>
<li>折叠法</li>
<li>平方取中法</li>
</ul>
<h4 id="冲突处理方法">冲突处理方法</h4>
<ul>
<li>链地址法：key 相同的用单链表链接</li>
<li>开放定址法
<ul>
<li>线性探测法：key 相同 -&gt; 放到 key 的下一个位置，<code>Hi = (H(key) + i) % m</code></li>
<li>二次探测法：key 相同 -&gt; 放到 <code>Di = 1^2, -1^2, ..., ±（k)^2,(k&lt;=m/2）</code></li>
<li>随机探测法：<code>H = (H(key) + 伪随机数) % m</code></li>
</ul>
</li>
</ul>
<h4 id="线性探测的哈希表数据结构">线性探测的哈希表数据结构</h4>
<p>线性探测的哈希表数据结构和图片</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">char</span> KeyType;

<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> {
	KeyType key;
}RcdType;

<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> {
	RcdType <span style="color:#f92672">*</span>rcd;
	<span style="color:#66d9ef">int</span> size;
	<span style="color:#66d9ef">int</span> count;
	<span style="color:#66d9ef">bool</span> <span style="color:#f92672">*</span>tag;
}HashTable;
</code></pre></div><p><img src="https://gitee.com/huihut/interview/raw/master/images/HashTable.png" alt=""></p>
<h3 id="递归">递归</h3>
<h4 id="概念-1">概念</h4>
<p>函数直接或间接地调用自身</p>
<h4 id="递归与分治">递归与分治</h4>
<ul>
<li>分治法
<ul>
<li>问题的分解</li>
<li>问题规模的分解</li>
</ul>
</li>
<li>折半查找（递归）</li>
<li>归并排序（递归）</li>
<li>快速排序（递归）</li>
</ul>
<h4 id="递归与迭代">递归与迭代</h4>
<ul>
<li>迭代：反复利用变量旧值推出新值</li>
<li>折半查找（迭代）</li>
<li>归并排序（迭代）</li>
</ul>
<h4 id="广义表">广义表</h4>
<h5 id="头尾链表存储表示">头尾链表存储表示</h5>
<p>广义表的头尾链表存储表示和图片</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// 广义表的头尾链表存储表示
</span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">enum</span> {ATOM, LIST} ElemTag;
<span style="color:#75715e">// ATOM==0：原子，LIST==1：子表
</span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">GLNode</span> {
    ElemTag tag;
    <span style="color:#75715e">// 公共部分，用于区分原子结点和表结点
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">union</span> {
        <span style="color:#75715e">// 原子结点和表结点的联合部分
</span><span style="color:#75715e"></span>        AtomType atom;
        <span style="color:#75715e">// atom 是原子结点的值域，AtomType 由用户定义
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">struct</span> {
            <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">GLNode</span> <span style="color:#f92672">*</span>hp, <span style="color:#f92672">*</span>tp;
        } ptr;
        <span style="color:#75715e">// ptr 是表结点的指针域，prt.hp 和 ptr.tp 分别指向表头和表尾
</span><span style="color:#75715e"></span>    } a;
} <span style="color:#f92672">*</span>GList, GLNode;
</code></pre></div><p><img src="https://gitee.com/huihut/interview/raw/master/images/GeneralizedList1.png" alt=""></p>
<h5 id="扩展线性链表存储表示">扩展线性链表存储表示</h5>
<p>扩展线性链表存储表示和图片</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// 广义表的扩展线性链表存储表示
</span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">enum</span> {ATOM, LIST} ElemTag;
<span style="color:#75715e">// ATOM==0：原子，LIST==1：子表
</span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">GLNode1</span> {
    ElemTag tag;
    <span style="color:#75715e">// 公共部分，用于区分原子结点和表结点
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">union</span> {
        <span style="color:#75715e">// 原子结点和表结点的联合部分
</span><span style="color:#75715e"></span>        AtomType atom; <span style="color:#75715e">// 原子结点的值域
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">GLNode1</span> <span style="color:#f92672">*</span>hp; <span style="color:#75715e">// 表结点的表头指针
</span><span style="color:#75715e"></span>    } a;
    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">GLNode1</span> <span style="color:#f92672">*</span>tp;
    <span style="color:#75715e">// 相当于线性链表的 next，指向下一个元素结点
</span><span style="color:#75715e"></span>} <span style="color:#f92672">*</span>GList1, GLNode1;
</code></pre></div><p><img src="https://gitee.com/huihut/interview/raw/master/images/GeneralizedList2.png" alt=""></p>
<h3 id="二叉树">二叉树</h3>
<p><a href="https://github.com/huihut/interview/blob/master/DataStructure/BinaryTree.cpp">BinaryTree.cpp</a></p>
<h4 id="性质">性质</h4>
<ol>
<li>非空二叉树第 i 层最多 2<sup>(i-1)</sup> 个结点 （i &gt;= 1）</li>
<li>深度为 k 的二叉树最多 2<sup>k</sup> - 1 个结点 （k &gt;= 1）</li>
<li>度为 0 的结点数为 n<sub>0</sub>，度为 2 的结点数为 n<sub>2</sub>，则 n<sub>0</sub> = n<sub>2</sub> + 1</li>
<li>有 n 个结点的完全二叉树深度 k = ⌊ log<sub>2</sub>(n) ⌋ + 1</li>
<li>对于含 n 个结点的完全二叉树中编号为 i （1 &lt;= i &lt;= n） 的结点
<ol>
<li>若 i = 1，为根，否则双亲为 ⌊ i / 2 ⌋</li>
<li>若 2i &gt; n，则 i 结点没有左孩子，否则孩子编号为 2i</li>
<li>若 2i + 1 &gt; n，则 i 结点没有右孩子，否则孩子编号为 2i + 1</li>
</ol>
</li>
</ol>
<h4 id="存储结构">存储结构</h4>
<p>二叉树数据结构</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">BiTNode</span>
{
    TElemType data;
    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">BiTNode</span> <span style="color:#f92672">*</span>lchild, <span style="color:#f92672">*</span>rchild;
}BiTNode, <span style="color:#f92672">*</span>BiTree;
</code></pre></div><h5 id="顺序存储">顺序存储</h5>
<p>二叉树顺序存储图片</p>
<p><img src="https://gitee.com/huihut/interview/raw/master/images/SqBinaryTree.png" alt=""></p>
<h5 id="链式存储">链式存储</h5>
<p>二叉树链式存储图片</p>
<p><img src="https://gitee.com/huihut/interview/raw/master/images/LinkBinaryTree.png" alt=""></p>
<h4 id="遍历方式">遍历方式</h4>
<ul>
<li>先序遍历</li>
<li>中序遍历</li>
<li>后续遍历</li>
<li>层次遍历</li>
</ul>
<h4 id="分类">分类</h4>
<ul>
<li>满二叉树</li>
<li>完全二叉树（堆）
<ul>
<li>大顶堆：根 &gt;= 左 &amp;&amp; 根 &gt;= 右</li>
<li>小顶堆：根 &lt;= 左 &amp;&amp; 根 &lt;= 右</li>
</ul>
</li>
<li>二叉查找树（二叉排序树）：左 &lt; 根 &lt; 右</li>
<li>平衡二叉树（AVL树）：| 左子树树高 - 右子树树高 | &lt;= 1</li>
<li>最小失衡树：平衡二叉树插入新结点导致失衡的子树：调整：
<ul>
<li>LL型：根的左孩子右旋</li>
<li>RR型：根的右孩子左旋</li>
<li>LR型：根的左孩子左旋，再右旋</li>
<li>RL型：右孩子的左子树，先右旋，再左旋</li>
</ul>
</li>
</ul>
<h3 id="其他树及森林">其他树及森林</h3>
<h4 id="树的存储结构">树的存储结构</h4>
<ul>
<li>双亲表示法</li>
<li>双亲孩子表示法</li>
<li>孩子兄弟表示法</li>
</ul>
<h4 id="并查集">并查集</h4>
<p>一种不相交的子集所构成的集合 S = {S1, S2, &hellip;, Sn}</p>
<h4 id="平衡二叉树avl树">平衡二叉树（AVL树）</h4>
<h5 id="性质-1">性质</h5>
<ul>
<li>| 左子树树高 - 右子树树高 | &lt;= 1</li>
<li>平衡二叉树必定是二叉搜索树，反之则不一定</li>
<li>最小二叉平衡树的节点的公式：<code>F(n)=F(n-1)+F(n-2)+1</code> （1 是根节点，F(n-1) 是左子树的节点数量，F(n-2) 是右子树的节点数量）</li>
</ul>
<p>平衡二叉树图片</p>
<p><img src="https://gitee.com/huihut/interview/raw/master/images/Self-balancingBinarySearchTree.png" alt=""></p>
<h5 id="最小失衡树">最小失衡树</h5>
<p>平衡二叉树插入新结点导致失衡的子树</p>
<p>调整：</p>
<ul>
<li>LL 型：根的左孩子右旋</li>
<li>RR 型：根的右孩子左旋</li>
<li>LR 型：根的左孩子左旋，再右旋</li>
<li>RL 型：右孩子的左子树，先右旋，再左旋</li>
</ul>
<h4 id="红黑树">红黑树</h4>
<p><a href="https://github.com/huihut/interview/blob/master/DataStructure/RedBlackTree.cpp">RedBlackTree.cpp</a></p>
<h5 id="红黑树的特征是什么">红黑树的特征是什么？</h5>
<ol>
<li>节点是红色或黑色。</li>
<li>根是黑色。</li>
<li>所有叶子都是黑色（叶子是 NIL 节点）。</li>
<li>每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）（新增节点的父节点必须相同）</li>
<li>从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。（新增节点必须为红）</li>
</ol>
<h5 id="调整">调整</h5>
<ol>
<li>变色</li>
<li>左旋</li>
<li>右旋</li>
</ol>
<h5 id="应用">应用</h5>
<ul>
<li>关联数组：如 STL 中的 map、set</li>
</ul>
<h5 id="红黑树b-树b-树的区别">红黑树、B 树、B+ 树的区别？</h5>
<ul>
<li>红黑树的深度比较大，而 B 树和 B+ 树的深度则相对要小一些</li>
<li>B+ 树则将数据都保存在叶子节点，同时通过链表的形式将他们连接在一起。</li>
</ul>
<h4 id="b-树b-treeb-树b-tree">B 树（B-tree）、B+ 树（B+-tree）</h4>
<p>B 树、B+ 树图片</p>
<p><img src="https://i.stack.imgur.com/l6UyF.png" alt="B 树（B-tree）、B+ 树（B+-tree）"></p>
<h5 id="特点">特点</h5>
<ul>
<li>一般化的二叉查找树（binary search tree）</li>
<li>“矮胖”，内部（非叶子）节点可以拥有可变数量的子节点（数量范围预先定义好）</li>
</ul>
<h5 id="应用-1">应用</h5>
<ul>
<li>大部分文件系统、数据库系统都采用B树、B+树作为索引结构</li>
</ul>
<h5 id="区别">区别</h5>
<ul>
<li>B+树中只有叶子节点会带有指向记录的指针（ROWID），而B树则所有节点都带有，在内部节点出现的索引项不会再出现在叶子节点中。</li>
<li>B+树中所有叶子节点都是通过指针连接在一起，而B树不会。</li>
</ul>
<h5 id="b树的优点">B树的优点</h5>
<p>对于在内部节点的数据，可直接得到，不必根据叶子节点来定位。</p>
<h5 id="b树的优点-1">B+树的优点</h5>
<ul>
<li>非叶子节点不会带上 ROWID，这样，一个块中可以容纳更多的索引项，一是可以降低树的高度。二是一个内部节点可以定位更多的叶子节点。</li>
<li>叶子节点之间通过指针来连接，范围扫描将十分简单，而对于B树来说，则需要在叶子节点和内部节点不停的往返移动。</li>
</ul>
<blockquote>
<p>B 树、B+ 树区别来自：<a href="https://stackoverflow.com/questions/870218/differences-between-b-trees-and-b-trees">differences-between-b-trees-and-b-trees</a>、<a href="https://www.cnblogs.com/ivictor/p/5849061.html">B树和B+树的区别</a></p>
</blockquote>
<h4 id="八叉树">八叉树</h4>
<p>八叉树图片</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/35/Octree2.png/400px-Octree2.png" alt=""></p>
<p>八叉树（octree），或称八元树，是一种用于描述三维空间（划分空间）的树状数据结构。八叉树的每个节点表示一个正方体的体积元素，每个节点有八个子节点，这八个子节点所表示的体积元素加在一起就等于父节点的体积。一般中心点作为节点的分叉中心。</p>
<h5 id="用途">用途</h5>
<ul>
<li>三维计算机图形</li>
<li>最邻近搜索</li>
</ul>

        
        ]]>
      </description>
=======
      <description>转载自https://github.com/huihut/interview 顺序结构 顺序栈（Sequence Stack） SqStack.cpp 顺序栈数据结构和图</description>
>>>>>>> 35a30928abf5c3213b754024efc550556652db2d
    </item>
    
    <item>
      <title>【转载】C&#43;&#43; 开发必备之 STL</title>
      <link>/collection/c&#43;&#43;stl/</link>
      <pubDate>Fri, 14 Jan 2022 20:23:31 +0800</pubDate>
      
      <guid>/collection/c&#43;&#43;stl/</guid>
      <description>转载自https://github.com/huihut/interview STL 索引 STL 方法含义索引 STL 容器 容器 底层数据结构 时间复杂度 有无序 可不可</description>
    </item>
    
    <item>
      <title>【转载】C&#43;&#43; 开发必备之 Effective C&#43;&#43;</title>
      <link>/collection/effectivec&#43;&#43;/</link>
      <pubDate>Fri, 14 Jan 2022 20:16:02 +0800</pubDate>
      
      <guid>/collection/effectivec&#43;&#43;/</guid>
      <description>转载自https://github.com/huihut/interview Effective C++ 视 C++ 为一个语言联邦（C、Object-Oriented C++</description>
    </item>
    
    <item>
      <title>【转载】C&#43;&#43; 开发必备之 C/C&#43;&#43;基础</title>
      <link>/collection/cc&#43;&#43;base/</link>
      <pubDate>Tue, 11 Jan 2022 23:20:27 +0800</pubDate>
      
      <guid>/collection/cc&#43;&#43;base/</guid>
<<<<<<< HEAD
      <description>
        <![CDATA[
        <p>转载自<a href="https://github.com/huihut/interview">https://github.com/huihut/interview</a></p>
<h3 id="const">const</h3>
<h4 id="作用">作用</h4>
<ol>
<li>修饰变量，说明该变量不可以被改变；</li>
<li>修饰指针，分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer）；</li>
<li>修饰引用，指向常量的引用（reference to const），用于形参类型，即避免了拷贝，又避免了函数对值的修改；</li>
<li>修饰成员函数，说明该成员函数内不能修改成员变量。</li>
</ol>
<h4 id="const-的指针与引用">const 的指针与引用</h4>
<ul>
<li>指针
<ul>
<li>指向常量的指针（pointer to const）</li>
<li>自身是常量的指针（常量指针，const pointer）</li>
</ul>
</li>
<li>引用
<ul>
<li>指向常量的引用（reference to const）</li>
<li>没有 const reference，因为引用只是对象的别名，引用不是对象，不能用 const 修饰</li>
</ul>
</li>
</ul>
<blockquote>
<p>（为了方便记忆可以想成）被 const 修饰（在 const 后面）的值不可改变，如下文使用例子中的 <code>p2</code>、<code>p3</code></p>
</blockquote>
<h4 id="使用">使用</h4>
<p>const 使用</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// 类
</span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span>
{
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> a;                <span style="color:#75715e">// 常对象成员，可以使用初始化列表或者类内初始化
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#75715e">// 构造函数
</span><span style="color:#75715e"></span>    A() <span style="color:#f92672">:</span> a(<span style="color:#ae81ff">0</span>) { };
    A(<span style="color:#66d9ef">int</span> x) <span style="color:#f92672">:</span> a(x) { };        <span style="color:#75715e">// 初始化列表
</span><span style="color:#75715e"></span>
    <span style="color:#75715e">// const可用于对重载函数的区分
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">getValue</span>();             <span style="color:#75715e">// 普通成员函数
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">getValue</span>() <span style="color:#66d9ef">const</span>;       <span style="color:#75715e">// 常成员函数，不得修改类中的任何数据成员的值
</span><span style="color:#75715e"></span>};

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">function</span>()
{
    <span style="color:#75715e">// 对象
</span><span style="color:#75715e"></span>    A b;                        <span style="color:#75715e">// 普通对象，可以调用全部成员函数
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">const</span> A a;                  <span style="color:#75715e">// 常对象，只能调用常成员函数
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">const</span> A <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>a;            <span style="color:#75715e">// 指针变量，指向常对象
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">const</span> A <span style="color:#f92672">&amp;</span>q <span style="color:#f92672">=</span> a;             <span style="color:#75715e">// 指向常对象的引用
</span><span style="color:#75715e"></span>
    <span style="color:#75715e">// 指针
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">char</span> greeting[] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Hello&#34;</span>;
    <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> p1 <span style="color:#f92672">=</span> greeting;                <span style="color:#75715e">// 指针变量，指向字符数组变量
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> p2 <span style="color:#f92672">=</span> greeting;          <span style="color:#75715e">// 指针变量，指向字符数组常量（const 后面是 char，说明指向的字符（char）不可改变）
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> <span style="color:#66d9ef">const</span> p3 <span style="color:#f92672">=</span> greeting;          <span style="color:#75715e">// 自身是常量的指针，指向字符数组变量（const 后面是 p3，说明 p3 指针自身不可改变）
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> <span style="color:#66d9ef">const</span> p4 <span style="color:#f92672">=</span> greeting;    <span style="color:#75715e">// 自身是常量的指针，指向字符数组常量
</span><span style="color:#75715e"></span>}

<span style="color:#75715e">// 函数
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">function1</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> Var);           <span style="color:#75715e">// 传递过来的参数在函数内不可变
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">function2</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> Var);         <span style="color:#75715e">// 参数指针所指内容为常量
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">function3</span>(<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> <span style="color:#66d9ef">const</span> Var);         <span style="color:#75715e">// 参数指针为常量
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">function4</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">&amp;</span> Var);          <span style="color:#75715e">// 引用参数在函数内为常量
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// 函数返回值
</span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">function5</span>();      <span style="color:#75715e">// 返回一个常数
</span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> <span style="color:#a6e22e">function6</span>();     <span style="color:#75715e">// 返回一个指向常量的指针变量，使用：const int *p = function6();
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">function7</span>();     <span style="color:#75715e">// 返回一个指向变量的常指针，使用：int* const p = function7();
</span></code></pre></div><h4 id="宏定义-define-和-const-常量">宏定义 #define 和 const 常量</h4>
<table>
<thead>
<tr>
<th>宏定义 #define</th>
<th>const 常量</th>
</tr>
</thead>
<tbody>
<tr>
<td>宏定义，相当于字符替换</td>
<td>常量声明</td>
</tr>
<tr>
<td>预处理器处理</td>
<td>编译器处理</td>
</tr>
<tr>
<td>无类型安全检查</td>
<td>有类型安全检查</td>
</tr>
<tr>
<td>不分配内存</td>
<td>要分配内存</td>
</tr>
<tr>
<td>存储在代码段</td>
<td>存储在数据段</td>
</tr>
<tr>
<td>可通过 <code>#undef</code> 取消</td>
<td>不可取消</td>
</tr>
</tbody>
</table>
<h3 id="static">static</h3>
<h4 id="作用-1">作用</h4>
<ol>
<li>修饰普通变量，修改变量的存储区域和生命周期，使变量存储在静态区，在 main 函数运行前就分配了空间，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。</li>
<li>修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static。</li>
<li>修饰成员变量，修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员。</li>
<li>修饰成员函数，修饰成员函数使得不需要生成对象就可以访问该函数，但是在 static 函数内不能访问非静态成员。</li>
</ol>
<h3 id="this-指针">this 指针</h3>
<ol>
<li><code>this</code> 指针是一个隐含于每一个非静态成员函数中的特殊指针。它指向调用该成员函数的那个对象。</li>
<li>当对一个对象调用成员函数时，编译程序先将对象的地址赋给 <code>this</code> 指针，然后调用成员函数，每次成员函数存取数据成员时，都隐式使用 <code>this</code> 指针。</li>
<li>当一个成员函数被调用时，自动向它传递一个隐含的参数，该参数是一个指向这个成员函数所在的对象的指针。</li>
<li><code>this</code> 指针被隐含地声明为: <code>ClassName *const this</code>，这意味着不能给 <code>this</code> 指针赋值；在 <code>ClassName</code> 类的 <code>const</code> 成员函数中，<code>this</code> 指针的类型为：<code>const ClassName* const</code>，这说明不能对 <code>this</code> 指针所指向的这种对象是不可修改的（即不能对这种对象的数据成员进行赋值操作）；</li>
<li><code>this</code> 并不是一个常规变量，而是个右值，所以不能取得 <code>this</code> 的地址（不能 <code>&amp;this</code>）。</li>
<li>在以下场景中，经常需要显式引用 <code>this</code> 指针：
<ol>
<li>为实现对象的链式引用；</li>
<li>为避免对同一对象进行赋值操作；</li>
<li>在实现一些数据结构时，如 <code>list</code>。</li>
</ol>
</li>
</ol>
<h3 id="inline-内联函数">inline 内联函数</h3>
<h4 id="特征">特征</h4>
<ul>
<li>相当于把内联函数里面的内容写在调用内联函数处；</li>
<li>相当于不用执行进入函数的步骤，直接执行函数体；</li>
<li>相当于宏，却比宏多了类型检查，真正具有函数特性；</li>
<li>编译器一般不内联包含循环、递归、switch 等复杂操作的内联函数；</li>
<li>在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数。</li>
</ul>
<h4 id="使用-1">使用</h4>
<p>inline 使用</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// 声明1（加 inline，建议使用）
</span><span style="color:#75715e"></span><span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">functionName</span>(<span style="color:#66d9ef">int</span> first, <span style="color:#66d9ef">int</span> second,...);

<span style="color:#75715e">// 声明2（不加 inline）
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">functionName</span>(<span style="color:#66d9ef">int</span> first, <span style="color:#66d9ef">int</span> second,...);

<span style="color:#75715e">// 定义
</span><span style="color:#75715e"></span><span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">functionName</span>(<span style="color:#66d9ef">int</span> first, <span style="color:#66d9ef">int</span> second,...) {<span style="color:#75715e">/****/</span>};

<span style="color:#75715e">// 类内定义，隐式内联
</span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span> {
    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">doA</span>() { <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>; }         <span style="color:#75715e">// 隐式内联
</span><span style="color:#75715e"></span>}

<span style="color:#75715e">// 类外定义，需要显式内联
</span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span> {
    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">doA</span>();
}
<span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">int</span> A<span style="color:#f92672">::</span>doA() { <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>; }   <span style="color:#75715e">// 需要显式内联
</span></code></pre></div><h4 id="编译器对-inline-函数的处理步骤">编译器对 inline 函数的处理步骤</h4>
<ol>
<li>将 inline 函数体复制到 inline 函数调用点处；</li>
<li>为所用 inline 函数中的局部变量分配内存空间；</li>
<li>将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中；</li>
<li>如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 GOTO）。</li>
</ol>
<h4 id="优缺点">优缺点</h4>
<p>优点</p>
<ol>
<li>内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。</li>
<li>内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会。</li>
<li>在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能。</li>
<li>内联函数在运行时可调试，而宏定义不可以。</li>
</ol>
<p>缺点</p>
<ol>
<li>代码膨胀。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。</li>
<li>inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接。</li>
<li>是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。</li>
</ol>
<h4 id="虚函数virtual可以是内联函数inline吗">虚函数（virtual）可以是内联函数（inline）吗？</h4>
<blockquote>
<p><a href="http://www.cs.technion.ac.il/users/yechiel/c++-faq/inline-virtuals.html">Are &ldquo;inline virtual&rdquo; member functions ever actually &ldquo;inlined&rdquo;?</a></p>
</blockquote>
<ul>
<li>虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。</li>
<li>内联是在编译器建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。</li>
<li><code>inline virtual</code> 唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 <code>Base::who()</code>），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。</li>
</ul>
<p>虚函数内联使用</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;  </span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Base</span>
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	<span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> who()
	{
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;I am Base</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
	}
	<span style="color:#66d9ef">virtual</span> <span style="color:#f92672">~</span>Base() {}
};
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Derived</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Base
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	<span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">void</span> who()  <span style="color:#75715e">// 不写inline时隐式内联
</span><span style="color:#75715e"></span>	{
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;I am Derived</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
	}
};

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
	<span style="color:#75715e">// 此处的虚函数 who()，是通过类（Base）的具体对象（b）来调用的，编译期间就能确定了，所以它可以是内联的，但最终是否内联取决于编译器。 
</span><span style="color:#75715e"></span>	Base b;
	b.who();

	<span style="color:#75715e">// 此处的虚函数是通过指针调用的，呈现多态性，需要在运行时期间才能确定，所以不能为内联。  
</span><span style="color:#75715e"></span>	Base <span style="color:#f92672">*</span>ptr <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Derived();
	ptr<span style="color:#f92672">-&gt;</span>who();

	<span style="color:#75715e">// 因为Base有虚析构函数（virtual ~Base() {}），所以 delete 时，会先调用派生类（Derived）析构函数，再调用基类（Base）析构函数，防止内存泄漏。
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">delete</span> ptr;
	ptr <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;

	system(<span style="color:#e6db74">&#34;pause&#34;</span>);
	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
} 
</code></pre></div><h3 id="volatile">volatile</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">volatile</span> <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>; 
</code></pre></div><ul>
<li>volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以使用 volatile 告诉编译器不应对这样的对象进行优化。</li>
<li>volatile 关键字声明的变量，每次访问时都必须从内存中取出值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值）</li>
<li>const 可以是 volatile （如只读的状态寄存器）</li>
<li>指针可以是 volatile</li>
</ul>
<h3 id="assert">assert()</h3>
<p>断言，是宏，而非函数。assert 宏的原型定义在 <code>&lt;assert.h&gt;</code>（C）、<code>&lt;cassert&gt;</code>（C++）中，其作用是如果它的条件返回错误，则终止程序执行。可以通过定义 <code>NDEBUG</code> 来关闭 assert，但是需要在源代码的开头，<code>include &lt;assert.h&gt;</code> 之前。</p>
<p>assert() 使用</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#define NDEBUG          </span><span style="color:#75715e">// 加上这行，则 assert 不可用
</span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;assert.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
assert( p <span style="color:#f92672">!=</span> NULL );    <span style="color:#75715e">// assert 不可用
</span></code></pre></div><h3 id="sizeof">sizeof()</h3>
<ul>
<li>sizeof 对数组，得到整个数组所占空间大小。</li>
<li>sizeof 对指针，得到指针本身所占空间大小。</li>
</ul>
<h3 id="pragma-packn">#pragma pack(n)</h3>
<p>设定结构体、联合以及类成员变量以 n 字节方式对齐</p>
<p>#pragma pack(n) 使用</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#pragma pack(push)  </span><span style="color:#75715e">// 保存对齐状态
</span><span style="color:#75715e"></span><span style="color:#75715e">#pragma pack(4)     </span><span style="color:#75715e">// 设定为 4 字节对齐
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">test</span>
{
    <span style="color:#66d9ef">char</span> m1;
    <span style="color:#66d9ef">double</span> m4;
    <span style="color:#66d9ef">int</span> m3;
};

<span style="color:#75715e">#pragma pack(pop)   </span><span style="color:#75715e">// 恢复对齐状态
</span></code></pre></div><h3 id="位域">位域</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">Bit mode: <span style="color:#ae81ff">2</span>;    <span style="color:#75715e">// mode 占 2 位
</span></code></pre></div><p>类可以将其（非静态）数据成员定义为位域（bit-field），在一个位域中含有一定数量的二进制位。当一个程序需要向其他程序或硬件设备传递二进制数据时，通常会用到位域。</p>
<ul>
<li>位域在内存中的布局是与机器有关的</li>
<li>位域的类型必须是整型或枚举类型，带符号类型中的位域的行为将因具体实现而定</li>
<li>取地址运算符（&amp;）不能作用于位域，任何指针都无法指向类的位域</li>
</ul>
<h3 id="extern-c">extern &ldquo;C&rdquo;</h3>
<ul>
<li>被 extern 限定的函数或变量是 extern 类型的</li>
<li>被 <code>extern &quot;C&quot;</code> 修饰的变量和函数是按照 C 语言方式编译和链接的</li>
</ul>
<p><code>extern &quot;C&quot;</code> 的作用是让 C++ 编译器将 <code>extern &quot;C&quot;</code> 声明的代码当作 C 语言代码处理，可以避免 C++ 因符号修饰导致代码不能和C语言库中的符号进行链接的问题。</p>
<p>extern &ldquo;C&rdquo; 使用</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#ifdef __cplusplus
</span><span style="color:#75715e"></span><span style="color:#66d9ef">extern</span> <span style="color:#e6db74">&#34;C&#34;</span> {
<span style="color:#75715e">#endif
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">memset</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>, <span style="color:#66d9ef">int</span>, size_t);

<span style="color:#75715e">#ifdef __cplusplus
</span><span style="color:#75715e"></span>}
<span style="color:#75715e">#endif
</span></code></pre></div><h3 id="struct-和-typedef-struct">struct 和 typedef struct</h3>
<h4 id="c-中">C 中</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">// c
</span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> Student {
    <span style="color:#66d9ef">int</span> age; 
} S;
</code></pre></div><p>等价于</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">// c
</span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> Student { 
    <span style="color:#66d9ef">int</span> age; 
};

<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> Student S;
</code></pre></div><p>此时 <code>S</code> 等价于 <code>struct Student</code>，但两个标识符名称空间不相同。</p>
<p>另外还可以定义与 <code>struct Student</code> 不冲突的 <code>void Student() {}</code>。</p>
<h4 id="c-中-1">C++ 中</h4>
<p>由于编译器定位符号的规则（搜索规则）改变，导致不同于C语言。</p>
<p>一、如果在类标识符空间定义了 <code>struct Student {...};</code>，使用 <code>Student me;</code> 时，编译器将搜索全局标识符表，<code>Student</code> 未找到，则在类标识符内搜索。</p>
<p>即表现为可以使用 <code>Student</code> 也可以使用 <code>struct Student</code>，如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// cpp
</span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Student</span> { 
    <span style="color:#66d9ef">int</span> age; 
};

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">f</span>( Student me );       <span style="color:#75715e">// 正确，&#34;struct&#34; 关键字可省略
</span></code></pre></div><p>二、若定义了与 <code>Student</code> 同名函数之后，则 <code>Student</code> 只代表函数，不代表结构体，如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Student</span> { 
    <span style="color:#66d9ef">int</span> age; 
} S;

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Student</span>() {}           <span style="color:#75715e">// 正确，定义后 &#34;Student&#34; 只代表此函数
</span><span style="color:#75715e"></span>
<span style="color:#75715e">//void S() {}               // 错误，符号 &#34;S&#34; 已经被定义为一个 &#34;struct Student&#34; 的别名
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    Student(); 
    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Student</span> me;      <span style="color:#75715e">// 或者 &#34;S me&#34;;
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="c-中-struct-和-class">C++ 中 struct 和 class</h3>
<p>总的来说，struct 更适合看成是一个数据结构的实现体，class 更适合看成是一个对象的实现体。</p>
<h4 id="区别">区别</h4>
<ul>
<li>最本质的一个区别就是默认的访问控制
<ol>
<li>默认的继承访问权限。struct 是 public 的，class 是 private 的。</li>
<li>struct 作为数据结构的实现体，它默认的数据访问控制是 public 的，而 class 作为对象的实现体，它默认的成员变量访问控制是 private 的。</li>
</ol>
</li>
</ul>
<h3 id="union-联合">union 联合</h3>
<p>联合（union）是一种节省空间的特殊的类，一个 union 可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值。当某个成员被赋值后其他成员变为未定义状态。联合有如下特点：</p>
<ul>
<li>默认访问控制符为 public</li>
<li>可以含有构造函数、析构函数</li>
<li>不能含有引用类型的成员</li>
<li>不能继承自其他类，不能作为基类</li>
<li>不能含有虚函数</li>
<li>匿名 union 在定义所在作用域可直接访问 union 成员</li>
<li>匿名 union 不能包含 protected 成员或 private 成员</li>
<li>全局匿名联合必须是静态（static）的</li>
</ul>
<p>union 使用</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">union</span> <span style="color:#a6e22e">UnionTest</span> {
    UnionTest() <span style="color:#f92672">:</span> i(<span style="color:#ae81ff">10</span>) {};
    <span style="color:#66d9ef">int</span> i;
    <span style="color:#66d9ef">double</span> d;
};

<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">union</span> {
    <span style="color:#66d9ef">int</span> i;
    <span style="color:#66d9ef">double</span> d;
};

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    UnionTest u;

    <span style="color:#66d9ef">union</span> {
        <span style="color:#66d9ef">int</span> i;
        <span style="color:#66d9ef">double</span> d;
    };

    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> u.i <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;  <span style="color:#75715e">// 输出 UnionTest 联合的 10
</span><span style="color:#75715e"></span>
    <span style="color:#f92672">::</span>i <span style="color:#f92672">=</span> <span style="color:#ae81ff">20</span>;
    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">::</span>i <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;  <span style="color:#75715e">// 输出全局静态匿名联合的 20
</span><span style="color:#75715e"></span>
    i <span style="color:#f92672">=</span> <span style="color:#ae81ff">30</span>;
    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> i <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;    <span style="color:#75715e">// 输出局部匿名联合的 30
</span><span style="color:#75715e"></span>
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="c-实现-c-类">C 实现 C++ 类</h3>
<p>C 实现 C++ 的面向对象特性（封装、继承、多态）</p>
<ul>
<li>封装：使用函数指针把属性与方法封装到结构体中</li>
<li>继承：结构体嵌套</li>
<li>多态：父类与子类方法的函数指针不同</li>
</ul>
<blockquote>
<p><a href="https://stackoverflow.com/a/351745">Can you write object-oriented code in C? [closed]</a></p>
</blockquote>
<h3 id="explicit显式关键字">explicit（显式）关键字</h3>
<ul>
<li>explicit 修饰构造函数时，可以防止隐式转换和复制初始化</li>
<li>explicit 修饰转换函数时，可以防止隐式转换，但 <a href="https://zh.cppreference.com/w/cpp/language/implicit_conversion">按语境转换</a> 除外</li>
</ul>
<p>explicit 使用</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">A</span>
{
	A(<span style="color:#66d9ef">int</span>) { }
	<span style="color:#66d9ef">operator</span> <span style="color:#a6e22e">bool</span>() <span style="color:#66d9ef">const</span> { <span style="color:#66d9ef">return</span> true; }
};

<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">B</span>
{
	<span style="color:#66d9ef">explicit</span> <span style="color:#a6e22e">B</span>(<span style="color:#66d9ef">int</span>) {}
	<span style="color:#66d9ef">explicit</span> <span style="color:#66d9ef">operator</span> <span style="color:#a6e22e">bool</span>() <span style="color:#66d9ef">const</span> { <span style="color:#66d9ef">return</span> true; }
};

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">doA</span>(A a) {}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">doB</span>(B b) {}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
	A a1(<span style="color:#ae81ff">1</span>);		<span style="color:#75715e">// OK：直接初始化
</span><span style="color:#75715e"></span>	A a2 <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;		<span style="color:#75715e">// OK：复制初始化
</span><span style="color:#75715e"></span>	A a3{ <span style="color:#ae81ff">1</span> };		<span style="color:#75715e">// OK：直接列表初始化
</span><span style="color:#75715e"></span>	A a4 <span style="color:#f92672">=</span> { <span style="color:#ae81ff">1</span> };		<span style="color:#75715e">// OK：复制列表初始化
</span><span style="color:#75715e"></span>	A a5 <span style="color:#f92672">=</span> (A)<span style="color:#ae81ff">1</span>;		<span style="color:#75715e">// OK：允许 static_cast 的显式转换 
</span><span style="color:#75715e"></span>	doA(<span style="color:#ae81ff">1</span>);			<span style="color:#75715e">// OK：允许从 int 到 A 的隐式转换
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (a1);		<span style="color:#75715e">// OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">bool</span> a6(a1);		<span style="color:#75715e">// OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">bool</span> a7 <span style="color:#f92672">=</span> a1;		<span style="color:#75715e">// OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">bool</span> a8 <span style="color:#f92672">=</span> <span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span><span style="color:#f92672">&gt;</span>(a1);  <span style="color:#75715e">// OK ：static_cast 进行直接初始化
</span><span style="color:#75715e"></span>
	B b1(<span style="color:#ae81ff">1</span>);		<span style="color:#75715e">// OK：直接初始化
</span><span style="color:#75715e"></span>	B b2 <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;		<span style="color:#75715e">// 错误：被 explicit 修饰构造函数的对象不可以复制初始化
</span><span style="color:#75715e"></span>	B b3{ <span style="color:#ae81ff">1</span> };		<span style="color:#75715e">// OK：直接列表初始化
</span><span style="color:#75715e"></span>	B b4 <span style="color:#f92672">=</span> { <span style="color:#ae81ff">1</span> };		<span style="color:#75715e">// 错误：被 explicit 修饰构造函数的对象不可以复制列表初始化
</span><span style="color:#75715e"></span>	B b5 <span style="color:#f92672">=</span> (B)<span style="color:#ae81ff">1</span>;		<span style="color:#75715e">// OK：允许 static_cast 的显式转换
</span><span style="color:#75715e"></span>	doB(<span style="color:#ae81ff">1</span>);			<span style="color:#75715e">// 错误：被 explicit 修饰构造函数的对象不可以从 int 到 B 的隐式转换
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (b1);		<span style="color:#75715e">// OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">bool</span> b6(b1);		<span style="color:#75715e">// OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">bool</span> b7 <span style="color:#f92672">=</span> b1;		<span style="color:#75715e">// 错误：被 explicit 修饰转换函数 B::operator bool() 的对象不可以隐式转换
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">bool</span> b8 <span style="color:#f92672">=</span> <span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span><span style="color:#f92672">&gt;</span>(b1);  <span style="color:#75715e">// OK：static_cast 进行直接初始化
</span><span style="color:#75715e"></span>
	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="friend-友元类和友元函数">friend 友元类和友元函数</h3>
<ul>
<li>能访问私有成员</li>
<li>破坏封装性</li>
<li>友元关系不可传递</li>
<li>友元关系的单向性</li>
<li>友元声明的形式及数量不受限制</li>
</ul>
<h3 id="using">using</h3>
<h4 id="using-声明">using 声明</h4>
<p>一条 <code>using 声明</code> 语句一次只引入命名空间的一个成员。它使得我们可以清楚知道程序中所引用的到底是哪个名字。如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">using</span> namespace_name<span style="color:#f92672">::</span>name;
</code></pre></div><h4 id="构造函数的-using-声明">构造函数的 using 声明</h4>
<p>在 C++11 中，派生类能够重用其直接基类定义的构造函数。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Derived</span> <span style="color:#f92672">:</span> Base {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">using</span> Base<span style="color:#f92672">::</span>Base;
    <span style="color:#75715e">/* ... */</span>
};
</code></pre></div><p>如上 using 声明，对于基类的每个构造函数，编译器都生成一个与之对应（形参列表完全相同）的派生类构造函数。生成如下类型构造函数：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">Derived(parms) <span style="color:#f92672">:</span> Base(args) { }
</code></pre></div><h4 id="using-指示">using 指示</h4>
<p><code>using 指示</code> 使得某个特定命名空间中所有名字都可见，这样我们就无需再为它们添加任何前缀限定符了。如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">using</span> namespace_name name;
</code></pre></div><h4 id="尽量少使用-using-指示-污染命名空间">尽量少使用 <code>using 指示</code> 污染命名空间</h4>
<blockquote>
<p>一般说来，使用 using 命令比使用 using 编译命令更安全，这是由于它<strong>只导入了指定的名称</strong>。如果该名称与局部名称发生冲突，编译器将<strong>发出指示</strong>。using编译命令导入所有的名称，包括可能并不需要的名称。如果与局部名称发生冲突，则<strong>局部名称将覆盖名称空间版本</strong>，而编译器<strong>并不会发出警告</strong>。另外，名称空间的开放性意味着名称空间的名称可能分散在多个地方，这使得难以准确知道添加了哪些名称。</p>
</blockquote>
<p>using 使用</p>
<p>尽量少使用 <code>using 指示</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</code></pre></div><p>应该多使用 <code>using 声明</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">int</span> x;
std<span style="color:#f92672">::</span>cin <span style="color:#f92672">&gt;&gt;</span> x ;
std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> x <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</code></pre></div><p>或者</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">using</span> std<span style="color:#f92672">::</span>cin;
<span style="color:#66d9ef">using</span> std<span style="color:#f92672">::</span>cout;
<span style="color:#66d9ef">using</span> std<span style="color:#f92672">::</span>endl;
<span style="color:#66d9ef">int</span> x;
cin <span style="color:#f92672">&gt;&gt;</span> x;
cout <span style="color:#f92672">&lt;&lt;</span> x <span style="color:#f92672">&lt;&lt;</span> endl;
</code></pre></div><h3 id="-范围解析运算符">:: 范围解析运算符</h3>
<h4 id="分类">分类</h4>
<ol>
<li>全局作用域符（<code>::name</code>）：用于类型名称（类、类成员、成员函数、变量等）前，表示作用域为全局命名空间</li>
<li>类作用域符（<code>class::name</code>）：用于表示指定类型的作用域范围是具体某个类的</li>
<li>命名空间作用域符（<code>namespace::name</code>）:用于表示指定类型的作用域范围是具体某个命名空间的</li>
</ol>
<p>:: 使用</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">int</span> count <span style="color:#f92672">=</span> <span style="color:#ae81ff">11</span>;         <span style="color:#75715e">// 全局（::）的 count
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> count;   <span style="color:#75715e">// 类 A 的 count（A::count）
</span><span style="color:#75715e"></span>};
<span style="color:#66d9ef">int</span> A<span style="color:#f92672">::</span>count <span style="color:#f92672">=</span> <span style="color:#ae81ff">21</span>;

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">fun</span>()
{
	<span style="color:#66d9ef">int</span> count <span style="color:#f92672">=</span> <span style="color:#ae81ff">31</span>;     <span style="color:#75715e">// 初始化局部的 count 为 31
</span><span style="color:#75715e"></span>	count <span style="color:#f92672">=</span> <span style="color:#ae81ff">32</span>;         <span style="color:#75715e">// 设置局部的 count 的值为 32
</span><span style="color:#75715e"></span>}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#f92672">::</span>count <span style="color:#f92672">=</span> <span style="color:#ae81ff">12</span>;       <span style="color:#75715e">// 测试 1：设置全局的 count 的值为 12
</span><span style="color:#75715e"></span>
	A<span style="color:#f92672">::</span>count <span style="color:#f92672">=</span> <span style="color:#ae81ff">22</span>;      <span style="color:#75715e">// 测试 2：设置类 A 的 count 为 22
</span><span style="color:#75715e"></span>
	fun();		        <span style="color:#75715e">// 测试 3
</span><span style="color:#75715e"></span>
	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="enum-枚举类型">enum 枚举类型</h3>
<h4 id="限定作用域的枚举类型">限定作用域的枚举类型</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">enum</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">open_modes</span> { input, output, append };
</code></pre></div><h4 id="不限定作用域的枚举类型">不限定作用域的枚举类型</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">color</span> { red, yellow, green };
<span style="color:#66d9ef">enum</span> { floatPrec <span style="color:#f92672">=</span> <span style="color:#ae81ff">6</span>, doublePrec <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span> };
</code></pre></div><h3 id="decltype">decltype</h3>
<p>decltype 关键字用于检查实体的声明类型或表达式的类型及值分类。语法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">decltype</span> ( expression )
</code></pre></div><p>decltype 使用</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// 尾置返回允许我们在参数列表之后声明返回类型
</span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> It<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">auto</span> fcn(It beg, It end) <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">decltype</span>(<span style="color:#f92672">*</span>beg)
{
    <span style="color:#75715e">// 处理序列
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span>beg;    <span style="color:#75715e">// 返回序列中一个元素的引用
</span><span style="color:#75715e"></span>}
<span style="color:#75715e">// 为了使用模板参数成员，必须用 typename
</span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> It<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">auto</span> fcn2(It beg, It end) <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">typename</span> remove_reference<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">decltype</span>(<span style="color:#f92672">*</span>beg)<span style="color:#f92672">&gt;::</span>type
{
    <span style="color:#75715e">// 处理序列
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span>beg;    <span style="color:#75715e">// 返回序列中一个元素的拷贝
</span><span style="color:#75715e"></span>}
</code></pre></div><h3 id="引用">引用</h3>
<h4 id="左值引用">左值引用</h4>
<p>常规引用，一般表示对象的身份。</p>
<h4 id="右值引用">右值引用</h4>
<p>右值引用就是必须绑定到右值（一个临时对象、将要销毁的对象）的引用，一般表示对象的值。</p>
<p>右值引用可实现转移语义（Move Sementics）和精确传递（Perfect Forwarding），它的主要目的有两个方面：</p>
<ul>
<li>消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。</li>
<li>能够更简洁明确地定义泛型函数。</li>
</ul>
<h4 id="引用折叠">引用折叠</h4>
<ul>
<li><code>X&amp; &amp;</code>、<code>X&amp; &amp;&amp;</code>、<code>X&amp;&amp; &amp;</code> 可折叠成 <code>X&amp;</code></li>
<li><code>X&amp;&amp; &amp;&amp;</code> 可折叠成 <code>X&amp;&amp;</code></li>
</ul>
<h3 id="宏">宏</h3>
<ul>
<li>宏定义可以实现类似于函数的功能，但是它终归不是函数，而宏定义中括弧中的“参数”也不是真的参数，在宏展开的时候对 “参数” 进行的是一对一的替换。</li>
</ul>
<h3 id="成员初始化列表">成员初始化列表</h3>
<p>好处</p>
<ul>
<li>更高效：少了一次调用默认构造函数的过程。</li>
<li>有些场合必须要用初始化列表：
<ol>
<li>常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面</li>
<li>引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面</li>
<li>没有默认构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化</li>
</ol>
</li>
</ul>
<h3 id="initializer_list-列表初始化">initializer_list 列表初始化</h3>
<p>用花括号初始化器列表初始化一个对象，其中对应构造函数接受一个 <code>std::initializer_list</code> 参数.</p>
<p>initializer_list 使用</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;initializer_list&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span> 
<span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">S</span> {
    std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> v;
    S(std<span style="color:#f92672">::</span>initializer_list<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> l) <span style="color:#f92672">:</span> v(l) {
         std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;constructed with a &#34;</span> <span style="color:#f92672">&lt;&lt;</span> l.size() <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;-element list</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
    }
    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">append</span>(std<span style="color:#f92672">::</span>initializer_list<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> l) {
        v.insert(v.end(), l.begin(), l.end());
    }
    std<span style="color:#f92672">::</span>pair<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">const</span> T<span style="color:#f92672">*</span>, std<span style="color:#f92672">::</span>size_t<span style="color:#f92672">&gt;</span> c_arr() <span style="color:#66d9ef">const</span> {
        <span style="color:#66d9ef">return</span> {<span style="color:#f92672">&amp;</span>v[<span style="color:#ae81ff">0</span>], v.size()};  <span style="color:#75715e">// 在 return 语句中复制列表初始化
</span><span style="color:#75715e"></span>                                   <span style="color:#75715e">// 这不使用 std::initializer_list
</span><span style="color:#75715e"></span>    }
};
 
<span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">void</span> templated_fn(T) {}
 
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
    S<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> s <span style="color:#f92672">=</span> {<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>}; <span style="color:#75715e">// 复制初始化
</span><span style="color:#75715e"></span>    s.append({<span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">8</span>});      <span style="color:#75715e">// 函数调用中的列表初始化
</span><span style="color:#75715e"></span> 
    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;The vector size is now &#34;</span> <span style="color:#f92672">&lt;&lt;</span> s.c_arr().second <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; ints:</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
 
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> n : s.v)
        std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> n <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39; &#39;</span>;
    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
 
    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Range-for over brace-init-list: </span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
 
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> x : {<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">3</span>}) <span style="color:#75715e">// auto 的规则令此带范围 for 工作
</span><span style="color:#75715e"></span>        std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> x <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39; &#39;</span>;
    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
 
    <span style="color:#66d9ef">auto</span> al <span style="color:#f92672">=</span> {<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">11</span>, <span style="color:#ae81ff">12</span>};   <span style="color:#75715e">// auto 的特殊规则
</span><span style="color:#75715e"></span> 
    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;The list bound to auto has size() = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> al.size() <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
 
<span style="color:#75715e">//    templated_fn({1, 2, 3}); // 编译错误！“ {1, 2, 3} ”不是表达式，
</span><span style="color:#75715e"></span>                             <span style="color:#75715e">// 它无类型，故 T 无法推导
</span><span style="color:#75715e"></span>    templated_fn<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>initializer_list<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span>({<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>}); <span style="color:#75715e">// OK
</span><span style="color:#75715e"></span>    templated_fn<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span>({<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>});           <span style="color:#75715e">// 也 OK
</span><span style="color:#75715e"></span>}
</code></pre></div><h3 id="面向对象">面向对象</h3>
<p>面向对象程序设计（Object-oriented programming，OOP）是种具有对象概念的程序编程典范，同时也是一种程序开发的抽象方针。</p>
<p><img src="https://gitee.com/huihut/interview/raw/master/images/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81.png" alt="面向对象特征"></p>
<p>面向对象三大特征 —— 封装、继承、多态</p>
<h3 id="封装">封装</h3>
<p>把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。关键字：public, protected, private。不写默认为 private。</p>
<ul>
<li><code>public</code> 成员：可以被任意实体访问</li>
<li><code>protected</code> 成员：只允许被子类及本类的成员函数访问</li>
<li><code>private</code> 成员：只允许被本类的成员函数、友元类或友元函数访问</li>
</ul>
<h3 id="继承">继承</h3>
<ul>
<li>基类（父类）——&gt; 派生类（子类）</li>
</ul>
<h3 id="多态">多态</h3>
<ul>
<li>多态，即多种状态（形态）。简单来说，我们可以将多态定义为消息以多种形式显示的能力。</li>
<li>多态是以封装和继承为基础的。</li>
<li>C++ 多态分类及实现：
<ol>
<li>重载多态（Ad-hoc Polymorphism，编译期）：函数重载、运算符重载</li>
<li>子类型多态（Subtype Polymorphism，运行期）：虚函数</li>
<li>参数多态性（Parametric Polymorphism，编译期）：类模板、函数模板</li>
<li>强制多态（Coercion Polymorphism，编译期/运行期）：基本类型转换、自定义类型转换</li>
</ol>
</li>
</ul>
<blockquote>
<p><a href="https://catonmat.net/cpp-polymorphism">The Four Polymorphisms in C++</a></p>
</blockquote>
<h4 id="静态多态编译期早绑定">静态多态（编译期/早绑定）</h4>
<p>函数重载</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span>
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">void</span> <span style="color:#66d9ef">do</span>(<span style="color:#66d9ef">int</span> a);
    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">do</span>(<span style="color:#66d9ef">int</span> a, <span style="color:#66d9ef">int</span> b);
};
</code></pre></div><h4 id="动态多态运行期期晚绑定">动态多态（运行期期/晚绑定）</h4>
<ul>
<li>虚函数：用 virtual 修饰成员函数，使其成为虚函数</li>
<li>动态绑定：当使用基类的引用或指针调用一个虚函数时将发生动态绑定</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>可以将派生类的对象赋值给基类的指针或引用，反之不可</li>
<li>普通函数（非类成员函数）不能是虚函数</li>
<li>静态函数（static）不能是虚函数</li>
<li>构造函数不能是虚函数（因为在调用构造函数时，虚表指针并没有在对象的内存空间中，必须要构造函数调用完成后才会形成虚表指针）</li>
<li>内联函数不能是表现多态性时的虚函数，解释见：<a href="https://github.com/huihut/interview#%E8%99%9A%E5%87%BD%E6%95%B0virtual%E5%8F%AF%E4%BB%A5%E6%98%AF%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0inline%E5%90%97">虚函数（virtual）可以是内联函数（inline）吗？</a></li>
</ul>
<p>动态多态使用</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Shape</span>                     <span style="color:#75715e">// 形状类
</span><span style="color:#75715e"></span>{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">double</span> calcArea()
    {
        ...
    }
    <span style="color:#66d9ef">virtual</span> <span style="color:#f92672">~</span>Shape();
};
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Circle</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Shape     <span style="color:#75715e">// 圆形类
</span><span style="color:#75715e"></span>{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">double</span> calcArea();
    ...
};
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Rect</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Shape       <span style="color:#75715e">// 矩形类
</span><span style="color:#75715e"></span>{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">double</span> calcArea();
    ...
};
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
    Shape <span style="color:#f92672">*</span> shape1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Circle(<span style="color:#ae81ff">4.0</span>);
    Shape <span style="color:#f92672">*</span> shape2 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Rect(<span style="color:#ae81ff">5.0</span>, <span style="color:#ae81ff">6.0</span>);
    shape1<span style="color:#f92672">-&gt;</span>calcArea();         <span style="color:#75715e">// 调用圆形类里面的方法
</span><span style="color:#75715e"></span>    shape2<span style="color:#f92672">-&gt;</span>calcArea();         <span style="color:#75715e">// 调用矩形类里面的方法
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">delete</span> shape1;
    shape1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;
    <span style="color:#66d9ef">delete</span> shape2;
    shape2 <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="虚析构函数">虚析构函数</h3>
<p>虚析构函数是为了解决基类的指针指向派生类对象，并用基类的指针删除派生类对象。</p>
<p>虚析构函数使用</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Shape</span>
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    Shape();                    <span style="color:#75715e">// 构造函数不能是虚函数
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">double</span> <span style="color:#a6e22e">calcArea</span>();
    <span style="color:#66d9ef">virtual</span> <span style="color:#f92672">~</span>Shape();           <span style="color:#75715e">// 虚析构函数
</span><span style="color:#75715e"></span>};
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Circle</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Shape     <span style="color:#75715e">// 圆形类
</span><span style="color:#75715e"></span>{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">double</span> calcArea();
    ...
};
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
    Shape <span style="color:#f92672">*</span> shape1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Circle(<span style="color:#ae81ff">4.0</span>);
    shape1<span style="color:#f92672">-&gt;</span>calcArea();    
    <span style="color:#66d9ef">delete</span> shape1;  <span style="color:#75715e">// 因为Shape有虚析构函数，所以delete释放内存时，先调用子类析构函数，再调用基类析构函数，防止内存泄漏。
</span><span style="color:#75715e"></span>    shape1 <span style="color:#f92672">=</span> NULL;
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span><span style="color:#960050;background-color:#1e0010">；</span>
}
</code></pre></div><h3 id="纯虚函数">纯虚函数</h3>
<p>纯虚函数是一种特殊的虚函数，在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">A</span>() <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</code></pre></div><h3 id="虚函数纯虚函数">虚函数、纯虚函数</h3>
<ul>
<li>类里如果声明了虚函数，这个函数是实现的，哪怕是空实现，它的作用就是为了能让这个函数在它的子类里面可以被覆盖（override），这样的话，编译器就可以使用后期绑定来达到多态了。纯虚函数只是一个接口，是个函数的声明而已，它要留到子类里去实现。</li>
<li>虚函数在子类里面可以不重写；但纯虚函数必须在子类实现才可以实例化子类。</li>
<li>虚函数的类用于 “实作继承”，继承接口的同时也继承了父类的实现。纯虚函数关注的是接口的统一性，实现由子类完成。</li>
<li>带纯虚函数的类叫抽象类，这种类不能直接生成对象，而只有被继承，并重写其虚函数后，才能使用。抽象类被继承后，子类可以继续是抽象类，也可以是普通类。</li>
<li>虚基类是虚继承中的基类，具体见下文虚继承。</li>
</ul>
<blockquote>
<p><a href="https://blog.csdn.net/u012260238/article/details/53610462">CSDN . C++ 中的虚函数、纯虚函数区别和联系</a></p>
</blockquote>
<h3 id="虚函数指针虚函数表">虚函数指针、虚函数表</h3>
<ul>
<li>虚函数指针：在含有虚函数类的对象中，指向虚函数表，在运行时确定。</li>
<li>虚函数表：在程序只读数据段（<code>.rodata section</code>，见：<a href="#%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84">目标文件存储结构</a>），存放虚函数指针，如果派生类实现了基类的某个虚函数，则在虚表中覆盖原本基类的那个虚函数指针，在编译时根据类的声明创建。</li>
</ul>
<blockquote>
<p><a href="https://blog.twofei.com/496/">C++中的虚函数(表)实现机制以及用C语言对其进行的模拟实现</a></p>
</blockquote>
<h3 id="虚继承">虚继承</h3>
<p>虚继承用于解决多继承条件下的菱形继承问题（浪费存储空间、存在二义性）。</p>
<p>底层实现原理与编译器相关，一般通过<strong>虚基类指针</strong>和<strong>虚基类表</strong>实现，每个虚继承的子类都有一个虚基类指针（占用一个指针的存储空间，4字节）和虚基类表（不占用类对象的存储空间）（需要强调的是，虚基类依旧会在子类里面存在拷贝，只是仅仅最多存在一份而已，并不是不在子类里面了）；当虚继承的子类被当做父类继承时，虚基类指针也会被继承。</p>
<p>实际上，vbptr 指的是虚基类表指针（virtual base table pointer），该指针指向了一个虚基类表（virtual table），虚表中记录了虚基类与本类的偏移地址；通过偏移地址，这样就找到了虚基类成员，而虚继承也不用像普通多继承那样维持着公共基类（虚基类）的两份同样的拷贝，节省了存储空间。</p>
<h3 id="虚继承虚函数">虚继承、虚函数</h3>
<ul>
<li>相同之处：都利用了虚指针（均占用类的存储空间）和虚表（均不占用类的存储空间）</li>
<li>不同之处：
<ul>
<li>虚继承
<ul>
<li>虚基类依旧存在继承类中，只占用存储空间</li>
<li>虚基类表存储的是虚基类相对直接继承类的偏移</li>
</ul>
</li>
<li>虚函数
<ul>
<li>虚函数不占用存储空间</li>
<li>虚函数表存储的是虚函数地址</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="模板类成员模板虚函数">模板类、成员模板、虚函数</h3>
<ul>
<li>模板类中可以使用虚函数</li>
<li>一个类（无论是普通类还是类模板）的成员模板（本身是模板的成员函数）不能是虚函数</li>
</ul>
<h3 id="抽象类接口类聚合类">抽象类、接口类、聚合类</h3>
<ul>
<li>抽象类：含有纯虚函数的类</li>
<li>接口类：仅含有纯虚函数的抽象类</li>
<li>聚合类：用户可以直接访问其成员，并且具有特殊的初始化语法形式。满足如下特点：
<ul>
<li>所有成员都是 public</li>
<li>没有定义任何构造函数</li>
<li>没有类内初始化</li>
<li>没有基类，也没有 virtual 函数</li>
</ul>
</li>
</ul>
<h3 id="内存分配和管理">内存分配和管理</h3>
<h4 id="malloccallocreallocalloca">malloc、calloc、realloc、alloca</h4>
<ol>
<li>malloc：申请指定字节数的内存。申请到的内存中的初始值不确定。</li>
<li>calloc：为指定长度的对象，分配能容纳其指定个数的内存。申请到的内存的每一位（bit）都初始化为 0。</li>
<li>realloc：更改以前分配的内存长度（增加或减少）。当增加长度时，可能需将以前分配区的内容移到另一个足够大的区域，而新增区域内的初始值则不确定。</li>
<li>alloca：在栈上申请内存。程序在出栈的时候，会自动释放内存。但是需要注意的是，alloca 不具可移植性, 而且在没有传统堆栈的机器上很难实现。alloca 不宜使用在必须广泛移植的程序中。C99 中支持变长数组 (VLA)，可以用来替代 alloca。</li>
</ol>
<h4 id="mallocfree">malloc、free</h4>
<p>用于分配、释放内存</p>
<p>malloc、free 使用</p>
<p>申请内存，确认是否申请成功</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>str <span style="color:#f92672">=</span> (<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>) malloc(<span style="color:#ae81ff">100</span>);
assert(str <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nullptr</span>);
</code></pre></div><p>释放内存后指针置空</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">free(p); 
p <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;
</code></pre></div><h4 id="newdelete">new、delete</h4>
<ol>
<li>new / new[]：完成两件事，先底层调用 malloc 分配了内存，然后调用构造函数（创建对象）。</li>
<li>delete/delete[]：也完成两件事，先调用析构函数（清理资源），然后底层调用 free 释放空间。</li>
<li>new 在申请内存时会自动计算所需字节数，而 malloc 则需我们自己输入申请内存空间的字节数。</li>
</ol>
<p>new、delete 使用</p>
<p>申请内存，确认是否申请成功</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
    T<span style="color:#f92672">*</span> t <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> T();     <span style="color:#75715e">// 先内存分配 ，再构造函数
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">delete</span> t;           <span style="color:#75715e">// 先析构函数，再内存释放
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h4 id="定位-new">定位 new</h4>
<p>定位 new（placement new）允许我们向 new 传递额外的地址参数，从而在预先指定的内存区域创建对象。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">new</span> (place_address) type
<span style="color:#66d9ef">new</span> (place_address) type (initializers)
<span style="color:#66d9ef">new</span> (place_address) type [size]
<span style="color:#66d9ef">new</span> (place_address) type [size] { braced initializer list }
</code></pre></div><ul>
<li><code>place_address</code> 是个指针</li>
<li><code>initializers</code> 提供一个（可能为空的）以逗号分隔的初始值列表</li>
</ul>
<h3 id="delete-this-合法吗">delete this 合法吗？</h3>
<blockquote>
<p><a href="https://isocpp.org/wiki/faq/freestore-mgmt#delete-this">Is it legal (and moral) for a member function to say delete this?</a></p>
</blockquote>
<p>合法，但：</p>
<ol>
<li>必须保证 this 对象是通过 <code>new</code>（不是 <code>new[]</code>、不是 placement new、不是栈上、不是全局、不是其他对象成员）分配的</li>
<li>必须保证调用 <code>delete this</code> 的成员函数是最后一个调用 this 的成员函数</li>
<li>必须保证成员函数的 <code>delete this </code> 后面没有调用 this 了</li>
<li>必须保证 <code>delete this</code> 后没有人使用了</li>
</ol>
<h3 id="如何定义一个只能在堆上栈上生成对象的类">如何定义一个只能在堆上（栈上）生成对象的类？</h3>
<blockquote>
<p><a href="https://www.nowcoder.com/questionTerminal/0a584aa13f804f3ea72b442a065a7618">如何定义一个只能在堆上（栈上）生成对象的类?</a></p>
</blockquote>
<h4 id="只能在堆上">只能在堆上</h4>
<p>方法：将析构函数设置为私有</p>
<p>原因：C++ 是静态绑定语言，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。若析构函数不可访问，则不能在栈上创建对象。</p>
<h4 id="只能在栈上">只能在栈上</h4>
<p>方法：将 new 和 delete 重载为私有</p>
<p>原因：在堆上生成对象，使用 new 关键词操作，其过程分为两阶段：第一阶段，使用 new 在堆上寻找可用内存，分配给对象；第二阶段，调用构造函数生成对象。将 new 操作设置为私有，那么第一阶段就无法完成，就不能够在堆上生成对象。</p>
<h3 id="智能指针">智能指针</h3>
<h4 id="c-标准库stl中">C++ 标准库（STL）中</h4>
<p>头文件：<code>#include &lt;memory&gt;</code></p>
<h4 id="c-98">C++ 98</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">std<span style="color:#f92672">::</span>auto_ptr<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>string<span style="color:#f92672">&gt;</span> ps (<span style="color:#66d9ef">new</span> std<span style="color:#f92672">::</span>string(str))<span style="color:#960050;background-color:#1e0010">；</span>
</code></pre></div><h4 id="c-11">C++ 11</h4>
<ol>
<li>shared_ptr</li>
<li>unique_ptr</li>
<li>weak_ptr</li>
<li>auto_ptr（被 C++11 弃用）</li>
</ol>
<ul>
<li>Class shared_ptr 实现共享式拥有（shared ownership）概念。多个智能指针指向相同对象，该对象和其相关资源会在 “最后一个 reference 被销毁” 时被释放。为了在结构较复杂的情景中执行上述工作，标准库提供 weak_ptr、bad_weak_ptr 和 enable_shared_from_this 等辅助类。</li>
<li>Class unique_ptr 实现独占式拥有（exclusive ownership）或严格拥有（strict ownership）概念，保证同一时间内只有一个智能指针可以指向该对象。你可以移交拥有权。它对于避免内存泄漏（resource leak）——如 new 后忘记 delete ——特别有用。</li>
</ul>
<h5 id="shared_ptr">shared_ptr</h5>
<p>多个智能指针可以共享同一个对象，对象的最末一个拥有着有责任销毁对象，并清理与该对象相关的所有资源。</p>
<ul>
<li>支持定制型删除器（custom deleter），可防范 Cross-DLL 问题（对象在动态链接库（DLL）中被 new 创建，却在另一个 DLL 内被 delete 销毁）、自动解除互斥锁</li>
</ul>
<h5 id="weak_ptr">weak_ptr</h5>
<p>weak_ptr 允许你共享但不拥有某对象，一旦最末一个拥有该对象的智能指针失去了所有权，任何 weak_ptr 都会自动成空（empty）。因此，在 default 和 copy 构造函数之外，weak_ptr 只提供 “接受一个 shared_ptr” 的构造函数。</p>
<ul>
<li>可打破环状引用（cycles of references，两个其实已经没有被使用的对象彼此互指，使之看似还在 “被使用” 的状态）的问题</li>
</ul>
<h5 id="unique_ptr">unique_ptr</h5>
<p>unique_ptr 是 C++11 才开始提供的类型，是一种在异常时可以帮助避免资源泄漏的智能指针。采用独占式拥有，意味着可以确保一个对象和其相应的资源同一时间只被一个 pointer 拥有。一旦拥有着被销毁或编程 empty，或开始拥有另一个对象，先前拥有的那个对象就会被销毁，其任何相应资源亦会被释放。</p>
<ul>
<li>unique_ptr 用于取代 auto_ptr</li>
</ul>
<h5 id="auto_ptr">auto_ptr</h5>
<p>被 c++11 弃用，原因是缺乏语言特性如 “针对构造和赋值” 的 <code>std::move</code> 语义，以及其他瑕疵。</p>
<h5 id="auto_ptr-与-unique_ptr-比较">auto_ptr 与 unique_ptr 比较</h5>
<ul>
<li>auto_ptr 可以赋值拷贝，复制拷贝后所有权转移；unqiue_ptr 无拷贝赋值语义，但实现了<code>move</code> 语义；</li>
<li>auto_ptr 对象不能管理数组（析构调用 <code>delete</code>），unique_ptr 可以管理数组（析构调用 <code>delete[]</code> ）；</li>
</ul>
<h3 id="强制类型转换运算符">强制类型转换运算符</h3>
<blockquote>
<p><a href="https://msdn.microsoft.com/zh-CN/library/5f6c9f8h.aspx">MSDN . 强制转换运算符</a></p>
</blockquote>
<h4 id="static_cast">static_cast</h4>
<ul>
<li>用于非多态类型的转换</li>
<li>不执行运行时类型检查（转换安全性不如 dynamic_cast）</li>
<li>通常用于转换数值数据类型（如 float -&gt; int）</li>
<li>可以在整个类层次结构中移动指针，子类转化为父类安全（向上转换），父类转化为子类不安全（因为子类可能有不在父类的字段或方法）</li>
</ul>
<blockquote>
<p>向上转换是一种隐式转换。</p>
</blockquote>
<h4 id="dynamic_cast">dynamic_cast</h4>
<ul>
<li>用于多态类型的转换</li>
<li>执行行运行时类型检查</li>
<li>只适用于指针或引用</li>
<li>对不明确的指针的转换将失败（返回 nullptr），但不引发异常</li>
<li>可以在整个类层次结构中移动指针，包括向上转换、向下转换</li>
</ul>
<h4 id="const_cast">const_cast</h4>
<ul>
<li>用于删除 const、volatile 和 __unaligned 特性（如将 const int 类型转换为 int 类型 ）</li>
</ul>
<h4 id="reinterpret_cast">reinterpret_cast</h4>
<ul>
<li>用于位的简单重新解释</li>
<li>滥用 reinterpret_cast 运算符可能很容易带来风险。 除非所需转换本身是低级别的，否则应使用其他强制转换运算符之一。</li>
<li>允许将任何指针转换为任何其他指针类型（如 <code>char*</code> 到 <code>int*</code> 或 <code>One_class*</code> 到 <code>Unrelated_class*</code> 之类的转换，但其本身并不安全）</li>
<li>也允许将任何整数类型转换为任何指针类型以及反向转换。</li>
<li>reinterpret_cast 运算符不能丢掉 const、volatile 或 __unaligned 特性。</li>
<li>reinterpret_cast 的一个实际用途是在哈希函数中，即，通过让两个不同的值几乎不以相同的索引结尾的方式将值映射到索引。</li>
</ul>
<h4 id="bad_cast">bad_cast</h4>
<ul>
<li>由于强制转换为引用类型失败，dynamic_cast 运算符引发 bad_cast 异常。</li>
</ul>
<p>bad_cast 使用</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">try</span> {  
    Circle<span style="color:#f92672">&amp;</span> ref_circle <span style="color:#f92672">=</span> <span style="color:#66d9ef">dynamic_cast</span><span style="color:#f92672">&lt;</span>Circle<span style="color:#f92672">&amp;&gt;</span>(ref_shape);   
}  
<span style="color:#66d9ef">catch</span> (bad_cast b) {  
    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Caught: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> b.what();  
} 
</code></pre></div><h3 id="运行时类型信息-rtti">运行时类型信息 (RTTI)</h3>
<h4 id="dynamic_cast-1">dynamic_cast</h4>
<ul>
<li>用于多态类型的转换</li>
</ul>
<h4 id="typeid">typeid</h4>
<ul>
<li>typeid 运算符允许在运行时确定对象的类型</li>
<li>type_id 返回一个 type_info 对象的引用</li>
<li>如果想通过基类的指针获得派生类的数据类型，基类必须带有虚函数</li>
<li>只能获取对象的实际类型</li>
</ul>
<h4 id="type_info">type_info</h4>
<ul>
<li>type_info 类描述编译器在程序中生成的类型信息。 此类的对象可以有效存储指向类型的名称的指针。 type_info 类还可存储适合比较两个类型是否相等或比较其排列顺序的编码值。 类型的编码规则和排列顺序是未指定的，并且可能因程序而异。</li>
<li>头文件：<code>typeinfo</code></li>
</ul>
<p>typeid、type_info 使用</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Flyable</span>                       <span style="color:#75715e">// 能飞的
</span><span style="color:#75715e"></span>{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> takeoff() <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;     <span style="color:#75715e">// 起飞
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">land</span>() <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;        <span style="color:#75715e">// 降落
</span><span style="color:#75715e"></span>};
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Bird</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Flyable         <span style="color:#75715e">// 鸟
</span><span style="color:#75715e"></span>{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">void</span> foraging() {...}           <span style="color:#75715e">// 觅食
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">takeoff</span>() {...}
    <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">land</span>() {...}
    <span style="color:#66d9ef">virtual</span> <span style="color:#f92672">~</span>Bird(){}
};
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Plane</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Flyable        <span style="color:#75715e">// 飞机
</span><span style="color:#75715e"></span>{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">void</span> carry() {...}              <span style="color:#75715e">// 运输
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">takeoff</span>() {...}
    <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">land</span>() {...}
};

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">type_info</span>
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> name() <span style="color:#66d9ef">const</span>;
    <span style="color:#66d9ef">bool</span> <span style="color:#66d9ef">operator</span> <span style="color:#f92672">==</span> (<span style="color:#66d9ef">const</span> type_info <span style="color:#f92672">&amp;</span> rhs) <span style="color:#66d9ef">const</span>;
    <span style="color:#66d9ef">bool</span> <span style="color:#66d9ef">operator</span> <span style="color:#f92672">!=</span> (<span style="color:#66d9ef">const</span> type_info <span style="color:#f92672">&amp;</span> rhs) <span style="color:#66d9ef">const</span>;
    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">before</span>(<span style="color:#66d9ef">const</span> type_info <span style="color:#f92672">&amp;</span> rhs) <span style="color:#66d9ef">const</span>;
    <span style="color:#66d9ef">virtual</span> <span style="color:#f92672">~</span>type_info();
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
    ...
};

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">doSomething</span>(Flyable <span style="color:#f92672">*</span>obj)                 <span style="color:#75715e">// 做些事情
</span><span style="color:#75715e"></span>{
    obj<span style="color:#f92672">-&gt;</span>takeoff();

    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#66d9ef">typeid</span>(<span style="color:#f92672">*</span>obj).name() <span style="color:#f92672">&lt;&lt;</span> endl;        <span style="color:#75715e">// 输出传入对象类型（&#34;class Bird&#34; or &#34;class Plane&#34;）
</span><span style="color:#75715e"></span>
    <span style="color:#66d9ef">if</span>(<span style="color:#66d9ef">typeid</span>(<span style="color:#f92672">*</span>obj) <span style="color:#f92672">==</span> <span style="color:#66d9ef">typeid</span>(Bird))            <span style="color:#75715e">// 判断对象类型
</span><span style="color:#75715e"></span>    {
        Bird <span style="color:#f92672">*</span>bird <span style="color:#f92672">=</span> <span style="color:#66d9ef">dynamic_cast</span><span style="color:#f92672">&lt;</span>Bird <span style="color:#f92672">*&gt;</span>(obj); <span style="color:#75715e">// 对象转化
</span><span style="color:#75715e"></span>        bird<span style="color:#f92672">-&gt;</span>foraging();
    }

    obj<span style="color:#f92672">-&gt;</span>land();
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
	Bird <span style="color:#f92672">*</span>b <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Bird();
	doSomething(b);
	<span style="color:#66d9ef">delete</span> b;
	b <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;
	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div>
        
        ]]>
      </description>
=======
      <description>转载自https://github.com/huihut/interview const 作用 修饰变量，说明该变量不可以被改变； 修饰指针，分为指向常量的</description>
>>>>>>> 35a30928abf5c3213b754024efc550556652db2d
    </item>
    
    <item>
      <title>【转载】C Primer 之 new, delete</title>
      <link>/collection/cprimer04/</link>
      <pubDate>Thu, 30 Dec 2021 07:13:11 +0800</pubDate>
      
      <guid>/collection/cprimer04/</guid>
      <description>转载自https://github.com/andycai/cprimer new和delete运算符用于动态分配和撤销内存的运算符 (1) new用</description>
    </item>
    
    <item>
      <title>【转载】C Primer 之 char*, char[], string</title>
      <link>/collection/cprimer03/</link>
      <pubDate>Thu, 30 Dec 2021 07:12:45 +0800</pubDate>
      
      <guid>/collection/cprimer03/</guid>
<<<<<<< HEAD
      <description>
        <![CDATA[
        <p>转载自<a href="https://github.com/andycai/cprimer">https://github.com/andycai/cprimer</a></p>
<h2 id="31-char-char-string">3.1 char*, char[], string</h2>
<p>在C中，并没有字符串这个数据类型，而是使用字符数组来保存字符串。C字符串实际上就是一个以null('\0')字符结尾的字符数组，null字符表示字符串的结束。需要注意的是：只有以null字符结尾的字符数组才是C字符串，否则只是一般的C字符数组。</p>
<p>C字符串定义时可以利用&quot;=&ldquo;号进行初始化，但是以后不能利用&rdquo;=&ldquo;对C字符串进行赋值。对C字符串的操作需要通过&quot;string&quot;文件中定义的字符串处理函数。例如：</p>
<pre><code>//字符串的初始化
char a[11] = &quot;huanying&quot;;
//字符串的赋值
strcpy(a,&quot;nihao&quot;)
//获取字符串的长度，不包括'\0'在内
strlen(a);
printf(&quot;%s&quot;,a);
</code></pre>
<p>在C中也可以使用字符指针来访问一个字符串,通过字符指针指向存放字符串数组的首元素地址来进行访问.
char *a = &ldquo;nihao&rdquo;;
printf(&quot;%s&rdquo;,a);</p>
<p>在C++中则把字符串封装成了一种数据类型string,可以直接声明变量并进行赋值等字符串操作。以下是C字符串和C++中string的区别：</p>
<pre><code>                             C字符串                 string对象
所需的头文件名称       	&lt;string&gt;或&lt;string.h&gt;        	&lt;string&gt;或&lt;string.h&gt;
为什么需要头文件       	为了使用字符串函数            为了使用string类
如何声明                 char name[20];              string name;
如何初始化               char name[20]=&quot;nihao&quot;;   	string name = &quot;nihao&quot;;
必须声明字符串长度么？		是                          否
使用一个null字符么？     	是                          否
怎样实现字符串赋值      	strcpy(name,&quot;John&quot;);        name = &quot;John&quot;;
其他优点               	更快                        更易于使用，优选方案
可以赋一个比现有字符更 	不能                        可以
长的字符串么？  
</code></pre>
<h3 id="1-c常用字符串函数">(1) C++常用字符串函数</h3>
<pre><code>char s1[]=&quot;I am a student&quot;;
char s2[20]=&quot;teacher&quot;;
char s3[]=&quot;student&quot;;
int result;
char s4[20],*p;
</code></pre>
<ol>
<li>
<p>串长度 int strlen(char *str)</p>
<p>cout&laquo;strlen(s1)&laquo;endl; 输出14
cout&laquo;strlen(s2)&laquo;endl; 输出7</p>
</li>
<li>
<p>串拷贝 char *strcpy(char *str1,char *str2)</p>
<p>strcpy(s4,s2);   //s4为&quot;teacher&quot;</p>
</li>
<li>
<p>串连接 char *strcat(char <em>str1,char</em>str2)</p>
<p>strcat(s2,s3); //s2为&quot;teacherstudent&quot;</p>
</li>
<li>
<p>串比较 int strcmp(char *str1,char *str) //比较的是对应字符的ASCII码值，如果str1&gt;str2,返回1</p>
<p>result=strcmp(s2,s3);   //result&gt;0
result=strcmp(s2,s2);   //result=0
result=strcmp(s3,s2);   //result&lt;0</p>
</li>
<li>
<p>串定位 char *strchr(char *str,char ch)</p>
<p>p=strchr(s1,&rsquo;s');    //找到返回字符在字串中的位置，否则返回-1
strcpy(p,s2);      //s1为&quot;I am a teacher&quot;</p>
</li>
<li>
<p>在一个串中查找是否存在和另一个串相等的子串</p>
</li>
<li>
<p>截取子串形成一个新串</p>
</li>
</ol>
<h3 id="2-字符串的输入">(2) 字符串的输入</h3>
<ol>
<li>
<p>方法一：使用输入操符来填充一个C字符串变量
例如：
char a[80];
cin&raquo;a;
注：以这种方式来读取C字符串时，会忽略最初的空白字符(空格、制表符和换行符)，而且输入会在下一个空格或者换行符处停止。</p>
</li>
<li>
<p>方法二：使用预定义函数getline获取整行输入(包括空格)
getline函数有两个参数：第一个参数用于接收输入的C字符串变量；第二个参数用于规定getline最多能接收的字符个数。
例如:
char a[80];
cin.getline(a,80);
当遇到行结束的时候，输入才会停止。</p>
</li>
</ol>
<h3 id="3-c-string类的输入">(3) C++ string类的输入</h3>
<ol>
<li>方法一：和C字符串输入的方法一相同。</li>
<li>方法二：使用getline函数。</li>
</ol>
<p>例如：</p>
<pre><code>string a;
getline(cin,a);
</code></pre>
<h3 id="4-string对象和c字符串之间的转换">(4) string对象和C字符串之间的转换</h3>
<p>可以将C字符串存储在string类型的变量中，例如：</p>
<pre><code>char a[] = &quot;nihao&quot;;
string b;
b=a;
</code></pre>
<p>但string对象不能自动的转换为C字符串，需要进行显式的类型转换，需要用到string类的成员函数c_str().
例如：</p>
<pre><code>strcpy(a,b.c_str());
</code></pre>
<h3 id="5-字符串到数字的转换">(5) 字符串到数字的转换</h3>
<p>atoi函数获取一个C字符串参数，返回对应的int值。如果参数不与一个int值对应，atoi就会返回0。atoi函数在文件为cstdlib的库中。如果数字太大，不能转换成int类型的值，可以使用atol将字符串转换为long类型的值。
例如:</p>
<pre><code>atoi(&quot;1234&quot;);   //返回整数1234
atoi(&quot;#123&quot;);   //返回0
</code></pre>
<h2 id="导航">导航</h2>
<ul>
<li><a href="00.md">目录</a></li>
<li>上一章：<a href="02.md">Chapter 2 - pointers, refrence</a></li>
<li>下一章：<a href="04.md">Chapter 4 - uint8_t, uint16_t, uint32_t, uint64_t</a></li>
</ul>

        
        ]]>
      </description>
=======
      <description>转载自https://github.com/andycai/cprimer 3.1 char*, char[], string 在C中，并没有字符串这个数据类型，而是使用字符数组来保存字</description>
>>>>>>> 35a30928abf5c3213b754024efc550556652db2d
    </item>
    
    <item>
      <title>【转载】C Primer 之 指针和引用</title>
      <link>/collection/cprimer02/</link>
      <pubDate>Thu, 30 Dec 2021 07:12:43 +0800</pubDate>
      
      <guid>/collection/cprimer02/</guid>
<<<<<<< HEAD
      <description>
        <![CDATA[
        <p>转载自<a href="https://github.com/andycai/cprimer">https://github.com/andycai/cprimer</a></p>
<h2 id="21-refrence-引用">2.1 refrence 引用</h2>
<p>引用是C++中的概念，初学者容易把引用和指针混淆一起。以下程序中，n 是 m 的一个引用（reference），m 是被引用物（referent）。</p>
<pre><code>int m; 
int &amp;n = m;
</code></pre>
<p>n 相当于 m 的别名（绰号），对 n 的任何操作就是对m的操作。所以 n 既不是 m 的拷贝，也不是指向 m 的指针，其实 n 就是 m 它自己。</p>
<p><strong>引用的规则：</strong></p>
<ul>
<li>引用被创建的同时必须被初始化（指针则可以在任何时候被初始化）。</li>
<li>不能有NULL引用，引用必须与合法的存储单元关联（指针则可以是NULL）。</li>
<li>一旦引用被初始化，就不能改变引用的关系（指针则可以随时改变所指的对象）。</li>
</ul>
<p>以下示例程序中，k 被初始化为 i 的引用。语句 k = j 并不能将 k 修改成为 j 的引用，只是把 k 的值改变成为6。由于 k 是 i 的引用，所以 i 的值也变成了6。</p>
<pre><code>int i = 5; 
int j = 6; 
int &amp;k = i; 
k = j; // k和i的值都变成了6; 
</code></pre>
<p><strong>引用的主要功能是传递函数的参数和返回值</strong>。</p>
<p>C++语言中，函数的参数和返回值的传递方式有三种：<strong>值传递、指针传递和引用传递</strong>。</p>
<h3 id="1-以下是值传递的示例程序">(1) 以下是&quot;值传递&quot;的示例程序</h3>
<p>由于Func1函数体内的x是外部变量n的一份拷贝，改变x的值不会影响n, 所以n的值仍然是0。</p>
<pre><code>void Func1(int x) 
{ 
	x = x + 10; 
} 
... 
int n = 0; 
Func1(n); 
cout &lt;&lt; &quot;n = &quot; &lt;&lt; n &lt;&lt; endl; // n = 0 
</code></pre>
<h3 id="2-以下是指针传递的示例程序">(2) 以下是&quot;指针传递&quot;的示例程序</h3>
<p>由于Func2函数体内的x是指向外部变量n的指针，改变该指针的内容将导致n的值改变，所以n的值成为10。</p>
<pre><code>void Func2(int *x) 
{ 
	(* x) = (* x) + 10; 
} 
... 
int n = 0; 
Func2(&amp;n); 
cout &lt;&lt; &quot;n = &quot; &lt;&lt; n &lt;&lt; endl; // n = 10 
</code></pre>
<h3 id="3-以下是引用传递的示例程序">(3) 以下是&quot;引用传递&quot;的示例程序</h3>
<p>由于Func3函数体内的x是外部变量n的引用，x和n是同一个东西，改变x等于改变n，所以n的值成为10。</p>
<pre><code>void Func3(int &amp;x) 
{ 
	x = x + 10; 
} 
... 
int n = 0; 
Func3(n); 
cout &lt;&lt; &quot;n = &quot; &lt;&lt; n &lt;&lt; endl; // n = 10 
</code></pre>
<p>对比上述三个示例程序，<strong>会发现&quot;引用传递&quot;的性质象&quot;指针传递&quot;，而书写方式象&quot;值传递&quot;</strong>。</p>
<p>实际上&quot;引用&quot;可以做的任何事情&quot;指针&quot;也都能够做，为什么还要&quot;引用&quot;这东西？ 
答案是&quot;用适当的工具做恰如其分的工作&quot;。</p>
<p>指针能够毫无约束地操作内存中的任何东西，尽管指针功能强大，但是非常危险。</p>
<p>如果的确只需要借用一下某个对象的&quot;别名&quot;，那么就用&quot;引用&quot;，而不要用&quot;指针&quot;，以免发生意外。</p>
<h2 id="导航">导航</h2>
<ul>
<li><a href="00.md">目录</a></li>
<li>上一章：<a href="01.md">Chapter 1 - const, inline，static, this</a></li>
<li>下一章：<a href="03.md">Chapter 3 - char*, char[], string</a></li>
</ul>

        
        ]]>
      </description>
=======
      <description>转载自https://github.com/andycai/cprimer 2.1 refrence 引用 引用是C++中的概念，初学者容易把引用和指针混淆一起。以下</description>
>>>>>>> 35a30928abf5c3213b754024efc550556652db2d
    </item>
    
    <item>
      <title>【转载】C Primer 之 const, inline, static, this</title>
      <link>/collection/cprimer01/</link>
      <pubDate>Thu, 30 Dec 2021 07:12:38 +0800</pubDate>
      
      <guid>/collection/cprimer01/</guid>
      <description>转载自https://github.com/andycai/cprimer 1.1 const (1) const 基础 如果const关键字不涉及到指针，我们很好理解，下面是</description>
    </item>
    
    <item>
      <title>C&#43;&#43; 基础总结</title>
      <link>/post/2021/12/15/cppbase/</link>
      <pubDate>Wed, 15 Dec 2021 12:35:27 +0800</pubDate>
      
      <guid>/post/2021/12/15/cppbase/</guid>
      <description>一、语法基础 指针和引用的概念 指针与内存关系 程序编译过程 static、const、#define的用法和区别 C和C++区别 内存模型 内存中的栈和</description>
    </item>
    
  </channel>
</rss>
