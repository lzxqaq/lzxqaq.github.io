[{"content":" 人类同胞们，\n我来此召集你们，是要你们了解目前的形势。\n每个人都应该意识到我们此时所遭受的危机，\n我们彼此互相争斗，\n为了共和历史的微小冲突而被分散。\n现在，更大的危险正向我们靠近。\n这股威胁将会毁灭我们的所有成就……\n—— 阿克图拉斯一世\n 现在，战争、疾病、贫穷、压迫等话题再次进入世界舆论中心。在纷争、嘈杂的社会环境中，我们如何认识世界，并在其中找到自己？\n现代文明是集统治、科技、文化、宗教的复杂混合体，我们很难对每一方面都有足够的认知。但现代文明是人类的文明，我们可以从自身的角度出发，认识世界的全貌。审视自身，残忍、虚伪、傲慢、背叛和厌世等等人之恶无一不在，但我知道，我们绝不仅有这些，善良、追求美好也一直存在。同样，现在世界不乏纷争、歧视等阴暗，但同时也在追求和平、发展。人不是生来如此的，我们需要不断学习，世界也不是向来如此的。让人类从蛮荒中走向文明，我们现在赖以生存的基础，不是由一个神、一个党派、一个政府建立的，而是由一个又一个人的努力。\n 历史的潮流在不断变化，要是想到达旅途的终点，我们必须不断适应，勇往直前。\n  人类的天性就是不断地推动自己越过新的边界。我们考验自身的极限，我们直面自己的恐惧，我们奋起迎接挑战，最终成为远超我们自身的存在。\n ","permalink":"/blog/2022/03/20/%E8%AE%A4%E7%9F%A5%E4%B8%96%E7%95%8C%E5%BD%A2%E5%8A%BF%E5%8F%98%E5%8C%96/","summary":"人类同胞们， 我来此召集你们，是要你们了解目前的形势。 每个人都应该意识到我们此时所遭受的危机， 我们彼此互相争斗， 为了共和历史的微小冲突而被分散","title":"认知世界形势变化"},{"content":"最近时常回忆起以前的事情，并且想用文字记下一些东西的念头越来越强烈。\n回首往昔，能记起来的事却少之又少，其中多数藏在脑海深处久矣。二十多年的人生，好似极其漫长，又一览无余。现在，该和自己和解了，把一切收拾好，行动起来！\n","permalink":"/blog/2022/03/16/%E5%9C%A8%E8%B7%AF%E7%9A%84%E5%B0%BD%E5%A4%B4%E4%BD%A0%E4%BC%9A%E6%89%BE%E5%88%B0%E4%BD%A0%E8%87%AA%E5%B7%B1/","summary":"最近时常回忆起以前的事情，并且想用文字记下一些东西的念头越来越强烈。 回首往昔，能记起来的事却少之又少，其中多数藏在脑海深处久矣。二十多年的人","title":"在路的尽头，你会找到你自己"},{"content":"作者：吴秦\n出处：(http://www.cnblogs.com/skynet/)\n1、网络中进程之间如何通信？ 本地的进程间通信（IPC）有很多种方式，但可以总结为下面4类：\n 消息传递（管道、FIFO、消息队列） 同步（互斥量、条件变量、读写锁、文件和写记录锁、信号量） 共享内存（匿名的和具名的） 远程过程调用（Solaris门和Sun RPC）  但这些都不是本文的主题！我们要讨论的是网络中进程之间如何通信？首要解决的问题是如何唯一标识一个进程，否则通信无从谈起！在本地可以通过进程PID来唯一标识一个进程，但是在网络中这是行不通的。其实TCP/IP协议族已经帮我们解决了这个问题，网络层的“ip地址”可以唯一标识网络中的主机，而传输层的“协议+端口”可以唯一标识主机中的应用程序（进程）。这样利用三元组（ip地址，协议，端口）就可以标识网络的进程了，网络中的进程通信就可以利用这个标志与其它进程进行交互。\n使用TCP/IP协议的应用程序通常采用应用编程接口：UNIX BSD的套接字（socket）和UNIX System V的TLI（已经被淘汰），来实现网络进程之间的通信。就目前而言，几乎所有的应用程序都是采用socket，而现在又是网络时代，网络中进程通信是无处不在，这就是我为什么说“一切皆socket”。\n2、什么是Socket？ 上面我们已经知道网络中的进程是通过socket来通信的，那什么是socket呢？socket起源于Unix，而Unix/Linux基本哲学之一就是“一切皆文件”，都可以用“打开open –\u0026gt; 读写write/read –\u0026gt; 关闭close”模式来操作。我的理解就是Socket就是该模式的一个实现，socket即是一种特殊的文件，一些socket函数就是对其进行的操作（读/写IO、打开、关闭），这些函数我们在后面进行介绍。\n socket一词的起源 在组网领域的首次使用是在1970年2月12日发布的文献IETF RFC33中发现的，撰写者为Stephen Carr、Steve Crocker和Vint Cerf。根据美国计算机历史博物馆的记载，Croker写道：“命名空间的元素都可称为套接字接口。一个套接字接口构成一个连接的一端，而一个连接可完全由一对套接字接口规定。”计算机历史博物馆补充道：“这比BSD的套接字接口定义早了大约12年。”\n 3、socket的基本操作 既然socket是“open—write/read—close”模式的一种实现，那么socket就提供了这些操作对应的函数接口。下面以TCP为例，介绍几个基本的socket接口函数。\n3.1、socket()函数 int socket(int domain, int type, int protocol);\nsocket函数对应于普通文件的打开操作。普通文件的打开操作返回一个文件描述字，而socket()用于创建一个socket描述符（socket descriptor），它唯一标识一个socket。这个socket描述字跟文件描述字一样，后续的操作都有用到它，把它作为参数，通过它来进行一些读写操作。\n正如可以给fopen的传入不同参数值，以打开不同的文件。创建socket的时候，也可以指定不同的参数创建不同的socket描述符，socket函数的三个参数分别为：\n  domain：即协议域，又称为协议族（family）。常用的协议族有，AF_INET、AF_INET6、AF_LOCAL（或称AF_UNIX，Unix域socket）、AF_ROUTE等等。协议族决定了socket的地址类型，在通信中必须采用对应的地址，如AF_INET决定了要用ipv4地址（32位的）与端口号（16位的）的组合、AF_UNIX决定了要用一个绝对路径名作为地址。\n  type：指定socket类型。常用的socket类型有，SOCK_STREAM、SOCK_DGRAM、SOCK_RAW、SOCK_PACKET、SOCK_SEQPACKET等等（socket的类型有哪些？）。\n  protocol：故名思意，就是指定协议。常用的协议有，IPPROTO_TCP、IPPTOTO_UDP、IPPROTO_SCTP、IPPROTO_TIPC等，它们分别对应TCP传输协议、UDP传输协议、STCP传输协议、TIPC传输协议（这个协议我将会单独开篇讨论！）。\n  注意：并不是上面的type和protocol可以随意组合的，如SOCK_STREAM不可以跟IPPROTO_UDP组合。当protocol为0时，会自动选择type类型对应的默认协议。\n当我们调用socket创建一个socket时，返回的socket描述字它存在于协议族（address family，AF_XXX）空间中，但没有一个具体的地址。如果想要给它赋值一个地址，就必须调用bind()函数，否则就当调用connect()、listen()时系统会自动随机分配一个端口。\n3.2、bind()函数 正如上面所说bind()函数把一个地址族中的特定地址赋给socket。例如对应AF_INET、AF_INET6就是把一个ipv4或ipv6地址和端口号组合赋给socket。\nint bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen); 函数的三个参数分别为：\n sockfd：即socket描述字，它是通过socket()函数创建了，唯一标识一个socket。bind()函数就是将给这个描述字绑定一个名字。 addr：一个const struct sockaddr *指针，指向要绑定给sockfd的协议地址。这个地址结构根据地址创建socket时的地址协议族的不同而不同，如ipv4对应的是：  struct sockaddr_in { sa_family_t sin_family; /* address family: AF_INET */ in_port_t sin_port; /* port in network byte order */ struct in_addr sin_addr; /* internet address */ }; /* Internet address. */ struct in_addr { uint32_t s_addr; /* address in network byte order */ }; ipv6对应的是：\nstruct sockaddr_in6 { sa_family_t sin6_family; /* AF_INET6 */ in_port_t sin6_port; /* port number */ uint32_t sin6_flowinfo; /* IPv6 flow information */ struct in6_addr sin6_addr; /* IPv6 address */ uint32_t sin6_scope_id; /* Scope ID (new in 2.4) */ }; struct in6_addr { unsigned char s6_addr[16]; /* IPv6 address */ }; Unix域对应的是：\n#define UNIX_PATH_MAX 108 struct sockaddr_un { sa_family_t sun_family; /* AF_UNIX */ char sun_path[UNIX_PATH_MAX]; /* pathname */ };  addrlen：对应的是地址的长度。  通常服务器在启动的时候都会绑定一个众所周知的地址（如ip地址+端口号），用于提供服务，客户就可以通过它来接连服务器；而客户端就不用指定，有系统自动分配一个端口号和自身的ip地址组合。这就是为什么通常服务器端在listen之前会调用bind()，而客户端就不会调用，而是在connect()时由系统随机生成一个。\n网络字节序与主机字节序 主机字节序就是我们平常说的大端和小端模式：不同的CPU有不同的字节序类型，这些字节序是指整数在内存中保存的顺序，这个叫做主机序。引用标准的Big-Endian和Little-Endian的定义如下：\n  a) Little-Endian就是低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。\n  b) Big-Endian就是高位字节排放在内存的低地址端，低位字节排放在内存的高地址端。\n  网络字节序：4个字节的32 bit值以下面的次序传输：首先是0～7bit，其次8～15bit，然后16～23bit，最后是24~31bit。这种传输次序称作大端字节序。由于TCP/IP首部中所有的二进制整数在网络中传输时都要求以这种次序，因此它又称作网络字节序。字节序，顾名思义字节的顺序，就是大于一个字节类型的数据在内存中的存放顺序，一个字节的数据没有顺序的问题了。\n所以：在将一个地址绑定到socket的时候，请先将主机字节序转换成为网络字节序，而不要假定主机字节序跟网络字节序一样使用的是Big-Endian。由于这个问题曾引发过血案！公司项目代码中由于存在这个问题，导致了很多莫名其妙的问题，所以请谨记对主机字节序不要做任何假定，务必将其转化为网络字节序再赋给socket。\n3.3、listen()、connect()函数 如果作为一个服务器，在调用socket()、bind()之后就会调用listen()来监听这个socket，如果客户端这时调用connect()发出连接请求，服务器端就会接收到这个请求。\nint listen(int sockfd, int backlog); int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen); listen函数的第一个参数即为要监听的socket描述字，第二个参数为相应socket可以排队的最大连接个数。socket()函数创建的socket默认是一个主动类型的，listen函数将socket变为被动类型的，等待客户的连接请求。\nconnect函数的第一个参数即为客户端的socket描述字，第二参数为服务器的socket地址，第三个参数为socket地址的长度。客户端通过调用connect函数来建立与TCP服务器的连接。\n3.4、accept()函数 TCP服务器端依次调用socket()、bind()、listen()之后，就会监听指定的socket地址了。TCP客户端依次调用socket()、connect()之后就想TCP服务器发送了一个连接请求。TCP服务器监听到这个请求之后，就会调用accept()函数取接收请求，这样连接就建立好了。之后就可以开始网络I/O操作了，即类同于普通文件的读写I/O操作。\nint accept(int sockfd, struct sockaddr *addr, socklen_t * accept函数的第一个参数为服务器的socket描述字，第二个参数为指向struct sockaddr *的指针，用于返回客户端的协议地址，第三个参数为协议地址的长度。如果accpet成功，那么其返回值是由内核自动生成的一个全新的描述字，代表与返回客户的TCP连接。\n注意：accept的第一个参数为服务器的socket描述字，是服务器开始调用socket()函数生成的，称为监听socket描述字；而accept函数返回的是已连接的socket描述字。一个服务器通常通常仅仅只创建一个监听socket描述字，它在该服务器的生命周期内一直存在。内核为每个由服务器进程接受的客户连接创建了一个已连接socket描述字，当服务器完成了对某个客户的服务，相应的已连接socket描述字就被关闭。\n3.5、read()、write()等函数 万事具备只欠东风，至此服务器与客户已经建立好连接了。可以调用网络I/O进行读写操作了，即实现了网咯中不同进程之间的通信！网络I/O操作有下面几组：\n read()/write() recv()/send() readv()/writev() recvmsg()/sendmsg() recvfrom()/sendto()  我推荐使用recvmsg()/sendmsg()函数，这两个函数是最通用的I/O函数，实际上可以把上面的其它函数都替换成这两个函数。它们的声明如下：\n#include \u0026lt;unistd.h\u0026gt; ssize_t read(int fd, void *buf, size_t count); ssize_t write(int fd, const void *buf, size_t count); #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;sys/socket.h\u0026gt; ssize_t send(int sockfd, const void *buf, size_t len, int flags); ssize_t recv(int sockfd, void *buf, size_t len, int flags); ssize_t sendto(int sockfd, const void *buf, size_t len, int flags, const struct sockaddr *dest_addr, socklen_t addrlen); ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen); ssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags); ssize_t recvmsg(int sockfd, struct msghdr *msg, int flags); read函数是负责从fd中读取内容.当读成功时，read返回实际所读的字节数，如果返回的值是0表示已经读到文件的结束了，小于0表示出现了错误。如果错误为EINTR说明读是由中断引起的，如果是ECONNREST表示网络连接出了问题。\nwrite函数将buf中的nbytes字节内容写入文件描述符fd.成功时返回写的字节数。失败时返回-1，并设置errno变量。 在网络程序中，当我们向套接字文件描述符写时有俩种可能。1)write的返回值大于0，表示写了部分或者是全部的数据。2)返回的值小于0，此时出现了错误。我们要根据错误类型来处理。如果错误为EINTR表示在写的时候出现了中断错误。如果为EPIPE表示网络连接出现了问题(对方已经关闭了连接)。\n其它的我就不一一介绍这几对I/O函数了，具体参见man文档或者baidu、Google，下面的例子中将使用到send/recv。\n3.6、close()函数 在服务器与客户端建立连接之后，会进行一些读写操作，完成了读写操作就要关闭相应的socket描述字，好比操作完打开的文件要调用fclose关闭打开的文件。\n#include \u0026lt;unistd.h\u0026gt; int close(int fd); close一个TCP socket的缺省行为时把该socket标记为以关闭，然后立即返回到调用进程。该描述字不能再由调用进程使用，也就是说不能再作为read或write的第一个参数。\n注意：close操作只是使相应socket描述字的引用计数-1，只有当引用计数为0的时候，才会触发TCP客户端向服务器发送终止连接请求。\n4、socket中TCP的三次握手建立连接详解 我们知道tcp建立连接要进行“三次握手”，即交换三个分组。大致流程如下：\n 客户端向服务器发送一个SYN J 服务器向客户端响应一个SYN K，并对SYN J进行确认ACK J+1 客户端再想服务器发一个确认ACK K+1  只有就完了三次握手，但是这个三次握手发生在socket的那几个函数中呢？请看下图：\n从图中可以看出，当客户端调用connect时，触发了连接请求，向服务器发送了SYN J包，这时connect进入阻塞状态；服务器监听到连接请求，即收到SYN J包，调用accept函数接收请求向客户端发送SYN K ，ACK J+1，这时accept进入阻塞状态；客户端收到服务器的SYN K ，ACK J+1之后，这时connect返回，并对SYN K进行确认；服务器收到ACK K+1时，accept返回，至此三次握手完毕，连接建立。\n总结：客户端的connect在三次握手的第二个次返回，而服务器端的accept在三次握手的第三次返回。\n5、socket中TCP的四次握手释放连接详解 上面介绍了socket中TCP的三次握手建立过程，及其涉及的socket函数。现在我们介绍socket中的四次握手释放连接的过程，请看下图：\n图示过程如下：\n 某个应用进程首先调用close主动关闭连接，这时TCP发送一个FIN M； 另一端接收到FIN M之后，执行被动关闭，对这个FIN进行确认。它的接收也作为文件结束符传递给应用进程，因为FIN的接收意味着应用进程在相应的连接上再也接收不到额外数据； 一段时间之后，接收到文件结束符的应用进程调用close关闭它的socket。这导致它的TCP也发送一个FIN N； 接收到这个FIN的源发送端TCP对它进行确认。  这样每个方向上都有一个FIN和ACK。\n6、一个例子（实践一下） 说了这么多了，动手实践一下。下面编写一个简单的服务器、客户端（使用TCP）——服务器端一直监听本机的6666号端口，如果收到连接请求，将接收请求并接收客户端发来的消息；客户端与服务器端建立连接并发送一条消息。\n服务器端代码：\n//服务器端 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;stdlib.h\u0026gt; #include\u0026lt;string.h\u0026gt; #include\u0026lt;errno.h\u0026gt; #include\u0026lt;sys/types.h\u0026gt; #include\u0026lt;sys/socket.h\u0026gt; #include\u0026lt;netinet/in.h\u0026gt; #define MAXLINE 4096 int main(int argc, char** argv) { int listenfd, connfd; struct sockaddr_in servaddr; char buff[4096]; int n; if( (listenfd = socket(AF_INET, SOCK_STREAM, 0)) == -1 ){ printf(\u0026#34;create socket error: %s(errno: %d)\\n\u0026#34;,strerror(errno),errno); exit(0); } memset(\u0026amp;servaddr, 0, sizeof(servaddr)); servaddr.sin_family = AF_INET; servaddr.sin_addr.s_addr = htonl(INADDR_ANY); servaddr.sin_port = htons(6666); if( bind(listenfd, (struct sockaddr*)\u0026amp;servaddr, sizeof(servaddr)) == -1){ printf(\u0026#34;bind socket error: %s(errno: %d)\\n\u0026#34;,strerror(errno),errno); exit(0); } if( listen(listenfd, 10) == -1){ printf(\u0026#34;listen socket error: %s(errno: %d)\\n\u0026#34;,strerror(errno),errno); exit(0); } printf(\u0026#34;======waiting for client\u0026#39;s request======\\n\u0026#34;); while(1){ if( (connfd = accept(listenfd, (struct sockaddr*)NULL, NULL)) == -1){ printf(\u0026#34;accept socket error: %s(errno: %d)\u0026#34;,strerror(errno),errno); continue; } n = recv(connfd, buff, MAXLINE, 0); buff[n] = \u0026#39;\\0\u0026#39;; printf(\u0026#34;recv msg from client: %s\\n\u0026#34;, buff); close(connfd); } close(listenfd); } 客户端代码：\n//客户端 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;stdlib.h\u0026gt; #include\u0026lt;string.h\u0026gt; #include\u0026lt;errno.h\u0026gt; #include\u0026lt;sys/types.h\u0026gt; #include\u0026lt;sys/socket.h\u0026gt; #include\u0026lt;netinet/in.h\u0026gt; #define MAXLINE 4096 int main(int argc, char** argv) { int sockfd, n; char recvline[4096], sendline[4096]; struct sockaddr_in servaddr; if( argc != 2){ printf(\u0026#34;usage: ./client \u0026lt;ipaddress\u0026gt;\\n\u0026#34;); exit(0); } if( (sockfd = socket(AF_INET, SOCK_STREAM, 0)) \u0026lt; 0){ printf(\u0026#34;create socket error: %s(errno: %d)\\n\u0026#34;, strerror(errno),errno); exit(0); } memset(\u0026amp;servaddr, 0, sizeof(servaddr)); servaddr.sin_family = AF_INET; servaddr.sin_port = htons(6666); if( inet_pton(AF_INET, argv[1], \u0026amp;servaddr.sin_addr) \u0026lt;= 0){ printf(\u0026#34;inet_pton error for %s\\n\u0026#34;,argv[1]); exit(0); } if( connect(sockfd, (struct sockaddr*)\u0026amp;servaddr, sizeof(servaddr)) \u0026lt; 0){ printf(\u0026#34;connect error: %s(errno: %d)\\n\u0026#34;,strerror(errno),errno); exit(0); } printf(\u0026#34;send msg to server: \\n\u0026#34;); fgets(sendline, 4096, stdin); if( send(sockfd, sendline, strlen(sendline), 0) \u0026lt; 0) { printf(\u0026#34;send msg error: %s(errno: %d)\\n\u0026#34;, strerror(errno), errno); exit(0); } close(sockfd); exit(0); } 当然上面的代码很简单，也有很多缺点，这就只是简单的演示socket的基本函数使用。其实不管有多复杂的网络程序，都使用的这些基本函数。上面的服务器使用的是迭代模式的，即只有处理完一个客户端请求才会去处理下一个客户端的请求，这样的服务器处理能力是很弱的，现实中的服务器都需要有并发处理能力！为了需要并发处理，服务器需要fork()一个新的进程或者线程去处理请求等。\n","permalink":"/collection/linuxsocket/","summary":"作者：吴秦 出处：(http://www.cnblogs.com/skynet/) 1、网络中进程之间如何通信？ 本地的进程间通信（IPC）有很多","title":"【转载】Linux Socket 编程（不限 Linux）"},{"content":"转载自https://github.com/huihut/interview\nSocket  Linux Socket 编程（不限 Linux）\n Socket 中的 read()、write() 函数 ssize_t read(int fd, void *buf, size_t count); ssize_t write(int fd, const void *buf, size_t count); read()  read 函数是负责从 fd 中读取内容。 当读成功时，read 返回实际所读的字节数。 如果返回的值是 0 表示已经读到文件的结束了，小于 0 表示出现了错误。 如果错误为 EINTR 说明读是由中断引起的；如果是 ECONNREST 表示网络连接出了问题。  write()  write 函数将 buf 中的 nbytes 字节内容写入文件描述符 fd。 成功时返回写的字节数。失败时返回 -1，并设置 errno 变量。 在网络程序中，当我们向套接字文件描述符写时有俩种可能。 （1）write 的返回值大于 0，表示写了部分或者是全部的数据。 （2）返回的值小于 0，此时出现了错误。 如果错误为 EINTR 表示在写的时候出现了中断错误；如果为 EPIPE 表示网络连接出现了问题（对方已经关闭了连接）。  Socket 中 TCP 的三次握手建立连接 我们知道 TCP 建立连接要进行 “三次握手”，即交换三个分组。大致流程如下：\n 客户端向服务器发送一个 SYN J 服务器向客户端响应一个 SYN K，并对 SYN J 进行确认 ACK J+1 客户端再想服务器发一个确认 ACK K+1  只有就完了三次握手，但是这个三次握手发生在 Socket 的那几个函数中呢？请看下图：\n从图中可以看出：\n 当客户端调用 connect 时，触发了连接请求，向服务器发送了 SYN J 包，这时 connect 进入阻塞状态； 服务器监听到连接请求，即收到 SYN J 包，调用 accept 函数接收请求向客户端发送 SYN K ，ACK J+1，这时 accept 进入阻塞状态； 客户端收到服务器的 SYN K ，ACK J+1 之后，这时 connect 返回，并对 SYN K 进行确认； 服务器收到 ACK K+1 时，accept 返回，至此三次握手完毕，连接建立。  Socket 中 TCP 的四次握手释放连接 上面介绍了 socket 中 TCP 的三次握手建立过程，及其涉及的 socket 函数。现在我们介绍 socket 中的四次握手释放连接的过程，请看下图：\n图示过程如下：\n 某个应用进程首先调用 close 主动关闭连接，这时 TCP 发送一个 FIN M； 另一端接收到 FIN M 之后，执行被动关闭，对这个 FIN 进行确认。它的接收也作为文件结束符传递给应用进程，因为 FIN 的接收意味着应用进程在相应的连接上再也接收不到额外数据； 一段时间之后，接收到文件结束符的应用进程调用 close 关闭它的 socket。这导致它的 TCP 也发送一个 FIN N； 接收到这个 FIN 的源发送端 TCP 对它进行确认。  这样每个方向上都有一个 FIN 和 ACK。\n","permalink":"/collection/networkpg/","summary":"转载自https://github.com/huihut/interview Socket Linux Socket 编程（不限 Linux） Socket 中的 read()、write() 函","title":"【转载】C++ 开发必备之网络编程"},{"content":"C/C++ 代码编译成可执行程序的过程   预处理\n 进行宏定义展开、头文件展开、条件编译，不检查语法。 gcc -E demo1.c -o demo1.i    编译\n 检查语法，将预处理过的文件编译生成汇编文件 gcc -S demo2.c -o demo2.s    汇编\n 将汇编文件生成目标文件（二进制代码文件，即.o 文件） gcc -c demo3.c -o demo3.o    链接\n 找到依赖的库文件，将目标文件链接为可执行程序。 gcc demo4.c -o demo4 -L./ -llib1 通过gcc编译器让 demo4 链接自己制作的 lib1 动态库，并把 demo4 编译成可执行程序。    Java 代码编译和执行的过程  源文件由编译器编译成字节码 字节码由 Java 虚拟机解释运行。因为 Java 程序既要编译同时也要经过 JVM 的解释运行，所以 Java 也被称为半解释语言。  静态和动态  静态：在编译（编译 + 链接）阶段 动态：在执行阶段  #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main() { int m, n; int *p, *q; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;m, \u0026amp;n); p = (int*)malloc(sizeof(int) * m); q = (int*)malloc(sizeof(int) * n); return 0; }  m、n、p、q 静态分配内存。局部变量，要占多大空间、往哪里放，在编译时就已经确定。 malloc 函数动态分配内存，在堆区分配内存，把地址赋值给 p、q。\n 进一步：静态和动态 + static 关键字\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; void hehe() { int k=0; static int sum = 0; k++; sum++; printf(\u0026#34;%d %d\\n\u0026#34;, k, sum); } int main() { int *p; p = (int*)malloc(sizeof(int)); hehe(); hehe(); return 0; }  k、sum 静态分配内存。局部变量，它们要占多大空间、往哪里放，在编译时就已经确定。 static 和静态、动态分配内存没关系，static 指 sum 变量的创建和销毁不会随着 hehe() 函数的调用而一次次创建销毁。\n C 语言的内存分区  栈（Stack） 堆（Heap） 全局/静态 常量 文本（代码）Text(Code)  #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int total = 0;//全局变量-\u0026gt;全局/静态区 void hehe() { static int he = 0;//静态局部变量，只创建一次，静态区 he++; total++; } int main() { int k = 3;//局部变量-\u0026gt;栈， 3-\u0026gt;文本区 char *str = \u0026#34;Hello\u0026#34;;//str-\u0026gt;栈 \u0026#34;Hello\u0026#34;-\u0026gt;常量区 int *p = (int*)malloc(sizeof(int));//p-\u0026gt;栈 malloc分配控件-\u0026gt;堆 hehe();//函数每次结束，栈空间都会释放，而静态区不会 free(p); return 0; } //文本区-\u0026gt;放这个文件编译后的二进制码 动态库、静态库   库是写好的现有的，成熟的，可以复用的代码。\n  linux：\n 静态库：.a 动态库：.so    window：\n 静态库：.lib 动态库：.dll     静态库：是因为在链接阶段，会将汇编生成的目标文件.o与引用到的库一起链接打包到可执行文件中。因此对应的链接方式称为静态链接。 动态库：在程序编译时并不会被连接到目标代码中，而是在程序运行是才被载入。不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例。  静态库的特点：\n 1、使用静态库的时候，会将静态库的信息直接编译到可执行文件中（在编译时期完成的） 2、优点:当静态库被删除，对可执行文件没有影响 3、缺点:浪费内存空间。如果静态库被修改，可执行程序要重新编译  动态库的特点：\n 加载器在加载动态库时，操作系统会先检查动态库是否因为其它程序已经将这个动态库信息加载到了内存中。如果没有加载到内存中，操作系统会将动态库载入内存，并将它的引用计数设置为1;如果已经加载到内存，仅将动态库的引用计数加1。  动态库与模板  由于模板实例化是在编译时执行，如果在动态库中导出模板类(函数)，因为实际的调用代码是在外部exe中，不在动态库本身中，所以在编译生成动态库的时候是不会生成实例的，这样在编译外部exe的时候就会报链接错误。 只有将导出库里面的模板函数或者模板类实例化，才能将实例化后模板函数的地址信息和模板类实例化的地址信息保存在导出库中。  //TemplateLib.h 使用动态库 #ifdef\tTEST_DLL_EXPORTS #define\tTEST_API\t__declspec(dllexport) #else #define TEST_API\t__declspec(dllimport) #endif // 导出模板函数 template\u0026lt;typename T1\u0026gt; TEST_API\tvoid\tfun1(T1); template\u0026lt;typename T1,typename T2\u0026gt; TEST_API\tvoid\tfun2(T1 , T2); // 模板类 template\u0026lt;typename T,int size\u0026gt; class TEST_API\tCTest { public: CTest()\t{}; ~CTest()\t{}; T*\tGetDataBuff()\t{\treturn m_data;} private: T\tm_data[size]; }; // TemplateLib.cpp : 定义 DLL 应用程序的导出函数。 #include \u0026#34;stdafx.h\u0026#34; #include \u0026#34;TemplateLib.h\u0026#34; // 1.利用重载来实例化不同类型的模板，代码量大不说，基本上是重复的代码 // 2.库的设计者不知道用户会传入什么类型，也就是说设计者不可能实例化每一种类型的模板。 TEST_API\tvoid fun1(int var1)\t{} TEST_API\tvoid fun1(char var1)\t{} template\u0026lt;typename T1,typename T2\u0026gt; TEST_API\tvoid fun2( T1 var1, T2 var2)\t{} // 这个名字空间不作为导出使用，唯一作用是用来例化函数模板和类模板. namespace implement_template_private { void\timplement_template() { int\tidata = 10; char\tchr\t= \u0026#39;x\u0026#39;; float\tfdata = 20.f; UINT\tundata= 9; char*\tstr\t=\t\u0026#34;hello\u0026#34;; // 这种方式的实例化，代码量比重载方式少许多，但需运行一次该模板函数 // 也许在某些时候凭空运行这个函数是不合理的。 fun2(idata,chr);\t// int,char fun2(undata,str);\t// UINT,char* fun2\u0026lt;float,char*\u0026gt;(fdata,str);\t// float,char* 显示参数 // 导出类的实例化。 // 1.除了要实例化提供给用户使用的公有成员函数外，这里面还隐含的实例化了构造函数和析构函数. // 2.注意这里每一个模板的实例化都是唯一的。 // 3.假如客户如果在项目中使用了CTest\u0026lt;char,30\u0026gt; impl_obj; 将会连接错误， 模板的参数列表必须完全匹配。 // 4.假如该模板类非常大，功能非常多，那么实例化工作可以想象是不堪忍受的。 // 5.库的设计者不知道用户会传入什么类型，也就是说设计者不可能实例化每一种类型的模板。 CTest\u0026lt;char,20\u0026gt;\timpl_obj; impl_obj.GetDataBuff(); CTest\u0026lt;int,5\u0026gt;\timpl_obj2; impl_obj.GetDataBuff(); } };  总结：不建议在导出库中使用模板相关的技术，假如你能够确定用户在使用你设计的模板函数时，将传入哪些类型，设计者要将这些类型的模板一一实例化。 在动态库和静态库使用模板:https://blog.csdn.net/xiexievv/article/details/8500234  auto（C++ 11） 其核心在于类型推导，也就是让编译器根据等号右边的表达式来决定auto实际代表的类型。C++的auto只涉及到编译期的行为而不是运行期。\n 优点：  可以极大的缩短代码的长度。   缺点：  可能会降低代码的可读性。 可能会引入额外的性能开销。    如：\n MyBigDataType\u0026amp; func(); ... auto value = func(); 因为 auto 会移除表达式类型的引用属性，那么此时以上最后一行的行为就是拷贝构造一MyBigData实例，相信这不是此函数的实现者希望的。\n 注意：在引用类型、const 等类型上使用 auto 时要小心。  C++ 引用 参数传递：注意值传递和引用传递的区别。\n#include \u0026lt;iostream\u0026gt; using namespace std; void fun(int \u0026amp;k) { k = 2; } int main() { int a = 1; fun(a); cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; return 0; } 新的 for 循环（C++ 11） int arr[5] = {1, 2, 3, 4, 5}; for (int x : arr) { x += 100; cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } cout \u0026lt;\u0026lt; arr[0];  arr 到 x 是值传递，可以用 int \u0026amp;x，或者 auto \u0026amp;  lambda（C++） 定义一个匿名函数，还可以捕获外部一定范围内的变量。\nauto f1 = [](int a, int b) -\u0026gt; int{return a + b; }; auto f2 = [](auto a, auto b) -\u0026gt; auto{return a + b; }; //编译器就根据 return 语句自动推导出返回值类型。 auto f3 = [](auto a, auto b){return a + b; }; int c = 9; //按值捕获 c 变量，同时不捕获其他变量。 auto f4 = [c](auto a, auto b){return a + b + c; }; //捕获外部作用域中所有变量（按值捕获） auto f5 = [=](auto a, auto b){return a + b + c; }; cout \u0026lt;\u0026lt; f1(1, 2) \u0026lt;\u0026lt; endl; 类型转换（C++）  int k; k = 3.14;//在 Java 中会报错，在 C/C++ 编译器中正常（k==3）。  Java 对类型转换更严格。 C/C++ 编译器给了程序员太多自由：编译器认为，程序员可以这样写，程序员应该知道他在干什么，也应该为自己的行为负责。  指针？引用（Java） Java：基本数据类型（int、long等）、引用数据类型（数组、类、接口）。\nStudent zs = new Student(); //Java，引用 Student *pzs = new Student(); //c++，指针  实质是一样的。 要注意 Java 中的值传递和引用传递问题，实质上 Java 还是值传递的，只不过对于引用数据类型时，值的内容是它的引用（指针）。  for 循环（Java） int[] arr = new int[10]; for (int temp : arr) { temp++; } for (Student s : ss) { s.changeSomething(); } lamda（Java） (parameters) -\u0026gt; expression 或 (parameters) -\u0026gt;{ statements; }  Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）  // 1. 不需要参数,返回值为 5 () -\u0026gt; 5 // 2. 接收一个参数(数字类型),返回其2倍的值 x -\u0026gt; 2 * x // 3. 接受2个参数(数字),并返回他们的差值 (x, y) -\u0026gt; x – y // 4. 接收2个int型整数,返回他们的和 (int x, int y) -\u0026gt; x + y // 5. 接受一个 string 对象,并在控制台打印,不返回任何值(看起来像是返回void) (String s) -\u0026gt; System.out.print(s) 理解封装  类：某一类东西 对象：某类东西的实例 “封”：数据 + 操作  成员：成员变量、成员函数 属性，方法（服务）   “装”：访问控制  public/protected/private/\u0026hellip;    构造和析构（C++）  构造函数、析构函数 初始化列表  在构造函数中用初始化列表的方式对成员变量进行初始化，效率会更高，因为只进行构造，少了一次赋值。 成员变量的初始化顺序与初始化列表中列出的变量的顺序无关，它只与成员变量在类中声明的顺序有关。    #include \u0026lt;iostream\u0026gt; using namespace std; class Note { public: int nid; Note(int id) :nid(id) {} }; class Student { private: int sid; string name; Note nt; public: Student(int sid, string name, int id) : sid(sid), name(name), nt(id) {//初始化列表，进行初始化构造 //写在这里的只能是赋值 } } 对象的复制（C++）  注意浅拷贝、深拷贝。 默认生成的赋值函数、拷贝构造函数都是浅拷贝（值拷贝），成员变量中有指针变量时，需要自己重写（深拷贝）。  Java 类-与C++不同  没有析构 不支持默认参数 显示构造  对象的复制（Java） Array a = new Array(); Array b = a; 其实是引用的复制。\nArray b = new Array(a); 对象的复制（返回新对象的引用）\n理解“继承”  目的：代码复用 代码复用：  组合（has-a）：窗口、按钮、文本框 继承（is-a）：人（id、姓名、性别）、学生（id、姓名、性别、学号）、教师（id、姓名、性别、教师号）    C++ 的继承和Java 的继承区别  C++ 可以多继承 Java 单继承  多态-需求是什么 多态：指为不同数据类型的实体提供统一的接口。\n是否有需要使用基类指针（引用）指向（引向）派生类对象？\nclass People { public: void say() { cout \u0026lt;\u0026lt; \u0026#34;I \u0026#39;m a person!\u0026#34; \u0026lt;\u0026lt; endl; } }; class Student : public People { public: void say() { cout \u0026lt;\u0026lt; \u0026#34;I\u0026#39;m a student!\u0026#34; \u0026lt;\u0026lt; endl; } }; int main() { People *zs = new Student(); zs-\u0026gt;say(); return 0; }  这不是真需求，应该用 Student 指针，甚至是 Student 对象。  class People { public: void say() {} }; class Student : public People { public: void say() {} }; class Teacher : public People { public: void say() {} }; void func(People *zs) { zs-\u0026gt;say(); } int main() { Student zs; Teacher ls; func(\u0026amp;zs); func(\u0026amp;ls); return 0; }  拿不同的派生类的对象干同一件事 func() 和具体的派生类型没关系。 用相同形式的东西（指针或引用），在具体调用的时候去执行不同对象或实体的行为 动态联编：编译时不确定，运行时才确定。  Qt 隐式共享  Qt 中的许多 C++ 类使用隐式数据共享来最大化资源使用并最小化复制。 当作为参数传递时，隐式共享类既安全又高效，因为只有一个指向数据的指针被传递，并且只有当函数写入数据时才会复制数据，即copy-on-write。  QPixmap p1, p2; p1.load(\u0026#34;image.bmp\u0026#34;); p2 = p1; // p1 and p2 share data QPainter paint; paint.begin(\u0026amp;p2); // cuts p2 loose from p1 paint.drawText(0,50, \u0026#34;Hi\u0026#34;); paint.end();   隐式共享对象的对象分配（使用 operator=()）是使用浅拷贝实现的。\n  隐式共享大多发生在幕后；程序员很少需要担心它。但是，Qt 的容器迭代器与 STL 的容器迭代器具有不同的行为。\n  Qt doc：https://doc.qt.io/qt-6/implicit-sharing.html\n  QList   QList 类是提供动态数组的模板类。该类中的所有函数都是可重入的(可以由多个线程同时调用)。另外两个常用的顺序容器 QStack 和 QQueue 继承自 Qlist。\n  对于大多数应用程序， QList 是最好使用的类型。 它提供了非常快速的追加。 如果你真的需要一个链表，使用 std::list。\n  Qt 元对象系统 Qt 的元对象系统为对象间通信、运行时类型信息和动态属性系统提供了信号和槽机制。\n  QObject 类为可以利用元对象系统的对象提供基类 。\n  Q_OBJECT 宏用于启用元对象功能，例如动态属性、信号和插槽。\n  元对象编译器(moc)为每个 QObject 子类提供实现元对象功能所需的代码。\n   这 moc工具读取 C++ 源文件。 类声明 Q_OBJECT ，它会生成另一个 C++ 源文件，其中包含每个这些类的元对象代码。 这个生成的源文件是 #include 到类的源文件中，或者更常见的是，编译并链接到类的实现中。    Qt 对象应该被视为身份，而不是值。 因此，QObject和所有子类都禁用了拷贝构造函数和赋值操作符。\n  为了方便内存管理，QObject 的构造函数中会传入一个 Parent 父对象指针，当父对象析构的时候，这个子对象列表中的所有对象都会被析构，当析构子对象的时候，会自动从父对象的子对象列表中删除。\n  这种机制在 GUI 程序开发过程中是相当实用的。有一个很明显的现象就是我们会在窗口中new很多控件，但是却没有delete，因为在父控件销毁时这些子控件以及布局管理器对象会一并销毁。\n  C++中规定了析构顺序应该按照其创建顺序的相反过程。\n  先创建父对象再创建子类对象，并且在创建子对象时就指定父对象；\n  Qt 跨平台和 Java 跨平台   Qt 允许我们编写独立于平台的代码，其中相同的代码库可以在不同平台上编译和部署，而无需任何更改（理想状态）。\n  Java 运行在虚拟机上。\n  Java：在虚拟机上 一次编译到处运行，但虚拟机是平台各异的，执行代码格式统一。\n  Qt 程序的运行是建立在 Qt 框架上的，一次编码到处编译，但框架是平台各异的，编程接口统一。\n  java也为此付出了运行效率的代价。因为一般程序直接通过操作系统由 CPU 执行，而 java 语言需要先通过 JVM 再映射到操作系统里，最后由 CPU 执行，执行过程多了一步。\n  Qt平台并没有使用类似 JVM 的明显抽象层（但是原理类似，它底层封装了针对不同平台的类库，API之类的，只是这些都被上层做了封装，对开发者来说操作各种平台的接口都是一样的），因此在框架开发过程中处理各种平台问题的复杂性要超过java。\n  ","permalink":"/post/2022/03/07/java2c-/","summary":"C/C++ 代码编译成可执行程序的过程 预处理 进行宏定义展开、头文件展开、条件编译，不检查语法。 gcc -E demo1.c -o demo1.i 编译 检查语法，将预处理过的文件编译生成汇编文件","title":"从 Java 到 Qt/C++ 的一些经验总结"},{"content":"简介 Marp（Markdown Presentation Ecosystem）为创建漂亮的幻灯片提供了直观的体验。 你只需要专注于在 Markdown 文档中写你的故事。\n安装使用 Marp 有两个集成应用，Marp for VS Code 和 Marp CLI。Marp for VS Code 是一个 VS Code 插件扩展，允许您在 VS Code 中编辑 Markdown 和预览幻灯片，Marp CLI 是一个命令行工具，允许您使用简单的 CLI 界面转换 Markdown。对普通用户而言，Marp for VS Code 已经足够了，本文只对其进行介绍。\n安装：在 VS Code 左侧插件栏中搜索安装 Marp for VS Code 插件，同时你也可以选择再安装一个 Markdown All in One 插件，它有助于书写 Markdown。\n使用：\n方式1：新建或打开 md 格式文件，在开头写入：\n--- marp: true --- 然后，在后面书写 Markdown 格式内容。\n方式2：通过 VS Code 菜单：File -\u0026gt; New File\u0026hellip; -\u0026gt; Marp Markdown，生成新文件。\n官方示例 源码：\n--- marp: true theme: gaia _class: lead paginate: true backgroundColor: #fff backgroundImage: url(\u0026#39;https://marp.app/assets/hero-background.svg\u0026#39;) --- ![bg left:40% 80%](https://marp.app/assets/marp.svg) # **Marp** Markdown Presentation Ecosystem https://marp.app/ --- # How to write slides Split pages by horizontal ruler (`---`). It\u0026#39;s very simple! 😆 ```markdown # Slide 1 foobar --- # Slide 2 foobar 效果图：\n","permalink":"/post/2022/02/28/marp%E4%BD%BF%E7%94%A8-markdown-%E5%88%9B%E5%BB%BA%E6%BC%82%E4%BA%AE%E7%9A%84%E5%B9%BB%E7%81%AF%E7%89%87/","summary":"简介 Marp（Markdown Presentation Ecosystem）为创建漂亮的幻灯片提供了直观的体验。 你只需要专注于在 Markdown 文档中写你的故事。 安装使用 Marp 有两个","title":"Marp：使用 Markdown 创建漂亮的幻灯片"},{"content":"一  安妮：希望戴安娜会成为我的知心朋友，我一定会喜欢戴安娜的，而且我相信戴安娜她一定也会喜欢我的。因为今天晚上戴安娜家中的橙光，看起来是离我那么近。\n 二  安妮：雨很快就会停了是不是，还是会一直下个不停呢？\n  马修：你不用担心了，中午以前雨就会停了。\n  安妮：马修，真的吗？\n  玛莉娜：马修的天气预报蛮准的哟。\n  安妮：谢谢老天爷。那我今天就可以去找戴安娜了。\n  玛莉娜：是啊。不过必须过了下午茶时间，我们不能给人家添麻烦。\n  安妮：嗯。\n 三  玛莉娜：安妮，该出发了。\n  玛莉娜：为什么换衣服？我们只是顺便去借做衣服的样版而已。\n  安妮：可是……\n  玛莉娜：快走吧，再拖下去天都黑了。\n  玛莉娜：怎么回事啊？\n  安妮：玛丽娜，我现在开始担心了。我担心万一，万一戴安娜她看到我，不喜欢我的话，那我该怎么办呢？那这将成为我这一辈子最大最大的失望。\n  玛莉娜：用不着这么紧张。首先，我不希望你用这么一大串的形容词。小孩子用大人的口气说话，太奇怪了。你放心，戴安娜一定会很喜欢你的。不过重要的是她妈妈。如果她妈妈不喜欢你的话，就算戴安娜再喜欢你，那也没用的。如果她知道你对林德太太说粗话，还有你帽子的事，不知道对你有什么看法。你一定要有礼貌守规矩，别再发表你那惊人的言论了。你该不是在发抖吧……\n  安妮：玛丽娜……如果你想要跟一个可能会成为你的好朋友的人见面，你一定也会很激动的。而且，她的妈妈要是不喜欢你的话，那该怎么办呢？\n 四  贝瑞夫人：你好啊，玛丽娜，好久不见，快请进吧。我想那一位即是你领养的小女孩了。是不是呀。别站在那里，快点进来呀。\n  玛莉娜：她是安妮·夏利。\n  安妮：很高兴见到你，夫人。\n  贝瑞夫人：你好啊。\n  安妮：夫人，托您的福，我很好。虽然我现在的情绪有点紧张，贝瑞夫人。\n  贝瑞夫人：快点进来吧。\n  安妮：玛丽娜，我说的话不会夸张吧。\n  玛莉娜：你的声音应该再小一点。\n  贝瑞夫人：这一位就是我的女儿，戴安娜。\n  安妮：戴安娜，她就是戴安娜……\n  贝瑞夫人：戴安娜，带安妮到花园，让她看看你种的花，不要老是一直看书，这样对眼睛不好。\n  戴安娜:好啊。\n 五  安妮：戴安娜，我……我们初次见面，我不知道你会不会喜欢我，会不会把我当成你的好朋友呢？\n  戴安娜:会啊，我想我们能够成为好朋友的。我真的好高兴，你能够住到绿色庄园来耶。有个同伴在一起玩，真的是好棒喔。\n  安妮：你说的是真的吧！\n  戴安娜：这里附近没有其他的女孩子跟我玩，而且我妹妹也还小。\n  安妮：那么请你发誓你愿意一辈子当我的好朋友！\n  戴安娜:发誓？\n  安妮：那是一种承诺啊，而且是很虔诚的承诺喔。\n  戴安娜:嗯，我很乐意啊。该怎么做呢？\n  安妮：首先，我们必须手拉手，然后……真正的发誓程序应该是在流动的河水上。可是，我们可以把这条小道想成是流动的河水。那我先开始发誓咯。\n  安妮：现在我虔诚的发誓，要永远永远对我的好朋友——戴安娜忠诚，就像日月一样的长久。\n  安妮：现在把名字换成你的就行了。\n  戴安娜：现在我虔诚的发誓，要永远永远对我的好朋友——安妮·夏利忠诚，就像日月一样的长久。\n ","permalink":"/blog/2022/02/09/%E7%BA%A2%E5%8F%91%E5%B0%91%E5%A5%B3%E5%AE%89%E5%A6%AE%E8%99%94%E8%AF%9A%E7%9A%84%E6%89%BF%E8%AF%BA/","summary":"一 安妮：希望戴安娜会成为我的知心朋友，我一定会喜欢戴安娜的，而且我相信戴安娜她一定也会喜欢我的。因为今天晚上戴安娜家中的橙光，看起来是离我那","title":"《红发少女安妮——虔诚的承诺》"},{"content":"前些天，我感觉我的世界崩塌了，可渐渐的，我的心平静了下来，那些一直一直困扰我的问题也随之解开。为了纪念自己进入“不惑”之年，我决定在此发表一段重要讲话：\n 我现在看清了我真正的敌人。\n他在虚空中等待着我，\n拥有着我无法想象的力量……\n为了对抗他，我放弃了所有的一切。\n我的人性、\n我的身份、\n还有我爱的人。\n但我不会独自去面对他的。\n因为我即是 Artanis！\n 来人，快把这个中二病拖走！\n另外，最近疫情严重，不知各位看官身体是否安康？春节假期是否过得愉快？\n话说不知道我这个网站有没有被 Github 沉进北极里，如果人类因疫情而遭受劫难，不知这些文字是否有重见天日的一天？想到这里，庆幸自己没有弄过于复杂的网页……\n","permalink":"/blog/2022/02/05/%E6%88%91%E7%8E%B0%E5%9C%A8%E7%9C%8B%E6%B8%85%E4%BA%86%E6%88%91%E7%9C%9F%E6%AD%A3%E7%9A%84%E6%95%8C%E4%BA%BA/","summary":"前些天，我感觉我的世界崩塌了，可渐渐的，我的心平静了下来，那些一直一直困扰我的问题也随之解开。为了纪念自己进入“不惑”之年，我决定在此发表一","title":"我现在看清了我真正的敌人"},{"content":" 苦涩的沙 吹痛脸庞的感觉\n  像父亲的责骂 母亲的哭泣 永远难忘记\n  年少的我 喜欢一个人在海边\n  卷起裤管 光着脚丫 踩在沙滩上\n  总是幻想海洋的尽头有另一个世界\n  总是以为勇敢的水手是真正的男儿\n  总是一副弱不禁风孬种的样子\n  在受人欺负的时候 总是听见水手说\n  他说 风雨中 这点痛算什么\n  擦干泪 不要怕\n  至少我们还有梦\n  他说 风雨中 这点痛算什么\n  擦干泪 不要问 为什么\n  长大以后 为了理想而努力\n  渐渐的忽略了父亲母亲和故乡的消息\n  如今的我 生活就像在演戏\n  说着言不由衷的话 戴着伪善的面具\n  总是拿着微不足道的成就来骗自己\n  总是莫名其妙感到一阵的空虚\n  总是靠一点酒精的麻醉才能够睡去\n  在半睡半醒之间仿佛又听见水手说\n  他说 风雨中 这点痛算什么\n  擦干泪 不要怕\n  至少我们还有梦\n  他说 风雨中 这点痛算什么\n  擦干泪 不要问 为什么\n  寻寻觅觅寻不到活着的证据\n  都市的柏油路太硬 踩不出足迹\n  骄傲无知的现代人 不知道珍惜\n  那一片被文明糟踏过的海洋和天地\n  只有远离人群才能找回我自己\n  在带着咸味的空气中自由地呼吸\n  耳畔又传来汽笛声和水手的笑语\n  永远在内心的最深处 听见水手说\n  他说 风雨中 这点痛算什么\n  擦干泪 不要怕\n  至少我们还有梦\n  他说 风雨中 这点痛算什么\n  擦干泪 不要问 为什么\n  他说 风雨中 这点痛算什么\n  擦干泪 不要怕\n  至少我们还有梦\n  他说 风雨中 这点痛算什么\n  擦干泪 不要问 为什么\n  他说 风雨中 这点痛算什么\n  擦干泪 不要怕\n  至少我们还有梦\n  他说 风雨中 这点痛算什么\n  擦干泪 不要问\n  为什么\n ","permalink":"/blog/2022/02/05/%E9%9F%B3%E4%B9%90%E6%B0%B4%E6%89%8B/","summary":"苦涩的沙 吹痛脸庞的感觉 像父亲的责骂 母亲的哭泣 永远难忘记 年少的我 喜欢一个人在海边 卷起裤管 光着脚丫 踩在沙滩上 总是幻想海洋的尽头有另一个世界 总是以","title":"【音乐】水手"},{"content":" 充满鲜花的世界到底在哪里\n  如果它真的存在那么我一定会去\n  我想在那里最高的山峰矗立\n  不在乎它是不是悬崖峭壁\n  用力活着用力爱哪怕肝脑涂地\n  不求任何人满意只要对得起自己\n  关于理想我从来没选择放弃\n  即使在灰头土脸的日子里\n  也许我没有天分\n  但我有梦的天真\n  我将会去证明用我的一生\n  也许我手比较笨\n  但我愿不停探寻\n  付出所有的青春不留遗憾\n  向前跑 迎着冷眼和嘲笑\n  生命的广阔不历经磨难怎能感到\n  命运它无法让我们跪地求饶\n  就算鲜血洒满了怀抱\n  继续跑 带着赤子的骄傲\n  生命的闪耀不坚持到底怎能看到\n  与其苟延残喘不如纵情燃烧吧\n  有一天会再发芽\n  未来迷人绚烂总在向我召唤\n  哪怕只有痛苦作伴也要勇往直前\n  我想在那里最蓝的大海扬帆\n  绝不管自己能不能回还\n  失败后郁郁寡欢\n  那是懦夫的表现\n  只要一息尚存请握紧双拳\n  在天色破晓之前\n  我们要更加勇敢\n  等待日出时最耀眼的瞬间\n  向前跑 迎着冷眼和嘲笑\n  生命的广阔不历经磨难怎能感到\n  命运它无法让我们跪地求饶\n  就算鲜血洒满了怀抱\n  继续跑 带着赤子的骄傲\n  生命的闪耀不坚持到底怎能看到\n  与其苟延残喘不如纵情燃烧吧\n  为了心中的美好\n  不妥协直到变老\n ","permalink":"/blog/2022/02/05/%E9%9F%B3%E4%B9%90%E8%BF%BD%E6%A2%A6%E8%B5%A4%E5%AD%90%E5%BF%83/","summary":"充满鲜花的世界到底在哪里 如果它真的存在那么我一定会去 我想在那里最高的山峰矗立 不在乎它是不是悬崖峭壁 用力活着用力爱哪怕肝脑涂地 不求任何人满意只","title":"【音乐】追梦赤子心"},{"content":" コツコツとアスファルトに刻む\n脚步声咯噔咯噔刻在沥青路上\n足音を踏みしめるたびに\n每踩一步时\n俺は俺で在り続けたい そう願った\n我都祈愿了 要永远保持住本真的自我\n裏腹な心たちが見えて やりきれない夜を数え\n看得见相反的不同内心 我数着难熬的夜晚\nのがれられない闇の中で 今日も眠ったふりをする\n在无法逃脱的黑暗之中 今天也假装睡着了\n死にたいくらいに憧れた 花の都 大東京\n曾令我憧憬得要死要活的 繁华都市大东京\n薄っぺらのボストンバッグ 北へ北へ向かった\n我提着瘪瘪的波士顿包 一路向北奔去\nざらついたにがい砂を噛むと\n咀嚼了粗糙苦涩的砂砾后\nねじふせられた正直さが\n被摁倒了的正直\n今ごろになってやけに骨身にしみる\n如今更加 铭心刻骨\n  ああしあわせのとんぼよ どこへ\n啊 幸福的蜻蜓啊 往哪里\nお前はどこへ飛んで行く\n你往哪里飞去\nああしあわせのとんぼが ほら\n啊 幸福的蜻蜓 你瞧\n舌を出して 笑ってらあ※\n正伸出舌头在笑呢\n  明日からまた冬の風が 横っつらを吹き抜けて行く\n从明天起冬日的风 又将吹过我的侧脸而去\nそれでもおめおめと生きぬく 俺を恥らう\n即便如此 仍令厚颜无耻赖活的我感到羞耻\n裸足のまんまじゃ寒くて 凍りつくような夜を数え\n我就这样冷赤着双脚 数着冰凉的夜晚\nだけど俺はこの街を愛し そしてこの街を憎んだ\n但我爱着这个城市 并又憎恨着这座城市\n死にたいくらいに憧れた 東京のバカヤローが\n曾令我憧憬得要死要活的 东京的混蛋们\n知らん顔して黙ったまま 突っ立ってる\n一副装聋作哑的嘴脸沉默着 正伫立在那里\n  ケツの座りの悪い都会で 憤りの酒をたらせば\n在难以安身立命的都会 若灌下愤怒的酒\n半端な俺の骨身にしみる\n愚蠢的我 铭心刻骨\n  ああしあわせのとんぼよ どこへ\n啊 幸福的蜻蜓啊 往哪里\nお前はどこへ飛んで行く\n你往哪里飞去\nああしあわせのとんぼが ほら\n啊 幸福的蜻蜓 你瞧\n舌を出して 笑ってらあ※\n正伸出舌头在笑呢\nああしあわせのとんぼよ どこへ\n啊 幸福的蜻蜓啊 往哪里\nお前はどこへ飛んで行く\n你往哪里飞去\nああしあわせのとんぼが ほら\n啊 幸福的蜻蜓 你瞧\n舌を出して 笑ってらあ※\n正伸出舌头在笑呢\nああしあわせのとんぼよ どこへ\n啊 幸福的蜻蜓啊 往哪里\nお前はどこへ飛んで行く\n你往哪里飞去\nああしあわせのとんぼが ほら\n啊 幸福的蜻蜓 你瞧\n舌を出して 笑ってらあ\n正伸出舌头在笑呢\n ","permalink":"/blog/2022/02/05/%E9%9F%B3%E4%B9%90%E3%81%A8%E3%82%93%E3%81%BC/","summary":"コツコツとアスファルトに刻む 脚步声咯噔咯噔刻在沥青路上 足音を踏みしめるたびに 每踩一步时 俺は俺で在り続けたい そう願った 我都祈愿了 要永远保持住本","title":"【音乐】とんぼ"},{"content":"很久之前，我见到过这样一个画面：一位年轻的母亲和她的孩子坐公交，她用手抱着小孩，小孩用手抱着手机。她在刷短视频，一遍又一遍。我就这么看着，什么也没说。\n我什么都没说，因为大家都是这样做的；那位母亲什么错也没有，因为大家都是这样做的。但是那孩子，真的知道自己想要什么吗？\n在这一点上，我很欣赏（ 喂！崇敬！注意你的用词! ）益辉的观念：我不是专职保姆，除非你的故事“催人泪下”（ 我瞎说的 )。我也很欣赏益辉因为不喜欢微信就拒绝回国的态度（还是瞎说的！）。然而，益辉的贡献是很多很多人无法比拟的，我并不是指他在 R 语言社区或者数据分析领域的贡献（ 因为我不懂～ ），我是觉得他在帮助人们关注阅读、关注写作上面做了很多努力（ 满大街都是抄他博客的人，当然也包括我，哈哈哈哈！ )。\n今天又提益辉的名字，因为我现在就是在抄他的主题，甚至抄他的 blogdown（//▽//）。\n","permalink":"/blog/2022/02/05/%E6%88%91%E4%BB%80%E4%B9%88%E4%B9%9F%E6%B2%A1%E8%AF%B4/","summary":"很久之前，我见到过这样一个画面：一位年轻的母亲和她的孩子坐公交，她用手抱着小孩，小孩用手抱着手机。她在刷短视频，一遍又一遍。我就这么看着，什","title":"我什么也没说"},{"content":"如果说《世界名作系列》是想告诉世人什么是爱，那么《圣斗士星矢》则给我们展示了为爱而战斗的意志。爆发你的小宇宙吧！这样你才有力量去追求你爱的一切！\n《圣斗士星矢》，80年代的动漫，感觉挺有意思。就是资源不太好找，不过还是强烈推荐日语中字的，TV版。千万别去看国语配音的……反正我是受不了(＠_＠;)。\n“未必要有希望才能坚持”，今天从益辉博客里看来的。还有，我打算换一个网站主题了，虽然我很喜欢现在这个，但是毕竟这是益辉给自己定制的，我也想自己做一个。\n","permalink":"/blog/2022/02/04/%E6%88%98%E6%96%97%E5%90%A7%E4%B8%BA%E4%BA%86%E9%9B%85%E5%85%B8%E5%A8%9C/","summary":"如果说《世界名作系列》是想告诉世人什么是爱，那么《圣斗士星矢》则给我们展示了为爱而战斗的意志。爆发你的小宇宙吧！这样你才有力量去追求你爱的一","title":"战斗吧！为了雅典娜！"},{"content":" 这一生也在进取\n  这分钟却挂念谁\n  我会说是唯独你不可失去\n  好风光似幻似虚\n  谁明人生乐趣\n  我会说为情为爱仍然是对\n  谁比你重要\n  成功了败了也完全无重要\n  谁比你重要\n  狂风与暴雨都因你燃烧\n  一追再追\n  只想追赶生命里一分一秒\n  原来多么可笑\n  你是真正目标\n  一追再追\n  追踪一些生活最基本需要\n  原来早不缺少\n  Oh\n  有了你即使平凡却最重要\n  好光阴纵没太多\n  一分钟那又如何\n  会与你共同渡过都不枉过\n  疯恋多错误更多\n  如能从新做过\n  我会说愿能为你提前做错\n  谁比你重要\n  成功了败了也完全无重要\n  谁比你重要\n  狂风与暴雨都因你燃烧\n  一追再追\n  只想追赶生命里一分一秒\n  原来多么可笑\n  你是真正目标\n  一追再追\n  追踪一些生活最基本需要\n  原来早不缺少\n  Oh\n  有了你即使平凡却最重要\n  （一追再追）\n  只想追赶生命里一分一秒\n  原来多么可笑\n  你是真正目标\n  一追再追\n  追踪一些生活最基本需要\n  原来早不缺少\n  有了你即使平凡却最重要\n  只得你\n  有了你即使沉睡了\n  也在笑\n ","permalink":"/blog/2022/02/03/%E9%9F%B3%E4%B9%90%E8%BF%BD-%E5%BC%A0%E5%9B%BD%E8%8D%A3/","summary":"这一生也在进取 这分钟却挂念谁 我会说是唯独你不可失去 好风光似幻似虚 谁明人生乐趣 我会说为情为爱仍然是对 谁比你重要 成功了败了也完全无重要 谁比你重要","title":"【音乐】追 - 张国荣"},{"content":" 这世界看来很快乐\n  看不出难过\n  始终笑著沉默\n  你不慌不忙\n  自然坦荡\n  脱下了伪装\n  摘去了信仰\n  你不愿多说话\n  你想放纵一下\n  没什么可怕\n  没什么放心不下\n  痛苦地享乐\n  犹豫著堕落\n  YI DA LI DA\n  YI DA LI DA\n  左右不了诱惑\n  你才拒绝寂寞\n  你没有错\n  因为没有谁作对过\n  心安理得\n  于是你堕落\n  YI DA LI DA\n  YI DA LI DA\n  来呀来呀\n  我陪你\n  来呀来呀来呀\n  继续继续\n  我没什么可说\n  想不清后果\n  也不准备自责\n  我不慌不忙\n  自然而坦荡\n  绝望地逆流而上\n  甘心地自投罗网\n  没有别的想法\n  只想放纵一下\n  就当没发现\n  美好背后的虚假\n  敷衍著灵魂\n  勉强地挣扎\n  YI DA LI DA\n  YI DA LI DA\n  什么也没错过\n  其实一无所获\n  谈不上失落\n  陶醉和麻醉交错\n  从这里开始\n  无意识地堕落\n  YI DA LI DA\n  YI DA LI DA\n  来呀来呀\n  我陪你\n  来呀来呀来呀\n  继续继续\n ","permalink":"/blog/2022/02/03/%E9%9F%B3%E4%B9%90%E5%A2%AE%E8%90%BD-%E7%8E%8B%E8%8F%B2/","summary":"这世界看来很快乐 看不出难过 始终笑著沉默 你不慌不忙 自然坦荡 脱下了伪装 摘去了信仰 你不愿多说话 你想放纵一下 没什么可怕 没什么放心不下 痛苦地享乐 犹豫著","title":"【音乐】墮落 - 王菲"},{"content":" 下雨天小雨点\n那一天亲我面\n我喜欢\n街中披雨到处走\n在那天七岁多\n多开心很少挂念\n雨那天起舞在前后\n玩雨水追雨点\n盼雨天一世现\n但雨点\n始终须要远走\n问母亲怎会的\n她温馨解释说着\n每种东西有定时候\n当飘到\n不可以送走\n若飘去\n如何不舍都要放手\n即使有泪流\n亦学习承受\n  下雨天的小雨点\n有一天轻抚你面\n你那天\n开始牵我两手\n十七岁那天\n多开心很少挂念\n说也许恋爱是时候\n在雨中轻倚你肩\n你说想天天见面\n你说想\n天边海角与我走\n但那天的雨点\n跟当天都不再现\n我有哭当你别离后\n当飘到\n不可以送走\n若飘去\n如何不舍都要放手\n即使有泪流\n亦学习承受\n  在这天飘飘雨点\n再这般的亲我面\n似不知 当天相隔已久\n现我心懂多了点\n知必须经考验\n笑与哭\n早注定是时候\n在雨中仿佛见到\n母亲的亲切面\n也见到\n当天的你与我走\n亦见到许多昨天\n许多东西使我念\n我半泣的笑着怀旧\n当飘到\n不可以送走\n若飘去\n如何不舍都要放手\n即使有泪流\n亦学习承受\n ","permalink":"/blog/2022/02/03/%E9%9F%B3%E4%B9%90%E6%98%A8%E5%A4%A9-%E4%BB%8A%E5%A4%A9-%E4%B8%8B%E9%9B%A8%E5%A4%A9/","summary":"下雨天小雨点 那一天亲我面 我喜欢 街中披雨到处走 在那天七岁多 多开心很少挂念 雨那天起舞在前后 玩雨水追雨点 盼雨天一世现 但雨点 始终须要远走 问母亲怎会的","title":"【音乐】昨天 今天 下雨天"},{"content":" My third story is about death.\n  我的第三个故事是关于死亡的。\n  When I was 17, I read a quote that went something like: \u0026ldquo;If you live each day as if it was your last, someday you\u0026rsquo;ll most certainly be right.\u0026rdquo;\n  17岁那年，我读到了一句话，它是这样说的：“如果你把每一天都当作生命中的最后一天去过，总有一天你会如愿以偿。”\n  It made an impression on me, and since then, for the past 33 years, I have looked in the mirror every morning and asked myself:\n  这句话给我留下了深刻的印象。从那时开始，33年过去了，我在每天早晨都会对着镜子问自己：\n  \u0026ldquo;If today were the last day of my life, would I want to do what I am about to do today?\u0026rdquo;\n  “如果今天是我生命中的最后一天，我还会去做你今天想做的事情吗？“\n  And whenever the answer has been \u0026ldquo;No\u0026rdquo; for too many days in a row, I know I need to change something.\n  当一连很多天我的回答都是“不”的时候，我知道自己应该有所改变了。\n  Remembering that I\u0026rsquo;ll be dead soon is the most important tool I\u0026rsquo;ve ever encountered to help me make the big choices in life.\n  “记住你随时都将死去”是我一生中遇到的最重要的箴言。它帮我做了生命中很多重要的选择。\n  Because almost everything—all external expectations, all pride, all fear of embarrassment or failure—\n  因为几乎所有的事情，包括所有的期待、骄傲、所有对难堪和失败的恐惧——\n  these things just fall away in the face of death, leaving only what is truly important.\n  它们在死亡面前都会消失，看到的是留下的真正重要的东西。\n  Remembering that you are going to die is the best way I know to avoid the trap of thinking you have something to lose.\n  记住自己随时都会死去是我知道的避免患得患失最好的而办法。\n  You are already naked. There is no reason not to follow your heart.\n  你已经一无所有了，没有理由不去跟随自己的感觉走。\n  About a year ago I was diagnosed with cancer.\n  大概一年以前，我被诊断出患有癌症。\n  I had a scan at 7:30 in the morning, and it clearly showed a tumor on my pancreas. I didn\u0026rsquo;t even know what a pancreas was.\n  那天早晨七点半，我做了一个扫描检查，检查结果清楚表明我的胰腺上有一个肿瘤。我当时都不知道胰腺是什么东西。\n  The doctors told me this was almost certainly a type of cancer that is incurable, and that I should expect to live no longer than three to six months.\n  医生告诉我那几乎是一种无法治愈的癌症，我最多还可以活三到六个月。\n  My doctor advised me to go home and get my affairs in order, which is doctor\u0026rsquo;s code for prepare to die.\n  医生建议我回家把一切事情都安排好，其实那就是医生在暗示我准备后事。\n  It means to try and tell your kids everything you thought you\u0026rsquo;d have the next ten years to tell them in just a few months.\n  那意味着你将要把未来十年对你小孩说的话在几个月里嘱咐完。\n  It means to make sure everything is buttoned up so that it will be as easy as possible for your family. It means to say your goodbyes.\n  意味着把每件事情都安排妥当，让你的家人会尽可能轻松的生活。那意味着你要说“再见“了。\n  I lived with that diagnosis all day.\n  我整天心里都想着那个诊断书。\n  Later that evening I had a biopsy, where they stuck an endoscope down my throat, through my stomach and into my intestines, put a needle into my pancreas and got a few cells from the tumor.\n  到了晚上，我做了一个组织切片检查。医生将一个内窥镜通过我的喉咙伸进我的胃，然后进入我的肠子，用一根针在我的胰腺上的肿瘤上取了几个细胞。\n  I was sedated, but my wife, who was there, told me that when they viewed the cells under a microscope the doctors started crying because it turned out to be a very rare form of pancreatic cancer that is curable with surgery.\n  我当时被麻醉了，但是我的妻子在那里。她后来告诉我，当医生在显微镜下观察到这些细胞的时候叫了起来，原来这些细胞竟然是一种罕见的可以用手术治愈的胰腺癌症。\n  I had the surgery and thankfully I\u0026rsquo;m fine now.\n  于是我做了手术，现在已经痊愈了。\n  This was the closest I\u0026rsquo;ve been to facing death, and I hope it\u0026rsquo;s the closest I get for a few more decades.\n  那是我离死亡最近的时候，我也希望这是以后的几十年最接近的一次。\n  Having lived through it, I can now say this to you with a bit more certainty than when death was a useful but purely intellectual concept: No one wants to die.\n  有了这次经历之后，现在我可以更加确定地和你们谈论死亡，而不觉得死亡只是一个有帮助性的纯粹的知识上的概念，我可以更肯定地对你们说：没有人愿意死。\n  Even people who want to go to heaven don\u0026rsquo;t want to die to get there.\n  即使那些想上天堂的人也不愿意死后再进。\n  And yet death is the destination we all share. No one has ever escaped it.\n  然而死亡是我们的共同归宿，没人能逃脱。\n  And that is as it should be, because Death is very likely the single best invention of Life.\n  我们注定会死，因为死亡很可能是生命中最好的一项发明。\n  It is Life\u0026rsquo;s change agent. It clears out the old to make way for the new.\n  它推进生命的变更，除去旧的，迎来新的。\n  Right now the new is you, but someday not too long from now, you will gradually become the old and be cleared away. Sorry to be so dramatic, but it\u0026rsquo;s quite true.\n  现在，你们就是新的，但是不久以后，你们将会逐渐变成旧的，然后被淘汰。抱歉我把话说得这么过头，但这千真万确。\n  Your time is limited, so don\u0026rsquo;t waste it living someone else\u0026rsquo;s life.\n  时间有限，不要按照别人的意愿来活，这是浪费时间。\n  Don\u0026rsquo;t be trapped by dogma—which is living with the results of other people\u0026rsquo;s thinking. Don\u0026rsquo;t let the noise of others\u0026rsquo; opinions drown out your own inner voice.\n  不要被教条所束缚，那是为别人的设想而活。不要让他人的意见淹没自己的心声。\n  And most important, have the courage to follow your heart and intuition. They somehow already know what you truly want to become. Everything else is secondary.\n  最重要的是，鼓起勇气，跟着自己的心和直觉前行。不管怎样，感觉和直觉早就知道你想成为什么样的人，其它都是次要的。\n  When I was young, there was an amazing publication called The Whole Earth Catalog, which was one of the bibles of my generation.\n  我年轻的时候有一本很好的期刊，叫做《全球概览》，它是我们那代人的宝书之一。\n  It was created by a fellow named Stewart Brand not far from here in Menlo Park, and he brought it to life with his poetic touch.\n  作者是斯图尔特-布兰德，住在离这儿不远的门罗帕克市。他用他诗一般的语言将期刊描写得栩栩如生。\n  This was in the late 1960\u0026rsquo;s, before personal computers and desktop publishing, so it was all made with typewriters, scissors, and polaroid cameras.\n  那是20世纪60年代，还没有个人电脑和台式机，全靠打字机、剪刀和宝丽来照相。\n  It was sort of like Google in paperback form, 35 years before Google came along: it was idealistic, overflowing with neat tools and great notions.\n  它就像纸质版的谷歌，却比谷歌早问世了35年。这份期刊太完美了，查阅手段齐全，构思不凡。\n  Stewart and his team put out several issues of The Whole Earth Catalog, and then when it had run its course, they put out a final issue.\n  斯图尔特和他的团队出了好几期《全球概览》，到最后办不下去的时候，他们出了最后一期。\n  It was the mid-1970s, and I was your age. On the back cover of their final issue was a photograph of an early morning country road, the kind you might find yourself hitchhiking on if you were so adventurous.\n  那是20世纪70年代中期，那时我也跟你们一样大。在他们最后一期的后封面上是一张清晨乡间小路的照片，是那种爱冒险的人等在那儿搭便车的那种小路。\n  Beneath it were the words: \u0026ldquo;Stay Hungry. Stay Foolish.\u0026rdquo; It was their farewell message as they signed off. Stay Hungry. Stay Foolish.\n  照片下面写着一行字：“好学若饥，谦卑若愚。“这是他们停刊前的告别词。\n  And I have always wished that for myself. And now, as you graduate to begin anew, I wish that for you. Stay Hungry. Stay Foolish.\n  这也是我一直想要做到的。现在，你们也要毕业了，要开始新的生活，希望你们也能做到。\n  Thank you all very much.\n  谢谢大家。\n ","permalink":"/blog/2022/01/30/thoughtsondeath/","summary":"My third story is about death. 我的第三个故事是关于死亡的。 When I was 17, I read a quote that went something like: \u0026ldquo;If you live each day as if it was your last, someday you\u0026rsquo;ll most certainly be right.\u0026rdquo; 17岁那年，我读到了一句话，它是这样说的：","title":"《Thoughts on Death》"},{"content":" 鈴なりの花を摘み\n  摘下串串花儿\n  吹く風に夏を知る\n  微风吹拂夏日临\n  おだやかに ああ おだやかに\n  静静地，啊静静地\n  今 ぼんやり遠くをながめてる\n  凝望远方\n  はるかなる空の果て\n  在遥远天尽头\n  想い出が駆けめぐる\n  回忆的思绪萦绕着\n  なだらかな この なだらかな\n  缓缓的，这缓缓的\n  名前さえしらない 坂だけど\n  无名小路上\n  咲く紫は 旅路を彩どる\n  盛开的紫丁香将旅途装扮\n  何処へと鳥は鳴き\n  何处鸟儿歌婉转\n  夢出ずる国をゆく\n  伴我奔向梦之国\n  世の中は ああ 世の中は\n  这世间，啊这世间\n  なぜ こんな急いてと流れてく\n  为何来去太匆匆\n  今宵は 月が旅路を照らそうぞ\n  月色今宵照旅途\n  喜びが川となり\n  快乐好似河水\n  悲しみは虹を呼ぶ\n  悲伤呼唤彩虹\n  道無きぞ この旅だけど\n  旅途前路虽未知\n  でも こんなに上手に歩いてる\n  亦要如此快乐前行\n  稲穂の先が いつしか垂れコウベ\n  稻穗轻轻颔首\n  咲く紫は 旅路を彩どる\n  盛开的紫丁香将旅途装扮\n ","permalink":"/blog/2022/01/27/%E9%9F%B3%E4%B9%90%E8%8A%B1%E5%92%B2%E3%81%8F%E6%97%85%E8%B7%AF/","summary":"鈴なりの花を摘み 摘下串串花儿 吹く風に夏を知る 微风吹拂夏日临 おだやかに ああ おだやかに 静静地，啊静静地 今 ぼんやり遠くをながめてる 凝望远方 はるかな","title":"【音乐】花咲く旅路"},{"content":" 你问我爱你有多深\n  我爱你有几分\n  我的情也真\n  我的爱也真\n  月亮代表我的心\n  你问我爱你有多深\n  我爱你有几分\n  我的情不移\n  我的爱不变\n  月亮代表我的心\n  轻轻的一个吻\n  已经打动我的心\n  深深的一段情\n  教我思念到如今\n  你问我爱你有多深\n  我爱你有几分\n  你去想一想\n  你去看一看\n  月亮代表我的心\n  轻轻的一个吻\n  已经打动我的心\n  深深的一段情\n  教我思念到如今\n  你问我爱你有多深\n  我爱你有几分\n  你去想一想\n  你去看一看\n  月亮代表我的心\n  你去想一想\n  你去看一看\n  月亮代表我的心\n ","permalink":"/blog/2022/01/27/%E9%9F%B3%E4%B9%90%E6%9C%88%E4%BA%AE%E4%BB%A3%E8%A1%A8%E6%88%91%E7%9A%84%E5%BF%83/","summary":"你问我爱你有多深 我爱你有几分 我的情也真 我的爱也真 月亮代表我的心 你问我爱你有多深 我爱你有几分 我的情不移 我的爱不变 月亮代表我的心 轻轻的一个吻 已经","title":"【音乐】月亮代表我的心"},{"content":" 不知道为何你会远走\n  不知道何时才再有对手\n  我的身心只适应你\n  没气力回头\n  不知道为何你会放手\n  只知道习惯抱你抱了太久\n  怕这双手一失去你\n  令动作颤抖\n  尚记得\n  左手边一脸温柔\n  来自你热暖在枕边消受\n  同样记得\n  当天一脸哀求\n  摇着我右臂\n  就这样而分手\n  从那天起我不辨别前后\n  从那天起我竟调乱左右\n  惯都扭转了\n  呼吸都张不开口\n  你离开了\n  却散落四周\n  从那天起我恋上我左手\n  从那天起我讨厌我右手\n  为何没力气\n  去捉紧这一点火花\n  天高海深\n  有什么可拥有\n  不知道为何你会放手\n  只知道习惯抱你抱了太久\n  怕这双手一失去你\n  令动作颤抖\n  尚记得\n  左手边一脸温柔\n  来自你热暖在枕边消受\n  同样记得\n  当天一脸哀求\n  摇着我右臂\n  就这样而分手\n  从那天起我不辨别前后\n  从那天起我竟调乱左右\n  习惯都扭转了\n  呼吸都张不开口\n  你离开了\n  却散落四周\n  从那天起我恋上我左手\n  从那天起我讨厌我右手\n  为何没力气\n  去捉紧这一点火花\n  天高海深\n  有什么可拥有\n  留住你\n  别要走\n  无奈怎能够\n  除下在左右我的手扣\n  有爱难偷\n  从那天起我不辨别前后\n  从那天起我竟调乱左右\n  习惯都扭转了\n  呼吸都张不开口\n  你离开了\n  却散落四周\n  从那天起我恋上我左手\n  从那天起我讨厌我右手\n  为何没力气\n  去捉紧这一点火花\n  天高海深\n  有什么可拥有\n  为何没力气\n  去捉紧这一点火花\n  天高海深\n  有什么可拥有\n ","permalink":"/blog/2022/01/27/%E9%9F%B3%E4%B9%90%E5%B7%A6%E5%8F%B3%E6%89%8B/","summary":"不知道为何你会远走 不知道何时才再有对手 我的身心只适应你 没气力回头 不知道为何你会放手 只知道习惯抱你抱了太久 怕这双手一失去你 令动作颤抖 尚记得 左手","title":"【音乐】左右手"},{"content":" 我怕来不及 我要抱着你\n  直到感觉你的皱纹\n  有了岁月的痕迹\n  直到肯定你是真的\n  直到失去力气\n  为了你 我愿意\n  动也不能动 也要抱着你\n  直到感觉你的发线\n  有了白雪的痕迹\n  直到视线变得模糊\n  直到不能呼吸\n  让我们 形影不离\n  如果 全世界我也可以放弃\n  只因还有你 值得我去珍惜\n  而你在这里 就是生命的奇迹\n  也许 全世界我也可以放弃\n  就是不愿意 失去你的消息\n  你掌心的痣 我总记得在那里\n  我怕来不及 我要抱着你\n  直到感觉你的发线\n  有了白雪的痕迹\n  直到视线变得模糊\n  直到不能呼吸\n  让我们 形影不离\n  如果 全世界我也可以放弃\n  只因还有你 值得我去珍惜\n  而你在这里 就是生命的奇迹\n  也许 全世界我也可以忘记\n  就是不愿意 失去你的消息\n  你掌心的痣 我总记得在那里\n  我们好不容易 我们身不由已\n  我怕时间太快 不够将你看仔细\n  我怕时间太慢 让我日夜担心你\n  恨不得一夜之间白头 永不分离\n  如果 全世界我也可以放弃\n  只因还有你 值得我去珍惜\n  而你在这里 就是生命的奇迹\n  也许 全世界我也可以忘记\n  就是不愿意 失去你的消息\n  你掌心的痣 我总记得在那里\n  在那里\n  在那里\n ","permalink":"/blog/2022/01/27/%E9%9F%B3%E4%B9%90%E8%87%B3%E5%B0%91%E8%BF%98%E6%9C%89%E4%BD%A0/","summary":"我怕来不及 我要抱着你 直到感觉你的皱纹 有了岁月的痕迹 直到肯定你是真的 直到失去力气 为了你 我愿意 动也不能动 也要抱着你 直到感觉你的发线 有了白雪的痕迹","title":"【音乐】至少还有你"},{"content":" —— Steve Jobs\n  My second story is about love and loss.\n  我的第二个故事是关于爱与得失的。\n  I was lucky —— I found what I loved to do early in life.\n  我很幸运，因为我在很早的时候就发现了自己钟爱的东西。\n  Woz and I started Apple in my parents\u0026rsquo; garage when I was 20. We worked hard, and in ten years Apple had grown from just the two of us in a garage ito a $2 billion company with over 4,000 employess.\n  我在二十岁的时候就和沃兹在父母的车库里面开创了苹果公司。我们工作很努力，十年之后，苹果公司从那两个车库中的穷光蛋发展到了拥有四千多名雇员、价值超过二十亿的大公司。\n  We had just released our finest creation —— the Macintosh —— a year earlier, and I had just turned 30. And then I got fired.\n  一年前，我们刚刚发布了最好的产品 —— Macintosh，我也快要到三十岁了。而就在那年，我被解雇了。\n  How can you get fired from a company you started?\n  你怎么会被你自己创立的公司炒鱿鱼呢？\n  Well, as Apple grew we hired someone who I thought was very talented to run the compay with me, and for the first year or so things went well.\n  是这样的，随着苹果公司越做越大，我们雇用了一个很有才华的家伙和我一起管理这个公司，在最初的几年，公司运转得很好。\n  But then our visions of the future began to diverge and eventually we had a falling out.\n  但是后来我们对未来的看法产生了分歧，最终我们反目了。\n  When we did, out Board of Directors sided with him. And so at 30 I was out. And very publicly out. What had been the focus of my entire adult life was gone, and it was devastating.\n  当我们吵得不可开交的时候，董事会站在了他的那边。所以三十岁的那年，我离开了公司。在这么多人的眼皮下我离开了公司。我的生命的全部支柱离自己远去，这真是毁灭性的打击。\n  I really didn\u0026rsquo;t know what to do for a few months. I felt that I had let the previous generation of entrepreneurs down —— that I had dropped the baton as it was being passed to me.\n  在接下来的几个月里，我真的不知道该做些什么。我感觉自己让老一代的创业者失望了，因为我扔掉了交到自己手里的接力棒。\n  I met with David Packard and Bob Noyce and tried to apologize for screwing up so badly. I was a very public failure, and I even thought about running away from the valley.\n  我去简历戴维帕卡德和鲍勃诺伊斯，想为自己把事情搞得这么糟说声道歉。这次失败弄得沸沸扬扬的，我甚至想过逃离硅谷。\n  But something slowly began to dawn on me —— I still loved what I did.\n  但是我渐渐发现，我仍然喜爱我从事的这些东西。\n  The turn of events at Apple had not changed that one bit. I had been rejected, but I was still in love. And so I decided to start over.\n  苹果公司发生的这些事情丝毫没有改变这一点。我虽然被拒之门外，但是我仍然热爱我的事业，所以我决定从头再来。\n  I didn\u0026rsquo;t see it then, but it truned out that getting fired from Apple was the best thing that could have ever happened to me.\n  我当时并没有意识到，但事后证明，被苹果公司炒鱿鱼是我这辈子碰到最好的一件事。\n  The heaviness of being successful was replaced by the lightness of being a beginner again, less sure about everything. I freed me to enter one of the most creative periods of my life.\n  从头开始的轻松感取代了保持成功的沉重感。这让我觉得如此自由，使我进入了人生中最有创造力的一个阶段。\n  During the next five years, I started a company named NeXT, another company named Pixar, and fell in love with an amazing woman who would become my wife.\n  在接下来的五年里，我创立了一个名叫 NeXT 的公司和名叫 Pixar 的公司，与一位了不起的女人相爱，最终结婚。\n  Pixar went on to create the world\u0026rsquo;s first computer animated feature film, Toy Story, and is now the most successful animation studio in the world.\n  Pixar 推出了世界上第一个用电脑制作的动画电影 ——— 《玩具总动员》，Pixar 现在也是世界上最成功的动画制作室。\n  In a remarkable turn of events, Apple bought NeXT, and I returned to Apple, and the technology we developed at NeXT is at the heart of Apple\u0026rsquo;s current renaissance. And Laurene and I have a wonderful family together.\n  世道轮回，苹果公司收购了 NeXT，然后我又回到了苹果公司。我们在 NeXT 开发的技术成了苹果公司重新崛起的核心。我和劳伦那也建立了美满的家庭。\n  I\u0026rsquo;m pretty sure none of this would have happened if I hadn\u0026rsquo;t been fired from Apple. It was awful tasting medicine, but I guess the patient needed it.\n  我可以非常肯定地说，如果我不被苹果公司解雇，这一切决不可能发生。这是一剂苦药，但我认为苦药利于病。\n  Sometimes life is gonna hit you in the head with a brick. Don\u0026rsquo;t lose faith.\n  有时候生活会给你当头一棒，但不要灰心。\n  I\u0026rsquo;m convinced that the only thing that kept me going was that I loved what I did.You\u0026rsquo;ve got to find what you love. And that is as true for work as it is for your lovers.\n  我坚信唯一使我一直坚持下去的就是我对所做事情的无比热爱。所以你一定要清楚自己喜欢什么，选择爱人时如此，找寻工作亦如此。\n  Your work is gonna fill a large part of your life, and the only way to be truly satisfied is to do what you believe is great work. And the only way to do great work is to love what you do.\n  你的工作将会占据生活的很大的一部分。让自己真正满意的唯一方法就是做自己认为有意义的工作；做有意义的工作的唯一办法就是热爱自己的工作。\n  If you haven\u0026rsquo;t found it yet, keep looking. And don\u0026rsquo;t settle.\n  如果你吸纳在还没有发现自己喜欢什么，那就继续寻找，不要急于作出决定。\n  As with all matters of the heart, you\u0026rsquo;ll know when you find it. And, like any great relationship, it just gets better and better as the years roll on.\n  用心地去寻找，只有这样，当你发现的时候你就会感觉到。正如任何真挚的关系都是历久弥新。\n  So keep looking. Don\u0026rsquo;t settle.\n  所以继续寻找，直到找到自己喜欢的东西。\n ","permalink":"/blog/2022/01/27/loveandloss/","summary":"—— Steve Jobs My second story is about love and loss. 我的第二个故事是关于爱与得失的。 I was lucky —— I found what I loved to do early in life. 我很幸运，因为我在很早的时候就发现了自己钟爱的东西。 Woz","title":"《Love and Loss》"},{"content":" —— Steve Jobs\n  I am honored to be with you today for your commencement from one of the finest universities in the world.\n  很荣幸与大家一道参加这次的毕业典礼，斯坦福大学是世界上最好的大学之一。\n  Truth be told, I never graduated from college. And this is the closest I\u0026rsquo;ve ever gotten to a college graduation.\n  说实话，我大学还没毕业，今天是我第一次离大学毕业典礼这么近。\n  Today I want to tell you three stories from my life. That\u0026rsquo;s it. That\u0026rsquo;s it. No big deal. Just three stories.\n  今天我想向你们讲述我生活中的三个故事。不讲别的，也不是什么大道理，就只是是三个故事。\n  The first story is about connecting the dots.\n  第一个故事讲的是把点串起来。\n  I dropping out of Reed College after the first six months, but then stayed around as a drop-in for another 18 months or so before I really quit.\n  我在里德学院只读了六个月就退学了，此后便在学校当旁听生，过了一年半我才真正离开了学校。\n  So why did I drop out? It started before I was born. My biological mother was a young, unwed graduate student, and she decided to put me up for adoption.\n  我为什么要退学呢？故事要从我还未出生讲起。我的生母是一个年轻的，没有结婚的大学毕业生，因此她决定让别人收养我。\n  She felt very strongly that I should be adopted by college graduates, so everything was all set for me to be adopted at birth by a lawyer and his wife. Except that when I popped out they decided for the last minute that they really wanted a girl.\n  她非常想让我被有大学文凭的人收养。所以在我还没出生的时候，她把一切都安排好了，我一出生就交给一对律师夫妇收养。但是她没有料到，当我出生之后，律师夫妇突然决定想要一个女孩。\n  So my parents, who were on a waiting list, got a call in the middle of the night asking: \u0026ldquo;We\u0026rsquo;ve got an unexpected baby boy; do you want him?\u0026rdquo; They said: \u0026ldquo;Of course.\u0026rdquo;\n  就这样，我的养父母——当时他们还在我亲生父母的观察名单上——在半夜接到了一个电话：“我们这儿有一个期望之外的男婴，你们想要吗？”他们回答道：“当然！”\n  My biological mother found out later that my mother had never graduated from college and that my father had never graduated from high school. She refused to sign the final adoption papers.\n  随后，我的生母发现，我的养母根本没有大学毕业，而我的养父甚至连高中都没有毕业，所以她拒绝签这个收养合同。\n  She only relented a few months later when my parents promised that I would go to college. This was the start in my life.\n  不过，没过几个月，我的生母就心软了，因为我的养父母答应她一定会送我上大学。我的生活就这样开始了。\n  And 17 years later I did go to college. But I naively chose a college that was almost as expensive as Stanford, and all of my working-class parents\u0026rsquo; savings were being spent on my college tuition.\n  十七年之后，我真的上了大学。当时我很天真，选择了一所几乎和斯坦福大学一样贵的学校。我的父母都是工人，他们几乎把所有积蓄都花在了我的学费上面。\n  After six months, I couldn\u0026rsquo;t see the value in it. I had no idea what I wanted to do with my life and no idea how college was going to help me figure it out. And here I was spending all of the money my parents had saved their entire life.\n  读了六个月后，我却看不到读书的价值所在。我既不知道我一辈子想要做什么，也不清楚大学是否能帮助我找到答案，但我几乎花光了我父母这一辈子的所有积蓄。\n  So I decided to drop out and trust that it would all work out OK. It was pretty scary at the time, but looking back it was one of the best decisions I ever made.\n  所以我决定要退学，并且相信退学之后一切也能照常发展。不可否认，当时做出这个决定确实是非常的害怕，但是现在回想起来，这的确是我一生中做的最棒的一个决定。\n  The minute I dropped out I could stop taking the required classes that didn\u0026rsquo;t interest me, and begin dropping in on the ones that looked far more interesting.\n  从我退学那一刻起，我终于可以不必去读那些令我提不起丝毫兴趣的课程了，然后我开始去旁听那些看起来有意思的课程。\n  It wasn\u0026rsquo;t all romantic. I didn\u0026rsquo;t have a dorm room, so I slept on the floor in friends\u0026rsquo; rooms.\n  但是那些日子一点儿也不浪漫。我没有了宿舍，只能睡在朋友房间的地板上。\n  I returned coke bottles for the $0.05 deposits to buy food with, and I would walk the seven miles across town every Sunday night to get one good meal a week at the Hare Krishna temple.\n  我去退还可乐瓶子，用那5美分的押金买点吃的；每个星期天晚上我都要走七英里的路程，到城那头的黑尔-科里施纳寺庙去，只是为了吃上一周唯一一顿好一点的饭。\n  I loved it. And much of what I stumbled into by following my curiosity and intuition turned out to be pricelessn later on.\n  但是我喜欢这样。我凭着直觉和好奇心所干的事情，此后很多都被证明是无价之宝。\n  Let me give you one example:Reed College at that time offered perhaps the best calligraphy instruction in the country. Throughout the campus every poster, every label on every drawer, was beautifully hand calligraphed.\n  我给你们举一个例子吧：那时里德大学的书法课大概是全国最好的。大学里的每张海报和每个抽屉标签上面的字都写的很漂亮。\n  Because I had dropped out and didn\u0026rsquo;t have to take the normal classes, I decided to take a calligraphy class to learn how to do this.\n  我因为退学了，不用正常上课，所以决定去参加书法课程，好好学学写字。\n  I learned about serif and san serif typefaces, about varying the amount of space between different letter combinations, about what makes great typography great.\n  我学会了带衬线和不带衬线的字体，根据不同字母调整间距以及怎样把版式调得很漂亮。\n  It was beautiful, historical, artistically subtle in a way that science can\u0026rsquo;t capture, and I found it fascinating.\n  这门课太棒了，是一种科学永远不能捕捉到的既美丽又富有历史价值的艺术精妙。\n  None of this had even a hope of any practical application in my life. But ten years later, when we were designing the first Macintosh computer, it all came back to me. And we designed it all into the Mac. It was the first computer with beautiful typography.\n  当时我并不指望书法能有什么实际应用的价值。但是十年之后，当我们在设计第一台 Macintosh 电脑的时候，所学的一切都浮现在我的眼前。我把这些东西全都设计进了 Mac。那是第一台有这么漂亮的文字版式的电脑。\n  If I had never dropped in on that single course in college, the Mac would have never had multiple typefaces or proportionally spaced fonts. And since Windows just copied the Mac, it\u0026rsquo;s likely that no personal computer would have them.\n  如果我当时没有参加这个书法课程，Mac就不会有这么多丰富的字体以及合理的字体间距。要不是 Windows 照搬了 Macintosh，现在个人电脑就不会有现在这么美妙的字形了。\n  If I had never dropped out, I would have never dropped in on that calligraphy class, and personal computers might not have the wonderful typography that they do.\n  如果我没有退学，我绝不会选了这门书法课，个人电脑也就不会有现在这些漂亮的版式了。\n  Of course it was impossible to connect the dots looking forward when I was in college. But it was very, very clear looking backwards 10 years later.\n  当然我在大学的时候，还不可能把从前的点点滴滴串联起来，但是当我十年后回顾这一切的时候，真的豁然开朗了。\n  Again, you can\u0026rsquo;t connect the dots looking forward; you can only connect them looking backwards.\n  你在向前展望的时候不可能将这些片段串联起来；你只能在回顾的时候才能将点点滴滴串联起来。\n  So you have to trust that the dots will somehow connect in your future. You have to trust in something——your gut, destiny, life, karma, whatever.\n  所以你要相信这些片段会在你未来的某一天串联起来。你必须要相信的直觉、归宿、生活和命运。\n  Because believing that the dots will connect down the road will give you the configdence to follow your heart even when it leads you off the well-worn path and that will make all the difference.\n  因为相信这些点滴会串成前行的道路能给你跟从内心的自信，让你远离平凡，变得与众不同。\n ","permalink":"/blog/2022/01/26/connectthedots/","summary":"—— Steve Jobs I am honored to be with you today for your commencement from one of the finest universities in the world. 很荣幸与大家一道参加这次的毕业典礼，斯坦福大学是世界上最好的大学之一。 Truth be told, I never graduated from college. And this is","title":"《Connecting the dots》"},{"content":"","permalink":"/blog/2022/01/23/%E7%88%B1%E8%87%AA%E5%B7%B1/","summary":"","title":"爱自己"},{"content":"转载自https://github.com/huihut/interview\n 各大设计模式例子参考：CSDN专栏 . C++ 设计模式 系列博文\n 设计模式工程目录\n单例模式 单例模式例子\n抽象工厂模式 抽象工厂模式例子\n适配器模式 适配器模式例子\n桥接模式 桥接模式例子\n观察者模式 观察者模式例子\n设计模式的六大原则  单一职责原则（SRP，Single Responsibility Principle） 里氏替换原则（LSP，Liskov Substitution Principle） 依赖倒置原则（DIP，Dependence Inversion Principle） 接口隔离原则（ISP，Interface Segregation Principle） 迪米特法则（LoD，Law of Demeter） 开放封闭原则（OCP，Open Close Principle）  ","permalink":"/collection/design-pattern/","summary":"转载自https://github.com/huihut/interview 各大设计模式例子参考：CSDN专栏 . C++ 设计模式 系列博文 设计模式工","title":"【转载】C++ 开发必备之设计模式"},{"content":"转载自https://github.com/huihut/interview\n 本节部分知识点来自《程序员的自我修养——链接装载库》\n 内存、栈、堆 一般应用程序内存空间有如下区域：\n 栈：由操作系统自动分配释放，存放函数的参数值、局部变量等的值，用于维护函数调用的上下文 堆：一般由程序员分配释放，若程序员不释放，程序结束时可能由操作系统回收，用来容纳应用程序动态分配的内存区域 可执行文件映像：存储着可执行文件在内存中的映像，由装载器装载是将可执行文件的内存读取或映射到这里 保留区：保留区并不是一个单一的内存区域，而是对内存中受到保护而禁止访问的内存区域的总称，如通常 C 语言讲无效指针赋值为 0（NULL），因此 0 地址正常情况下不可能有效的访问数据  栈 栈保存了一个函数调用所需要的维护信息，常被称为堆栈帧（Stack Frame）或活动记录（Activate Record），一般包含以下几方面：\n 函数的返回地址和参数 临时变量：包括函数的非静态局部变量以及编译器自动生成的其他临时变量 保存上下文：包括函数调用前后需要保持不变的寄存器  堆 堆分配算法：\n 空闲链表（Free List） 位图（Bitmap） 对象池  “段错误（segment fault）” 或 “非法操作，该内存地址不能 read/write” 典型的非法指针解引用造成的错误。当指针指向一个不允许读写的内存地址，而程序却试图利用指针来读或写该地址时，会出现这个错误。\n普遍原因：\n 将指针初始化为 NULL，之后没有给它一个合理的值就开始使用指针 没用初始化栈中的指针，指针的值一般会是随机数，之后就直接开始使用指针  编译链接 各平台文件格式    平台 可执行文件 目标文件 动态库/共享对象 静态库     Windows exe obj dll lib   Unix/Linux ELF、out o so a   Mac Mach-O o dylib、tbd、framework a、framework    编译链接过程  预编译（预编译器处理如 #include、#define 等预编译指令，生成 .i 或 .ii 文件） 编译（编译器进行词法分析、语法分析、语义分析、中间代码生成、目标代码生成、优化，生成 .s 文件） 汇编（汇编器把汇编码翻译成机器码，生成 .o 文件） 链接（连接器进行地址和空间分配、符号决议、重定位，生成 .out 文件）   现在版本 GCC 把预编译和编译合成一步，预编译编译程序 cc1、汇编器 as、连接器 ld\n  MSVC 编译环境，编译器 cl、连接器 link、可执行文件查看器 dumpbin\n 目标文件 编译器编译源代码后生成的文件叫做目标文件。目标文件从结构上讲，它是已经编译后的可执行文件格式，只是还没有经过链接的过程，其中可能有些符号或有些地址还没有被调整。\n 可执行文件（Windows 的 .exe 和 Linux 的 ELF）、动态链接库（Windows 的 .dll 和 Linux 的 .so）、静态链接库（Windows 的 .lib 和 Linux 的 .a）都是按照可执行文件格式存储（Windows 按照 PE-COFF，Linux 按照 ELF）\n 目标文件格式  Windows 的 PE（Portable Executable），或称为 PE-COFF，.obj 格式 Linux 的 ELF（Executable Linkable Format），.o 格式 Intel/Microsoft 的 OMF（Object Module Format） Unix 的 a.out 格式 MS-DOS 的 .COM 格式   PE 和 ELF 都是 COFF（Common File Format）的变种\n 目标文件存储结构    段 功能     File Header 文件头，描述整个文件的文件属性（包括文件是否可执行、是静态链接或动态连接及入口地址、目标硬件、目标操作系统等）   .text section 代码段，执行语句编译成的机器代码   .data section 数据段，已初始化的全局变量和局部静态变量   .bss section BSS 段（Block Started by Symbol），未初始化的全局变量和局部静态变量（因为默认值为 0，所以只是在此预留位置，不占空间）   .rodata section 只读数据段，存放只读数据，一般是程序里面的只读变量（如 const 修饰的变量）和字符串常量   .comment section 注释信息段，存放编译器版本信息   .note.GNU-stack section 堆栈提示段     其他段略\n 链接的接口————符号 在链接中，目标文件之间相互拼合实际上是目标文件之间对地址的引用，即对函数和变量的地址的引用。我们将函数和变量统称为符号（Symbol），函数名或变量名就是符号名（Symbol Name）。\n如下符号表（Symbol Table）：\n   Symbol（符号名） Symbol Value （地址）     main 0x100   Add 0x123   \u0026hellip; \u0026hellip;    Linux 的共享库（Shared Library） Linux 下的共享库就是普通的 ELF 共享对象。\n共享库版本更新应该保证二进制接口 ABI（Application Binary Interface）的兼容\n命名 libname.so.x.y.z\n x：主版本号，不同主版本号的库之间不兼容，需要重新编译 y：次版本号，高版本号向后兼容低版本号 z：发布版本号，不对接口进行更改，完全兼容  路径 大部分包括 Linux 在内的开源系统遵循 FHS（File Hierarchy Standard）的标准，这标准规定了系统文件如何存放，包括各个目录结构、组织和作用。\n /lib：存放系统最关键和最基础的共享库，如动态链接器、C 语言运行库、数学库等 /usr/lib：存放非系统运行时所需要的关键性的库，主要是开发库 /usr/local/lib：存放跟操作系统本身并不十分相关的库，主要是一些第三方应用程序的库   动态链接器会在 /lib、/usr/lib 和由 /etc/ld.so.conf 配置文件指定的，目录中查找共享库\n 环境变量  LD_LIBRARY_PATH：临时改变某个应用程序的共享库查找路径，而不会影响其他应用程序 LD_PRELOAD：指定预先装载的一些共享库甚至是目标文件 LD_DEBUG：打开动态链接器的调试功能  so 共享库的编写 使用 CLion 编写共享库\n创建一个名为 MySharedLib 的共享库\nCMakeLists.txt\ncmake_minimum_required(VERSION 3.10)project(MySharedLib)set(CMAKE_CXX_STANDARD 11)add_library(MySharedLib SHARED library.cpp library.h)library.h\n#ifndef MYSHAREDLIB_LIBRARY_H #define MYSHAREDLIB_LIBRARY_H  // 打印 Hello World! void hello(); // 使用可变模版参数求和 template \u0026lt;typename T\u0026gt; T sum(T t) { return t; } template \u0026lt;typename T, typename ...Types\u0026gt; T sum(T first, Types ... rest) { return first + sum\u0026lt;T\u0026gt;(rest...); } #endif library.cpp\n#include \u0026lt;iostream\u0026gt;#include \u0026#34;library.h\u0026#34; void hello() { std::cout \u0026lt;\u0026lt; \u0026#34;Hello, World!\u0026#34; \u0026lt;\u0026lt; std::endl; } so 共享库的使用（被可执行项目调用） 使用 CLion 调用共享库\n创建一个名为 TestSharedLib 的可执行项目\nCMakeLists.txt\ncmake_minimum_required(VERSION 3.10)project(TestSharedLib)# C++11 编译 set(CMAKE_CXX_STANDARD 11)# 头文件路径 set(INC_DIR /home/xx/code/clion/MySharedLib)# 库文件路径 set(LIB_DIR /home/xx/code/clion/MySharedLib/cmake-build-debug)include_directories(${INC_DIR})link_directories(${LIB_DIR})link_libraries(MySharedLib)add_executable(TestSharedLib main.cpp)# 链接 MySharedLib 库 target_link_libraries(TestSharedLib MySharedLib)main.cpp\n#include \u0026lt;iostream\u0026gt;#include \u0026#34;library.h\u0026#34;using std::cout; using std::endl; int main() { hello(); cout \u0026lt;\u0026lt; \u0026#34;1 + 2 = \u0026#34; \u0026lt;\u0026lt; sum(1,2) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;1 + 2 + 3 = \u0026#34; \u0026lt;\u0026lt; sum(1,2,3) \u0026lt;\u0026lt; endl; return 0; } 执行结果\nHello, World! 1 + 2 = 3 1 + 2 + 3 = 6 Windows 应用程序入口函数  GUI（Graphical User Interface）应用，链接器选项：/SUBSYSTEM:WINDOWS CUI（Console User Interface）应用，链接器选项：/SUBSYSTEM:CONSOLE  _tWinMain 与 _tmain 函数声明\nInt WINAPI _tWinMain( HINSTANCE hInstanceExe, HINSTANCE, PTSTR pszCmdLine, int nCmdShow); int _tmain( int argc, TCHAR *argv[], TCHAR *envp[]);    应用程序类型 入口点函数 嵌入可执行文件的启动函数     处理ANSI字符（串）的GUI应用程序 _tWinMain(WinMain) WinMainCRTSartup   处理Unicode字符（串）的GUI应用程序 _tWinMain(wWinMain) wWinMainCRTSartup   处理ANSI字符（串）的CUI应用程序 _tmain(Main) mainCRTSartup   处理Unicode字符（串）的CUI应用程序 _tmain(wMain) wmainCRTSartup   动态链接库（Dynamic-Link Library） DllMain _DllMainCRTStartup    Windows 的动态链接库（Dynamic-Link Library）  部分知识点来自《Windows 核心编程（第五版）》\n 用处  扩展了应用程序的特性 简化了项目管理 有助于节省内存 促进了资源的共享 促进了本地化 有助于解决平台间的差异 可以用于特殊目的  注意  创建 DLL，事实上是在创建可供一个可执行模块调用的函数 当一个模块提供一个内存分配函数（malloc、new）的时候，它必须同时提供另一个内存释放函数（free、delete） 在使用 C 和 C++ 混编的时候，要使用 extern \u0026ldquo;C\u0026rdquo; 修饰符 一个 DLL 可以导出函数、变量（避免导出）、C++ 类（导出导入需要同编译器，否则避免导出） DLL 模块：cpp 文件中的 __declspec(dllexport) 写在 include 头文件之前 调用 DLL 的可执行模块：cpp 文件的 __declspec(dllimport) 之前不应该定义 MYLIBAPI  加载 Windows 程序的搜索顺序  包含可执行文件的目录 Windows 的系统目录，可以通过 GetSystemDirectory 得到 16 位的系统目录，即 Windows 目录中的 System 子目录 Windows 目录，可以通过 GetWindowsDirectory 得到 进程的当前目录 PATH 环境变量中所列出的目录  DLL 入口函数 DllMain 函数\nBOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved) { switch(fdwReason) { case DLL_PROCESS_ATTACH: // 第一次将一个DLL映射到进程地址空间时调用  // The DLL is being mapped into the process\u0026#39; address space.  break; case DLL_THREAD_ATTACH: // 当进程创建一个线程的时候，用于告诉DLL执行与线程相关的初始化（非主线程执行）  // A thread is bing created.  break; case DLL_THREAD_DETACH: // 系统调用 ExitThread 线程退出前，即将终止的线程通过告诉DLL执行与线程相关的清理  // A thread is exiting cleanly.  break; case DLL_PROCESS_DETACH: // 将一个DLL从进程的地址空间时调用  // The DLL is being unmapped from the process\u0026#39; address space.  break; } return (TRUE); // Used only for DLL_PROCESS_ATTACH } 载入卸载库 LoadLibrary、LoadLibraryExA、LoadPackagedLibrary、FreeLibrary、FreeLibraryAndExitThread 函数声明\n// 载入库 HMODULE WINAPI LoadLibrary( _In_ LPCTSTR lpFileName ); HMODULE LoadLibraryExA( LPCSTR lpLibFileName, HANDLE hFile, DWORD dwFlags ); // 若要在通用 Windows 平台（UWP）应用中加载 Win32 DLL，需要调用 LoadPackagedLibrary，而不是 LoadLibrary 或 LoadLibraryEx HMODULE LoadPackagedLibrary( LPCWSTR lpwLibFileName, DWORD Reserved ); // 卸载库 BOOL WINAPI FreeLibrary( _In_ HMODULE hModule ); // 卸载库和退出线程 VOID WINAPI FreeLibraryAndExitThread( _In_ HMODULE hModule, _In_ DWORD dwExitCode ); 显示地链接到导出符号 GetProcAddress 函数声明\nFARPROC GetProcAddress( HMODULE hInstDll, PCSTR pszSymbolName // 只能接受 ANSI 字符串，不能是 Unicode ); DumpBin.exe 查看 DLL 信息 在 VS 的开发人员命令提示符 使用 DumpBin.exe 可查看 DLL 库的导出段（导出的变量、函数、类名的符号）、相对虚拟地址（RVA，relative virtual address）。如：\nDUMPBIN -exports D:\\mydll.dll LoadLibrary 与 FreeLibrary 流程图 LoadLibrary 与 FreeLibrary 流程图\nLoadLibrary FreeLibrary DLL 库的编写（导出一个 DLL 模块） DLL 库的编写（导出一个 DLL 模块） DLL 头文件\n// MyLib.h  #ifdef MYLIBAPI  // MYLIBAPI 应该在全部 DLL 源文件的 include \u0026#34;Mylib.h\u0026#34; 之前被定义 // 全部函数/变量正在被导出  #else  // 这个头文件被一个exe源代码模块包含，意味着全部函数/变量被导入 #define MYLIBAPI extern \u0026#34;C\u0026#34; __declspec(dllimport)  #endif  // 这里定义任何的数据结构和符号  // 定义导出的变量（避免导出变量） MYLIBAPI int g_nResult; // 定义导出函数原型 MYLIBAPI int Add(int nLeft, int nRight); DLL 源文件\n// MyLibFile1.cpp  // 包含标准Windows和C运行时头文件 #include \u0026lt;windows.h\u0026gt; // DLL源码文件导出的函数和变量 #define MYLIBAPI extern \u0026#34;C\u0026#34; __declspec(dllexport)  // 包含导出的数据结构、符号、函数、变量 #include \u0026#34;MyLib.h\u0026#34; // 将此DLL源代码文件的代码放在此处 int g_nResult; int Add(int nLeft, int nRight) { g_nResult = nLeft + nRight; return g_nResult; } DLL 库的使用（运行时动态链接 DLL） DLL 库的使用（运行时动态链接 DLL）\n// A simple program that uses LoadLibrary and // GetProcAddress to access myPuts from Myputs.dll.  #include \u0026lt;windows.h\u0026gt; #include \u0026lt;stdio.h\u0026gt;  typedef int (__cdecl *MYPROC)(LPWSTR); int main( void ) { HINSTANCE hinstLib; MYPROC ProcAdd; BOOL fFreeResult, fRunTimeLinkSuccess = FALSE; // Get a handle to the DLL module.  hinstLib = LoadLibrary(TEXT(\u0026#34;MyPuts.dll\u0026#34;)); // If the handle is valid, try to get the function address.  if (hinstLib != NULL) { ProcAdd = (MYPROC) GetProcAddress(hinstLib, \u0026#34;myPuts\u0026#34;); // If the function address is valid, call the function.  if (NULL != ProcAdd) { fRunTimeLinkSuccess = TRUE; (ProcAdd) (L\u0026#34;Message sent to the DLL function\\n\u0026#34;); } // Free the DLL module.  fFreeResult = FreeLibrary(hinstLib); } // If unable to call the DLL function, use an alternative.  if (! fRunTimeLinkSuccess) printf(\u0026#34;Message printed from executable\\n\u0026#34;); return 0; } 运行库（Runtime Library） 典型程序运行步骤  操作系统创建进程，把控制权交给程序的入口（往往是运行库中的某个入口函数） 入口函数对运行库和程序运行环境进行初始化（包括堆、I/O、线程、全局变量构造等等）。 入口函数初始化后，调用 main 函数，正式开始执行程序主体部分。 main 函数执行完毕后，返回到入口函数进行清理工作（包括全局变量析构、堆销毁、关闭I/O等），然后进行系统调用结束进程。   一个程序的 I/O 指代程序与外界的交互，包括文件、管程、网络、命令行、信号等。更广义地讲，I/O 指代操作系统理解为 “文件” 的事物。\n glibc 入口 _start -\u0026gt; __libc_start_main -\u0026gt; exit -\u0026gt; _exit\n其中 main(argc, argv, __environ) 函数在 __libc_start_main 里执行。\nMSVC CRT 入口 int mainCRTStartup(void)\n执行如下操作：\n 初始化和 OS 版本有关的全局变量。 初始化堆。 初始化 I/O。 获取命令行参数和环境变量。 初始化 C 库的一些数据。 调用 main 并记录返回值。 检查错误并将 main 的返回值返回。  C 语言运行库（CRT） 大致包含如下功能：\n 启动与退出：包括入口函数及入口函数所依赖的其他函数等。 标准函数：有 C 语言标准规定的C语言标准库所拥有的函数实现。 I/O：I/O 功能的封装和实现。 堆：堆的封装和实现。 语言实现：语言中一些特殊功能的实现。 调试：实现调试功能的代码。  C语言标准库（ANSI C） 包含：\n 标准输入输出（stdio.h） 文件操作（stdio.h） 字符操作（ctype.h） 字符串操作（string.h） 数学函数（math.h） 资源管理（stdlib.h） 格式转换（stdlib.h） 时间/日期（time.h） 断言（assert.h） 各种类型上的常数（limits.h \u0026amp; float.h） 变长参数（stdarg.h） 非局部跳转（setjmp.h）  ","permalink":"/collection/library/","summary":"转载自https://github.com/huihut/interview 本节部分知识点来自《程序员的自我修养——链接装载库》 内存、栈、堆","title":"【转载】C++ 开发必备之链接装载库"},{"content":"转载自https://github.com/huihut/interview\n 本节部分知识点来自《数据库系统概论（第 5 版）》\n 基本概念  数据（data）：描述事物的符号记录称为数据。 数据库（DataBase，DB）：是长期存储在计算机内、有组织的、可共享的大量数据的集合，具有永久存储、有组织、可共享三个基本特点。 数据库管理系统（DataBase Management System，DBMS）：是位于用户与操作系统之间的一层数据管理软件。 数据库系统（DataBase System，DBS）：是有数据库、数据库管理系统（及其应用开发工具）、应用程序和数据库管理员（DataBase Administrator DBA）组成的存储、管理、处理和维护数据的系统。 实体（entity）：客观存在并可相互区别的事物称为实体。 属性（attribute）：实体所具有的某一特性称为属性。 码（key）：唯一标识实体的属性集称为码。 实体型（entity type）：用实体名及其属性名集合来抽象和刻画同类实体，称为实体型。 实体集（entity set）：同一实体型的集合称为实体集。 联系（relationship）：实体之间的联系通常是指不同实体集之间的联系。 模式（schema）：模式也称逻辑模式，是数据库全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。 外模式（external schema）：外模式也称子模式（subschema）或用户模式，它是数据库用户（包括应用程序员和最终用户）能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图，是与某一应用有关的数据的逻辑表示。 内模式（internal schema）：内模式也称为存储模式（storage schema），一个数据库只有一个内模式。他是数据物理结构和存储方式的描述，是数据库在数据库内部的组织方式。  常用数据模型  层次模型（hierarchical model） 网状模型（network model） 关系模型（relational model）  关系（relation）：一个关系对应通常说的一张表 元组（tuple）：表中的一行即为一个元组 属性（attribute）：表中的一列即为一个属性 码（key）：表中可以唯一确定一个元组的某个属性组 域（domain）：一组具有相同数据类型的值的集合 分量：元组中的一个属性值 关系模式：对关系的描述，一般表示为 关系名(属性1, 属性2, ..., 属性n)   面向对象数据模型（object oriented data model） 对象关系数据模型（object relational data model） 半结构化数据模型（semistructure data model）  常用 SQL 操作   对象类型 对象 操作类型   数据库模式 模式 CREATE SCHEMA   基本表 CREATE SCHEMA，ALTER TABLE   视图 CREATE VIEW   索引 CREATE INDEX   数据 基本表和视图 SELECT，INSERT，UPDATE，DELETE，REFERENCES，ALL PRIVILEGES   属性列 SELECT，INSERT，UPDATE，REFERENCES，ALL PRIVILEGES    SQL 语法教程：runoob . SQL 教程\n 关系型数据库  基本关系操作：查询（选择、投影、连接（等值连接、自然连接、外连接（左外连接、右外连接））、除、并、差、交、笛卡尔积等）、插入、删除、修改 关系模型中的三类完整性约束：实体完整性、参照完整性、用户定义的完整性  索引  数据库索引：顺序索引、B+ 树索引、hash 索引 MySQL 索引背后的数据结构及算法原理  数据库完整性  数据库的完整性是指数据的正确性和相容性。  完整性：为了防止数据库中存在不符合语义（不正确）的数据。 安全性：为了保护数据库防止恶意破坏和非法存取。   触发器：是用户定义在关系表中的一类由事件驱动的特殊过程。  关系数据理论  数据依赖是一个关系内部属性与属性之间的一种约束关系，是通过属性间值的相等与否体现出来的数据间相关联系。 最重要的数据依赖：函数依赖、多值依赖。  范式  第一范式（1NF）：属性（字段）是最小单位不可再分。 第二范式（2NF）：满足 1NF，每个非主属性完全依赖于主键（消除 1NF 非主属性对码的部分函数依赖）。 第三范式（3NF）：满足 2NF，任何非主属性不依赖于其他非主属性（消除 2NF 非主属性对码的传递函数依赖）。 鲍依斯-科得范式（BCNF）：满足 3NF，任何非主属性不能对主键子集依赖（消除 3NF 主属性对码的部分和传递函数依赖）。 第四范式（4NF）：满足 3NF，属性之间不能有非平凡且非函数依赖的多值依赖（消除 3NF 非平凡且非函数依赖的多值依赖）。  数据库恢复  事务：是用户定义的一个数据库操作序列，这些操作要么全做，要么全不做，是一个不可分割的工作单位。 事物的 ACID 特性：原子性、一致性、隔离性、持续性。 恢复的实现技术：建立冗余数据 -\u0026gt; 利用冗余数据实施数据库恢复。 建立冗余数据常用技术：数据转储（动态海量转储、动态增量转储、静态海量转储、静态增量转储）、登记日志文件。  并发控制  事务是并发控制的基本单位。 并发操作带来的数据不一致性包括：丢失修改、不可重复读、读 “脏” 数据。 并发控制主要技术：封锁、时间戳、乐观控制法、多版本并发控制等。 基本封锁类型：排他锁（X 锁 / 写锁）、共享锁（S 锁 / 读锁）。 活锁死锁：  活锁：事务永远处于等待状态，可通过先来先服务的策略避免。 死锁：事务永远不能结束  预防：一次封锁法、顺序封锁法； 诊断：超时法、等待图法； 解除：撤销处理死锁代价最小的事务，并释放此事务的所有的锁，使其他事务得以继续运行下去。     可串行化调度：多个事务的并发执行是正确的，当且仅当其结果与按某一次序串行地执行这些事务时的结果相同。可串行性时并发事务正确调度的准则。  ","permalink":"/collection/database/","summary":"转载自https://github.com/huihut/interview 本节部分知识点来自《数据库系统概论（第 5 版）》 基本概念 数据（da","title":"【转载】C++ 开发必备之数据库"},{"content":"转载自https://github.com/huihut/interview\n 本节部分知识点来自《计算机网络（第 7 版）》\n 计算机网络体系结构：\n各层作用及协议    分层 作用 协议     物理层 通过媒介传输比特，确定机械及电气规范（比特 Bit） RJ45、CLOCK、IEEE802.3（中继器，集线器）   数据链路层 将比特组装成帧和点到点的传递（帧 Frame） PPP、FR、HDLC、VLAN、MAC（网桥，交换机）   网络层 负责数据包从源到宿的传递和网际互连（包 Packet） IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP（路由器）   运输层 提供端到端的可靠报文传递和错误恢复（ 段Segment） TCP、UDP、SPX   会话层 建立、管理和终止会话（会话协议数据单元 SPDU） NFS、SQL、NETBIOS、RPC   表示层 对数据进行翻译、加密和压缩（表示协议数据单元 PPDU） JPEG、MPEG、ASII   应用层 允许访问OSI环境的手段（应用协议数据单元 APDU） FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS    物理层  传输数据的单位：比特 数据传输系统：源系统（源点、发送器） \u0026ndash;\u0026gt; 传输系统 \u0026ndash;\u0026gt; 目的系统（接收器、终点）  通道：\n 单向通道（单工通道）：只有一个方向通信，没有反方向交互，如广播 双向交替通信（半双工通信）：通信双方都可发消息，但不能同时发送或接收 双向同时通信（全双工通信）：通信双方可以同时发送和接收信息  通道复用技术：\n 频分复用（FDM，Frequency Division Multiplexing）：不同用户在不同频带，所用用户在同样时间占用不同带宽资源 时分复用（TDM，Time Division Multiplexing）：不同用户在同一时间段的不同时间片，所有用户在不同时间占用同样的频带宽度 波分复用（WDM，Wavelength Division Multiplexing）：光的频分复用 码分复用（CDM，Code Division Multiplexing）：不同用户使用不同的码，可以在同样时间使用同样频带通信  数据链路层 主要信道：\n 点对点信道 广播信道  点对点信道  数据单元：帧  三个基本问题：\n 封装成帧：把网络层的 IP 数据报封装成帧，SOH - 数据部分 - EOT 透明传输：不管数据部分什么字符，都能传输出去；可以通过字节填充方法解决（冲突字符前加转义字符） 差错检测：降低误码率（BER，Bit Error Rate），广泛使用循环冗余检测（CRC，Cyclic Redundancy Check）  点对点协议（Point-to-Point Protocol）：\n 点对点协议（Point-to-Point Protocol）：用户计算机和 ISP 通信时所使用的协议  广播信道 广播通信：\n 硬件地址（物理地址、MAC 地址） 单播（unicast）帧（一对一）：收到的帧的 MAC 地址与本站的硬件地址相同 广播（broadcast）帧（一对全体）：发送给本局域网上所有站点的帧 多播（multicast）帧（一对多）：发送给本局域网上一部分站点的帧  网络层  IP（Internet Protocol，网际协议）是为计算机网络相互连接进行通信而设计的协议。 ARP（Address Resolution Protocol，地址解析协议） ICMP（Internet Control Message Protocol，网际控制报文协议） IGMP（Internet Group Management Protocol，网际组管理协议）  IP 网际协议 IP 地址分类：\n IP 地址 ::= {\u0026lt;网络号\u0026gt;,\u0026lt;主机号\u0026gt;}     IP 地址类别 网络号 网络范围 主机号 IP 地址范围     A 类 8bit，第一位固定为 0 0 —— 127 24bit 1.0.0.0 —— 127.255.255.255   B 类 16bit，前两位固定为 10 128.0 —— 191.255 16bit 128.0.0.0 —— 191.255.255.255   C 类 24bit，前三位固定为 110 192.0.0 —— 223.255.255 8bit 192.0.0.0 —— 223.255.255.255   D 类 前四位固定为 1110，后面为多播地址      E 类 前五位固定为 11110，后面保留为今后所用       IP 数据报格式：\nICMP 网际控制报文协议 ICMP 报文格式：\n应用：\n PING（Packet InterNet Groper，分组网间探测）测试两个主机之间的连通性 TTL（Time To Live，生存时间）该字段指定 IP 包被路由器丢弃之前允许通过的最大网段数量  内部网关协议  RIP（Routing Information Protocol，路由信息协议） OSPF（Open Sortest Path First，开放最短路径优先）  外部网关协议  BGP（Border Gateway Protocol，边界网关协议）  IP多播  IGMP（Internet Group Management Protocol，网际组管理协议） 多播路由选择协议  VPN 和 NAT  VPN（Virtual Private Network，虚拟专用网） NAT（Network Address Translation，网络地址转换）  路由表包含什么？  网络 ID（Network ID, Network number）：就是目标地址的网络 ID。 子网掩码（subnet mask）：用来判断 IP 所属网络 下一跳地址/接口（Next hop / interface）：就是数据在发送到目标地址的旅途中下一站的地址。其中 interface 指向 next hop（即为下一个 route）。一个自治系统（AS, Autonomous system）中的 route 应该包含区域内所有的子网络，而默认网关（Network id: 0.0.0.0, Netmask: 0.0.0.0）指向自治系统的出口。  根据应用和执行的不同，路由表可能含有如下附加信息：\n 花费（Cost）：就是数据发送过程中通过路径所需要的花费。 路由的服务质量 路由中需要过滤的出/入连接列表  运输层 协议：\n TCP（Transmission Control Protocol，传输控制协议） UDP（User Datagram Protocol，用户数据报协议）  端口：\n   应用程序 FTP TELNET SMTP DNS TFTP HTTP HTTPS SNMP     端口号 21 23 25 53 69 80 443 161    TCP  TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议，其传输的单位是报文段。  特征：\n 面向连接 只能点对点（一对一）通信 可靠交互 全双工通信 面向字节流  TCP 如何保证可靠传输：\n 确认和超时重传 数据合理分片和排序 流量控制 拥塞控制 数据校验  TCP 报文结构\nTCP 首部\nTCP：状态控制码（Code，Control Flag），占 6 比特，含义如下：\n URG：紧急比特（urgent），当 URG＝1 时，表明紧急指针字段有效，代表该封包为紧急封包。它告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据)， 且上图中的 Urgent Pointer 字段也会被启用。 ACK：确认比特（Acknowledge）。只有当 ACK＝1 时确认号字段才有效，代表这个封包为确认封包。当 ACK＝0 时，确认号无效。 PSH：（Push function）若为 1 时，代表要求对方立即传送缓冲区内的其他对应封包，而无需等缓冲满了才送。 RST：复位比特(Reset)，当 RST＝1 时，表明 TCP 连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接。 SYN：同步比特(Synchronous)，SYN 置为 1，就表示这是一个连接请求或连接接受报文，通常带有 SYN 标志的封包表示『主动』要连接到对方的意思。 FIN：终止比特(Final)，用来释放一个连接。当 FIN＝1 时，表明此报文段的发送端的数据已发送完毕，并要求释放运输连接。  UDP  UDP（User Datagram Protocol，用户数据报协议）是 OSI（Open System Interconnection 开放式系统互联） 参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务，其传输的单位是用户数据报。  特征：\n 无连接 尽最大努力交付 面向报文 没有拥塞控制 支持一对一、一对多、多对一、多对多的交互通信 首部开销小  UDP 报文结构\nUDP 首部\n TCP/UDP 图片来源于：https://github.com/JerryC8080/understand-tcp-udp\n TCP 与 UDP 的区别  TCP 面向连接，UDP 是无连接的； TCP 提供可靠的服务，也就是说，通过 TCP 连接传送的数据，无差错，不丢失，不重复，且按序到达；UDP 尽最大努力交付，即不保证可靠交付 TCP 的逻辑通信信道是全双工的可靠信道；UDP 则是不可靠信道 每一条 TCP 连接只能是点到点的；UDP 支持一对一，一对多，多对一和多对多的交互通信 TCP 面向字节流（可能出现黏包问题），实际上是 TCP 把数据看成一连串无结构的字节流；UDP 是面向报文的（不会出现黏包问题） UDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如 IP 电话，实时视频会议等） TCP 首部开销20字节；UDP 的首部开销小，只有 8 个字节  TCP 黏包问题 原因 TCP 是一个基于字节流的传输服务（UDP 基于报文的），“流” 意味着 TCP 所传输的数据是没有边界的。所以可能会出现两个数据包黏在一起的情况。\n解决  发送定长包。如果每个消息的大小都是一样的，那么在接收对等方只要累计接收数据，直到数据等于一个定长的数值就将它作为一个消息。 包头加上包体长度。包头是定长的 4 个字节，说明了包体的长度。接收对等方先接收包头长度，依据包头长度来接收包体。 在数据包之间设置边界，如添加特殊符号 \\r\\n 标记。FTP 协议正是这么做的。但问题在于如果数据正文中也含有 \\r\\n，则会误判为消息的边界。 使用更加复杂的应用层协议。  TCP 流量控制 概念 流量控制（flow control）就是让发送方的发送速率不要太快，要让接收方来得及接收。\n方法 利用可变窗口进行流量控制\nTCP 拥塞控制 概念 拥塞控制就是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。\n方法  慢开始( slow-start ) 拥塞避免( congestion avoidance ) 快重传( fast retransmit ) 快恢复( fast recovery )  TCP的拥塞控制图\nTCP 传输连接管理  因为 TCP 三次握手建立连接、四次挥手释放连接很重要，所以附上《计算机网络（第 7 版）-谢希仁》书中对此章的详细描述：https://gitee.com/huihut/interview/raw/master/images/TCP-transport-connection-management.png\n TCP 三次握手建立连接 【TCP 建立连接全过程解释】\n 客户端发送 SYN 给服务器，说明客户端请求建立连接； 服务端收到客户端发的 SYN，并回复 SYN+ACK 给客户端（同意建立连接）； 客户端收到服务端的 SYN+ACK 后，回复 ACK 给服务端（表示客户端收到了服务端发的同意报文）； 服务端收到客户端的 ACK，连接已建立，可以数据传输。  TCP 为什么要进行三次握手？ 【答案一】因为信道不可靠，而 TCP 想在不可靠信道上建立可靠地传输，那么三次通信是理论上的最小值。（而 UDP 则不需建立可靠传输，因此 UDP 不需要三次握手。）\n Google Groups . TCP 建立连接为什么是三次握手？{技术}{网络通信}\n 【答案二】因为双方都需要确认对方收到了自己发送的序列号，确认过程最少要进行三次通信。\n 知乎 . TCP 为什么是三次握手，而不是两次或四次？\n 【答案三】为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。\n 《计算机网络（第 7 版）-谢希仁》\n TCP 四次挥手释放连接 【TCP 释放连接全过程解释】\n 客户端发送 FIN 给服务器，说明客户端不必发送数据给服务器了（请求释放从客户端到服务器的连接）； 服务器接收到客户端发的 FIN，并回复 ACK 给客户端（同意释放从客户端到服务器的连接）； 客户端收到服务端回复的 ACK，此时从客户端到服务器的连接已释放（但服务端到客户端的连接还未释放，并且客户端还可以接收数据）； 服务端继续发送之前没发完的数据给客户端； 服务端发送 FIN+ACK 给客户端，说明服务端发送完了数据（请求释放从服务端到客户端的连接，就算没收到客户端的回复，过段时间也会自动释放）； 客户端收到服务端的 FIN+ACK，并回复 ACK 给客户端（同意释放从服务端到客户端的连接）； 服务端收到客户端的 ACK 后，释放从服务端到客户端的连接。  TCP 为什么要进行四次挥手？ 【问题一】TCP 为什么要进行四次挥手？ / 为什么 TCP 建立连接需要三次，而释放连接则需要四次？\n【答案一】因为 TCP 是全双工模式，客户端请求关闭连接后，客户端向服务端的连接关闭（一二次挥手），服务端继续传输之前没传完的数据给客户端（数据传输），服务端向客户端的连接关闭（三四次挥手）。所以 TCP 释放连接时服务器的 ACK 和 FIN 是分开发送的（中间隔着数据传输），而 TCP 建立连接时服务器的 ACK 和 SYN 是一起发送的（第二次握手），所以 TCP 建立连接需要三次，而释放连接则需要四次。\n【问题二】为什么 TCP 连接时可以 ACK 和 SYN 一起发送，而释放时则 ACK 和 FIN 分开发送呢？（ACK 和 FIN 分开是指第二次和第三次挥手）\n【答案二】因为客户端请求释放时，服务器可能还有数据需要传输给客户端，因此服务端要先响应客户端 FIN 请求（服务端发送 ACK），然后数据传输，传输完成后，服务端再提出 FIN 请求（服务端发送 FIN）；而连接时则没有中间的数据传输，因此连接时可以 ACK 和 SYN 一起发送。\n【问题三】为什么客户端释放最后需要 TIME-WAIT 等待 2MSL 呢？\n【答案三】\n 为了保证客户端发送的最后一个 ACK 报文能够到达服务端。若未成功到达，则服务端超时重传 FIN+ACK 报文段，客户端再重传 ACK，并重新计时。 防止已失效的连接请求报文段出现在本连接中。TIME-WAIT 持续 2MSL 可使本连接持续的时间内所产生的所有报文段都从网络中消失，这样可使下次连接中不会出现旧的连接报文段。  TCP 有限状态机 TCP 有限状态机图片\n应用层 DNS  DNS（Domain Name System，域名系统）是互联网的一项服务。它作为将域名和 IP 地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。DNS 使用 TCP 和 UDP 端口 53。当前，对于每一级域名长度的限制是 63 个字符，域名总长度则不能超过 253 个字符。  域名：\n 域名 ::= {\u0026lt;三级域名\u0026gt;.\u0026lt;二级域名\u0026gt;.\u0026lt;顶级域名\u0026gt;}，如：blog.huihut.com  FTP  FTP（File Transfer Protocol，文件传输协议）是用于在网络上进行文件传输的一套标准协议，使用客户/服务器模式，使用 TCP 数据报，提供交互式访问，双向传输。 TFTP（Trivial File Transfer Protocol，简单文件传输协议）一个小且易实现的文件传输协议，也使用客户-服务器方式，使用UDP数据报，只支持文件传输而不支持交互，没有列目录，不能对用户进行身份鉴定  TELNET   TELNET 协议是 TCP/IP 协议族中的一员，是 Internet 远程登陆服务的标准协议和主要方式。它为用户提供了在本地计算机上完成远程主机工作的能力。\n  HTTP（HyperText Transfer Protocol，超文本传输协议）是用于从 WWW（World Wide Web，万维网）服务器传输超文本到本地浏览器的传送协议。\n  SMTP（Simple Mail Transfer Protocol，简单邮件传输协议）是一组用于由源地址到目的地址传送邮件的规则，由它来控制信件的中转方式。SMTP 协议属于 TCP/IP 协议簇，它帮助每台计算机在发送或中转信件时找到下一个目的地。\n  Socket 建立网络通信连接至少要一对端口号（Socket）。Socket 本质是编程接口（API），对 TCP/IP 的封装，TCP/IP 也要提供可供程序员做网络开发所用的接口，这就是 Socket 编程接口。\n  WWW  WWW（World Wide Web，环球信息网，万维网）是一个由许多互相链接的超文本组成的系统，通过互联网访问  URL  URL（Uniform Resource Locator，统一资源定位符）是因特网上标准的资源的地址（Address）  标准格式：\n 协议类型:[//服务器地址[:端口号]][/资源层级UNIX文件路径]文件名[?查询][#片段ID]  完整格式：\n 协议类型:[//[访问资源需要的凭证信息@]服务器地址[:端口号]][/资源层级UNIX文件路径]文件名[?查询][#片段ID]   其中【访问凭证信息@；:端口号；?查询；#片段ID】都属于选填项\n如：https://github.com/huihut/interview#cc\n HTTP HTTP（HyperText Transfer Protocol，超文本传输协议）是一种用于分布式、协作式和超媒体信息系统的应用层协议。HTTP 是万维网的数据通信的基础。\n请求方法\n   方法 意义     OPTIONS 请求一些选项信息，允许客户端查看服务器的性能   GET 请求指定的页面信息，并返回实体主体   HEAD 类似于 get 请求，只不过返回的响应中没有具体的内容，用于获取报头   POST 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改   PUT 从客户端向服务器传送的数据取代指定的文档的内容   DELETE 请求服务器删除指定的页面   TRACE 回显服务器收到的请求，主要用于测试或诊断    状态码（Status-Code）\n 1xx：表示通知信息，如请求收到了或正在进行处理  100 Continue：继续，客户端应继续其请求 101 Switching Protocols 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到 HTTP 的新版本协议   2xx：表示成功，如接收或知道了  200 OK: 请求成功   3xx：表示重定向，如要完成请求还必须采取进一步的行动  301 Moved Permanently: 永久移动。请求的资源已被永久的移动到新 URL，返回信息会包括新的 URL，浏览器会自动定向到新 URL。今后任何新的请求都应使用新的 URL 代替   4xx：表示客户的差错，如请求中有错误的语法或不能完成  400 Bad Request: 客户端请求的语法错误，服务器无法理解 401 Unauthorized: 请求要求用户的身份认证 403 Forbidden: 服务器理解请求客户端的请求，但是拒绝执行此请求（权限不够） 404 Not Found: 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置 “您所请求的资源无法找到” 的个性页面 408 Request Timeout: 服务器等待客户端发送的请求时间过长，超时   5xx：表示服务器的差错，如服务器失效无法完成请求  500 Internal Server Error: 服务器内部错误，无法完成请求 503 Service Unavailable: 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的 Retry-After 头信息中 504 Gateway Timeout: 充当网关或代理的服务器，未及时从远端服务器获取请求     更多状态码：菜鸟教程 . HTTP状态码\n 其他协议  SMTP（Simple Main Transfer Protocol，简单邮件传输协议）是在 Internet 传输 Email 的标准，是一个相对简单的基于文本的协议。在其之上指定了一条消息的一个或多个接收者（在大多数情况下被确认是存在的），然后消息文本会被传输。可以很简单地通过 Telnet 程序来测试一个 SMTP 服务器。SMTP 使用 TCP 端口 25。 DHCP（Dynamic Host Configuration Protocol，动态主机设置协议）是一个局域网的网络协议，使用 UDP 协议工作，主要有两个用途：  用于内部网络或网络服务供应商自动分配 IP 地址给用户 用于内部网络管理员作为对所有电脑作中央管理的手段   SNMP（Simple Network Management Protocol，简单网络管理协议）构成了互联网工程工作小组（IETF，Internet Engineering Task Force）定义的 Internet 协议族的一部分。该协议能够支持网络管理系统，用以监测连接到网络上的设备是否有任何引起管理上关注的情况。  \n🌩 网络编程 Socket  Linux Socket 编程（不限 Linux）\n Socket 中的 read()、write() 函数 ssize_t read(int fd, void *buf, size_t count); ssize_t write(int fd, const void *buf, size_t count); read()  read 函数是负责从 fd 中读取内容。 当读成功时，read 返回实际所读的字节数。 如果返回的值是 0 表示已经读到文件的结束了，小于 0 表示出现了错误。 如果错误为 EINTR 说明读是由中断引起的；如果是 ECONNREST 表示网络连接出了问题。  write()  write 函数将 buf 中的 nbytes 字节内容写入文件描述符 fd。 成功时返回写的字节数。失败时返回 -1，并设置 errno 变量。 在网络程序中，当我们向套接字文件描述符写时有俩种可能。 （1）write 的返回值大于 0，表示写了部分或者是全部的数据。 （2）返回的值小于 0，此时出现了错误。 如果错误为 EINTR 表示在写的时候出现了中断错误；如果为 EPIPE 表示网络连接出现了问题（对方已经关闭了连接）。  Socket 中 TCP 的三次握手建立连接 我们知道 TCP 建立连接要进行 “三次握手”，即交换三个分组。大致流程如下：\n 客户端向服务器发送一个 SYN J 服务器向客户端响应一个 SYN K，并对 SYN J 进行确认 ACK J+1 客户端再想服务器发一个确认 ACK K+1  只有就完了三次握手，但是这个三次握手发生在 Socket 的那几个函数中呢？请看下图：\n从图中可以看出：\n 当客户端调用 connect 时，触发了连接请求，向服务器发送了 SYN J 包，这时 connect 进入阻塞状态； 服务器监听到连接请求，即收到 SYN J 包，调用 accept 函数接收请求向客户端发送 SYN K ，ACK J+1，这时 accept 进入阻塞状态； 客户端收到服务器的 SYN K ，ACK J+1 之后，这时 connect 返回，并对 SYN K 进行确认； 服务器收到 ACK K+1 时，accept 返回，至此三次握手完毕，连接建立。  Socket 中 TCP 的四次握手释放连接 上面介绍了 socket 中 TCP 的三次握手建立过程，及其涉及的 socket 函数。现在我们介绍 socket 中的四次握手释放连接的过程，请看下图：\n图示过程如下：\n 某个应用进程首先调用 close 主动关闭连接，这时 TCP 发送一个 FIN M； 另一端接收到 FIN M 之后，执行被动关闭，对这个 FIN 进行确认。它的接收也作为文件结束符传递给应用进程，因为 FIN 的接收意味着应用进程在相应的连接上再也接收不到额外数据； 一段时间之后，接收到文件结束符的应用进程调用 close 关闭它的 socket。这导致它的 TCP 也发送一个 FIN N； 接收到这个 FIN 的源发送端 TCP 对它进行确认。  这样每个方向上都有一个 FIN 和 ACK。\n","permalink":"/collection/network/","summary":"转载自https://github.com/huihut/interview 本节部分知识点来自《计算机网络（第 7 版）》 计算机网络体系结构： 各","title":"【转载】C++ 开发必备之计算机网络"},{"content":"转载自https://github.com/huihut/interview\n进程与线程 对于有线程系统：\n 进程是资源分配的独立单位 线程是资源调度的独立单位  对于无线程系统：\n 进程是资源调度、分配的独立单位  进程之间的通信方式以及优缺点  管道（PIPE）  有名管道：一种半双工的通信方式，它允许无亲缘关系进程间的通信  优点：可以实现任意关系的进程间的通信 缺点：  长期存于系统中，使用不当容易出错 缓冲区有限     无名管道：一种半双工的通信方式，只能在具有亲缘关系的进程间使用（父子进程）  优点：简单方便 缺点：  局限于单向通信 只能创建在它的进程以及其有亲缘关系的进程之间 缓冲区有限       信号量（Semaphore）：一个计数器，可以用来控制多个线程对共享资源的访问  优点：可以同步进程 缺点：信号量有限   信号（Signal）：一种比较复杂的通信方式，用于通知接收进程某个事件已经发生 消息队列（Message Queue）：是消息的链表，存放在内核中并由消息队列标识符标识  优点：可以实现任意进程间的通信，并通过系统调用函数来实现消息发送和接收之间的同步，无需考虑同步问题，方便 缺点：信息的复制需要额外消耗 CPU 的时间，不适宜于信息量大或操作频繁的场合   共享内存（Shared Memory）：映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问  优点：无须复制，快捷，信息量大 缺点：  通信是通过将共享空间缓冲区直接附加到进程的虚拟地址空间中来实现的，因此进程间的读写操作的同步问题 利用内存缓冲区直接交换信息，内存的实体存在于计算机中，只能同一个计算机系统中的诸多进程共享，不方便网络通信     套接字（Socket）：可用于不同计算机间的进程通信  优点：  传输数据为字节级，传输数据可自定义，数据量小效率高 传输数据时间短，性能高 适合于客户端和服务器端之间信息实时交互 可以加密,数据安全性强   缺点：需对传输的数据进行解析，转化成应用级的数据。    线程之间的通信方式  锁机制：包括互斥锁/量（mutex）、读写锁（reader-writer lock）、自旋锁（spin lock）、条件变量（condition）  互斥锁/量（mutex）：提供了以排他方式防止数据结构被并发修改的方法。 读写锁（reader-writer lock）：允许多个线程同时读共享数据，而对写操作是互斥的。 自旋锁（spin lock）与互斥锁类似，都是为了保护共享资源。互斥锁是当资源被占用，申请者进入睡眠状态；而自旋锁则循环检测保持者是否已经释放锁。 条件变量（condition）：可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。   信号量机制(Semaphore)  无名线程信号量 命名线程信号量   信号机制(Signal)：类似进程间的信号处理 屏障（barrier）：屏障允许每个线程等待，直到所有的合作线程都达到某一点，然后从该点继续执行。  线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制\n 进程之间的通信方式以及优缺点来源于：进程线程面试题总结\n 进程之间私有和共享的资源  私有：地址空间、堆、全局变量、栈、寄存器 共享：代码段，公共数据，进程目录，进程 ID  线程之间私有和共享的资源  私有：线程栈，寄存器，程序计数器 共享：堆，地址空间，全局变量，静态变量  多进程与多线程间的对比、优劣与选择 对比    对比维度 多进程 多线程 总结     数据共享、同步 数据共享复杂，需要用 IPC；数据是分开的，同步简单 因为共享进程数据，数据共享简单，但也是因为这个原因导致同步复杂 各有优势   内存、CPU 占用内存多，切换复杂，CPU 利用率低 占用内存少，切换简单，CPU 利用率高 线程占优   创建销毁、切换 创建销毁、切换复杂，速度慢 创建销毁、切换简单，速度很快 线程占优   编程、调试 编程简单，调试简单 编程复杂，调试复杂 进程占优   可靠性 进程间不会互相影响 一个线程挂掉将导致整个进程挂掉 进程占优   分布式 适应于多核、多机分布式；如果一台机器不够，扩展到多台机器比较简单 适应于多核分布式 进程占优    优劣    优劣 多进程 多线程     优点 编程、调试简单，可靠性较高 创建、销毁、切换速度快，内存、资源占用小   缺点 创建、销毁、切换速度慢，内存、资源占用大 编程、调试复杂，可靠性较差    选择  需要频繁创建销毁的优先用线程 需要进行大量计算的优先使用线程 强相关的处理用线程，弱相关的处理用进程 可能要扩展到多机分布的用进程，多核分布的用线程 都满足需求的情况下，用你最熟悉、最拿手的方式   多进程与多线程间的对比、优劣与选择来自：多线程还是多进程的选择及区别\n Linux 内核的同步方式 原因 在现代操作系统里，同一时间可能有多个内核执行流在执行，因此内核其实像多进程多线程编程一样也需要一些同步机制来同步各执行单元对共享数据的访问。尤其是在多处理器系统上，更需要一些同步机制来同步不同处理器上的执行单元对共享的数据的访问。\n同步方式  原子操作 信号量（semaphore） 读写信号量（rw_semaphore） 自旋锁（spinlock） 大内核锁（BKL，Big Kernel Lock） 读写锁（rwlock） 大读者锁（brlock-Big Reader Lock） 读-拷贝修改(RCU，Read-Copy Update) 顺序锁（seqlock）   来自：Linux 内核的同步机制，第 1 部分、Linux 内核的同步机制，第 2 部分\n 死锁 原因  系统资源不足 资源分配不当 进程运行推进顺序不合适  产生条件  互斥 请求和保持 不剥夺 环路  预防  打破互斥条件：改造独占性资源为虚拟资源，大部分资源已无法改造。 打破不可抢占条件：当一进程占有一独占性资源后又申请一独占性资源而无法满足，则退出原占有的资源。 打破占有且申请条件：采用资源预先分配策略，即进程运行前申请全部资源，满足则运行，不然就等待，这样就不会占有且申请。 打破循环等待条件：实现资源有序分配策略，对所有设备实现分类编号，所有进程只能采用按序号递增的形式申请资源。 有序资源分配法 银行家算法  文件系统  Windows：FCB 表 + FAT + 位图 Unix：inode + 混合索引 + 成组链接  主机字节序与网络字节序 主机字节序（CPU 字节序） 概念 主机字节序又叫 CPU 字节序，其不是由操作系统决定的，而是由 CPU 指令集架构决定的。主机字节序分为两种：\n 大端字节序（Big Endian）：高序字节存储在低位地址，低序字节存储在高位地址 小端字节序（Little Endian）：高序字节存储在高位地址，低序字节存储在低位地址  存储方式 32 位整数 0x12345678 是从起始位置为 0x00 的地址开始存放，则：\n   内存地址 0x00 0x01 0x02 0x03     大端 12 34 56 78   小端 78 56 34 12    大端小端图片\n判断大端小端 判断大端小端\n可以这样判断自己 CPU 字节序是大端还是小端：\n#include \u0026lt;iostream\u0026gt;using namespace std; int main() { int i = 0x12345678; if (*((char*)\u0026amp;i) == 0x12) cout \u0026lt;\u0026lt; \u0026#34;大端\u0026#34; \u0026lt;\u0026lt; endl; else\tcout \u0026lt;\u0026lt; \u0026#34;小端\u0026#34; \u0026lt;\u0026lt; endl; return 0; } 各架构处理器的字节序  x86（Intel、AMD）、MOS Technology 6502、Z80、VAX、PDP-11 等处理器为小端序； Motorola 6800、Motorola 68000、PowerPC 970、System/370、SPARC（除 V9 外）等处理器为大端序； ARM（默认小端序）、PowerPC（除 PowerPC 970 外）、DEC Alpha、SPARC V9、MIPS、PA-RISC 及 IA64 的字节序是可配置的。  网络字节序 网络字节顺序是 TCP/IP 中规定好的一种数据表示格式，它与具体的 CPU 类型、操作系统等无关，从而可以保证数据在不同主机之间传输时能够被正确解释。\n网络字节顺序采用：大端（Big Endian）排列方式。\n页面置换算法 在地址映射过程中，若在页面中发现所要访问的页面不在内存中，则产生缺页中断。当发生缺页中断时，如果操作系统内存中没有空闲页面，则操作系统必须在内存选择一个页面将其移出内存，以便为即将调入的页面让出空间。而用来选择淘汰哪一页的规则叫做页面置换算法。\n分类  全局置换：在整个内存空间置换 局部置换：在本进程中进行置换  算法 全局：\n 工作集算法 缺页率置换算法  局部：\n 最佳置换算法（OPT） 先进先出置换算法（FIFO） 最近最久未使用（LRU）算法 时钟（Clock）置换算法  ","permalink":"/collection/os/","summary":"转载自https://github.com/huihut/interview 进程与线程 对于有线程系统： 进程是资源分配的独立单位 线程是资源调度","title":"【转载】C++ 开发必备之操作系统"},{"content":"转载自https://github.com/huihut/interview\n排序    排序算法 平均时间复杂度 最差时间复杂度 空间复杂度 数据对象稳定性     冒泡排序 O(n2) O(n2) O(1) 稳定   选择排序 O(n2) O(n2) O(1) 数组不稳定、链表稳定   插入排序 O(n2) O(n2) O(1) 稳定   快速排序 O(n*log2n) O(n2) O(log2n) 不稳定   堆排序 O(n*log2n) O(n*log2n) O(1) 不稳定   归并排序 O(n*log2n) O(n*log2n) O(n) 稳定   希尔排序 O(n*log2n) O(n2) O(1) 不稳定   计数排序 O(n+m) O(n+m) O(n+m) 稳定   桶排序 O(n) O(n) O(m) 稳定   基数排序 O(k*n) O(n2)  稳定      均按从小到大排列 k：代表数值中的 “数位” 个数 n：代表数据规模 m：代表数据的最大值减最小值 来自：wikipedia . 排序算法   查找    查找算法 平均时间复杂度 空间复杂度 查找条件     顺序查找 O(n) O(1) 无序或有序   二分查找（折半查找） O(log2n) O(1) 有序   插值查找 O(log2(log2n)) O(1) 有序   斐波那契查找 O(log2n) O(1) 有序   哈希查找 O(1) O(n) 无序或有序   二叉查找树（二叉搜索树查找） O(log2n)     红黑树 O(log2n)     2-3树 O(log2n - log3n)     B树/B+树 O(log2n)      图搜索算法    图搜索算法 数据结构 遍历时间复杂度 空间复杂度     BFS广度优先搜索 邻接矩阵邻接链表 O(|v|2)O(|v|+|E|) O(|v|2)O(|v|+|E|)   DFS深度优先搜索 邻接矩阵邻接链表 O(|v|2)O(|v|+|E|) O(|v|2)O(|v|+|E|)    其他算法    算法 思想 应用     分治法 把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并 循环赛日程安排问题、排序算法（快速排序、归并排序）   动态规划 通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法，适用于有重叠子问题和最优子结构性质的问题 背包问题、斐波那契数列   贪心法 一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是最好或最优的算法 旅行推销员问题（最短路径问题）、最小生成树、哈夫曼编码    ","permalink":"/collection/algorithm/","summary":"转载自https://github.com/huihut/interview 排序 排序算法 平均时间复杂度 最差时间复杂度 空间复杂度 数据对象稳定性","title":"【转载】C++ 开发必备之算法"},{"content":"转载自https://github.com/huihut/interview\n顺序结构 顺序栈（Sequence Stack） SqStack.cpp\n顺序栈数据结构和图片\ntypedef struct { ElemType *elem; int top; int size; int increment; } SqStack; 队列（Sequence Queue） 队列数据结构\ntypedef struct { ElemType * elem; int front; int rear; int maxSize; }SqQueue; 非循环队列 非循环队列图片\nSqQueue.rear++\n循环队列 循环队列图片\nSqQueue.rear = (SqQueue.rear + 1) % SqQueue.maxSize\n顺序表（Sequence List） SqList.cpp\n顺序表数据结构和图片\ntypedef struct { ElemType *elem; int length; int size; int increment; } SqList; 链式结构 LinkList.cpp\nLinkList_with_head.cpp\n链式数据结构\ntypedef struct LNode { ElemType data; struct LNode *next; } LNode, *LinkList; 链队列（Link Queue） 链队列图片\n线性表的链式表示 单链表（Link List） 单链表图片\n双向链表（Du-Link-List） 双向链表图片\n循环链表（Cir-Link-List） 循环链表图片\n哈希表 HashTable.cpp\n概念 哈希函数：H(key): K -\u0026gt; D , key ∈ K\n构造方法  直接定址法 除留余数法 数字分析法 折叠法 平方取中法  冲突处理方法  链地址法：key 相同的用单链表链接 开放定址法  线性探测法：key 相同 -\u0026gt; 放到 key 的下一个位置，Hi = (H(key) + i) % m 二次探测法：key 相同 -\u0026gt; 放到 Di = 1^2, -1^2, ..., ±（k)^2,(k\u0026lt;=m/2） 随机探测法：H = (H(key) + 伪随机数) % m    线性探测的哈希表数据结构 线性探测的哈希表数据结构和图片\ntypedef char KeyType; typedef struct { KeyType key; }RcdType; typedef struct { RcdType *rcd; int size; int count; bool *tag; }HashTable; 递归 概念 函数直接或间接地调用自身\n递归与分治  分治法  问题的分解 问题规模的分解   折半查找（递归） 归并排序（递归） 快速排序（递归）  递归与迭代  迭代：反复利用变量旧值推出新值 折半查找（迭代） 归并排序（迭代）  广义表 头尾链表存储表示 广义表的头尾链表存储表示和图片\n// 广义表的头尾链表存储表示 typedef enum {ATOM, LIST} ElemTag; // ATOM==0：原子，LIST==1：子表 typedef struct GLNode { ElemTag tag; // 公共部分，用于区分原子结点和表结点  union { // 原子结点和表结点的联合部分  AtomType atom; // atom 是原子结点的值域，AtomType 由用户定义  struct { struct GLNode *hp, *tp; } ptr; // ptr 是表结点的指针域，prt.hp 和 ptr.tp 分别指向表头和表尾  } a; } *GList, GLNode; 扩展线性链表存储表示 扩展线性链表存储表示和图片\n// 广义表的扩展线性链表存储表示 typedef enum {ATOM, LIST} ElemTag; // ATOM==0：原子，LIST==1：子表 typedef struct GLNode1 { ElemTag tag; // 公共部分，用于区分原子结点和表结点  union { // 原子结点和表结点的联合部分  AtomType atom; // 原子结点的值域  struct GLNode1 *hp; // 表结点的表头指针  } a; struct GLNode1 *tp; // 相当于线性链表的 next，指向下一个元素结点 } *GList1, GLNode1; 二叉树 BinaryTree.cpp\n性质  非空二叉树第 i 层最多 2(i-1) 个结点 （i \u0026gt;= 1） 深度为 k 的二叉树最多 2k - 1 个结点 （k \u0026gt;= 1） 度为 0 的结点数为 n0，度为 2 的结点数为 n2，则 n0 = n2 + 1 有 n 个结点的完全二叉树深度 k = ⌊ log2(n) ⌋ + 1 对于含 n 个结点的完全二叉树中编号为 i （1 \u0026lt;= i \u0026lt;= n） 的结点  若 i = 1，为根，否则双亲为 ⌊ i / 2 ⌋ 若 2i \u0026gt; n，则 i 结点没有左孩子，否则孩子编号为 2i 若 2i + 1 \u0026gt; n，则 i 结点没有右孩子，否则孩子编号为 2i + 1    存储结构 二叉树数据结构\ntypedef struct BiTNode { TElemType data; struct BiTNode *lchild, *rchild; }BiTNode, *BiTree; 顺序存储 二叉树顺序存储图片\n链式存储 二叉树链式存储图片\n遍历方式  先序遍历 中序遍历 后续遍历 层次遍历  分类  满二叉树 完全二叉树（堆）  大顶堆：根 \u0026gt;= 左 \u0026amp;\u0026amp; 根 \u0026gt;= 右 小顶堆：根 \u0026lt;= 左 \u0026amp;\u0026amp; 根 \u0026lt;= 右   二叉查找树（二叉排序树）：左 \u0026lt; 根 \u0026lt; 右 平衡二叉树（AVL树）：| 左子树树高 - 右子树树高 | \u0026lt;= 1 最小失衡树：平衡二叉树插入新结点导致失衡的子树：调整：  LL型：根的左孩子右旋 RR型：根的右孩子左旋 LR型：根的左孩子左旋，再右旋 RL型：右孩子的左子树，先右旋，再左旋    其他树及森林 树的存储结构  双亲表示法 双亲孩子表示法 孩子兄弟表示法  并查集 一种不相交的子集所构成的集合 S = {S1, S2, \u0026hellip;, Sn}\n平衡二叉树（AVL树） 性质  | 左子树树高 - 右子树树高 | \u0026lt;= 1 平衡二叉树必定是二叉搜索树，反之则不一定 最小二叉平衡树的节点的公式：F(n)=F(n-1)+F(n-2)+1 （1 是根节点，F(n-1) 是左子树的节点数量，F(n-2) 是右子树的节点数量）  平衡二叉树图片\n最小失衡树 平衡二叉树插入新结点导致失衡的子树\n调整：\n LL 型：根的左孩子右旋 RR 型：根的右孩子左旋 LR 型：根的左孩子左旋，再右旋 RL 型：右孩子的左子树，先右旋，再左旋  红黑树 RedBlackTree.cpp\n红黑树的特征是什么？  节点是红色或黑色。 根是黑色。 所有叶子都是黑色（叶子是 NIL 节点）。 每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）（新增节点的父节点必须相同） 从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。（新增节点必须为红）  调整  变色 左旋 右旋  应用  关联数组：如 STL 中的 map、set  红黑树、B 树、B+ 树的区别？  红黑树的深度比较大，而 B 树和 B+ 树的深度则相对要小一些 B+ 树则将数据都保存在叶子节点，同时通过链表的形式将他们连接在一起。  B 树（B-tree）、B+ 树（B+-tree） B 树、B+ 树图片\n特点  一般化的二叉查找树（binary search tree） “矮胖”，内部（非叶子）节点可以拥有可变数量的子节点（数量范围预先定义好）  应用  大部分文件系统、数据库系统都采用B树、B+树作为索引结构  区别  B+树中只有叶子节点会带有指向记录的指针（ROWID），而B树则所有节点都带有，在内部节点出现的索引项不会再出现在叶子节点中。 B+树中所有叶子节点都是通过指针连接在一起，而B树不会。  B树的优点 对于在内部节点的数据，可直接得到，不必根据叶子节点来定位。\nB+树的优点  非叶子节点不会带上 ROWID，这样，一个块中可以容纳更多的索引项，一是可以降低树的高度。二是一个内部节点可以定位更多的叶子节点。 叶子节点之间通过指针来连接，范围扫描将十分简单，而对于B树来说，则需要在叶子节点和内部节点不停的往返移动。   B 树、B+ 树区别来自：differences-between-b-trees-and-b-trees、B树和B+树的区别\n 八叉树 八叉树图片\n八叉树（octree），或称八元树，是一种用于描述三维空间（划分空间）的树状数据结构。八叉树的每个节点表示一个正方体的体积元素，每个节点有八个子节点，这八个子节点所表示的体积元素加在一起就等于父节点的体积。一般中心点作为节点的分叉中心。\n用途  三维计算机图形 最邻近搜索  ","permalink":"/collection/data-structure/","summary":"转载自https://github.com/huihut/interview 顺序结构 顺序栈（Sequence Stack） SqStack.cpp 顺序栈数据结构和图","title":"【转载】C++ 开发必备之数据结构"},{"content":"转载自https://github.com/huihut/interview\nSTL 索引 STL 方法含义索引\nSTL 容器    容器 底层数据结构 时间复杂度 有无序 可不可重复 其他     array 数组 随机读改 O(1) 无序 可重复 支持随机访问   vector 数组 随机读改、尾部插入、尾部删除 O(1)头部插入、头部删除 O(n) 无序 可重复 支持随机访问   deque 双端队列 头尾插入、头尾删除 O(1) 无序 可重复 一个中央控制器 + 多个缓冲区，支持首尾快速增删，支持随机访问   forward_list 单向链表 插入、删除 O(1) 无序 可重复 不支持随机访问   list 双向链表 插入、删除 O(1) 无序 可重复 不支持随机访问   stack deque / list 顶部插入、顶部删除 O(1) 无序 可重复 deque 或 list 封闭头端开口，不用 vector 的原因应该是容量大小有限制，扩容耗时   queue deque / list 尾部插入、头部删除 O(1) 无序 可重复 deque 或 list 封闭头端开口，不用 vector 的原因应该是容量大小有限制，扩容耗时   priority_queue vector + max-heap 插入、删除 O(log2n) 有序 可重复 vector容器+heap处理规则   set 红黑树 插入、删除、查找 O(log2n) 有序 不可重复    multiset 红黑树 插入、删除、查找 O(log2n) 有序 可重复    map 红黑树 插入、删除、查找 O(log2n) 有序 不可重复    multimap 红黑树 插入、删除、查找 O(log2n) 有序 可重复    unordered_set 哈希表 插入、删除、查找 O(1) 最差 O(n) 无序 不可重复    unordered_multiset 哈希表 插入、删除、查找 O(1) 最差 O(n) 无序 可重复    unordered_map 哈希表 插入、删除、查找 O(1) 最差 O(n) 无序 不可重复    unordered_multimap 哈希表 插入、删除、查找 O(1) 最差 O(n) 无序 可重复     STL 算法    算法 底层算法 时间复杂度 可不可重复     find 顺序查找 O(n) 可重复   sort 内省排序 O(n*log2n) 可重复    ","permalink":"/collection/c++stl/","summary":"转载自https://github.com/huihut/interview STL 索引 STL 方法含义索引 STL 容器 容器 底层数据结构 时间复杂度 有无序 可不可","title":"【转载】C++ 开发必备之 STL"},{"content":"转载自https://github.com/huihut/interview\nEffective C++  视 C++ 为一个语言联邦（C、Object-Oriented C++、Template C++、STL） 宁可以编译器替换预处理器（尽量以 const、enum、inline 替换 #define） 尽可能使用 const 确定对象被使用前已先被初始化（构造时赋值（copy 构造函数）比 default 构造后赋值（copy assignment）效率高） 了解 C++ 默默编写并调用哪些函数（编译器暗自为 class 创建 default 构造函数、copy 构造函数、copy assignment 操作符、析构函数） 若不想使用编译器自动生成的函数，就应该明确拒绝（将不想使用的成员函数声明为 private，并且不予实现） 为多态基类声明 virtual 析构函数（如果 class 带有任何 virtual 函数，它就应该拥有一个 virtual 析构函数） 别让异常逃离析构函数（析构函数应该吞下不传播异常，或者结束程序，而不是吐出异常；如果要处理异常应该在非析构的普通函数处理） 绝不在构造和析构过程中调用 virtual 函数（因为这类调用从不下降至 derived class） 令 operator= 返回一个 reference to *this （用于连锁赋值） 在 operator= 中处理 “自我赋值” 赋值对象时应确保复制 “对象内的所有成员变量” 及 “所有 base class 成分”（调用基类复制构造函数） 以对象管理资源（资源在构造函数获得，在析构函数释放，建议使用智能指针，资源取得时机便是初始化时机（Resource Acquisition Is Initialization，RAII）） 在资源管理类中小心 copying 行为（普遍的 RAII class copying 行为是：抑制 copying、引用计数、深度拷贝、转移底部资源拥有权（类似 auto_ptr）） 在资源管理类中提供对原始资源（raw resources）的访问（对原始资源的访问可能经过显式转换或隐式转换，一般而言显示转换比较安全，隐式转换对客户比较方便） 成对使用 new 和 delete 时要采取相同形式（new 中使用 [] 则 delete []，new 中不使用 [] 则 delete） 以独立语句将 newed 对象存储于（置入）智能指针（如果不这样做，可能会因为编译器优化，导致难以察觉的资源泄漏） 让接口容易被正确使用，不易被误用（促进正常使用的办法：接口的一致性、内置类型的行为兼容；阻止误用的办法：建立新类型，限制类型上的操作，约束对象值、消除客户的资源管理责任） 设计 class 犹如设计 type，需要考虑对象创建、销毁、初始化、赋值、值传递、合法值、继承关系、转换、一般化等等。 宁以 pass-by-reference-to-const 替换 pass-by-value （前者通常更高效、避免切割问题（slicing problem），但不适用于内置类型、STL迭代器、函数对象） 必须返回对象时，别妄想返回其 reference（绝不返回 pointer 或 reference 指向一个 local stack 对象，或返回 reference 指向一个 heap-allocated 对象，或返回 pointer 或 reference 指向一个 local static 对象而有可能同时需要多个这样的对象。） 将成员变量声明为 private（为了封装、一致性、对其读写精确控制等） 宁以 non-member、non-friend 替换 member 函数（可增加封装性、包裹弹性（packaging flexibility）、机能扩充性） 若所有参数（包括被this指针所指的那个隐喻参数）皆须要类型转换，请为此采用 non-member 函数 考虑写一个不抛异常的 swap 函数 尽可能延后变量定义式的出现时间（可增加程序清晰度并改善程序效率） 尽量少做转型动作（旧式：(T)expression、T(expression)；新式：const_cast\u0026lt;T\u0026gt;(expression)、dynamic_cast\u0026lt;T\u0026gt;(expression)、reinterpret_cast\u0026lt;T\u0026gt;(expression)、static_cast\u0026lt;T\u0026gt;(expression)、；尽量避免转型、注重效率避免 dynamic_casts、尽量设计成无需转型、可把转型封装成函数、宁可用新式转型） 避免使用 handles（包括 引用、指针、迭代器）指向对象内部（以增加封装性、使 const 成员函数的行为更像 const、降低 “虚吊号码牌”（dangling handles，如悬空指针等）的可能性） 为 “异常安全” 而努力是值得的（异常安全函数（Exception-safe functions）即使发生异常也不会泄露资源或允许任何数据结构败坏，分为三种可能的保证：基本型、强列型、不抛异常型） 透彻了解 inlining 的里里外外（inlining 在大多数 C++ 程序中是编译期的行为；inline 函数是否真正 inline，取决于编译器；大部分编译器拒绝太过复杂（如带有循环或递归）的函数 inlining，而所有对 virtual 函数的调用（除非是最平淡无奇的）也都会使 inlining 落空；inline 造成的代码膨胀可能带来效率损失；inline 函数无法随着程序库的升级而升级） 将文件间的编译依存关系降至最低（如果使用 object references 或 object pointers 可以完成任务，就不要使用 objects；如果能够，尽量以 class 声明式替换 class 定义式；为声明式和定义式提供不同的头文件） 确定你的 public 继承塑模出 is-a（是一种）关系（适用于 base classes 身上的每一件事情一定适用于 derived classes 身上，因为每一个 derived class 对象也都是一个 base class 对象） 避免遮掩继承而来的名字（可使用 using 声明式或转交函数（forwarding functions）来让被遮掩的名字再见天日） 区分接口继承和实现继承（在 public 继承之下，derived classes 总是继承 base class 的接口；pure virtual 函数只具体指定接口继承；非纯 impure virtual 函数具体指定接口继承及缺省实现继承；non-virtual 函数具体指定接口继承以及强制性实现继承） 考虑 virtual 函数以外的其他选择（如 Template Method 设计模式的 non-virtual interface（NVI）手法，将 virtual 函数替换为 “函数指针成员变量”，以 tr1::function 成员变量替换 virtual 函数，将继承体系内的 virtual 函数替换为另一个继承体系内的 virtual 函数） 绝不重新定义继承而来的 non-virtual 函数 绝不重新定义继承而来的缺省参数值，因为缺省参数值是静态绑定（statically bound），而 virtual 函数却是动态绑定（dynamically bound） 通过复合塑模 has-a（有一个）或 “根据某物实现出”（在应用域（application domain），复合意味 has-a（有一个）；在实现域（implementation domain），复合意味着 is-implemented-in-terms-of（根据某物实现出）） 明智而审慎地使用 private 继承（private 继承意味着 is-implemented-in-terms-of（根据某物实现出），尽可能使用复合，当 derived class 需要访问 protected base class 的成员，或需要重新定义继承而来的时候 virtual 函数，或需要 empty base 最优化时，才使用 private 继承） 明智而审慎地使用多重继承（多继承比单一继承复杂，可能导致新的歧义性，以及对 virtual 继承的需要，但确有正当用途，如 “public 继承某个 interface class” 和 “private 继承某个协助实现的 class”；virtual 继承可解决多继承下菱形继承的二义性问题，但会增加大小、速度、初始化及赋值的复杂度等等成本） 了解隐式接口和编译期多态（class 和 templates 都支持接口（interfaces）和多态（polymorphism）；class 的接口是以签名为中心的显式的（explicit），多态则是通过 virtual 函数发生于运行期；template 的接口是奠基于有效表达式的隐式的（implicit），多态则是通过 template 具现化和函数重载解析（function overloading resolution）发生于编译期） 了解 typename 的双重意义（声明 template 类型参数是，前缀关键字 class 和 typename 的意义完全相同；请使用关键字 typename 标识嵌套从属类型名称，但不得在基类列（base class lists）或成员初值列（member initialization list）内以它作为 base class 修饰符） 学习处理模板化基类内的名称（可在 derived class templates 内通过 this-\u0026gt; 指涉 base class templates 内的成员名称，或藉由一个明白写出的 “base class 资格修饰符” 完成） 将与参数无关的代码抽离 templates（因类型模板参数（non-type template parameters）而造成代码膨胀往往可以通过函数参数或 class 成员变量替换 template 参数来消除；因类型参数（type parameters）而造成的代码膨胀往往可以通过让带有完全相同二进制表述（binary representations）的实现类型（instantiation types）共享实现码） 运用成员函数模板接受所有兼容类型（请使用成员函数模板（member function templates）生成 “可接受所有兼容类型” 的函数；声明 member templates 用于 “泛化 copy 构造” 或 “泛化 assignment 操作” 时还需要声明正常的 copy 构造函数和 copy assignment 操作符） 需要类型转换时请为模板定义非成员函数（当我们编写一个 class template，而它所提供之 “与此 template 相关的” 函数支持 “所有参数之隐式类型转换” 时，请将那些函数定义为 “class template 内部的 friend 函数”） 请使用 traits classes 表现类型信息（traits classes 通过 templates 和 “templates 特化” 使得 “类型相关信息” 在编译期可用，通过重载技术（overloading）实现在编译期对类型执行 if\u0026hellip;else 测试） 认识 template 元编程（模板元编程（TMP，template metaprogramming）可将工作由运行期移往编译期，因此得以实现早期错误侦测和更高的执行效率；TMP 可被用来生成 “给予政策选择组合”（based on combinations of policy choices）的客户定制代码，也可用来避免生成对某些特殊类型并不适合的代码） 了解 new-handler 的行为（set_new_handler 允许客户指定一个在内存分配无法获得满足时被调用的函数；nothrow new 是一个颇具局限的工具，因为它只适用于内存分配（operator new），后继的构造函数调用还是可能抛出异常） 了解 new 和 delete 的合理替换时机（为了检测运用错误、收集动态分配内存之使用统计信息、增加分配和归还速度、降低缺省内存管理器带来的空间额外开销、弥补缺省分配器中的非最佳齐位、将相关对象成簇集中、获得非传统的行为） 编写 new 和 delete 时需固守常规（operator new 应该内涵一个无穷循环，并在其中尝试分配内存，如果它无法满足内存需求，就应该调用 new-handler，它也应该有能力处理 0 bytes 申请，class 专属版本则还应该处理 “比正确大小更大的（错误）申请”；operator delete 应该在收到 null 指针时不做任何事，class 专属版本则还应该处理 “比正确大小更大的（错误）申请”） 写了 placement new 也要写 placement delete（当你写一个 placement operator new，请确定也写出了对应的 placement operator delete，否则可能会发生隐微而时断时续的内存泄漏；当你声明 placement new 和 placement delete，请确定不要无意识（非故意）地遮掩了它们地正常版本） 不要轻忽编译器的警告 让自己熟悉包括 TR1 在内的标准程序库（TR1，C++ Technical Report 1，C++11 标准的草稿文件） 让自己熟悉 Boost（准标准库）  More Effective c++  仔细区别 pointers 和 references（当你知道你需要指向某个东西，而且绝不会改变指向其他东西，或是当你实现一个操作符而其语法需求无法由 pointers 达成，你就应该选择 references；任何其他时候，请采用 pointers） 最好使用 C++ 转型操作符（static_cast、const_cast、dynamic_cast、reinterpret_cast） 绝不要以多态（polymorphically）方式处理数组（多态（polymorphism）和指针算术不能混用；数组对象几乎总是会涉及指针的算术运算，所以数组和多态不要混用） 非必要不提供 default constructor（避免对象中的字段被无意义地初始化） 对定制的 “类型转换函数” 保持警觉（单自变量 constructors 可通过简易法（explicit 关键字）或代理类（proxy classes）来避免编译器误用；隐式类型转换操作符可改为显式的 member function 来避免非预期行为） 区别 increment/decrement 操作符的前置（prefix）和后置（postfix）形式（前置式累加后取出，返回一个 reference；后置式取出后累加，返回一个 const 对象；处理用户定制类型时，应该尽可能使用前置式 increment；后置式的实现应以其前置式兄弟为基础） 千万不要重载 \u0026amp;\u0026amp;，|| 和 , 操作符（\u0026amp;\u0026amp; 与 || 的重载会用 “函数调用语义” 取代 “骤死式语义”；, 的重载导致不能保证左侧表达式一定比右侧表达式更早被评估） 了解各种不同意义的 new 和 delete（new operator、operator new、placement new、operator new[]；delete operator、operator delete、destructor、operator delete[]） 利用 destructors 避免泄漏资源（在 destructors 释放资源可以避免异常时的资源泄漏） 在 constructors 内阻止资源泄漏（由于 C++ 只会析构已构造完成的对象，因此在构造函数可以使用 try\u0026hellip;catch 或者 auto_ptr（以及与之相似的 classes） 处理异常时资源泄露问题） 禁止异常流出 destructors 之外（原因：一、避免 terminate 函数在 exception 传播过程的栈展开（stack-unwinding）机制种被调用；二、协助确保 destructors 完成其应该完成的所有事情） 了解 “抛出一个 exception” 与 “传递一个参数” 或 “调用一个虚函数” 之间的差异（第一，exception objects 总是会被复制（by pointer 除外），如果以 by value 方式捕捉甚至被复制两次，而传递给函数参数的对象则不一定得复制；第二，“被抛出成为 exceptions” 的对象，其被允许的类型转换动作比 “被传递到函数去” 的对象少；第三，catch 子句以其 “出现于源代码的顺序” 被编译器检验对比，其中第一个匹配成功者便执行，而调用一个虚函数，被选中执行的是那个 “与对象类型最佳吻合” 的函数） 以 by reference 方式捕获 exceptions（可避免对象删除问题、exception objects 的切割问题，可保留捕捉标准 exceptions 的能力，可约束 exception object 需要复制的次数） 明智运用 exception specifications（exception specifications 对 “函数希望抛出什么样的 exceptions” 提供了卓越的说明；也有一些缺点，包括编译器只对它们做局部性检验而很容易不经意地违反，与可能会妨碍更上层的 exception 处理函数处理未预期的 exceptions） 了解异常处理的成本（粗略估计，如果使用 try 语句块，代码大约整体膨胀 5%-10%，执行速度亦大约下降这个数；因此请将你对 try 语句块和 exception specifications 的使用限制于非用不可的地点，并且在真正异常的情况下才抛出 exceptions） 谨记 80-20 法则（软件的整体性能几乎总是由其构成要素（代码）的一小部分决定的，可使用程序分析器（program profiler）识别出消耗资源的代码） 考虑使用 lazy evaluation（缓式评估）（可应用于：Reference Counting（引用计数）来避免非必要的对象复制、区分 operator[] 的读和写动作来做不同的事情、Lazy Fetching（缓式取出）来避免非必要的数据库读取动作、Lazy Expression Evaluation（表达式缓评估）来避免非必要的数值计算动作） 分期摊还预期的计算成本（当你必须支持某些运算而其结构几乎总是被需要，或其结果常常被多次需要的时候，over-eager evaluation（超急评估）可以改善程序效率）  Google C++ Style Guide  英文：Google C++ Style Guide 中文：C++ 风格指南  其他  Bjarne Stroustrup 的常见问题 Bjarne Stroustrup 的 C++ 风格和技巧常见问题  ","permalink":"/collection/effectivec++/","summary":"转载自https://github.com/huihut/interview Effective C++ 视 C++ 为一个语言联邦（C、Object-Oriented C++","title":"【转载】C++ 开发必备之 Effective C++"},{"content":"转载自https://github.com/huihut/interview\nconst 作用  修饰变量，说明该变量不可以被改变； 修饰指针，分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer）； 修饰引用，指向常量的引用（reference to const），用于形参类型，即避免了拷贝，又避免了函数对值的修改； 修饰成员函数，说明该成员函数内不能修改成员变量。  const 的指针与引用  指针  指向常量的指针（pointer to const） 自身是常量的指针（常量指针，const pointer）   引用  指向常量的引用（reference to const） 没有 const reference，因为引用只是对象的别名，引用不是对象，不能用 const 修饰     （为了方便记忆可以想成）被 const 修饰（在 const 后面）的值不可改变，如下文使用例子中的 p2、p3\n 使用 const 使用\n// 类 class A { private: const int a; // 常对象成员，可以使用初始化列表或者类内初始化  public: // 构造函数  A() : a(0) { }; A(int x) : a(x) { }; // 初始化列表  // const可用于对重载函数的区分  int getValue(); // 普通成员函数  int getValue() const; // 常成员函数，不得修改类中的任何数据成员的值 }; void function() { // 对象  A b; // 普通对象，可以调用全部成员函数  const A a; // 常对象，只能调用常成员函数  const A *p = \u0026amp;a; // 指针变量，指向常对象  const A \u0026amp;q = a; // 指向常对象的引用  // 指针  char greeting[] = \u0026#34;Hello\u0026#34;; char* p1 = greeting; // 指针变量，指向字符数组变量  const char* p2 = greeting; // 指针变量，指向字符数组常量（const 后面是 char，说明指向的字符（char）不可改变）  char* const p3 = greeting; // 自身是常量的指针，指向字符数组变量（const 后面是 p3，说明 p3 指针自身不可改变）  const char* const p4 = greeting; // 自身是常量的指针，指向字符数组常量 } // 函数 void function1(const int Var); // 传递过来的参数在函数内不可变 void function2(const char* Var); // 参数指针所指内容为常量 void function3(char* const Var); // 参数指针为常量 void function4(const int\u0026amp; Var); // 引用参数在函数内为常量  // 函数返回值 const int function5(); // 返回一个常数 const int* function6(); // 返回一个指向常量的指针变量，使用：const int *p = function6(); int* const function7(); // 返回一个指向变量的常指针，使用：int* const p = function7(); 宏定义 #define 和 const 常量    宏定义 #define const 常量     宏定义，相当于字符替换 常量声明   预处理器处理 编译器处理   无类型安全检查 有类型安全检查   不分配内存 要分配内存   存储在代码段 存储在数据段   可通过 #undef 取消 不可取消    static 作用  修饰普通变量，修改变量的存储区域和生命周期，使变量存储在静态区，在 main 函数运行前就分配了空间，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。 修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static。 修饰成员变量，修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员。 修饰成员函数，修饰成员函数使得不需要生成对象就可以访问该函数，但是在 static 函数内不能访问非静态成员。  this 指针  this 指针是一个隐含于每一个非静态成员函数中的特殊指针。它指向调用该成员函数的那个对象。 当对一个对象调用成员函数时，编译程序先将对象的地址赋给 this 指针，然后调用成员函数，每次成员函数存取数据成员时，都隐式使用 this 指针。 当一个成员函数被调用时，自动向它传递一个隐含的参数，该参数是一个指向这个成员函数所在的对象的指针。 this 指针被隐含地声明为: ClassName *const this，这意味着不能给 this 指针赋值；在 ClassName 类的 const 成员函数中，this 指针的类型为：const ClassName* const，这说明不能对 this 指针所指向的这种对象是不可修改的（即不能对这种对象的数据成员进行赋值操作）； this 并不是一个常规变量，而是个右值，所以不能取得 this 的地址（不能 \u0026amp;this）。 在以下场景中，经常需要显式引用 this 指针：  为实现对象的链式引用； 为避免对同一对象进行赋值操作； 在实现一些数据结构时，如 list。    inline 内联函数 特征  相当于把内联函数里面的内容写在调用内联函数处； 相当于不用执行进入函数的步骤，直接执行函数体； 相当于宏，却比宏多了类型检查，真正具有函数特性； 编译器一般不内联包含循环、递归、switch 等复杂操作的内联函数； 在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数。  使用 inline 使用\n// 声明1（加 inline，建议使用） inline int functionName(int first, int second,...); // 声明2（不加 inline） int functionName(int first, int second,...); // 定义 inline int functionName(int first, int second,...) {/****/}; // 类内定义，隐式内联 class A { int doA() { return 0; } // 隐式内联 } // 类外定义，需要显式内联 class A { int doA(); } inline int A::doA() { return 0; } // 需要显式内联 编译器对 inline 函数的处理步骤  将 inline 函数体复制到 inline 函数调用点处； 为所用 inline 函数中的局部变量分配内存空间； 将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中； 如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 GOTO）。  优缺点 优点\n 内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。 内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会。 在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能。 内联函数在运行时可调试，而宏定义不可以。  缺点\n 代码膨胀。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。 inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接。 是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。  虚函数（virtual）可以是内联函数（inline）吗？  Are \u0026ldquo;inline virtual\u0026rdquo; member functions ever actually \u0026ldquo;inlined\u0026rdquo;?\n  虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。 内联是在编译器建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。 inline virtual 唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 Base::who()），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。  虚函数内联使用\n#include \u0026lt;iostream\u0026gt; using namespace std; class Base { public: inline virtual void who() { cout \u0026lt;\u0026lt; \u0026#34;I am Base\\n\u0026#34;; } virtual ~Base() {} }; class Derived : public Base { public: inline void who() // 不写inline时隐式内联 \t{ cout \u0026lt;\u0026lt; \u0026#34;I am Derived\\n\u0026#34;; } }; int main() { // 此处的虚函数 who()，是通过类（Base）的具体对象（b）来调用的，编译期间就能确定了，所以它可以是内联的，但最终是否内联取决于编译器。 \tBase b; b.who(); // 此处的虚函数是通过指针调用的，呈现多态性，需要在运行时期间才能确定，所以不能为内联。 \tBase *ptr = new Derived(); ptr-\u0026gt;who(); // 因为Base有虚析构函数（virtual ~Base() {}），所以 delete 时，会先调用派生类（Derived）析构函数，再调用基类（Base）析构函数，防止内存泄漏。 \tdelete ptr; ptr = nullptr; system(\u0026#34;pause\u0026#34;); return 0; } volatile volatile int i = 10;  volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以使用 volatile 告诉编译器不应对这样的对象进行优化。 volatile 关键字声明的变量，每次访问时都必须从内存中取出值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值） const 可以是 volatile （如只读的状态寄存器） 指针可以是 volatile  assert() 断言，是宏，而非函数。assert 宏的原型定义在 \u0026lt;assert.h\u0026gt;（C）、\u0026lt;cassert\u0026gt;（C++）中，其作用是如果它的条件返回错误，则终止程序执行。可以通过定义 NDEBUG 来关闭 assert，但是需要在源代码的开头，include \u0026lt;assert.h\u0026gt; 之前。\nassert() 使用\n#define NDEBUG // 加上这行，则 assert 不可用 #include \u0026lt;assert.h\u0026gt; assert( p != NULL ); // assert 不可用 sizeof()  sizeof 对数组，得到整个数组所占空间大小。 sizeof 对指针，得到指针本身所占空间大小。  #pragma pack(n) 设定结构体、联合以及类成员变量以 n 字节方式对齐\n#pragma pack(n) 使用\n#pragma pack(push) // 保存对齐状态 #pragma pack(4) // 设定为 4 字节对齐  struct test { char m1; double m4; int m3; }; #pragma pack(pop) // 恢复对齐状态 位域 Bit mode: 2; // mode 占 2 位 类可以将其（非静态）数据成员定义为位域（bit-field），在一个位域中含有一定数量的二进制位。当一个程序需要向其他程序或硬件设备传递二进制数据时，通常会用到位域。\n 位域在内存中的布局是与机器有关的 位域的类型必须是整型或枚举类型，带符号类型中的位域的行为将因具体实现而定 取地址运算符（\u0026amp;）不能作用于位域，任何指针都无法指向类的位域  extern \u0026ldquo;C\u0026rdquo;  被 extern 限定的函数或变量是 extern 类型的 被 extern \u0026quot;C\u0026quot; 修饰的变量和函数是按照 C 语言方式编译和链接的  extern \u0026quot;C\u0026quot; 的作用是让 C++ 编译器将 extern \u0026quot;C\u0026quot; 声明的代码当作 C 语言代码处理，可以避免 C++ 因符号修饰导致代码不能和C语言库中的符号进行链接的问题。\nextern \u0026ldquo;C\u0026rdquo; 使用\n#ifdef __cplusplus extern \u0026#34;C\u0026#34; { #endif  void *memset(void *, int, size_t); #ifdef __cplusplus } #endif struct 和 typedef struct C 中 // c typedef struct Student { int age; } S; 等价于\n// c struct Student { int age; }; typedef struct Student S; 此时 S 等价于 struct Student，但两个标识符名称空间不相同。\n另外还可以定义与 struct Student 不冲突的 void Student() {}。\nC++ 中 由于编译器定位符号的规则（搜索规则）改变，导致不同于C语言。\n一、如果在类标识符空间定义了 struct Student {...};，使用 Student me; 时，编译器将搜索全局标识符表，Student 未找到，则在类标识符内搜索。\n即表现为可以使用 Student 也可以使用 struct Student，如下：\n// cpp struct Student { int age; }; void f( Student me ); // 正确，\u0026#34;struct\u0026#34; 关键字可省略 二、若定义了与 Student 同名函数之后，则 Student 只代表函数，不代表结构体，如下：\ntypedef struct Student { int age; } S; void Student() {} // 正确，定义后 \u0026#34;Student\u0026#34; 只代表此函数  //void S() {} // 错误，符号 \u0026#34;S\u0026#34; 已经被定义为一个 \u0026#34;struct Student\u0026#34; 的别名  int main() { Student(); struct Student me; // 或者 \u0026#34;S me\u0026#34;;  return 0; } C++ 中 struct 和 class 总的来说，struct 更适合看成是一个数据结构的实现体，class 更适合看成是一个对象的实现体。\n区别  最本质的一个区别就是默认的访问控制  默认的继承访问权限。struct 是 public 的，class 是 private 的。 struct 作为数据结构的实现体，它默认的数据访问控制是 public 的，而 class 作为对象的实现体，它默认的成员变量访问控制是 private 的。    union 联合 联合（union）是一种节省空间的特殊的类，一个 union 可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值。当某个成员被赋值后其他成员变为未定义状态。联合有如下特点：\n 默认访问控制符为 public 可以含有构造函数、析构函数 不能含有引用类型的成员 不能继承自其他类，不能作为基类 不能含有虚函数 匿名 union 在定义所在作用域可直接访问 union 成员 匿名 union 不能包含 protected 成员或 private 成员 全局匿名联合必须是静态（static）的  union 使用\n#include\u0026lt;iostream\u0026gt; union UnionTest { UnionTest() : i(10) {}; int i; double d; }; static union { int i; double d; }; int main() { UnionTest u; union { int i; double d; }; std::cout \u0026lt;\u0026lt; u.i \u0026lt;\u0026lt; std::endl; // 输出 UnionTest 联合的 10  ::i = 20; std::cout \u0026lt;\u0026lt; ::i \u0026lt;\u0026lt; std::endl; // 输出全局静态匿名联合的 20  i = 30; std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; std::endl; // 输出局部匿名联合的 30  return 0; } C 实现 C++ 类 C 实现 C++ 的面向对象特性（封装、继承、多态）\n 封装：使用函数指针把属性与方法封装到结构体中 继承：结构体嵌套 多态：父类与子类方法的函数指针不同   Can you write object-oriented code in C? [closed]\n explicit（显式）关键字  explicit 修饰构造函数时，可以防止隐式转换和复制初始化 explicit 修饰转换函数时，可以防止隐式转换，但 按语境转换 除外  explicit 使用\nstruct A { A(int) { } operator bool() const { return true; } }; struct B { explicit B(int) {} explicit operator bool() const { return true; } }; void doA(A a) {} void doB(B b) {} int main() { A a1(1);\t// OK：直接初始化 \tA a2 = 1;\t// OK：复制初始化 \tA a3{ 1 };\t// OK：直接列表初始化 \tA a4 = { 1 };\t// OK：复制列表初始化 \tA a5 = (A)1;\t// OK：允许 static_cast 的显式转换 \tdoA(1);\t// OK：允许从 int 到 A 的隐式转换 \tif (a1);\t// OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换 \tbool a6(a1);\t// OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换 \tbool a7 = a1;\t// OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换 \tbool a8 = static_cast\u0026lt;bool\u0026gt;(a1); // OK ：static_cast 进行直接初始化  B b1(1);\t// OK：直接初始化 \tB b2 = 1;\t// 错误：被 explicit 修饰构造函数的对象不可以复制初始化 \tB b3{ 1 };\t// OK：直接列表初始化 \tB b4 = { 1 };\t// 错误：被 explicit 修饰构造函数的对象不可以复制列表初始化 \tB b5 = (B)1;\t// OK：允许 static_cast 的显式转换 \tdoB(1);\t// 错误：被 explicit 修饰构造函数的对象不可以从 int 到 B 的隐式转换 \tif (b1);\t// OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换 \tbool b6(b1);\t// OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换 \tbool b7 = b1;\t// 错误：被 explicit 修饰转换函数 B::operator bool() 的对象不可以隐式转换 \tbool b8 = static_cast\u0026lt;bool\u0026gt;(b1); // OK：static_cast 进行直接初始化  return 0; } friend 友元类和友元函数  能访问私有成员 破坏封装性 友元关系不可传递 友元关系的单向性 友元声明的形式及数量不受限制  using using 声明 一条 using 声明 语句一次只引入命名空间的一个成员。它使得我们可以清楚知道程序中所引用的到底是哪个名字。如：\nusing namespace_name::name; 构造函数的 using 声明 在 C++11 中，派生类能够重用其直接基类定义的构造函数。\nclass Derived : Base { public: using Base::Base; /* ... */ }; 如上 using 声明，对于基类的每个构造函数，编译器都生成一个与之对应（形参列表完全相同）的派生类构造函数。生成如下类型构造函数：\nDerived(parms) : Base(args) { } using 指示 using 指示 使得某个特定命名空间中所有名字都可见，这样我们就无需再为它们添加任何前缀限定符了。如：\nusing namespace_name name; 尽量少使用 using 指示 污染命名空间  一般说来，使用 using 命令比使用 using 编译命令更安全，这是由于它只导入了指定的名称。如果该名称与局部名称发生冲突，编译器将发出指示。using编译命令导入所有的名称，包括可能并不需要的名称。如果与局部名称发生冲突，则局部名称将覆盖名称空间版本，而编译器并不会发出警告。另外，名称空间的开放性意味着名称空间的名称可能分散在多个地方，这使得难以准确知道添加了哪些名称。\n using 使用\n尽量少使用 using 指示\nusing namespace std; 应该多使用 using 声明\nint x; std::cin \u0026gt;\u0026gt; x ; std::cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; std::endl; 或者\nusing std::cin; using std::cout; using std::endl; int x; cin \u0026gt;\u0026gt; x; cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl; :: 范围解析运算符 分类  全局作用域符（::name）：用于类型名称（类、类成员、成员函数、变量等）前，表示作用域为全局命名空间 类作用域符（class::name）：用于表示指定类型的作用域范围是具体某个类的 命名空间作用域符（namespace::name）:用于表示指定类型的作用域范围是具体某个命名空间的  :: 使用\nint count = 11; // 全局（::）的 count  class A { public: static int count; // 类 A 的 count（A::count） }; int A::count = 21; void fun() { int count = 31; // 初始化局部的 count 为 31 \tcount = 32; // 设置局部的 count 的值为 32 } int main() { ::count = 12; // 测试 1：设置全局的 count 的值为 12  A::count = 22; // 测试 2：设置类 A 的 count 为 22  fun();\t// 测试 3  return 0; } enum 枚举类型 限定作用域的枚举类型 enum class open_modes { input, output, append }; 不限定作用域的枚举类型 enum color { red, yellow, green }; enum { floatPrec = 6, doublePrec = 10 }; decltype decltype 关键字用于检查实体的声明类型或表达式的类型及值分类。语法：\ndecltype ( expression ) decltype 使用\n// 尾置返回允许我们在参数列表之后声明返回类型 template \u0026lt;typename It\u0026gt; auto fcn(It beg, It end) -\u0026gt; decltype(*beg) { // 处理序列  return *beg; // 返回序列中一个元素的引用 } // 为了使用模板参数成员，必须用 typename template \u0026lt;typename It\u0026gt; auto fcn2(It beg, It end) -\u0026gt; typename remove_reference\u0026lt;decltype(*beg)\u0026gt;::type { // 处理序列  return *beg; // 返回序列中一个元素的拷贝 } 引用 左值引用 常规引用，一般表示对象的身份。\n右值引用 右值引用就是必须绑定到右值（一个临时对象、将要销毁的对象）的引用，一般表示对象的值。\n右值引用可实现转移语义（Move Sementics）和精确传递（Perfect Forwarding），它的主要目的有两个方面：\n 消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。 能够更简洁明确地定义泛型函数。  引用折叠  X\u0026amp; \u0026amp;、X\u0026amp; \u0026amp;\u0026amp;、X\u0026amp;\u0026amp; \u0026amp; 可折叠成 X\u0026amp; X\u0026amp;\u0026amp; \u0026amp;\u0026amp; 可折叠成 X\u0026amp;\u0026amp;  宏  宏定义可以实现类似于函数的功能，但是它终归不是函数，而宏定义中括弧中的“参数”也不是真的参数，在宏展开的时候对 “参数” 进行的是一对一的替换。  成员初始化列表 好处\n 更高效：少了一次调用默认构造函数的过程。 有些场合必须要用初始化列表：  常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面 引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面 没有默认构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化    initializer_list 列表初始化 用花括号初始化器列表初始化一个对象，其中对应构造函数接受一个 std::initializer_list 参数.\ninitializer_list 使用\n#include \u0026lt;iostream\u0026gt;#include \u0026lt;vector\u0026gt;#include \u0026lt;initializer_list\u0026gt; template \u0026lt;class T\u0026gt; struct S { std::vector\u0026lt;T\u0026gt; v; S(std::initializer_list\u0026lt;T\u0026gt; l) : v(l) { std::cout \u0026lt;\u0026lt; \u0026#34;constructed with a \u0026#34; \u0026lt;\u0026lt; l.size() \u0026lt;\u0026lt; \u0026#34;-element list\\n\u0026#34;; } void append(std::initializer_list\u0026lt;T\u0026gt; l) { v.insert(v.end(), l.begin(), l.end()); } std::pair\u0026lt;const T*, std::size_t\u0026gt; c_arr() const { return {\u0026amp;v[0], v.size()}; // 在 return 语句中复制列表初始化  // 这不使用 std::initializer_list  } }; template \u0026lt;typename T\u0026gt; void templated_fn(T) {} int main() { S\u0026lt;int\u0026gt; s = {1, 2, 3, 4, 5}; // 复制初始化  s.append({6, 7, 8}); // 函数调用中的列表初始化  std::cout \u0026lt;\u0026lt; \u0026#34;The vector size is now \u0026#34; \u0026lt;\u0026lt; s.c_arr().second \u0026lt;\u0026lt; \u0026#34; ints:\\n\u0026#34;; for (auto n : s.v) std::cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#39; \u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#34;Range-for over brace-init-list: \\n\u0026#34;; for (int x : {-1, -2, -3}) // auto 的规则令此带范围 for 工作  std::cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#39; \u0026#39;; std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; auto al = {10, 11, 12}; // auto 的特殊规则  std::cout \u0026lt;\u0026lt; \u0026#34;The list bound to auto has size() = \u0026#34; \u0026lt;\u0026lt; al.size() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // templated_fn({1, 2, 3}); // 编译错误！“ {1, 2, 3} ”不是表达式，  // 它无类型，故 T 无法推导  templated_fn\u0026lt;std::initializer_list\u0026lt;int\u0026gt;\u0026gt;({1, 2, 3}); // OK  templated_fn\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt;({1, 2, 3}); // 也 OK } 面向对象 面向对象程序设计（Object-oriented programming，OOP）是种具有对象概念的程序编程典范，同时也是一种程序开发的抽象方针。\n面向对象三大特征 —— 封装、继承、多态\n封装 把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。关键字：public, protected, private。不写默认为 private。\n public 成员：可以被任意实体访问 protected 成员：只允许被子类及本类的成员函数访问 private 成员：只允许被本类的成员函数、友元类或友元函数访问  继承  基类（父类）——\u0026gt; 派生类（子类）  多态  多态，即多种状态（形态）。简单来说，我们可以将多态定义为消息以多种形式显示的能力。 多态是以封装和继承为基础的。 C++ 多态分类及实现：  重载多态（Ad-hoc Polymorphism，编译期）：函数重载、运算符重载 子类型多态（Subtype Polymorphism，运行期）：虚函数 参数多态性（Parametric Polymorphism，编译期）：类模板、函数模板 强制多态（Coercion Polymorphism，编译期/运行期）：基本类型转换、自定义类型转换     The Four Polymorphisms in C++\n 静态多态（编译期/早绑定） 函数重载\nclass A { public: void do(int a); void do(int a, int b); }; 动态多态（运行期期/晚绑定）  虚函数：用 virtual 修饰成员函数，使其成为虚函数 动态绑定：当使用基类的引用或指针调用一个虚函数时将发生动态绑定  注意：\n 可以将派生类的对象赋值给基类的指针或引用，反之不可 普通函数（非类成员函数）不能是虚函数 静态函数（static）不能是虚函数 构造函数不能是虚函数（因为在调用构造函数时，虚表指针并没有在对象的内存空间中，必须要构造函数调用完成后才会形成虚表指针） 内联函数不能是表现多态性时的虚函数，解释见：虚函数（virtual）可以是内联函数（inline）吗？  动态多态使用\nclass Shape // 形状类 { public: virtual double calcArea() { ... } virtual ~Shape(); }; class Circle : public Shape // 圆形类 { public: virtual double calcArea(); ... }; class Rect : public Shape // 矩形类 { public: virtual double calcArea(); ... }; int main() { Shape * shape1 = new Circle(4.0); Shape * shape2 = new Rect(5.0, 6.0); shape1-\u0026gt;calcArea(); // 调用圆形类里面的方法  shape2-\u0026gt;calcArea(); // 调用矩形类里面的方法  delete shape1; shape1 = nullptr; delete shape2; shape2 = nullptr; return 0; } 虚析构函数 虚析构函数是为了解决基类的指针指向派生类对象，并用基类的指针删除派生类对象。\n虚析构函数使用\nclass Shape { public: Shape(); // 构造函数不能是虚函数  virtual double calcArea(); virtual ~Shape(); // 虚析构函数 }; class Circle : public Shape // 圆形类 { public: virtual double calcArea(); ... }; int main() { Shape * shape1 = new Circle(4.0); shape1-\u0026gt;calcArea(); delete shape1; // 因为Shape有虚析构函数，所以delete释放内存时，先调用子类析构函数，再调用基类析构函数，防止内存泄漏。  shape1 = NULL; return 0； } 纯虚函数 纯虚函数是一种特殊的虚函数，在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做。\nvirtual int A() = 0; 虚函数、纯虚函数  类里如果声明了虚函数，这个函数是实现的，哪怕是空实现，它的作用就是为了能让这个函数在它的子类里面可以被覆盖（override），这样的话，编译器就可以使用后期绑定来达到多态了。纯虚函数只是一个接口，是个函数的声明而已，它要留到子类里去实现。 虚函数在子类里面可以不重写；但纯虚函数必须在子类实现才可以实例化子类。 虚函数的类用于 “实作继承”，继承接口的同时也继承了父类的实现。纯虚函数关注的是接口的统一性，实现由子类完成。 带纯虚函数的类叫抽象类，这种类不能直接生成对象，而只有被继承，并重写其虚函数后，才能使用。抽象类被继承后，子类可以继续是抽象类，也可以是普通类。 虚基类是虚继承中的基类，具体见下文虚继承。   CSDN . C++ 中的虚函数、纯虚函数区别和联系\n 虚函数指针、虚函数表  虚函数指针：在含有虚函数类的对象中，指向虚函数表，在运行时确定。 虚函数表：在程序只读数据段（.rodata section，见：目标文件存储结构），存放虚函数指针，如果派生类实现了基类的某个虚函数，则在虚表中覆盖原本基类的那个虚函数指针，在编译时根据类的声明创建。   C++中的虚函数(表)实现机制以及用C语言对其进行的模拟实现\n 虚继承 虚继承用于解决多继承条件下的菱形继承问题（浪费存储空间、存在二义性）。\n底层实现原理与编译器相关，一般通过虚基类指针和虚基类表实现，每个虚继承的子类都有一个虚基类指针（占用一个指针的存储空间，4字节）和虚基类表（不占用类对象的存储空间）（需要强调的是，虚基类依旧会在子类里面存在拷贝，只是仅仅最多存在一份而已，并不是不在子类里面了）；当虚继承的子类被当做父类继承时，虚基类指针也会被继承。\n实际上，vbptr 指的是虚基类表指针（virtual base table pointer），该指针指向了一个虚基类表（virtual table），虚表中记录了虚基类与本类的偏移地址；通过偏移地址，这样就找到了虚基类成员，而虚继承也不用像普通多继承那样维持着公共基类（虚基类）的两份同样的拷贝，节省了存储空间。\n虚继承、虚函数  相同之处：都利用了虚指针（均占用类的存储空间）和虚表（均不占用类的存储空间） 不同之处：  虚继承  虚基类依旧存在继承类中，只占用存储空间 虚基类表存储的是虚基类相对直接继承类的偏移   虚函数  虚函数不占用存储空间 虚函数表存储的是虚函数地址      模板类、成员模板、虚函数  模板类中可以使用虚函数 一个类（无论是普通类还是类模板）的成员模板（本身是模板的成员函数）不能是虚函数  抽象类、接口类、聚合类  抽象类：含有纯虚函数的类 接口类：仅含有纯虚函数的抽象类 聚合类：用户可以直接访问其成员，并且具有特殊的初始化语法形式。满足如下特点：  所有成员都是 public 没有定义任何构造函数 没有类内初始化 没有基类，也没有 virtual 函数    内存分配和管理 malloc、calloc、realloc、alloca  malloc：申请指定字节数的内存。申请到的内存中的初始值不确定。 calloc：为指定长度的对象，分配能容纳其指定个数的内存。申请到的内存的每一位（bit）都初始化为 0。 realloc：更改以前分配的内存长度（增加或减少）。当增加长度时，可能需将以前分配区的内容移到另一个足够大的区域，而新增区域内的初始值则不确定。 alloca：在栈上申请内存。程序在出栈的时候，会自动释放内存。但是需要注意的是，alloca 不具可移植性, 而且在没有传统堆栈的机器上很难实现。alloca 不宜使用在必须广泛移植的程序中。C99 中支持变长数组 (VLA)，可以用来替代 alloca。  malloc、free 用于分配、释放内存\nmalloc、free 使用\n申请内存，确认是否申请成功\nchar *str = (char*) malloc(100); assert(str != nullptr); 释放内存后指针置空\nfree(p); p = nullptr; new、delete  new / new[]：完成两件事，先底层调用 malloc 分配了内存，然后调用构造函数（创建对象）。 delete/delete[]：也完成两件事，先调用析构函数（清理资源），然后底层调用 free 释放空间。 new 在申请内存时会自动计算所需字节数，而 malloc 则需我们自己输入申请内存空间的字节数。  new、delete 使用\n申请内存，确认是否申请成功\nint main() { T* t = new T(); // 先内存分配 ，再构造函数  delete t; // 先析构函数，再内存释放  return 0; } 定位 new 定位 new（placement new）允许我们向 new 传递额外的地址参数，从而在预先指定的内存区域创建对象。\nnew (place_address) type new (place_address) type (initializers) new (place_address) type [size] new (place_address) type [size] { braced initializer list }  place_address 是个指针 initializers 提供一个（可能为空的）以逗号分隔的初始值列表  delete this 合法吗？  Is it legal (and moral) for a member function to say delete this?\n 合法，但：\n 必须保证 this 对象是通过 new（不是 new[]、不是 placement new、不是栈上、不是全局、不是其他对象成员）分配的 必须保证调用 delete this 的成员函数是最后一个调用 this 的成员函数 必须保证成员函数的 delete this  后面没有调用 this 了 必须保证 delete this 后没有人使用了  如何定义一个只能在堆上（栈上）生成对象的类？  如何定义一个只能在堆上（栈上）生成对象的类?\n 只能在堆上 方法：将析构函数设置为私有\n原因：C++ 是静态绑定语言，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。若析构函数不可访问，则不能在栈上创建对象。\n只能在栈上 方法：将 new 和 delete 重载为私有\n原因：在堆上生成对象，使用 new 关键词操作，其过程分为两阶段：第一阶段，使用 new 在堆上寻找可用内存，分配给对象；第二阶段，调用构造函数生成对象。将 new 操作设置为私有，那么第一阶段就无法完成，就不能够在堆上生成对象。\n智能指针 C++ 标准库（STL）中 头文件：#include \u0026lt;memory\u0026gt;\nC++ 98 std::auto_ptr\u0026lt;std::string\u0026gt; ps (new std::string(str))； C++ 11  shared_ptr unique_ptr weak_ptr auto_ptr（被 C++11 弃用）   Class shared_ptr 实现共享式拥有（shared ownership）概念。多个智能指针指向相同对象，该对象和其相关资源会在 “最后一个 reference 被销毁” 时被释放。为了在结构较复杂的情景中执行上述工作，标准库提供 weak_ptr、bad_weak_ptr 和 enable_shared_from_this 等辅助类。 Class unique_ptr 实现独占式拥有（exclusive ownership）或严格拥有（strict ownership）概念，保证同一时间内只有一个智能指针可以指向该对象。你可以移交拥有权。它对于避免内存泄漏（resource leak）——如 new 后忘记 delete ——特别有用。  shared_ptr 多个智能指针可以共享同一个对象，对象的最末一个拥有着有责任销毁对象，并清理与该对象相关的所有资源。\n 支持定制型删除器（custom deleter），可防范 Cross-DLL 问题（对象在动态链接库（DLL）中被 new 创建，却在另一个 DLL 内被 delete 销毁）、自动解除互斥锁  weak_ptr weak_ptr 允许你共享但不拥有某对象，一旦最末一个拥有该对象的智能指针失去了所有权，任何 weak_ptr 都会自动成空（empty）。因此，在 default 和 copy 构造函数之外，weak_ptr 只提供 “接受一个 shared_ptr” 的构造函数。\n 可打破环状引用（cycles of references，两个其实已经没有被使用的对象彼此互指，使之看似还在 “被使用” 的状态）的问题  unique_ptr unique_ptr 是 C++11 才开始提供的类型，是一种在异常时可以帮助避免资源泄漏的智能指针。采用独占式拥有，意味着可以确保一个对象和其相应的资源同一时间只被一个 pointer 拥有。一旦拥有着被销毁或编程 empty，或开始拥有另一个对象，先前拥有的那个对象就会被销毁，其任何相应资源亦会被释放。\n unique_ptr 用于取代 auto_ptr  auto_ptr 被 c++11 弃用，原因是缺乏语言特性如 “针对构造和赋值” 的 std::move 语义，以及其他瑕疵。\nauto_ptr 与 unique_ptr 比较  auto_ptr 可以赋值拷贝，复制拷贝后所有权转移；unqiue_ptr 无拷贝赋值语义，但实现了move 语义； auto_ptr 对象不能管理数组（析构调用 delete），unique_ptr 可以管理数组（析构调用 delete[] ）；  强制类型转换运算符  MSDN . 强制转换运算符\n static_cast  用于非多态类型的转换 不执行运行时类型检查（转换安全性不如 dynamic_cast） 通常用于转换数值数据类型（如 float -\u0026gt; int） 可以在整个类层次结构中移动指针，子类转化为父类安全（向上转换），父类转化为子类不安全（因为子类可能有不在父类的字段或方法）   向上转换是一种隐式转换。\n dynamic_cast  用于多态类型的转换 执行行运行时类型检查 只适用于指针或引用 对不明确的指针的转换将失败（返回 nullptr），但不引发异常 可以在整个类层次结构中移动指针，包括向上转换、向下转换  const_cast  用于删除 const、volatile 和 __unaligned 特性（如将 const int 类型转换为 int 类型 ）  reinterpret_cast  用于位的简单重新解释 滥用 reinterpret_cast 运算符可能很容易带来风险。 除非所需转换本身是低级别的，否则应使用其他强制转换运算符之一。 允许将任何指针转换为任何其他指针类型（如 char* 到 int* 或 One_class* 到 Unrelated_class* 之类的转换，但其本身并不安全） 也允许将任何整数类型转换为任何指针类型以及反向转换。 reinterpret_cast 运算符不能丢掉 const、volatile 或 __unaligned 特性。 reinterpret_cast 的一个实际用途是在哈希函数中，即，通过让两个不同的值几乎不以相同的索引结尾的方式将值映射到索引。  bad_cast  由于强制转换为引用类型失败，dynamic_cast 运算符引发 bad_cast 异常。  bad_cast 使用\ntry { Circle\u0026amp; ref_circle = dynamic_cast\u0026lt;Circle\u0026amp;\u0026gt;(ref_shape); } catch (bad_cast b) { cout \u0026lt;\u0026lt; \u0026#34;Caught: \u0026#34; \u0026lt;\u0026lt; b.what(); } 运行时类型信息 (RTTI) dynamic_cast  用于多态类型的转换  typeid  typeid 运算符允许在运行时确定对象的类型 type_id 返回一个 type_info 对象的引用 如果想通过基类的指针获得派生类的数据类型，基类必须带有虚函数 只能获取对象的实际类型  type_info  type_info 类描述编译器在程序中生成的类型信息。 此类的对象可以有效存储指向类型的名称的指针。 type_info 类还可存储适合比较两个类型是否相等或比较其排列顺序的编码值。 类型的编码规则和排列顺序是未指定的，并且可能因程序而异。 头文件：typeinfo  typeid、type_info 使用\n#include \u0026lt;iostream\u0026gt;using namespace std; class Flyable // 能飞的 { public: virtual void takeoff() = 0; // 起飞  virtual void land() = 0; // 降落 }; class Bird : public Flyable // 鸟 { public: void foraging() {...} // 觅食  virtual void takeoff() {...} virtual void land() {...} virtual ~Bird(){} }; class Plane : public Flyable // 飞机 { public: void carry() {...} // 运输  virtual void takeoff() {...} virtual void land() {...} }; class type_info { public: const char* name() const; bool operator == (const type_info \u0026amp; rhs) const; bool operator != (const type_info \u0026amp; rhs) const; int before(const type_info \u0026amp; rhs) const; virtual ~type_info(); private: ... }; void doSomething(Flyable *obj) // 做些事情 { obj-\u0026gt;takeoff(); cout \u0026lt;\u0026lt; typeid(*obj).name() \u0026lt;\u0026lt; endl; // 输出传入对象类型（\u0026#34;class Bird\u0026#34; or \u0026#34;class Plane\u0026#34;）  if(typeid(*obj) == typeid(Bird)) // 判断对象类型  { Bird *bird = dynamic_cast\u0026lt;Bird *\u0026gt;(obj); // 对象转化  bird-\u0026gt;foraging(); } obj-\u0026gt;land(); } int main(){ Bird *b = new Bird(); doSomething(b); delete b; b = nullptr; return 0; } ","permalink":"/collection/cc++base/","summary":"转载自https://github.com/huihut/interview const 作用 修饰变量，说明该变量不可以被改变； 修饰指针，分为指向常量的","title":"【转载】C++ 开发必备之 C/C++基础"},{"content":" 乞丐：（大笑）这倒像是是实话了。\n  砍柴人：我可不撒谎，是我亲眼看见来的。\n  乞丐：那也靠不住。\n  砍柴人：是真的，我可不撒谎。\n  乞丐：撒谎的人才不会说自己是说谎的呢。\n  云游和尚：这真是可怕的事了。若是任何人都不能相信，那么这个世界就成了地狱。\n  乞丐：没错，这世界就是个地狱。\n  云游和尚：不，我相信人。我不想把世界看成地狱。\n  乞丐：光说好听的话是不中用的。你倒想想看，刚才那三个人的话，又该相信谁的哪一句才好呢？\n  砍柴人：不懂……简直就是不懂。\n  乞丐：没有什么值得大惊小怪的。人做的事根本就是无法琢磨的。\n  婴儿：（啼哭）\n  砍柴人：你这是干什么？\n  乞丐：你才干什么呢。\n  砍柴人：你的心也太狠了。\n  乞丐：心狠？这小衣服反正早晚都会叫人剥去的。我拿走又有什么不对呢？\n  砍柴人：你是恶鬼么！\n  乞丐：恶鬼？我要是恶鬼，这个崽子的爹娘又该是什么？自己任性地图个痛快，搞出来的崽子也不想养活？把孩子扔了的他们才是真的恶鬼。\n  砍柴人：不对，这跟你说的不一样。你瞧，这小衣服上还缝着长命百岁的符咒呢。你替扔孩子的爹娘想想看吧，一定是有万不得已的苦衷啊。\n  乞丐：什么事都替别人着想，那就没完没了。\n  砍柴人：这也太自私自利……\n  乞丐：自私自利为什么不行？这是个人不如狗的世界。谁要不自顾自就活不成啊。\n  砍柴人：混蛋。是啊，谁都只是自私自利，只会给自己的自私自利行为辩护。那强盗！那女的！那男人！还有你也是！\n  乞丐：难道你就不是吗？真可笑。纠察使署的官差们也许能被你糊弄过去，可我不会。我问你……那女人的短刀哪儿去了？多襄丸也说是镶螺钿的好家伙。那把短刀哪儿去了？难道落在草里就没了吗？不是你偷了，还有谁呀？看来被我说中了啊。贼喊捉贼的你，才叫自私自利。还有什么说的吗？没有的话，我先走了。（大笑）\n  婴儿：（啼哭）\n  砍柴人：（伸手去抱孩子）\n  云游和尚：你想干嘛，还想剥这孩子的贴身布衫吗？\n  砍柴人：我家里有六个孩子，养六个还是再添这一个，都一样辛苦。\n  云游和尚：我为我说的话感到惭愧。\n  砍柴人：在如今这世道，凡是人都不能不怀疑他啊。惭愧的该是我。我自己就摸不清自己的心眼。\n  云游和尚：不，我得感激你。谢谢你，亏得你，我还是可以相信人的。\n ","permalink":"/blog/2022/01/09/rashomon/","summary":"乞丐：（大笑）这倒像是是实话了。 砍柴人：我可不撒谎，是我亲眼看见来的。 乞丐：那也靠不住。 砍柴人：是真的，我可不撒谎。 乞丐：撒谎的人才不会说自","title":"《罗生门》"},{"content":"Spring chicken，”春天里的小鸡“，这个词前一段时间总浮现在我脑海里，没想到，今天真成了冬天里的“落汤鸡”。\n今天如同往常一样，在单位餐厅吃晚餐。正当吃完去放餐具时，在我旁边的一位女生，餐盘没拿稳，一大碗面汤撒在我身上……在事情发生前一刻，我还在想着别的什么事情；发生的那瞬间，我下意识伸手去扶；发生后的那一刻，我脑子还有点懵。恍惚之间，感觉我脑海里也幻想过这个场景。低头看下衣服，确认是真实发生的……因为放餐盘的时候需要把筷子什么的放到另一个盆里，必然有一刻是需要一只手拿筷子，一只手拿着餐盘，如果是吃面的话，碗里还有汤，会比较重，我以前还曾幻想过餐盘没拿稳撒到别人的场景，没想到今天真发生了！不过这角色互换了……这事很尴尬，肇事者不停道歉，我当时的想法是“今晚不用加班了……”，不过看到衣服上挂的面条还是没说出来，只能安慰她一下就溜回去了……\n","permalink":"/blog/2022/01/05/%E6%88%91%E7%BB%88%E4%BA%8E%E5%8F%98%E6%88%90%E4%BA%86%E5%86%AC%E5%A4%A9%E7%9A%84%E8%90%BD%E6%B1%A4%E9%B8%A1/","summary":"Spring chicken，”春天里的小鸡“，这个词前一段时间总浮现在我脑海里，没想到，今天真成了冬天里的“落汤鸡”。 今天如同往常一样，在单位餐厅吃晚","title":"我终于变成了冬天的落汤鸡"},{"content":" —— Charlie Chaplin\n  As I began to love myself\nI found that anguish and emotional suffering\nare only warning signs\nthat I was living against my own truth.\nToday, I know, this is “AUTHENTICITY”.\n  当我真正开始爱自己\n我才意识到，所有的痛苦和情感的折磨\n仅仅是在提醒\n我的生活背离了真正的自己\n今日，我明白了，这叫做“真实“\n  As I began to love myself\nI understood how much it can offend somebody\nif I try to force my desires on this person,\neven though I knew the time was not right\nand the person was not ready for it,\nand even though this person was me.\nToday I call it “RESPECT”.\n  当我真正开始爱自己\n我才懂得，当我将自己的意愿强加于人时，是多么的冒犯无礼\n即使那时我知晓时机尚未成熟\n那个人也并未做好准备\n即使那个人就是我自己\n今日，我明白了这叫做“尊重”\n  As I began to love myself\nI stopped craving for a different life,\nand I could see that everything that surrounded me\nwas inviting me to grow.\nToday I call it “MATURITY”.\n  当我真正开始爱自己\n我不再苛求不一样的人生\n我明白任何发生在我身边的事\n都是对我成长的邀约\n今日，我称之为“成熟”\n  As I began to love myself\nI understood that at any circumstance,\nI am in the right place at the right time, and everything happens at the exactly right moment.\nSo I could be calm.\nToday I call it “SELF-CONFIDENCE”.\n  当我真正开始爱自己\n我才明白在任何情况下\n我其实一直处于恰好的时机、恰好的地方\n而每件事的发生也都恰如其分\n今日，我称其为“自信”\n  As I began to love myself\nI quit stealing my own time,\nand I stopped designing huge projects for the future.\nToday, I only do what brings me joy and happiness,\nthings I love to do and that make my heart cheer,\nand I do them in my own way and in my own rhythm.\nToday I call it “SIMPLICITY”.\n  当我真正开始爱自己\n我不再挥霍自己的生命和时间\n不再臂画波澜壮阔的未来\n今天的我，只做能为我带来喜悦和幸福的事\n做那些我所热爱，且能鼓舞我心的事情\n用我特有的方式\n按照我自己的节奏\n今日，我知晓这叫“单纯”\n  As I began to love myself\nI freed myself of anything that is no good for my health –\nfood, people, things, situations,\nand everything that drew me down and away from myself.\nAt first I called this attitude a healthy egoism.\nToday I know it is “LOVE OF ONESELF”.\n  当我真正开始爱自己\n我开始远离所有不健康的东西\n不论是饮食、人物、事情亦或环境\n远离拖累我、让我背离了真实自我的一切\n从前的我称这种态度为“有益健康的利己主义”\n今天我知道，这其实是“自爱”\n  As I began to love myself\nI quit trying to always be right,\nand ever since I was wrong less of the time.\nToday I discovered that is “MODESTY”.\n  当我真正开始爱自己\n我不再想永远正确\n从那时起，我犯错的时候反而更少\n现在我发现那就是“谦虚”\n  As I began to love myself\nI refused to go on living in the past and worrying about the future.\nNow, I only live for the moment, where everything is happening.\nToday I live each day, day by day,\nand I call it “FULFILLMENT”.\n  当我真正开始爱自己\n我不再继续沉溺与过去\n也不再为明天而忧虑\n如今，我只活在这一切发生的当下\n今天，我活在此时此地\n如此日复一日\n而我称这为“圆满”\n  As I began to love myself\nI recognized that my mind can disturb me and it can make me sick.\nBut as I connected it to my heart, my mind became a valuable ally.\nToday I call this connection “WISDOM OF THE HEART”.\n  当我真正开始爱自己 我明白，我的思虑扰乱了自我\n使我变得了无生趣\n但当我与本心相连\n心灵的力量就成为我坚实的后盾\n今日我称这种连结为“心灵的智慧”\n  We no longer need to fear arguments,\nconfrontations or any kind of problems with ourselves or others.\nEven stars collide,\nand out of their crashing new worlds are born.\nToday I know “THAT IS LIFE”!\n  我们无需再害怕生命中的争论、冲突\n或是任何出现在与我们自己或与其他人之间的问题\n因为即使是星星也会有碰撞在一起的时候\n而从它们的撞击中，新的世界将会诞生\n今天我知道，这，就是“生命”！\n ","permalink":"/blog/2022/01/03/asibegantolovemyself/","summary":"—— Charlie Chaplin As I began to love myself I found that anguish and emotional suffering are only warning signs that I was living against my own truth. Today, I know, this is “AUTHENTICITY”. 当我真正开始爱自己 我才意识到，所有的痛苦和","title":"《As I Began to Love Myself》"},{"content":"刚刚躺着的时候，我还在想着喵喵到哪去了。因为我在它的窝没看到，别的地方也没找到。还在想着，突然就听到它跳上床的声音……\n今天给它伤口涂了些药，用酒精擦拭的时候它没有反抗，但后面它还是把伤口贴咬下来了。白天的时候，它就侧躺着在地上晒太阳，我看着它，它也在看着我。我玩手机的时候，它就跑到我怀里，枕着我的手。我能感受它呼吸，但，即使距离如此近，我仍不能理解它。因为人和动物无法交流，我不知道它是否在害怕，不知道它是否很痛苦。\n人类也一样，也许无尽的未来中，人类也能实现“神圣的卡拉连接着我们每个人的思想“的梦想，但现在，每个人都是独立的，我们的大脑都在独立地思考。但是，目前是什么力量连接着我们呢？我想，答案，就在我们心中。\n","permalink":"/blog/2022/01/01/%E4%BD%A0%E6%B0%B8%E8%BF%9C%E9%83%BD%E4%B8%8D%E6%98%AF%E7%8B%AC%E8%87%AA%E4%B8%80%E4%BA%BA/","summary":"刚刚躺着的时候，我还在想着喵喵到哪去了。因为我在它的窝没看到，别的地方也没找到。还在想着，突然就听到它跳上床的声音…… 今天给它伤口涂了些药，","title":"你永远都不是独自一人"},{"content":" when the day meets the night, when the knife meets the fork, when you meet your soulmate.\n—— Jessie\n 在高中那会，我开始喜欢听电台音频。也不知道为了学英语，还是为了找到一个声音塞满思绪。这时，我遇到了 SoulmateEnglish 频道，刚听到 Jessie 的音频，我至今还记得那份感动。遗憾的是，SoulmateEnglish 频道很多年没更新了，我也以为再也不会遇见这个声音了。\n然而缘总是很奇妙，在很久很久后的一天，我抓住了它的尾巴。在某个的平台里，我发现了活跃中的 SoulmateEnglish 频道，我当时感觉非常高兴，就在最新的作品下留言，Jessie 回复了。\n我认为互联网最大的魅力便在于此，沿着历史的痕迹，你可以了解一个人的过往，了解当时他/她的喜怒哀乐，只要有两台设备，它就可以让两个人跨越时间、空间的界限，进行交流。\n","permalink":"/blog/2021/12/30/%E7%9B%B8%E9%80%A2%E7%A6%BB%E5%88%AB%E6%97%B6/","summary":"when the day meets the night, when the knife meets the fork, when you meet your soulmate. —— Jessie 在高中那会，我开始喜欢听电台音频。也不知道为了学英语，还是为了找到一个声音塞满思绪。这时，我遇到了 SoulmateEnglish","title":"相逢离别时"},{"content":"转载自https://github.com/andycai/cprimer\nnew和delete运算符用于动态分配和撤销内存的运算符\n(1) new用法  开辟单变量地址空间    new int; //开辟一个存放数组的存储空间,返回一个指向该存储空间的地址.int *a = new int 即为将一个int类型的地址赋值给整型指针a.\n  int *a = new int(5) 作用同上,但是同时将整数赋值为5\n   开辟数组空间\n一维:\n int *a = new int[100]; // 开辟一个大小为100的整型数组空间  二维:\n int **a = new int[5][6]  三维及其以上:依此类推\n  一般用法: new 类型 [初值]\n(2) delete用法   int *a = new int;\n delete a; //释放单个int的空间    int *a = new int[5];\n delete [] a; //释放int数组空间    要访问new所开辟的结构体空间,无法直接通过变量名进行,只能通过赋值的指针进行访问。\n用new和delete可以动态开辟，撤销地址空间。在编程序时,若用完一个变量(一般是暂时存储的数组)，下次需要再用，但却又想省去重新初始化的功夫，可以在每次开始使用时开辟一个空间，在用完后撤销它。\n导航  目录 上一章：Chapter 4 - uint8_t, uint16_t, uint32_t, uint64_t  ","permalink":"/collection/cprimer04/","summary":"转载自https://github.com/andycai/cprimer new和delete运算符用于动态分配和撤销内存的运算符 (1) new用","title":"【转载】C Primer 之 new, delete"},{"content":"转载自https://github.com/andycai/cprimer\n3.1 char*, char[], string 在C中，并没有字符串这个数据类型，而是使用字符数组来保存字符串。C字符串实际上就是一个以null(\u0026rsquo;\\0\u0026rsquo;)字符结尾的字符数组，null字符表示字符串的结束。需要注意的是：只有以null字符结尾的字符数组才是C字符串，否则只是一般的C字符数组。\nC字符串定义时可以利用\u0026quot;=\u0026ldquo;号进行初始化，但是以后不能利用\u0026rdquo;=\u0026ldquo;对C字符串进行赋值。对C字符串的操作需要通过\u0026quot;string\u0026quot;文件中定义的字符串处理函数。例如：\n//字符串的初始化 char a[11] = \u0026quot;huanying\u0026quot;; //字符串的赋值 strcpy(a,\u0026quot;nihao\u0026quot;) //获取字符串的长度，不包括'\\0'在内 strlen(a); printf(\u0026quot;%s\u0026quot;,a);  在C中也可以使用字符指针来访问一个字符串,通过字符指针指向存放字符串数组的首元素地址来进行访问. char *a = \u0026ldquo;nihao\u0026rdquo;; printf(\u0026quot;%s\u0026rdquo;,a);\n在C++中则把字符串封装成了一种数据类型string,可以直接声明变量并进行赋值等字符串操作。以下是C字符串和C++中string的区别：\n C字符串 string对象 所需的头文件名称 \u0026lt;string\u0026gt;或\u0026lt;string.h\u0026gt; \u0026lt;string\u0026gt;或\u0026lt;string.h\u0026gt; 为什么需要头文件 为了使用字符串函数 为了使用string类 如何声明 char name[20]; string name; 如何初始化 char name[20]=\u0026quot;nihao\u0026quot;; string name = \u0026quot;nihao\u0026quot;; 必须声明字符串长度么？\t是 否 使用一个null字符么？ 是 否 怎样实现字符串赋值 strcpy(name,\u0026quot;John\u0026quot;); name = \u0026quot;John\u0026quot;; 其他优点 更快 更易于使用，优选方案 可以赋一个比现有字符更 不能 可以 长的字符串么？  (1) C++常用字符串函数 char s1[]=\u0026quot;I am a student\u0026quot;; char s2[20]=\u0026quot;teacher\u0026quot;; char s3[]=\u0026quot;student\u0026quot;; int result; char s4[20],*p;    串长度 int strlen(char *str)\ncout\u0026laquo;strlen(s1)\u0026laquo;endl; 输出14 cout\u0026laquo;strlen(s2)\u0026laquo;endl; 输出7\n  串拷贝 char *strcpy(char *str1,char *str2)\nstrcpy(s4,s2); //s4为\u0026quot;teacher\u0026quot;\n  串连接 char *strcat(char str1,charstr2)\nstrcat(s2,s3); //s2为\u0026quot;teacherstudent\u0026quot;\n  串比较 int strcmp(char *str1,char *str) //比较的是对应字符的ASCII码值，如果str1\u0026gt;str2,返回1\nresult=strcmp(s2,s3); //result\u0026gt;0 result=strcmp(s2,s2); //result=0 result=strcmp(s3,s2); //result\u0026lt;0\n  串定位 char *strchr(char *str,char ch)\np=strchr(s1,\u0026rsquo;s\u0026rsquo;); //找到返回字符在字串中的位置，否则返回-1 strcpy(p,s2); //s1为\u0026quot;I am a teacher\u0026quot;\n  在一个串中查找是否存在和另一个串相等的子串\n  截取子串形成一个新串\n  (2) 字符串的输入   方法一：使用输入操符来填充一个C字符串变量 例如： char a[80]; cin\u0026raquo;a; 注：以这种方式来读取C字符串时，会忽略最初的空白字符(空格、制表符和换行符)，而且输入会在下一个空格或者换行符处停止。\n  方法二：使用预定义函数getline获取整行输入(包括空格) getline函数有两个参数：第一个参数用于接收输入的C字符串变量；第二个参数用于规定getline最多能接收的字符个数。 例如: char a[80]; cin.getline(a,80); 当遇到行结束的时候，输入才会停止。\n  (3) C++ string类的输入  方法一：和C字符串输入的方法一相同。 方法二：使用getline函数。  例如：\nstring a; getline(cin,a);  (4) string对象和C字符串之间的转换 可以将C字符串存储在string类型的变量中，例如：\nchar a[] = \u0026quot;nihao\u0026quot;; string b; b=a;  但string对象不能自动的转换为C字符串，需要进行显式的类型转换，需要用到string类的成员函数c_str(). 例如：\nstrcpy(a,b.c_str());  (5) 字符串到数字的转换 atoi函数获取一个C字符串参数，返回对应的int值。如果参数不与一个int值对应，atoi就会返回0。atoi函数在文件为cstdlib的库中。如果数字太大，不能转换成int类型的值，可以使用atol将字符串转换为long类型的值。 例如:\natoi(\u0026quot;1234\u0026quot;); //返回整数1234 atoi(\u0026quot;#123\u0026quot;); //返回0  导航  目录 上一章：Chapter 2 - pointers, refrence 下一章：Chapter 4 - uint8_t, uint16_t, uint32_t, uint64_t  ","permalink":"/collection/cprimer03/","summary":"转载自https://github.com/andycai/cprimer 3.1 char*, char[], string 在C中，并没有字符串这个数据类型，而是使用字符数组来保存字","title":"【转载】C Primer 之 char*, char[], string"},{"content":"转载自https://github.com/andycai/cprimer\n2.1 refrence 引用 引用是C++中的概念，初学者容易把引用和指针混淆一起。以下程序中，n 是 m 的一个引用（reference），m 是被引用物（referent）。\nint m; int \u0026amp;n = m;  n 相当于 m 的别名（绰号），对 n 的任何操作就是对m的操作。所以 n 既不是 m 的拷贝，也不是指向 m 的指针，其实 n 就是 m 它自己。\n引用的规则：\n 引用被创建的同时必须被初始化（指针则可以在任何时候被初始化）。 不能有NULL引用，引用必须与合法的存储单元关联（指针则可以是NULL）。 一旦引用被初始化，就不能改变引用的关系（指针则可以随时改变所指的对象）。  以下示例程序中，k 被初始化为 i 的引用。语句 k = j 并不能将 k 修改成为 j 的引用，只是把 k 的值改变成为6。由于 k 是 i 的引用，所以 i 的值也变成了6。\nint i = 5; int j = 6; int \u0026amp;k = i; k = j; // k和i的值都变成了6;  引用的主要功能是传递函数的参数和返回值。\nC++语言中，函数的参数和返回值的传递方式有三种：值传递、指针传递和引用传递。\n(1) 以下是\u0026quot;值传递\u0026quot;的示例程序 由于Func1函数体内的x是外部变量n的一份拷贝，改变x的值不会影响n, 所以n的值仍然是0。\nvoid Func1(int x) { x = x + 10; } ... int n = 0; Func1(n); cout \u0026lt;\u0026lt; \u0026quot;n = \u0026quot; \u0026lt;\u0026lt; n \u0026lt;\u0026lt; endl; // n = 0  (2) 以下是\u0026quot;指针传递\u0026quot;的示例程序 由于Func2函数体内的x是指向外部变量n的指针，改变该指针的内容将导致n的值改变，所以n的值成为10。\nvoid Func2(int *x) { (* x) = (* x) + 10; } ... int n = 0; Func2(\u0026amp;n); cout \u0026lt;\u0026lt; \u0026quot;n = \u0026quot; \u0026lt;\u0026lt; n \u0026lt;\u0026lt; endl; // n = 10  (3) 以下是\u0026quot;引用传递\u0026quot;的示例程序 由于Func3函数体内的x是外部变量n的引用，x和n是同一个东西，改变x等于改变n，所以n的值成为10。\nvoid Func3(int \u0026amp;x) { x = x + 10; } ... int n = 0; Func3(n); cout \u0026lt;\u0026lt; \u0026quot;n = \u0026quot; \u0026lt;\u0026lt; n \u0026lt;\u0026lt; endl; // n = 10  对比上述三个示例程序，会发现\u0026quot;引用传递\u0026quot;的性质象\u0026quot;指针传递\u0026quot;，而书写方式象\u0026quot;值传递\u0026quot;。\n实际上\u0026quot;引用\u0026quot;可以做的任何事情\u0026quot;指针\u0026quot;也都能够做，为什么还要\u0026quot;引用\u0026quot;这东西？ 答案是\u0026quot;用适当的工具做恰如其分的工作\u0026quot;。\n指针能够毫无约束地操作内存中的任何东西，尽管指针功能强大，但是非常危险。\n如果的确只需要借用一下某个对象的\u0026quot;别名\u0026quot;，那么就用\u0026quot;引用\u0026quot;，而不要用\u0026quot;指针\u0026quot;，以免发生意外。\n导航  目录 上一章：Chapter 1 - const, inline，static, this 下一章：Chapter 3 - char*, char[], string  ","permalink":"/collection/cprimer02/","summary":"转载自https://github.com/andycai/cprimer 2.1 refrence 引用 引用是C++中的概念，初学者容易把引用和指针混淆一起。以下","title":"【转载】C Primer 之 指针和引用"},{"content":"转载自https://github.com/andycai/cprimer\n1.1 const (1) const 基础 如果const关键字不涉及到指针，我们很好理解，下面是涉及到指针的情况：\nint b = 500; const int* a = \u0026amp;b; [1] int const *a = \u0026amp;b; [2] int* const a = \u0026amp;b; [3] const int* const a = \u0026amp;b; [4]  如果你能区分出上述四种情况，那么，恭喜你，你已经迈出了可喜的一步。不知道，也没关系，我们可以参考《Effective c++》Item21上的做法， 如果 const 位于星号的左侧，则 const 就是用来修饰指针所指向的变量，即指针指向为常量；如果 const 位于星号的右侧，const 就是修饰指针本身，即指针本身是常量。\n因此，[1]和[2]的情况相同，都是指针所指向的内容为常量（const放在变量声明符的位置无关），这种情况下不允许对内容进行更改操作，如不能*a = 3；[3]为指针本身是常量，而指针所指向的内容不是常量，这种情况下不能对指针本身进行更改操作，如a++是错误的；[4]为指针本身和指向的内容均为常量。\n(2) 作为参数 void display(const double\u0026amp; r); void display(const double* r);  说明:\n 在引用或者指针参数的时候使用 const 限制是有意义的，而对于值传递的参数使用 const 则没有意义 保证引用的变量的值不被改变 const 在 double 前或者后面意思相同，只是不同的人的写法不同  (3) const对象 声明为 const 的对象只能访问类中声明为 const 的成员函数，不能调用其它成员函数。\n(4) const成员函数 类型说明符 函数名(参数表) const; void print(int i) const;  说明:\n const 是函数类型的一个组成部分，因此在实现部分也要带 const 关键字 常成员函数不能更新对象的数据成员，也不能调用该类中没有用 const 修饰的成员函数  (5) 使用const的一些建议  要大胆的使用 const，这将给你带来无尽的益处，但前提是你必须搞清楚原委 要避免最一般的赋值操作错误，如将 const 变量赋值，具体可见思考题 在参数中使用 const 应该使用引用或指针，而不是一般的对象实例，原因同上 const 在成员函数中的三种用法（参数、返回值、函数）要很好的使用 不要轻易的将函数的返回值类型定为 const 除了重载操作符外一般不要将返回值类型定为对某个对象的 const 引用  1.2 inline (1) 预处理宏 介绍内联函数之前，有必要介绍一下预处理宏。内联函数的功能和预处理宏的功能相似。相信大家都用过预处理宏，我们会经常定义一些宏，如：\n#define TABLE_COMP(x) ((x)\u0026gt;0 ? (x) : 0)  就定义了一个宏。\n为什么要使用宏呢？因为函数的调用必须要将程序执行的顺序转移到函数所存放在内存中的某个地址，将函数的程序内容执行完后，再返回到转去执行该函数前的地方。这种转移操作要求在转去执行前要保存现场并记忆执行的地址，转回后要恢复现场，并按原来保存地址继续执行。因此，函数调用要有一定的时间和空间方面的开销，于是将影响其效率。而宏只是在预处理的地方把代码展开，不需要额外的空间和时间方面的开销，所以调用一个宏比调用一个函数更有效率。\n但是宏也有很多的不尽人意的地方。\n 宏不能访问对象的私有成员。 宏的定义很容易产生二意性。  我们举个例子：\n#define TABLE_MULTI(x) (x*x)  我们用一个数字去调用它，TABLE_MULTI(10)，这样看上去没有什么错误，结果返回100，是正确的，但是如果我们用TABLE_MULTI(10+10)去调用的话，我们期望的结果是400，而宏的调用结果是(10+10*10+10)，结果是120，这显然不是我们要得到的结果。避免这些错误的方法，一定要给宏的参数都加上括号。\n#define TABLE_MULTI(x) ((x)*(x))  这样可以确保不会出错，但是，即使使用了这种定义，这个宏依然有可能出错，例如使用TABLE_MULTI(a++)调用它，他们本意是希望得到(a+1)(a+1)的结果，而实际上呢？我们可以看看宏的展开结果: (a++)(a++)，如果a的值是４，我们得到的结果是56=30。而我们期望的结果是55=25,这又出现了问题。事实上，在一些C的库函数中也有这些问题。例如: Toupper(*pChar++)就会对pChar执行两次++操作，因为Toupper实际上也是一个宏。\n(2) inline 函数 我们可以看到宏有一些难以避免的问题，怎么解决呢？\n下面就是用我要介绍的内联函数来解决这些问题，我们可以使用内联函数来取代宏的定义。而且事实上我们可以用内联函数完全取代预处理宏。\n内联函数和宏的区别在于，宏是由预处理器对宏进行替代，而内联函数是通过编译器控制来实现的。而且内联函数是真正的函数，只是在需要用到的时候，内联函数像宏一样的展开，所以取消了函数的参数压栈，减少了调用的开销。你可以象调用函数一样来调用内联函数，而不必担心会产生于处理宏的一些问题。\n我们可以用 inline 来定义内联函数，不过，任何在类的声明部分定义的函数都会被自动的认为是内联函数。\n在函数声明或定义中函数返回类型前加上关键字 inline 即把min（）指定为内联。\ninline int min(int first, int secend) {/****/};  我们可以把它作为一般的函数一样调用。但是执行速度确比一般函数的执行速度要快。inline 函数对编译器而言必须是可见的，以便它能够在调用点内展开该函数。与非inline函数不同的是，inline函数必须在调用该函数的每个文本文件中定义。当然，对于同一程序的不同文件，如果C++ inline函数出现的话，其定义必须相同。\n对于由两个文件compute.c和draw.c构成的程序来说，程序员不能定义这样的min()函数，它在compute.c中指一件事情，而在draw.c中指另外一件事情。如果两个定义不相同，程序将会有未定义的行为。\n为保证不会发生这样的事情，建议把inline函数的定义放到头文件中。在每个调用该inline函数的文件中包含该头文件。这种方法保证对每个inline函数只有一个定义，且程序员无需复制代码，并且不可能在程序的生命期中引起无意的不匹配的事情。\n(3) inline 函数的编程风格 关键字inline 必须与函数定义体放在一起才能使函数成为内联，仅将 inline 放在函数声明前面不起任何作用。如下风格的函数Foo 不能成为内联函数：\ninline void Foo(int x, int y); // inline 仅与函数声明放在一起 void Foo(int x, int y){}  而如下风格的函数Foo 则成为内联函数：\nvoid Foo(int x, int y); inline void Foo(int x, int y) // inline 与函数定义体放在一起{}  所以说，C++ inline函数是一种“用于实现的关键字”，而不是一种“用于声明的关键字”。一般地，用户可以阅读函数的声明，但是看不到函数的定义。尽管在大多数教科书中内联函数的声明、定义体前面都加了inline 关键字，但我认为inline 不应该出现在函数的声明中。这个细节虽然不会影响函数的功能，但是体现了高质量C++/C 程序设计风格的一个基本原则：声明与定义不可混为一谈，用户没有必要、也不应该知道函数是否需要内联。\n定义在类声明之中的成员函数将自动地成为内联函数，例如：\nclass A { public: void Foo(int x, int y) { } // 自动地成为内联函数 }  将成员函数的定义体放在类声明之中虽然能带来书写上的方便，但不是一种良好的编程风格，上例应该改成：\n// 头文件 class A { public: void Foo(int x, int y); } // 定义文件 inline void A::Foo(int x, int y){}  内联函数在C++类中，应用最广的，应该是用来定义存取函数。我们定义的类中一般会把数据成员定义成私有的或者保护的，这样，外界就不能直接读写我们类成员的数据了。对于私有或者保护成员的读写就必须使用成员接口函数来进行。如果我们把这些读写成员函数定义成内联函数的话，将会获得比较好的效率。\nClass sample { Private: int nTest; Public: int readtest(){ return nTest;} Void settest(int I) {nTest=I;} }  当然，内联函数也有一定的局限性。就是函数中的执行代码不能太多了，如果，内联函数的函数体过大，一般的编译器会放弃内联方式，而采用普通的方式调用函数。这样，内联函数就和普通函数执行效率一样了。\n1.3 static (1) 隐藏 当我们同时编译多个文件时，所有未加 static 前缀的全局变量和函数都具有全局可见性。\n(2) 保持变量内容的持久 存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。共有两种变量存储在静态存储区：全局变量和 static 变量，只不过和全局变量比起来，static 可以控制变量的可见范围，说到底 static 还是用来隐藏的。\n(3) 默认初始化为 0 其实全局变量也具备这一属性，因为全局变量也存储在静态数据区。在静态数据区，内存中所有的字节默认值都是 0x00，某些时候这一特点可以减少程序员的工作量。\n1.4 this 指针 先要理解class的意思。class应该理解为一种类型，像int和char一样，是用户自定义的类型。（虽然比 int 和 char 这样 built-in 类型复杂的多，但首先要理解它们一样是类型)。用这个类型可以来声明一个变量，比如int x, myclass my等等。这样就像变量 x 具有 int 类型一样，变量 my 具有 myclass 类型。\n理解了这个，就好解释 this 了，my 里的 this 就是指向 my 的指针。如果还有一个变量myclass mz，mz 的 this 就是指向 mz 的指针。这样就很容易理解this 的类型应该是 myclass *，而对其的解引用 *this 就应该是一个 myclass 类型的变量。\n通常在class定义时要用到类型变量自身时，因为这时候还不知道变量名（为了通用也不可能固定实际的变量名），就用this这样的指针来使用变量自身。\n(1) this指针的用处 一个对象的 this 指针并不是对象本身的一部分，不会影响sizeof(对象)的结果。this作用域是在类内部，当在类的非静态成员函数中访问类的非静态成员的时候，编译器会自动将对象本身的地址作为一个隐含参数传递给函数。也就是说，即使你没有写上 this 指针，编译器在编译的时候也是加上 this 的，它作为非静态成员函数的隐含形参，对各成员的访问均通过 this 进行。\n例如，调用 date.SetMonth(9) \u0026lt;===\u0026gt; SetMonth(\u0026amp;date, 9)，this帮助完成了这一转换。\n(2) this指针的使用 一种情况就是，在类的非静态成员函数中返回类对象本身的时候，直接使用 return *this；另外一种情况是当参数与成员变量名相同时，如this-\u0026gt;n = n （不能写成n = n）。\n(3) this指针程序示例 this指针是存在与类的成员函数中,指向被调用函数所在的类实例的地址。根据以下程序来说明 this 指针：\n#include\u0026lt;iostream.h\u0026gt; class Point { int x, y; public: Point(int a, int b) { x=a; y=b;} Void MovePoint( int a, int b){ x+=a; y+=b;} Void print(){ cout\u0026lt;\u0026lt;\u0026quot;x=\u0026quot;\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026quot;y=\u0026quot;\u0026lt;\u0026lt;y\u0026lt;\u0026lt;endl;} }; void main( ) { Point point1( 10,10); point1.MovePoint(2,2); point1.print( ); }  当对象 point1 调用 MovePoint(2,2) 函数时，即将 point1 对象的地址传递给了 this 指针。\nMovePoint 函数的原型应该是 void MovePoint( Point *this, int a, int b);第一个参数是指向该类对象的一个指针，我们在定义成员函数时没看见是因为这个参数在类中是隐含的。这样point1的地址传递给了 this，所以在 MovePoint 函数中便显式的写成：\nvoid MovePoint(int a, int b) { this-\u0026gt;x +=a; this-\u0026gt; y+= b;}  即可以知道，point1调用该函数后，也就是point1的数据成员被调用并更新了值。即该函数过程可写成 point1.x+= a; point1. y + = b;\n(4) 关于this指针的一个精典回答 当你进入一个房子后，你可以看见桌子、椅子、地板等，但是房子你是看不到全貌了。对于一个类的实例来说，你可以看到它的成员函数、成员变量，但是实例本身呢？this 是一个指针，它时时刻刻指向你这个实例本身。\n导航  目录 下一章：Chapter 2 - pointers, refrence  ","permalink":"/collection/cprimer01/","summary":"转载自https://github.com/andycai/cprimer 1.1 const (1) const 基础 如果const关键字不涉及到指针，我们很好理解，下面是","title":"【转载】C Primer 之 const, inline, static, this"},{"content":"转载自https://blog.csdn.net/lovelion/article/details/17517213\n开闭原则是面向对象的可复用设计的第一块基石，它是最重要的面向对象设计原则。开闭原则由Bertrand Meyer于1988年提出，其定义如下：\n 开闭原则(Open-Closed Principle, OCP)：一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。\n 在开闭原则的定义中，软件实体可以指一个软件模块、一个由多个类组成的局部结构或一个独立的类。\n任何软件都需要面临一个很重要的问题，即它们的需求会随时间的推移而发生变化。当软件系统需要面对新的需求时，我们应该尽量保证系统的设计框架是稳定的。如果一个软件设计符合开闭原则，那么可以非常方便地对系统进行扩展，而且在扩展时无须修改现有代码，使得软件系统在拥有适应性和灵活性的同时具备较好的稳定性和延续性。随着软件规模越来越大，软件寿命越来越长，软件维护成本越来越高，设计满足开闭原则的软件系统也变得越来越重要。\n为了满足开闭原则，需要对系统进行抽象化设计，抽象化是开闭原则的关键。在Java、C#等编程语言中，可以为系统定义一个相对稳定的抽象层，而将不同的实现行为移至具体的实现层中完成。在很多面向对象编程语言中都提供了接口、抽象类等机制，可以通过它们定义系统的抽象层，再通过具体类来进行扩展。如果需要修改系统的行为，无须对抽象层进行任何改动，只需要增加新的具体类来实现新的业务功能即可，实现在不修改已有代码的基础上扩展系统的功能，达到开闭原则的要求。\n Sunny软件公司开发的CRM系统可以显示各种类型的图表，如饼状图和柱状图等，为了支持多种图表显示方式，原始设计方案如图1所示：\n 图1 初始设计方案结构图\n在ChartDisplay类的display()方法中存在如下代码片段：\n...... if (type.equals(\u0026#34;pie\u0026#34;)) { PieChart chart = new PieChart(); chart.display(); } else if (type.equals(\u0026#34;bar\u0026#34;)) { BarChart chart = new BarChart(); chart.display(); } ...... 在该代码中，如果需要增加一个新的图表类，如折线图LineChart，则需要修改ChartDisplay类的display()方法的源代码，增加新的判断逻辑，违反了开闭原则。\n现对该系统进行重构，使之符合开闭原则。\n在本实例中，由于在ChartDisplay类的display()方法中针对每一个图表类编程，因此增加新的图表类不得不修改源代码。可以通过抽象化的方式对系统进行重构，使之增加新的图表类时无须修改源代码，满足开闭原则。具体做法如下：\n(1) 增加一个抽象图表类AbstractChart，将各种具体图表类作为其子类；\n(2) ChartDisplay类针对抽象图表类进行编程，由客户端来决定使用哪种具体图表。\n重构后结构如图2所示：\n图2 重构后的结构图\n在图2中，我们引入了抽象图表类AbstractChart，且ChartDisplay针对抽象图表类进行编程，并通过setChart()方法由客户端来设置实例化的具体图表对象，在ChartDisplay的display()方法中调用chart对象的display()方法显示图表。如果需要增加一种新的图表，如折线图LineChart，只需要将LineChart也作为AbstractChart的子类，在客户端向ChartDisplay中注入一个LineChart对象即可，无须修改现有类库的源代码。\n注意：因为xml和properties等格式的配置文件是纯文本文件，可以直接通过VI编辑器或记事本进行编辑，且无须编译，因此在软件开发中，一般不把对配置文件的修改认为是对系统源代码的修改。如果一个系统在扩展时只涉及到修改配置文件，而原有的Java代码或C#代码没有做任何修改，该系统即可认为是一个符合开闭原则的系统。\n","permalink":"/collection/oop/","summary":"转载自https://blog.csdn.net/lovelion/article/details/17517213 开闭原则是面向对象的可复","title":"【转载】面向对象设计原则之开闭原则"},{"content":"转载自https://blog.csdn.net/lovelion/article/details/17517213\n单一职责原则是最简单的面向对象设计原则，它用于控制类的粒度大小。单一职责原则定义如下：\n单一职责原则(Single Responsibility Principle, SRP)：一个类只负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。\n单一职责原则告诉我们：一个类不能太“累”！在软件系统中，一个类（大到模块，小到方法）承担的职责越多，它被复用的可能性就越小，而且一个类承担的职责过多，就相当于将这些职责耦合在一起，当其中一个职责变化时，可能会影响其他职责的运作，因此要将这些职责进行分离，将不同的职责封装在不同的类中，即将不同的变化原因封装在不同的类中，如果多个职责总是同时发生改变则可将它们封装在同一类中。\n单一职责原则是实现高内聚、低耦合的指导方针，它是最简单但又最难运用的原则，需要设计人员发现类的不同职责并将其分离，而发现类的多重职责需要设计人员具有较强的分析设计能力和相关实践经验。\n下面通过一个简单实例来进一步分析单一职责原则：\n Sunny软件公司开发人员针对某CRM（Customer Relationship Management，客户关系管理）系统中客户信息图形统计模块提出了如图1所示初始设计方案：\n 图1 初始设计方案结构图\n 在图1中，CustomerDataChart类中的方法说明如下：getConnection()方法用于连接数据库，findCustomers()用于查询所有的客户信息，createChart()用于创建图表，displayChart()用于显示图表。\n 现使用单一职责原则对其进行重构。\n在图1中，CustomerDataChart类承担了太多的职责，既包含与数据库相关的方法，又包含与图表生成和显示相关的方法。如果在其他类中也需要连接数据库或者使用findCustomers()方法查询客户信息，则难以实现代码的重用。无论是修改数据库连接方式还是修改图表显示方式都需要修改该类，它不止一个引起它变化的原因，违背了单一职责原则。因此需要对该类进行拆分，使其满足单一职责原则，类CustomerDataChart可拆分为如下三个类：\n(1) DBUtil：负责连接数据库，包含数据库连接方法getConnection()；\n(2) CustomerDAO：负责操作数据库中的Customer表，包含对Customer表的增删改查等方法，如findCustomers()；\n(3) CustomerDataChart：负责图表的生成和显示，包含方法createChart()和displayChart()。\n使用单一职责原则重构后的结构如图2所示：\n图2 重构后的结构图\n","permalink":"/collection/singleresponsibility/","summary":"转载自https://blog.csdn.net/lovelion/article/details/17517213 单一职责原则是最简单的面","title":"【转载】面向对象设计原则之单一职责原则"},{"content":"转载自https://blog.csdn.net/lovelion/article/details/17517213\n对于面向对象软件系统的设计而言，在支持可维护性的同时，提高系统的可复用性是一个至关重要的问题，如何同时提高一个软件系统的可维护性和可复用性是面向对象设计需要解决的核心问题之一。在面向对象设计中，可维护性的复用是以设计原则为基础的。每一个原则都蕴含一些面向对象设计的思想，可以从不同的角度提升一个软件结构的设计水平。\n面向对象设计原则为支持可维护性复用而诞生，这些原则蕴含在很多设计模式中，它们是从许多设计方案中总结出的指导性原则。面向对象设计原则也是我们用于评价一个设计模式的使用效果的重要指标之一，在设计模式的学习中，大家经常会看到诸如“XXX模式符合XXX原则”、“XXX模式违反了XXX原则”这样的语句。\n最常见的7种面向对象设计原则如下表所示：\n","permalink":"/collection/oop/","summary":"转载自https://blog.csdn.net/lovelion/article/details/17517213 对于面向对象软件系统的设","title":"【转载】面向对象设计原则概述"},{"content":"转载自https://blog.csdn.net/lovelion/article/details/17517213\n工厂模式是最常用的一类创建型设计模式，通常我们所说的工厂模式是指工厂方法模式，它也是使用频率最高的工厂模式。本章将要学习的简单工厂模式是工厂方法模式的“小弟”，它不属于GoF 23种设计模式，但在软件开发中应用也较为频繁，通常将它作为学习其他工厂模式的入门。此外，工厂方法模式还有一位“大哥”——抽象工厂模式。这三种工厂模式各具特色，难度也逐个加大，在软件开发中它们都得到了广泛的应用，成为面向对象软件中常用的创建对象的工具。\n一、图表库的设计  Sunny软件公司欲基于Java语言开发一套图表库，该图表库可以为应用系统提供各种不同外观的图表，例如柱状图、饼状图、折线图等。Sunny软件公司图表库设计人员希望为应用系统开发人员提供一套灵活易用的图表库，而且可以较为方便地对图表库进行扩展，以便能够在将来增加一些新类型的图表。\n Sunny软件公司图表库设计人员提出了一个初始设计方案，将所有图表的实现代码封装在一个Chart类中，其框架代码如下所示：\nclass Chart { private String type; //图表类型 public Chart(Object[][] data, String type) { this.type = type; if (type.equalsIgnoreCase(\u0026#34;histogram\u0026#34;)) { //初始化柱状图 } else if (type.equalsIgnoreCase(\u0026#34;pie\u0026#34;)) { //初始化饼状图 } else if (type.equalsIgnoreCase(\u0026#34;line\u0026#34;)) { //初始化折线图 } } public void display() { if (this.type.equalsIgnoreCase(\u0026#34;histogram\u0026#34;)) { //显示柱状图 } else if (this.type.equalsIgnoreCase(\u0026#34;pie\u0026#34;)) { //显示饼状图 } else if (this.type.equalsIgnoreCase(\u0026#34;line\u0026#34;)) { //显示折线图 }\t} } 客户端代码通过调用Chart类的构造函数来创建图表对象，根据参数type的不同可以得到不同类型的图表，然后再调用display()方法来显示相应的图表。\n不难看出，Chart类是一个“巨大的”类，在该类的设计中存在如下几个问题：\n(1) 在Chart类中包含很多“if…else…”代码块，整个类的代码相当冗长，代码越长，阅读难度、维护难度和测试难度也越大；而且大量条件语句的存在还将影响系统的性能，程序在执行过程中需要做大量的条件判断。\n(2) Chart类的职责过重，它负责初始化和显示所有的图表对象，将各种图表对象的初始化代码和显示代码集中在一个类中实现，违反了“单一职责原则”，不利于类的重用和维护；而且将大量的对象初始化代码都写在构造函数中将导致构造函数非常庞大，对象在创建时需要进行条件判断，降低了对象创建的效率。\n(3) 当需要增加新类型的图表时，必须修改Chart类的源代码，违反了“开闭原则”。\n(4) 客户端只能通过new关键字来直接创建Chart对象，Chart类与客户端类耦合度较高，对象的创建和使用无法分离。\n(5) 客户端在创建Chart对象之前可能还需要进行大量初始化设置，例如设置柱状图的颜色、高度等，如果在Chart类的构造函数中没有提供一个默认设置，那就只能由客户端来完成初始设置，这些代码在每次创建Chart对象时都会出现，导致代码的重复。\n面对一个如此巨大、职责如此重，且与客户端代码耦合度非常高的类，我们应该怎么办？本章将要介绍的简单工厂模式将在一定程度上解决上述问题。\n二、简单工厂模式概述 简单工厂模式并不属于GoF 23个经典设计模式，但通常将它作为学习其他工厂模式的基础，它的设计思想很简单，其基本流程如下：\n首先将需要创建的各种不同对象（例如各种不同的Chart对象）的相关代码封装到不同的类中，这些类称为具体产品类，而将它们公共的代码进行抽象和提取后封装在一个抽象产品类中，每一个具体产品类都是抽象产品类的子类；然后提供一个工厂类用于创建各种产品，在工厂类中提供一个创建产品的工厂方法，该方法可以根据所传入的参数不同创建不同的具体产品对象；客户端只需调用工厂类的工厂方法并传入相应的参数即可得到一个产品对象。\n简单工厂模式定义如下：\n简单工厂模式(Simple Factory Pattern)：定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。因为在简单工厂模式中用于创建实例的方法是静态(static)方法，因此简单工厂模式又被称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。\n简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。简单工厂模式结构比较简单，其核心是工厂类的设计，其结构如图1所示：\n在简单工厂模式结构图中包含如下几个角色：\n  Factory（工厂角色）：工厂角色即工厂类，它是简单工厂模式的核心，负责实现创建所有产品实例的内部逻辑；工厂类可以被外界直接调用，创建所需的产品对象；在工厂类中提供了静态的工厂方法factoryMethod()，它的返回类型为抽象产品类型Product。\n  Product（抽象产品角色）：它是工厂类所创建的所有对象的父类，封装了各种产品对象的公有方法，它的引入将提高系统的灵活性，使得在工厂类中只需定义一个通用的工厂方法，因为所有创建的具体产品对象都是其子类对象。\n  ConcreteProduct（具体产品角色）：它是简单工厂模式的创建目标，所有被创建的对象都充当这个角色的某个具体类的实例。每一个具体产品角色都继承了抽象产品角色，需要实现在抽象产品中声明的抽象方法。\n  在简单工厂模式中，客户端通过工厂类来创建一个产品类的实例，而无须直接使用new关键字来创建对象，它是工厂模式家族中最简单的一员。\n在使用简单工厂模式时，首先需要对产品类进行重构，不能设计一个包罗万象的产品类，而需根据实际情况设计一个产品层次结构，将所有产品类公共的代码移至抽象产品类，并在抽象产品类中声明一些抽象方法，以供不同的具体产品类来实现，典型的抽象产品类代码如下所示：\nabstract class Product { //所有产品类的公共业务方法 public void methodSame() { //公共方法的实现 } //声明抽象业务方法 public abstract void methodDiff(); } 在具体产品类中实现了抽象产品类中声明的抽象业务方法，不同的具体产品类可以提供不同的实现，典型的具体产品类代码如下所示：\nclass ConcreteProduct extends Product { //实现业务方法 public void methodDiff() { //业务方法的实现 } } 简单工厂模式的核心是工厂类，在没有工厂类之前，客户端一般会使用new关键字来直接创建产品对象，而在引入工厂类之后，客户端可以通过工厂类来创建产品，在简单工厂模式中，工厂类提供了一个静态工厂方法供客户端使用，根据所传入的参数不同可以创建不同的产品对象，典型的工厂类代码如下所示：\nclass Factory { //静态工厂方法 public static Product getProduct(String arg) { Product product = null; if (arg.equalsIgnoreCase(\u0026#34;A\u0026#34;)) { product = new ConcreteProductA(); //初始化设置product } else if (arg.equalsIgnoreCase(\u0026#34;B\u0026#34;)) { product = new ConcreteProductB(); //初始化设置product } return product; } } 在客户端代码中，我们通过调用工厂类的工厂方法即可得到产品对象，典型代码如下所示：\nclass Client { public static void main(String args[]) { Product product; product = Factory.getProduct(\u0026#34;A\u0026#34;); //通过工厂类创建产品对象 product.methodSame(); product.methodDiff(); } } 三、完整解决方案 为了将Chart类的职责分离，同时将Chart对象的创建和使用分离，Sunny软件公司开发人员决定使用简单工厂模式对图表库进行重构，重构后的结构如图2所示：\n在上图中，Chart接口充当抽象产品类，其子类HistogramChart、PieChart和LineChart充当具体产品类，ChartFactory充当工厂类。完整代码如下所示：\n//抽象图表接口：抽象产品类 interface Chart { public void display(); } //柱状图类：具体产品类 class HistogramChart implements Chart { public HistogramChart() { System.out.println(\u0026#34;创建柱状图！\u0026#34;); } public void display() { System.out.println(\u0026#34;显示柱状图！\u0026#34;); } } //饼状图类：具体产品类 class PieChart implements Chart { public PieChart() { System.out.println(\u0026#34;创建饼状图！\u0026#34;); } public void display() { System.out.println(\u0026#34;显示饼状图！\u0026#34;); } } //折线图类：具体产品类 class LineChart implements Chart { public LineChart() { System.out.println(\u0026#34;创建折线图！\u0026#34;); } public void display() { System.out.println(\u0026#34;显示折线图！\u0026#34;); } } //图表工厂类：工厂类 class ChartFactory { //静态工厂方法 public static Chart getChart(String type) { Chart chart = null; if (type.equalsIgnoreCase(\u0026#34;histogram\u0026#34;)) { chart = new HistogramChart(); System.out.println(\u0026#34;初始化设置柱状图！\u0026#34;); } else if (type.equalsIgnoreCase(\u0026#34;pie\u0026#34;)) { chart = new PieChart(); System.out.println(\u0026#34;初始化设置饼状图！\u0026#34;); } else if (type.equalsIgnoreCase(\u0026#34;line\u0026#34;)) { chart = new LineChart(); System.out.println(\u0026#34;初始化设置折线图！\u0026#34;);\t} return chart; } } 编写如下客户端测试代码：\nclass Client { public static void main(String args[]) { Chart chart; chart = ChartFactory.getChart(\u0026#34;histogram\u0026#34;); //通过静态工厂方法创建产品 chart.display(); } } 编译并运行程序，输出结果如下：\n创建柱状图！ 初始化设置柱状图！ 显示柱状图！ 在客户端测试类中，我们使用工厂类的静态工厂方法创建产品对象，如果需要更换产品，只需修改静态工厂方法中的参数即可，例如将柱状图改为饼状图，只需将代码：\nchart = ChartFactory.getChart(\u0026#34;histogram\u0026#34;); 改为：\nchart = ChartFactory.getChart(\u0026#34;pie\u0026#34;); 编译并运行程序，输出结果如下：\n创建饼状图！ 初始化设置饼状图！ 显示饼状图！ 四、方案的改进 Sunny软件公司开发人员发现在创建具体Chart对象时，每更换一个Chart对象都需要修改客户端代码中静态工厂方法的参数，客户端代码将要重新编译，这对于客户端而言，违反了“开闭原则”，有没有一种方法能够在不修改客户端代码的前提下更换具体产品对象呢？答案是肯定的，下面将介绍一种常用的实现方式。\n我们可以将静态工厂方法的参数存储在XML或properties格式的配置文件中，如下config.xml所示：\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;config\u0026gt; \u0026lt;chartType\u0026gt;histogram\u0026lt;/chartType\u0026gt; \u0026lt;/config\u0026gt; 再通过一个工具类XMLUtil来读取配置文件中的字符串参数，XMLUtil类的代码如下所示：\nimport javax.xml.parsers.*; import org.w3c.dom.*; import org.xml.sax.SAXException; import java.io.*; public class XMLUtil { //该方法用于从XML配置文件中提取图表类型，并返回类型名 public static String getChartType() { try { //创建文档对象 DocumentBuilderFactory dFactory = DocumentBuilderFactory.newInstance(); DocumentBuilder builder = dFactory.newDocumentBuilder(); Document doc;\tdoc = builder.parse(new File(\u0026#34;config.xml\u0026#34;)); //获取包含图表类型的文本节点 NodeList nl = doc.getElementsByTagName(\u0026#34;chartType\u0026#34;); Node classNode = nl.item(0).getFirstChild(); String chartType = classNode.getNodeValue().trim(); return chartType; } catch(Exception e) { e.printStackTrace(); return null; } } } 在引入了配置文件和工具类XMLUtil之后，客户端代码修改如下：\nclass Client { public static void main(String args[]) { Chart chart; String type = XMLUtil.getChartType(); //读取配置文件中的参数 chart = ChartFactory.getChart(type); //创建产品对象 chart.display(); } } 不难发现，在上述客户端代码中不包含任何与具体图表对象相关的信息，如果需要更换具体图表对象，只需修改配置文件config.xml，无须修改任何源代码，符合“开闭原则”。\n五、简单工厂模式的简化 有时候，为了简化简单工厂模式，我们可以将抽象产品类和工厂类合并，将静态工厂方法移至抽象产品类中，如图3所示：\n在图3中，客户端可以通过产品父类的静态工厂方法，根据参数的不同创建不同类型的产品子类对象，这种做法在JDK等类库和框架中也广泛存在。\n六、简单工厂模式总结 简单工厂模式提供了专门的工厂类用于创建对象，将对象的创建和对象的使用分离开，它作为一种最简单的工厂模式在软件开发中得到了较为广泛的应用。\n 主要优点  简单工厂模式的主要优点如下：\n(1) 工厂类包含必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的职责，而仅仅“消费”产品，简单工厂模式实现了对象创建和使用的分离。\n(2) 客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以在一定程度减少使用者的记忆量。\n(3) 通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。\n主要缺点  简单工厂模式的主要缺点如下：\n(1) 由于工厂类集中了所有产品的创建逻辑，职责过重，一旦不能正常工作，整个系统都要受到影响。\n(2) 使用简单工厂模式势必会增加系统中类的个数（引入了新的工厂类），增加了系统的复杂度和理解难度。\n(3) 系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。\n(4) 简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。\n适用场景  在以下情况下可以考虑使用简单工厂模式：\n(1) 工厂类负责创建的对象比较少，由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。\n(2) 客户端只知道传入工厂类的参数，对于如何创建对象并不关心。\n","permalink":"/collection/singlefactory/","summary":"转载自https://blog.csdn.net/lovelion/article/details/17517213 工厂模式是最常用的一类创","title":"【转载】简单工厂模式"},{"content":"这两张照片都是喵喵，狗子没有上镜。狗子就是前面有提到的罗小白，不过它现在已经不白了，而且因为它闯下的大祸，已经剥夺了它的取名资格……\n狗子非常缠人，在它的世界里，恐怕只有玩和吃，折腾没有一刻停止过。每次有客人来都会缠着走。家里本来也不怎么喜欢狗，更何况它又烦人，又比较脏（狗子很抗拒洗澡，每次给它洗澡都很困难）。久而久之，没人搭理它，它就消停一些了。\n直到喵喵的到来。喵喵刚来那会，狗子一直追着它闹。然后喵喵就到处找地方藏。第一张图片就是这个时候拍的，它刚好找到了我，正准备到我肩膀上来。\n直到后来有一天，狗子又追着喵喵跑，喵喵到处躲。不幸的是，这时候喵喵被车压到了……我猜想它是想躲到车底下，但是它不知道开着的车并不像往常那么安全……不幸中的万幸是只压到了腿。\n喵喵左后腿受伤严重，开始那会几乎没有食欲。狗子好像也自知闯了大祸，也同样精神萎靡。\n第二张图片，喵喵伤口又不小心又被扯到了（左腿白色毛那里）。那天晚上天很冷，它窝在凳子上就睡着了。\n","permalink":"/blog/2021/12/27/%E5%96%B5%E5%96%B5%E5%92%8C%E7%8B%97%E5%AD%90/","summary":"这两张照片都是喵喵，狗子没有上镜。狗子就是前面有提到的罗小白，不过它现在已经不白了，而且因为它闯下的大祸，已经剥夺了它的取名资格…… 狗子非常","title":"喵喵和狗子"},{"content":"前一阵子，我注意到一位项目组新成员喜欢使用 hpp 头文件的方式来写，他解释说很多开源库都是以这样的方式实现，还问我 hpp 头文件和 h + cpp 方式的区别。这个问题很麻烦，解释起来可能需要理一遍 C++ 基础，对此，我劝告他：从本质来说 hpp 是将声明和实现放在一个文件，而 h + cpp 是将声明和实现分开在两个文件，采用 hpp 这种方式也是可以的，但是必须要清楚它的局限。我本来是希望他去学习 C++ 基础，但没想到从这里就埋下了一个坑，导致这篇文章的产生\u0026hellip;..\n很快，遇到第一个问题，redefined identifier。我解释说，这是重复 include hpp 文件引入实现，会引发这个重定义的问题。使用 #ifndef 可以防止头文件被重复包含和引入。\n过了一阵，又遇到新的问题。我过去一看，循环依赖。第一个坑出现了。A 依赖 B，B 又 依赖 A，如果用 hpp 实现的话，那A、B 都互相包含对方，无尽循环……所以这种情况只能老老实实用回 h + cpp 的方式了，A 依赖 B，就在 A 的头文件中前向声明 B，然后在源文件中 include B，B 也如此操作。\n就这样过了很久很久，突然有一天，我发现有很多库都需要重新编译，奇怪的是这些库不应该有改动的。一看是依赖的一个底层动态库发生变化，再看，是这个库里的一个 hpp 文件发生变化。大坑，我最开始的时候提醒过的。 那个库本身就有别的坑，实际上它更应该是静态库，但因为客观原因，它暂时还是一个动态库。然后就这样，一个 hpp 文件被嵌入这个底层动态库对外开放的接口里面。它一改动，所有依赖这个库的库都需要重新编译，还真是“牵一发而动全身”啊。\n补充 一、#include 指令\n#include \u0026#34;test.hpp\u0026#34; C++ 会使用一个预处理器，在进行主编译之前对源文件进行处理，它会在编译程序时自动运行。上面所示 #include \u0026ldquo;test.hpp\u0026rdquo;，该编译指令导致预处理器将 test.hpp 文件的内容添加到程序中。实际上，test.hpp 文件的内容将取代程序中的代码行 #include \u0026ldquo;test.hpp\u0026rdquo;。原始文件没有被修改，而是将源码和 test.hpp 文件组合成一个复合文件，编译的下一个阶段将使用该文件。\n二、头文件名\n   头文件类型 约定 示例 说明     C++ 旧式风格 以 .h 结尾 iostream.h C++ 程序可以使用   C 旧式风格 以 .h 结尾 math.h C、C++ 程序可以使用   C++ 新式风格 没有扩展名 iostream C++ 程序可以使用，可以使用 namespace std   转换后的 C 加上前缀 c，没有扩展名 cmath C++ 程序可以使用，可以使用不是 C 的特性，如 namespace std    由于 C 使用不同的文件扩展名来表示不同文件类型，因此用一些特殊的扩展名（如 .hpp 或 .hxx）表示 C++ 头文件是有道理的，ANSI/ISO 委员会也这样认为。问题在于究竟使用哪种扩展名，因此最终他们一致同意不使用任何扩展名。:)\n","permalink":"/post/2021/12/26/hpp/","summary":"前一阵子，我注意到一位项目组新成员喜欢使用 hpp 头文件的方式来写，他解释说很多开源库都是以这样的方式实现，还问我 hpp 头文件和 h + cpp 方式的区别。这个","title":"由 hpp 头文件引发 C++ 编译的思考"},{"content":"在软件开发生命周期的每一个阶段都存在着一些被认同的模式。\n在软件模式中，设计模式是研究最为深入的分支，设计模式用于在特定的调剂爱你下为一些重复出现的软件设计问题提供合理的、有效的解决方案。\n一般定义：设计模式（Design Pattern)是一套被反复使用、多数人知晓的、进过分类编目的代码设计经验的总结，使用设计模式是为了可重用代码、让代码更容易被他人理解并且保证代码可靠性。\n狭义的设计模式是指 GoF 在《设计模式：可复用面向对象软件的基础》一书中所介绍的23种经典设计模式。不过设计模式并不仅仅只有这23种，越来越多的新模式不断诞生并得以应用。\n23 种设计模式根据用途可分为创建型、结构型和行为型三种。其中创建型模式主要用于描述如何创建对象，结构型模式主要用于描述如何实现类或对象的组合，行为型模式主要用于描述类或对象怎样交互以及怎样分配职责。\n值得注意的是，简单工厂模式没有在 23 种设计模式里面，但一般都会对它进行说明。\n","permalink":"/post/2021/12/26/design/","summary":"在软件开发生命周期的每一个阶段都存在着一些被认同的模式。 在软件模式中，设计模式是研究最为深入的分支，设计模式用于在特定的调剂爱你下为一些重复","title":"设计模式概述"},{"content":"从数据结构的角度看，栈和队列是操作受限的线性表，栈和队列的数据元素具有单一的前驱和后继的线性关系。\n栈 定义：栈是限定仅在表尾进行插入和删除操作的线性表，允许插入和删除的一端称为栈顶，另一端成为栈底。\n栈中元素除了具有线性关系外，还具有后进先出的特性。\n需要注意的是，栈只是对线性表的插入和删除操作的位置进行了限制，并没有限定插入和删除操作进行的时间，也就是说，出栈可以随时进行，只要某个元素位于栈顶就可以出栈。\n栈的顺序存储结构——顺序栈 顺序栈的本质是顺序表的简化，唯一需要确定的是用数组的哪一端表示栈底。通常把数组下标为0的一端称为栈底，同时附设指针 top 指示栈顶元素在数组中的位置。\n设存储栈元素的数组长度为 StackSize,则栈空时栈顶指针 top=-1；栈满时栈顶指针 top=StackSize-1。入栈时，栈顶指针 top 加 1；出栈时，栈顶指针 top 减 1。\n栈的链接存储结构——链栈 通常链栈用单链表表示。因为只能在栈顶执行插入和删除操作，显然以单链表的头部作为栈顶是最方便的。\n队列 定义：队列是只允许在一端进行插入操作，在另一端进行删除操作的线性表，允许插入（也称入队、进队）的一端成为队尾，允许删除（也称出队）的一端成为队头。\n队中元素除了具有线性关系外，还具有先进先出的特性。\n队列的顺序存储结构——循环队列 队列是特殊的线性表，从这个出发点来考虑队列的顺序存储问题。\n将存储队列的数组看成头尾相接的循环结构，即允许队列直接从数组中下标最大的位置延续到下标最小的位置，这通过取模操作很容易实现。队列的这种头尾相接的顺序存储结构称为循环队列。\n要注意的是，在循环队列中还有一个很重要的问题：队空和队满的判定问题。\n","permalink":"/post/2021/12/26/stackqueue/","summary":"从数据结构的角度看，栈和队列是操作受限的线性表，栈和队列的数据元素具有单一的前驱和后继的线性关系。 栈 定义：栈是限定仅在表尾进行插入和删除操作","title":"栈和队列"},{"content":"面向对象思想  面向对象思想  一、三大特性  封装 继承 多态   二、类图  泛化关系 (Generalization) 实现关系 (Realization) 聚合关系 (Aggregation) 组合关系 (Composition) 关联关系 (Association) 依赖关系 (Dependency)   三、设计原则  S.O.L.I.D 其他常见原则   参考资料    一、三大特性 封装 利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体。数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外的接口使其与外部发生联系。用户无需关心对象内部的细节，但可以通过对象对外提供的接口来访问该对象。\n优点：\n 减少耦合：可以独立地开发、测试、优化、使用、理解和修改 减轻维护的负担：可以更容易被理解，并且在调试的时候可以不影响其他模块 有效地调节性能：可以通过剖析来确定哪些模块影响了系统的性能 提高软件的可重用性 降低了构建大型系统的风险：即使整个系统不可用，但是这些独立的模块却有可能是可用的  以下 Person 类封装 name、gender、age 等属性，外界只能通过 get() 方法获取一个 Person 对象的 name 属性和 gender 属性，而无法获取 age 属性，但是 age 属性可以供 work() 方法使用。\n注意到 gender 属性使用 int 数据类型进行存储，封装使得用户注意不到这种实现细节。并且在需要修改 gender 属性使用的数据类型时，也可以在不影响客户端代码的情况下进行。\npublic class Person { private String name; private int gender; private int age; public String getName() { return name; } public String getGender() { return gender == 0 ? \u0026#34;man\u0026#34; : \u0026#34;woman\u0026#34;; } public void work() { if (18 \u0026lt;= age \u0026amp;\u0026amp; age \u0026lt;= 50) { System.out.println(name + \u0026#34; is working very hard!\u0026#34;); } else { System.out.println(name + \u0026#34; can\u0026#39;t work any more!\u0026#34;); } } } 继承 继承实现了 IS-A 关系，例如 Cat 和 Animal 就是一种 IS-A 关系，因此 Cat 可以继承自 Animal，从而获得 Animal 非 private 的属性和方法。\n继承应该遵循里氏替换原则，子类对象必须能够替换掉所有父类对象。\nCat 可以当做 Animal 来使用，也就是说可以使用 Animal 引用 Cat 对象。父类引用指向子类对象称为 向上转型 。\nAnimal animal = new Cat(); 多态 多态分为编译时多态和运行时多态：\n 编译时多态主要指方法的重载 运行时多态指程序中定义的对象引用所指向的具体类型在运行期间才确定  运行时多态有三个条件：\n 继承 覆盖（重写） 向上转型  下面的代码中，乐器类（Instrument）有两个子类：Wind 和 Percussion，它们都覆盖了父类的 play() 方法，并且在 main() 方法中使用父类 Instrument 来引用 Wind 和 Percussion 对象。在 Instrument 引用调用 play() 方法时，会执行实际引用对象所在类的 play() 方法，而不是 Instrument 类的方法。\npublic class Instrument { public void play() { System.out.println(\u0026#34;Instument is playing...\u0026#34;); } } public class Wind extends Instrument { public void play() { System.out.println(\u0026#34;Wind is playing...\u0026#34;); } } public class Percussion extends Instrument { public void play() { System.out.println(\u0026#34;Percussion is playing...\u0026#34;); } } public class Music { public static void main(String[] args) { List\u0026lt;Instrument\u0026gt; instruments = new ArrayList\u0026lt;\u0026gt;(); instruments.add(new Wind()); instruments.add(new Percussion()); for(Instrument instrument : instruments) { instrument.play(); } } } Wind is playing... Percussion is playing... 二、类图 以下类图使用 PlantUML 绘制，更多语法及使用请参考：http://plantuml.com/ 。\n泛化关系 (Generalization) 用来描述继承关系，在 Java 中使用 extends 关键字。\n\n@startuml title Generalization class Vihical class Car class Trunck Vihical \u0026lt;|-- Car Vihical \u0026lt;|-- Trunck @enduml 实现关系 (Realization) 用来实现一个接口，在 Java 中使用 implements 关键字。\n\n@startuml title Realization interface MoveBehavior class Fly class Run MoveBehavior \u0026lt;|.. Fly MoveBehavior \u0026lt;|.. Run @enduml 聚合关系 (Aggregation) 表示整体由部分组成，但是整体和部分不是强依赖的，整体不存在了部分还是会存在。\n\n@startuml title Aggregation class Computer class Keyboard class Mouse class Screen Computer o-- Keyboard Computer o-- Mouse Computer o-- Screen @enduml 组合关系 (Composition) 和聚合不同，组合中整体和部分是强依赖的，整体不存在了部分也不存在了。比如公司和部门，公司没了部门就不存在了。但是公司和员工就属于聚合关系了，因为公司没了员工还在。\n\n@startuml title Composition class Company class DepartmentA class DepartmentB Company *-- DepartmentA Company *-- DepartmentB @enduml 关联关系 (Association) 表示不同类对象之间有关联，这是一种静态关系，与运行过程的状态无关，在最开始就可以确定。因此也可以用 1 对 1、多对 1、多对多这种关联关系来表示。比如学生和学校就是一种关联关系，一个学校可以有很多学生，但是一个学生只属于一个学校，因此这是一种多对一的关系，在运行开始之前就可以确定。\n\n@startuml title Association class School class Student School \u0026#34;1\u0026#34; - \u0026#34;n\u0026#34; Student @enduml 依赖关系 (Dependency) 和关联关系不同的是，依赖关系是在运行过程中起作用的。A 类和 B 类是依赖关系主要有三种形式：\n A 类是 B 类方法的局部变量； A 类是 B 类方法的参数； A 类向 B 类发送消息，从而影响 B 类发生变化。  \n@startuml title Dependency class Vihicle { move(MoveBehavior) } interface MoveBehavior { move() } note \u0026#34;MoveBehavior.move()\u0026#34; as N Vihicle ..\u0026gt; MoveBehavior Vihicle .. N @enduml 三、设计原则 S.O.L.I.D    简写 全拼 中文翻译     SRP The Single Responsibility Principle 单一责任原则   OCP The Open Closed Principle 开放封闭原则   LSP The Liskov Substitution Principle 里氏替换原则   ISP The Interface Segregation Principle 接口分离原则   DIP The Dependency Inversion Principle 依赖倒置原则    1. 单一责任原则  修改一个类的原因应该只有一个。\n 换句话说就是让一个类只负责一件事，当这个类需要做过多事情的时候，就需要分解这个类。\n如果一个类承担的职责过多，就等于把这些职责耦合在了一起，一个职责的变化可能会削弱这个类完成其它职责的能力。\n2. 开放封闭原则  类应该对扩展开放，对修改关闭。\n 扩展就是添加新功能的意思，因此该原则要求在添加新功能时不需要修改代码。\n符合开闭原则最典型的设计模式是装饰者模式，它可以动态地将责任附加到对象上，而不用去修改类的代码。\n3. 里氏替换原则  子类对象必须能够替换掉所有父类对象。\n 继承是一种 IS-A 关系，子类需要能够当成父类来使用，并且需要比父类更特殊。\n如果不满足这个原则，那么各个子类的行为上就会有很大差异，增加继承体系的复杂度。\n4. 接口分离原则  不应该强迫客户依赖于它们不用的方法。\n 因此使用多个专门的接口比使用单一的总接口要好。\n5. 依赖倒置原则  高层模块不应该依赖于低层模块，二者都应该依赖于抽象；抽象不应该依赖于细节，细节应该依赖于抽象。\n 高层模块包含一个应用程序中重要的策略选择和业务模块，如果高层模块依赖于低层模块，那么低层模块的改动就会直接影响到高层模块，从而迫使高层模块也需要改动。\n依赖于抽象意味着：\n 任何变量都不应该持有一个指向具体类的指针或者引用； 任何类都不应该从具体类派生； 任何方法都不应该覆写它的任何基类中的已经实现的方法。  其他常见原则 除了上述的经典原则，在实际开发中还有下面这些常见的设计原则。\n   简写 全拼 中文翻译     LOD The Law of Demeter 迪米特法则   CRP The Composite Reuse Principle 合成复用原则   CCP The Common Closure Principle 共同封闭原则   SAP The Stable Abstractions Principle 稳定抽象原则   SDP The Stable Dependencies Principle 稳定依赖原则    1. 迪米特法则 迪米特法则又叫作最少知识原则（Least Knowledge Principle，简写 LKP），就是说一个对象应当对其他对象有尽可能少的了解，不和陌生人说话。\n2. 合成复用原则 尽量使用对象组合，而不是通过继承来达到复用的目的。\n3. 共同封闭原则 一起修改的类，应该组合在一起（同一个包里）。如果必须修改应用程序里的代码，我们希望所有的修改都发生在一个包里（修改关闭），而不是遍布在很多包里。\n4. 稳定抽象原则 最稳定的包应该是最抽象的包，不稳定的包应该是具体的包，即包的抽象程度跟它的稳定性成正比。\n5. 稳定依赖原则 包之间的依赖关系都应该是稳定方向依赖的，包要依赖的包要比自己更具有稳定性。\n参考资料  Java 编程思想 敏捷软件开发：原则、模式与实践 面向对象设计的 SOLID 原则 看懂 UML 类图和时序图 UML 系列——时序图（顺序图）sequence diagram 面向对象编程三大特性 \u0026mdash;\u0026mdash; 封装、继承、多态  ","permalink":"/collection/2021-12-22-oop/","summary":"面向对象思想 面向对象思想 一、三大特性 封装 继承 多态 二、类图 泛化关系 (Generalization) 实现关系 (Realization) 聚合关系 (Aggregation) 组合关系 (Composition) 关联关系 (Association) 依赖关系 (Dependency) 三、设计原则 S.O.L.I.D 其他常见原","title":"【转载】面向对象思想"},{"content":"缓存  缓存  一、缓存特征 二、缓存位置 三、CDN 四、缓存问题 五、数据分布 六、一致性哈希 七、LRU 参考资料    一、缓存特征 命中率 当某个请求能够通过访问缓存而得到响应时，称为缓存命中。\n缓存命中率越高，缓存的利用率也就越高。\n最大空间 缓存通常位于内存中，内存的空间通常比磁盘空间小的多，因此缓存的最大空间不可能非常大。\n当缓存存放的数据量超过最大空间时，就需要淘汰部分数据来存放新到达的数据。\n淘汰策略   FIFO（First In First Out）：先进先出策略，在实时性的场景下，需要经常访问最新的数据，那么就可以使用 FIFO，使得最先进入的数据（最晚的数据）被淘汰。\n  LRU（Least Recently Used）：最近最久未使用策略，优先淘汰最久未使用的数据，也就是上次被访问时间距离现在最久的数据。该策略可以保证内存中的数据都是热点数据，也就是经常被访问的数据，从而保证缓存命中率。\n  LFU（Least Frequently Used）：最不经常使用策略，优先淘汰一段时间内使用次数最少的数据。\n  二、缓存位置 浏览器 当 HTTP 响应允许进行缓存时，浏览器会将 HTML、CSS、JavaScript、图片等静态资源进行缓存。\nISP 网络服务提供商（ISP）是网络访问的第一跳，通过将数据缓存在 ISP 中能够大大提高用户的访问速度。\n反向代理 反向代理位于服务器之前，请求与响应都需要经过反向代理。通过将数据缓存在反向代理，在用户请求反向代理时就可以直接使用缓存进行响应。\n本地缓存 使用 Guava Cache 将数据缓存在服务器本地内存中，服务器代码可以直接读取本地内存中的缓存，速度非常快。\n分布式缓存 使用 Redis、Memcache 等分布式缓存将数据缓存在分布式缓存系统中。\n相对于本地缓存来说，分布式缓存单独部署，可以根据需求分配硬件资源。不仅如此，服务器集群都可以访问分布式缓存，而本地缓存需要在服务器集群之间进行同步，实现难度和性能开销上都非常大。\n数据库缓存 MySQL 等数据库管理系统具有自己的查询缓存机制来提高查询效率。\nJava 内部的缓存 Java 为了优化空间，提高字符串、基本数据类型包装类的创建效率，设计了字符串常量池及 Byte、Short、Character、Integer、Long、Boolean 这六种包装类缓冲池。\nCPU 多级缓存 CPU 为了解决运算速度与主存 IO 速度不匹配的问题，引入了多级缓存结构，同时使用 MESI 等缓存一致性协议来解决多核 CPU 缓存数据一致性的问题。\n三、CDN 内容分发网络（Content distribution network，CDN）是一种互连的网络系统，它利用更靠近用户的服务器从而更快更可靠地将 HTML、CSS、JavaScript、音乐、图片、视频等静态资源分发给用户。\nCDN 主要有以下优点：\n 更快地将数据分发给用户； 通过部署多台服务器，从而提高系统整体的带宽性能； 多台服务器可以看成是一种冗余机制，从而具有高可用性。  \n四、缓存问题 缓存穿透 指的是对某个一定不存在的数据进行请求，该请求将会穿透缓存到达数据库。\n解决方案：\n 对这些不存在的数据缓存一个空数据； 对这类请求进行过滤。  缓存雪崩 指的是由于数据没有被加载到缓存中，或者缓存数据在同一时间大面积失效（过期），又或者缓存服务器宕机，导致大量的请求都到达数据库。\n在有缓存的系统中，系统非常依赖于缓存，缓存分担了很大一部分的数据请求。当发生缓存雪崩时，数据库无法处理这么大的请求，导致数据库崩溃。\n解决方案：\n 为了防止缓存在同一时间大面积过期导致的缓存雪崩，可以通过观察用户行为，合理设置缓存过期时间来实现； 为了防止缓存服务器宕机出现的缓存雪崩，可以使用分布式缓存，分布式缓存中每一个节点只缓存部分的数据，当某个节点宕机时可以保证其它节点的缓存仍然可用。 也可以进行缓存预热，避免在系统刚启动不久由于还未将大量数据进行缓存而导致缓存雪崩。  缓存一致性 缓存一致性要求数据更新的同时缓存数据也能够实时更新。\n解决方案：\n 在数据更新的同时立即去更新缓存； 在读缓存之前先判断缓存是否是最新的，如果不是最新的先进行更新。  要保证缓存一致性需要付出很大的代价，缓存数据最好是那些对一致性要求不高的数据，允许缓存数据存在一些脏数据。\n缓存 “无底洞” 现象 指的是为了满足业务要求添加了大量缓存节点，但是性能不但没有好转反而下降了的现象。\n产生原因：缓存系统通常采用 hash 函数将 key 映射到对应的缓存节点，随着缓存节点数目的增加，键值分布到更多的节点上，导致客户端一次批量操作会涉及多次网络操作，这意味着批量操作的耗时会随着节点数目的增加而不断增大。此外，网络连接数变多，对节点的性能也有一定影响。\n解决方案：\n 优化批量数据操作命令； 减少网络通信次数； 降低接入成本，使用长连接 / 连接池，NIO 等。  五、数据分布 哈希分布 哈希分布就是将数据计算哈希值之后，按照哈希值分配到不同的节点上。例如有 N 个节点，数据的主键为 key，则将该数据分配的节点序号为：hash(key)%N。\n传统的哈希分布算法存在一个问题：当节点数量变化时，也就是 N 值变化，那么几乎所有的数据都需要重新分布，将导致大量的数据迁移。\n顺序分布 将数据划分为多个连续的部分，按数据的 ID 或者时间分布到不同节点上。例如 User 表的 ID 范围为 1 ~ 7000，使用顺序分布可以将其划分成多个子表，对应的主键范围为 1 ~ 1000，1001 ~ 2000，\u0026hellip;，6001 ~ 7000。\n顺序分布相比于哈希分布的主要优点如下：\n 能保持数据原有的顺序； 并且能够准确控制每台服务器存储的数据量，从而使得存储空间的利用率最大。  六、一致性哈希 Distributed Hash Table（DHT） 是一种哈希分布方式，其目的是为了克服传统哈希分布在服务器节点数量变化时大量数据迁移的问题。\n基本原理 将哈希空间 [0, 2n-1] 看成一个哈希环，每个服务器节点都配置到哈希环上。每个数据对象通过哈希取模得到哈希值之后，存放到哈希环中顺时针方向第一个大于等于该哈希值的节点上。\n\n一致性哈希在增加或者删除节点时只会影响到哈希环中相邻的节点，例如下图中新增节点 X，只需要将它前一个节点 C 上的数据重新进行分布即可，对于节点 A、B、D 都没有影响。\n\n虚拟节点 上面描述的一致性哈希存在数据分布不均匀的问题，节点存储的数据量有可能会存在很大的不同。\n数据不均匀主要是因为节点在哈希环上分布的不均匀，这种情况在节点数量很少的情况下尤其明显。\n解决方式是通过增加虚拟节点，然后将虚拟节点映射到真实节点上。虚拟节点的数量比真实节点来得多，那么虚拟节点在哈希环上分布的均匀性就会比原来的真实节点好，从而使得数据分布也更加均匀。\n七、LRU 以下是基于 双向链表 + HashMap 的 LRU 算法实现，对算法的解释如下：\n 访问某个节点时，将其从原来的位置删除，并重新插入到链表头部。这样就能保证链表尾部存储的就是最近最久未使用的节点，当节点数量大于缓存最大空间时就淘汰链表尾部的节点。 为了使删除操作时间复杂度为 O(1)，就不能采用遍历的方式找到某个节点。HashMap 存储着 Key 到节点的映射，通过 Key 就能以 O(1) 的时间得到节点，然后再以 O(1) 的时间将其从双向队列中删除。  public class LRU\u0026lt;K, V\u0026gt; implements Iterable\u0026lt;K\u0026gt; { private Node head; private Node tail; private HashMap\u0026lt;K, Node\u0026gt; map; private int maxSize; private class Node { Node pre; Node next; K k; V v; public Node(K k, V v) { this.k = k; this.v = v; } } public LRU(int maxSize) { this.maxSize = maxSize; this.map = new HashMap\u0026lt;\u0026gt;(maxSize * 4 / 3); head = new Node(null, null); tail = new Node(null, null); head.next = tail; tail.pre = head; } public V get(K key) { if (!map.containsKey(key)) { return null; } Node node = map.get(key); unlink(node); appendHead(node); return node.v; } public void put(K key, V value) { if (map.containsKey(key)) { Node node = map.get(key); unlink(node); } Node node = new Node(key, value); map.put(key, node); appendHead(node); if (map.size() \u0026gt; maxSize) { Node toRemove = removeTail(); map.remove(toRemove.k); } } private void unlink(Node node) { Node pre = node.pre; Node next = node.next; pre.next = next; next.pre = pre; node.pre = null; node.next = null; } private void appendHead(Node node) { Node next = head.next; node.next = next; next.pre = node; node.pre = head; head.next = node; } private Node removeTail() { Node node = tail.pre; Node pre = node.pre; tail.pre = pre; pre.next = tail; node.pre = null; node.next = null; return node; } @Override public Iterator\u0026lt;K\u0026gt; iterator() { return new Iterator\u0026lt;K\u0026gt;() { private Node cur = head.next; @Override public boolean hasNext() { return cur != tail; } @Override public K next() { Node node = cur; cur = cur.next; return node.k; } }; } } 参考资料  大规模分布式存储系统 缓存那些事 一致性哈希算法 内容分发网络 How Aspiration CDN helps to improve your website loading speed?  ","permalink":"/collection/2021-12-22-cache/","summary":"缓存 缓存 一、缓存特征 二、缓存位置 三、CDN 四、缓存问题 五、数据分布 六、一致性哈希 七、LRU 参考资料 一、缓存特征 命中率 当某个请求能够通过访问缓","title":"【转载】缓存"},{"content":"Redis  Redis  一、概述 二、数据类型  STRING LIST SET HASH ZSET   三、数据结构  字典 跳跃表   四、使用场景  计数器 缓存 查找表 消息队列 会话缓存 分布式锁实现 其它   五、Redis 与 Memcached  数据类型 数据持久化 分布式 内存管理机制   六、键的过期时间 七、数据淘汰策略 八、持久化  RDB 持久化 AOF 持久化   九、事务 十、事件  文件事件 时间事件 事件的调度与执行   十一、复制  连接过程 主从链   十二、Sentinel 十三、分片 十四、一个简单的论坛系统分析  文章信息 点赞功能 对文章进行排序   参考资料    一、概述 Redis 是速度非常快的非关系型（NoSQL）内存键值数据库，可以存储键和五种不同类型的值之间的映射。\n键的类型只能为字符串，值支持五种数据类型：字符串、列表、集合、散列表、有序集合。\nRedis 支持很多特性，例如将内存中的数据持久化到硬盘中，使用复制来扩展读性能，使用分片来扩展写性能。\n二、数据类型    数据类型 可以存储的值 操作     STRING 字符串、整数或者浮点数 对整个字符串或者字符串的其中一部分执行操作\u0026lt;/br\u0026gt; 对整数和浮点数执行自增或者自减操作   LIST 列表 从两端压入或者弹出元素 \u0026lt;/br\u0026gt; 对单个或者多个元素进行修剪，\u0026lt;/br\u0026gt; 只保留一个范围内的元素   SET 无序集合 添加、获取、移除单个元素\u0026lt;/br\u0026gt; 检查一个元素是否存在于集合中\u0026lt;/br\u0026gt; 计算交集、并集、差集\u0026lt;/br\u0026gt; 从集合里面随机获取元素   HASH 包含键值对的无序散列表 添加、获取、移除单个键值对\u0026lt;/br\u0026gt; 获取所有键值对\u0026lt;/br\u0026gt; 检查某个键是否存在   ZSET 有序集合 添加、获取、删除元素\u0026lt;/br\u0026gt; 根据分值范围或者成员来获取元素\u0026lt;/br\u0026gt; 计算一个键的排名     What Redis data structures look like\n STRING \n\u0026gt; set hello world OK \u0026gt; get hello \u0026#34;world\u0026#34; \u0026gt; del hello (integer) 1 \u0026gt; get hello (nil) LIST \n\u0026gt; rpush list-key item (integer) 1 \u0026gt; rpush list-key item2 (integer) 2 \u0026gt; rpush list-key item (integer) 3 \u0026gt; lrange list-key 0 -1 1) \u0026#34;item\u0026#34; 2) \u0026#34;item2\u0026#34; 3) \u0026#34;item\u0026#34; \u0026gt; lindex list-key 1 \u0026#34;item2\u0026#34; \u0026gt; lpop list-key \u0026#34;item\u0026#34; \u0026gt; lrange list-key 0 -1 1) \u0026#34;item2\u0026#34; 2) \u0026#34;item\u0026#34; SET \n\u0026gt; sadd set-key item (integer) 1 \u0026gt; sadd set-key item2 (integer) 1 \u0026gt; sadd set-key item3 (integer) 1 \u0026gt; sadd set-key item (integer) 0 \u0026gt; smembers set-key 1) \u0026#34;item\u0026#34; 2) \u0026#34;item2\u0026#34; 3) \u0026#34;item3\u0026#34; \u0026gt; sismember set-key item4 (integer) 0 \u0026gt; sismember set-key item (integer) 1 \u0026gt; srem set-key item2 (integer) 1 \u0026gt; srem set-key item2 (integer) 0 \u0026gt; smembers set-key 1) \u0026#34;item\u0026#34; 2) \u0026#34;item3\u0026#34; HASH \n\u0026gt; hset hash-key sub-key1 value1 (integer) 1 \u0026gt; hset hash-key sub-key2 value2 (integer) 1 \u0026gt; hset hash-key sub-key1 value1 (integer) 0 \u0026gt; hgetall hash-key 1) \u0026#34;sub-key1\u0026#34; 2) \u0026#34;value1\u0026#34; 3) \u0026#34;sub-key2\u0026#34; 4) \u0026#34;value2\u0026#34; \u0026gt; hdel hash-key sub-key2 (integer) 1 \u0026gt; hdel hash-key sub-key2 (integer) 0 \u0026gt; hget hash-key sub-key1 \u0026#34;value1\u0026#34; \u0026gt; hgetall hash-key 1) \u0026#34;sub-key1\u0026#34; 2) \u0026#34;value1\u0026#34; ZSET \n\u0026gt; zadd zset-key 728 member1 (integer) 1 \u0026gt; zadd zset-key 982 member0 (integer) 1 \u0026gt; zadd zset-key 982 member0 (integer) 0 \u0026gt; zrange zset-key 0 -1 withscores 1) \u0026#34;member1\u0026#34; 2) \u0026#34;728\u0026#34; 3) \u0026#34;member0\u0026#34; 4) \u0026#34;982\u0026#34; \u0026gt; zrangebyscore zset-key 0 800 withscores 1) \u0026#34;member1\u0026#34; 2) \u0026#34;728\u0026#34; \u0026gt; zrem zset-key member1 (integer) 1 \u0026gt; zrem zset-key member1 (integer) 0 \u0026gt; zrange zset-key 0 -1 withscores 1) \u0026#34;member0\u0026#34; 2) \u0026#34;982\u0026#34; 三、数据结构 字典 dictht 是一个散列表结构，使用拉链法解决哈希冲突。\n/* This is our hash table structure. Every dictionary has two of this as we * implement incremental rehashing, for the old to the new table. */ typedef struct dictht { dictEntry **table; unsigned long size; unsigned long sizemask; unsigned long used; } dictht; typedef struct dictEntry { void *key; union { void *val; uint64_t u64; int64_t s64; double d; } v; struct dictEntry *next; } dictEntry; Redis 的字典 dict 中包含两个哈希表 dictht，这是为了方便进行 rehash 操作。在扩容时，将其中一个 dictht 上的键值对 rehash 到另一个 dictht 上面，完成之后释放空间并交换两个 dictht 的角色。\ntypedef struct dict { dictType *type; void *privdata; dictht ht[2]; long rehashidx; /* rehashing not in progress if rehashidx == -1 */ unsigned long iterators; /* number of iterators currently running */ } dict; rehash 操作不是一次性完成，而是采用渐进方式，这是为了避免一次性执行过多的 rehash 操作给服务器带来过大的负担。\n渐进式 rehash 通过记录 dict 的 rehashidx 完成，它从 0 开始，然后每执行一次 rehash 都会递增。例如在一次 rehash 中，要把 dict[0] rehash 到 dict[1]，这一次会把 dict[0] 上 table[rehashidx] 的键值对 rehash 到 dict[1] 上，dict[0] 的 table[rehashidx] 指向 null，并令 rehashidx++。\n在 rehash 期间，每次对字典执行添加、删除、查找或者更新操作时，都会执行一次渐进式 rehash。\n采用渐进式 rehash 会导致字典中的数据分散在两个 dictht 上，因此对字典的查找操作也需要到对应的 dictht 去执行。\n/* Performs N steps of incremental rehashing. Returns 1 if there are still * keys to move from the old to the new hash table, otherwise 0 is returned. * * Note that a rehashing step consists in moving a bucket (that may have more * than one key as we use chaining) from the old to the new hash table, however * since part of the hash table may be composed of empty spaces, it is not * guaranteed that this function will rehash even a single bucket, since it * will visit at max N*10 empty buckets in total, otherwise the amount of * work it does would be unbound and the function may block for a long time. */ int dictRehash(dict *d, int n) { int empty_visits = n * 10; /* Max number of empty buckets to visit. */ if (!dictIsRehashing(d)) return 0; while (n-- \u0026amp;\u0026amp; d-\u0026gt;ht[0].used != 0) { dictEntry *de, *nextde; /* Note that rehashidx can\u0026#39;t overflow as we are sure there are more * elements because ht[0].used != 0 */ assert(d-\u0026gt;ht[0].size \u0026gt; (unsigned long) d-\u0026gt;rehashidx); while (d-\u0026gt;ht[0].table[d-\u0026gt;rehashidx] == NULL) { d-\u0026gt;rehashidx++; if (--empty_visits == 0) return 1; } de = d-\u0026gt;ht[0].table[d-\u0026gt;rehashidx]; /* Move all the keys in this bucket from the old to the new hash HT */ while (de) { uint64_t h; nextde = de-\u0026gt;next; /* Get the index in the new hash table */ h = dictHashKey(d, de-\u0026gt;key) \u0026amp; d-\u0026gt;ht[1].sizemask; de-\u0026gt;next = d-\u0026gt;ht[1].table[h]; d-\u0026gt;ht[1].table[h] = de; d-\u0026gt;ht[0].used--; d-\u0026gt;ht[1].used++; de = nextde; } d-\u0026gt;ht[0].table[d-\u0026gt;rehashidx] = NULL; d-\u0026gt;rehashidx++; } /* Check if we already rehashed the whole table... */ if (d-\u0026gt;ht[0].used == 0) { zfree(d-\u0026gt;ht[0].table); d-\u0026gt;ht[0] = d-\u0026gt;ht[1]; _dictReset(\u0026amp;d-\u0026gt;ht[1]); d-\u0026gt;rehashidx = -1; return 0; } /* More to rehash... */ return 1; } 跳跃表 是有序集合的底层实现之一。\n跳跃表是基于多指针有序链表实现的，可以看成多个有序链表。\n\n在查找时，从上层指针开始查找，找到对应的区间之后再到下一层去查找。下图演示了查找 22 的过程。\n\n与红黑树等平衡树相比，跳跃表具有以下优点：\n 插入速度非常快速，因为不需要进行旋转等操作来维护平衡性； 更容易实现； 支持无锁操作。  四、使用场景 计数器 可以对 String 进行自增自减运算，从而实现计数器功能。\nRedis 这种内存型数据库的读写性能非常高，很适合存储频繁读写的计数量。\n缓存 将热点数据放到内存中，设置内存的最大使用量以及淘汰策略来保证缓存的命中率。\n查找表 例如 DNS 记录就很适合使用 Redis 进行存储。\n查找表和缓存类似，也是利用了 Redis 快速的查找特性。但是查找表的内容不能失效，而缓存的内容可以失效，因为缓存不作为可靠的数据来源。\n消息队列 List 是一个双向链表，可以通过 lpush 和 rpop 写入和读取消息\n不过最好使用 Kafka、RabbitMQ 等消息中间件。\n会话缓存 可以使用 Redis 来统一存储多台应用服务器的会话信息。\n当应用服务器不再存储用户的会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务器，从而更容易实现高可用性以及可伸缩性。\n分布式锁实现 在分布式场景下，无法使用单机环境下的锁来对多个节点上的进程进行同步。\n可以使用 Redis 自带的 SETNX 命令实现分布式锁，除此之外，还可以使用官方提供的 RedLock 分布式锁实现。\n其它 Set 可以实现交集、并集等操作，从而实现共同好友等功能。\nZSet 可以实现有序性操作，从而实现排行榜等功能。\n五、Redis 与 Memcached 两者都是非关系型内存键值数据库，主要有以下不同：\n数据类型 Memcached 仅支持字符串类型，而 Redis 支持五种不同的数据类型，可以更灵活地解决问题。\n数据持久化 Redis 支持两种持久化策略：RDB 快照和 AOF 日志，而 Memcached 不支持持久化。\n分布式 Memcached 不支持分布式，只能通过在客户端使用一致性哈希来实现分布式存储，这种方式在存储和查询时都需要先在客户端计算一次数据所在的节点。\nRedis Cluster 实现了分布式的支持。\n内存管理机制   在 Redis 中，并不是所有数据都一直存储在内存中，可以将一些很久没用的 value 交换到磁盘，而 Memcached 的数据则会一直在内存中。\n  Memcached 将内存分割成特定长度的块来存储数据，以完全解决内存碎片的问题。但是这种方式会使得内存的利用率不高，例如块的大小为 128 bytes，只存储 100 bytes 的数据，那么剩下的 28 bytes 就浪费掉了。\n  六、键的过期时间 Redis 可以为每个键设置过期时间，当键过期时，会自动删除该键。\n对于散列表这种容器，只能为整个键设置过期时间（整个散列表），而不能为键里面的单个元素设置过期时间。\n七、数据淘汰策略 可以设置内存最大使用量，当内存使用量超出时，会施行数据淘汰策略。\nRedis 具体有 6 种淘汰策略：\n   策略 描述     volatile-lru 从已设置过期时间的数据集中挑选最近最少使用的数据淘汰   volatile-ttl 从已设置过期时间的数据集中挑选将要过期的数据淘汰   volatile-random 从已设置过期时间的数据集中任意选择数据淘汰   allkeys-lru 从所有数据集中挑选最近最少使用的数据淘汰   allkeys-random 从所有数据集中任意选择数据进行淘汰   noeviction 禁止驱逐数据    作为内存数据库，出于对性能和内存消耗的考虑，Redis 的淘汰算法实际实现上并非针对所有 key，而是抽样一小部分并且从中选出被淘汰的 key。\n使用 Redis 缓存数据时，为了提高缓存命中率，需要保证缓存数据都是热点数据。可以将内存最大使用量设置为热点数据占用的内存量，然后启用 allkeys-lru 淘汰策略，将最近最少使用的数据淘汰。\nRedis 4.0 引入了 volatile-lfu 和 allkeys-lfu 淘汰策略，LFU 策略通过统计访问频率，将访问频率最少的键值对淘汰。\n八、持久化 Redis 是内存型数据库，为了保证数据在断电后不会丢失，需要将内存中的数据持久化到硬盘上。\nRDB 持久化 将某个时间点的所有数据都存放到硬盘上。\n可以将快照复制到其它服务器从而创建具有相同数据的服务器副本。\n如果系统发生故障，将会丢失最后一次创建快照之后的数据。\n如果数据量很大，保存快照的时间会很长。\nAOF 持久化 将写命令添加到 AOF 文件（Append Only File）的末尾。\n使用 AOF 持久化需要设置同步选项，从而确保写命令同步到磁盘文件上的时机。这是因为对文件进行写入并不会马上将内容同步到磁盘上，而是先存储到缓冲区，然后由操作系统决定什么时候同步到磁盘。有以下同步选项：\n   选项 同步频率     always 每个写命令都同步   everysec 每秒同步一次   no 让操作系统来决定何时同步     always 选项会严重减低服务器的性能； everysec 选项比较合适，可以保证系统崩溃时只会丢失一秒左右的数据，并且 Redis 每秒执行一次同步对服务器性能几乎没有任何影响； no 选项并不能给服务器性能带来多大的提升，而且也会增加系统崩溃时数据丢失的数量。  随着服务器写请求的增多，AOF 文件会越来越大。Redis 提供了一种将 AOF 重写的特性，能够去除 AOF 文件中的冗余写命令。\n九、事务 一个事务包含了多个命令，服务器在执行事务期间，不会改去执行其它客户端的命令请求。\n事务中的多个命令被一次性发送给服务器，而不是一条一条发送，这种方式被称为流水线，它可以减少客户端与服务器之间的网络通信次数从而提升性能。\nRedis 最简单的事务实现方式是使用 MULTI 和 EXEC 命令将事务操作包围起来。\n十、事件 Redis 服务器是一个事件驱动程序。\n文件事件 服务器通过套接字与客户端或者其它服务器进行通信，文件事件就是对套接字操作的抽象。\nRedis 基于 Reactor 模式开发了自己的网络事件处理器，使用 I/O 多路复用程序来同时监听多个套接字，并将到达的事件传送给文件事件分派器，分派器会根据套接字产生的事件类型调用相应的事件处理器。\n\n时间事件 服务器有一些操作需要在给定的时间点执行，时间事件是对这类定时操作的抽象。\n时间事件又分为：\n 定时事件：是让一段程序在指定的时间之内执行一次； 周期性事件：是让一段程序每隔指定时间就执行一次。  Redis 将所有时间事件都放在一个无序链表中，通过遍历整个链表查找出已到达的时间事件，并调用相应的事件处理器。\n事件的调度与执行 服务器需要不断监听文件事件的套接字才能得到待处理的文件事件，但是不能一直监听，否则时间事件无法在规定的时间内执行，因此监听时间应该根据距离现在最近的时间事件来决定。\n事件调度与执行由 aeProcessEvents 函数负责，伪代码如下：\ndef aeProcessEvents(): # 获取到达时间离当前时间最接近的时间事件 time_event = aeSearchNearestTimer() # 计算最接近的时间事件距离到达还有多少毫秒 remaind_ms = time_event.when - unix_ts_now() # 如果事件已到达，那么 remaind_ms 的值可能为负数，将它设为 0 if remaind_ms \u0026lt; 0: remaind_ms = 0 # 根据 remaind_ms 的值，创建 timeval timeval = create_timeval_with_ms(remaind_ms) # 阻塞并等待文件事件产生，最大阻塞时间由传入的 timeval 决定 aeApiPoll(timeval) # 处理所有已产生的文件事件 procesFileEvents() # 处理所有已到达的时间事件 processTimeEvents() 将 aeProcessEvents 函数置于一个循环里面，加上初始化和清理函数，就构成了 Redis 服务器的主函数，伪代码如下：\ndef main(): # 初始化服务器 init_server() # 一直处理事件，直到服务器关闭为止 while server_is_not_shutdown(): aeProcessEvents() # 服务器关闭，执行清理操作 clean_server() 从事件处理的角度来看，服务器运行流程如下：\n\n十一、复制 通过使用 slaveof host port 命令来让一个服务器成为另一个服务器的从服务器。\n一个从服务器只能有一个主服务器，并且不支持主主复制。\n连接过程   主服务器创建快照文件，发送给从服务器，并在发送期间使用缓冲区记录执行的写命令。快照文件发送完毕之后，开始向从服务器发送存储在缓冲区中的写命令；\n  从服务器丢弃所有旧数据，载入主服务器发来的快照文件，之后从服务器开始接受主服务器发来的写命令；\n  主服务器每执行一次写命令，就向从服务器发送相同的写命令。\n  主从链 随着负载不断上升，主服务器可能无法很快地更新所有从服务器，或者重新连接和重新同步从服务器将导致系统超载。为了解决这个问题，可以创建一个中间层来分担主服务器的复制工作。中间层的服务器是最上层服务器的从服务器，又是最下层服务器的主服务器。\n\n十二、Sentinel Sentinel（哨兵）可以监听集群中的服务器，并在主服务器进入下线状态时，自动从从服务器中选举出新的主服务器。\n十三、分片 分片是将数据划分为多个部分的方法，可以将数据存储到多台机器里面，这种方法在解决某些问题时可以获得线性级别的性能提升。\n假设有 4 个 Redis 实例 R0，R1，R2，R3，还有很多表示用户的键 user:1，user:2，\u0026hellip; ，有不同的方式来选择一个指定的键存储在哪个实例中。\n 最简单的方式是范围分片，例如用户 id 从 0~1000 的存储到实例 R0 中，用户 id 从 1001~2000 的存储到实例 R1 中，等等。但是这样需要维护一张映射范围表，维护操作代价很高。 还有一种方式是哈希分片，使用 CRC32 哈希函数将键转换为一个数字，再对实例数量求模就能知道应该存储的实例。  根据执行分片的位置，可以分为三种分片方式：\n 客户端分片：客户端使用一致性哈希等算法决定键应当分布到哪个节点。 代理分片：将客户端请求发送到代理上，由代理转发请求到正确的节点上。 服务器分片：Redis Cluster。  十四、一个简单的论坛系统分析 该论坛系统功能如下：\n 可以发布文章； 可以对文章进行点赞； 在首页可以按文章的发布时间或者文章的点赞数进行排序显示。  文章信息 文章包括标题、作者、赞数等信息，在关系型数据库中很容易构建一张表来存储这些信息，在 Redis 中可以使用 HASH 来存储每种信息以及其对应的值的映射。\nRedis 没有关系型数据库中的表这一概念来将同种类型的数据存放在一起，而是使用命名空间的方式来实现这一功能。键名的前面部分存储命名空间，后面部分的内容存储 ID，通常使用 : 来进行分隔。例如下面的 HASH 的键名为 article:92617，其中 article 为命名空间，ID 为 92617。\n\n点赞功能 当有用户为一篇文章点赞时，除了要对该文章的 votes 字段进行加 1 操作，还必须记录该用户已经对该文章进行了点赞，防止用户点赞次数超过 1。可以建立文章的已投票用户集合来进行记录。\n为了节约内存，规定一篇文章发布满一周之后，就不能再对它进行投票，而文章的已投票集合也会被删除，可以为文章的已投票集合设置一个一周的过期时间就能实现这个规定。\n\n对文章进行排序 为了按发布时间和点赞数进行排序，可以建立一个文章发布时间的有序集合和一个文章点赞数的有序集合。（下图中的 score 就是这里所说的点赞数；下面所示的有序集合分值并不直接是时间和点赞数，而是根据时间和点赞数间接计算出来的）\n\n参考资料  Carlson J L. Redis in Action[J]. Media.johnwiley.com.au, 2013. 黄健宏. Redis 设计与实现 [M]. 机械工业出版社, 2014. REDIS IN ACTION Skip Lists: Done Right 论述 Redis 和 Memcached 的差异 Redis 3.0 中文版- 分片 Redis 应用场景 Using Redis as an LRU cache  ","permalink":"/collection/2021-12-22-redis/","summary":"Redis Redis 一、概述 二、数据类型 STRING LIST SET HASH ZSET 三、数据结构 字典 跳跃表 四、使用场景 计数器 缓存 查找表 消息队列 会话缓存 分布式锁实现 其它 五、Redis 与 Memcached 数据类","title":"【转载】Redis"},{"content":"SQL 练习  SQL 练习  595. Big Countries 627. Swap Salary 620. Not Boring Movies 596. Classes More Than 5 Students 182. Duplicate Emails 196. Delete Duplicate Emails 175. Combine Two Tables 181. Employees Earning More Than Their Managers 183. Customers Who Never Order 184. Department Highest Salary 176. Second Highest Salary 177. Nth Highest Salary 178. Rank Scores 180. Consecutive Numbers 626. Exchange Seats    595. Big Countries https://leetcode.com/problems/big-countries/description/\nDescription +-----------------+------------+------------+--------------+---------------+ | name | continent | area | population | gdp | +-----------------+------------+------------+--------------+---------------+ | Afghanistan | Asia | 652230 | 25500100 | 20343000 | | Albania | Europe | 28748 | 2831741 | 12960000 | | Algeria | Africa | 2381741 | 37100000 | 188681000 | | Andorra | Europe | 468 | 78115 | 3712000 | | Angola | Africa | 1246700 | 20609294 | 100990000 | +-----------------+------------+------------+--------------+---------------+ 查找面积超过 3,000,000 或者人口数超过 25,000,000 的国家。\n+--------------+-------------+--------------+ | name | population | area | +--------------+-------------+--------------+ | Afghanistan | 25500100 | 652230 | | Algeria | 37100000 | 2381741 | +--------------+-------------+--------------+ Solution SELECTname,population,areaFROMWorldWHEREarea\u0026gt;3000000ORpopulation\u0026gt;25000000;SQL Schema SQL Schema 用于在本地环境下创建表结构并导入数据，从而方便在本地环境调试。\nDROPTABLEIFEXISTSWorld;CREATETABLEWorld(NAMEVARCHAR(255),continentVARCHAR(255),areaINT,populationINT,gdpINT);INSERTINTOWorld(NAME,continent,area,population,gdp)VALUES(\u0026#39;Afghanistan\u0026#39;,\u0026#39;Asia\u0026#39;,\u0026#39;652230\u0026#39;,\u0026#39;25500100\u0026#39;,\u0026#39;203430000\u0026#39;),(\u0026#39;Albania\u0026#39;,\u0026#39;Europe\u0026#39;,\u0026#39;28748\u0026#39;,\u0026#39;2831741\u0026#39;,\u0026#39;129600000\u0026#39;),(\u0026#39;Algeria\u0026#39;,\u0026#39;Africa\u0026#39;,\u0026#39;2381741\u0026#39;,\u0026#39;37100000\u0026#39;,\u0026#39;1886810000\u0026#39;),(\u0026#39;Andorra\u0026#39;,\u0026#39;Europe\u0026#39;,\u0026#39;468\u0026#39;,\u0026#39;78115\u0026#39;,\u0026#39;37120000\u0026#39;),(\u0026#39;Angola\u0026#39;,\u0026#39;Africa\u0026#39;,\u0026#39;1246700\u0026#39;,\u0026#39;20609294\u0026#39;,\u0026#39;1009900000\u0026#39;);627. Swap Salary https://leetcode.com/problems/swap-salary/description/\nDescription | id | name | sex | salary | |----|------|-----|--------| | 1 | A | m | 2500 | | 2 | B | f | 1500 | | 3 | C | m | 5500 | | 4 | D | f | 500 | 只用一个 SQL 查询，将 sex 字段反转。\n| id | name | sex | salary | |----|------|-----|--------| | 1 | A | f | 2500 | | 2 | B | m | 1500 | | 3 | C | f | 5500 | | 4 | D | m | 500 | Solution 两个相等的数异或的结果为 0，而 0 与任何一个数异或的结果为这个数。\nsex 字段只有两个取值：\u0026lsquo;f\u0026rsquo; 和 \u0026rsquo;m\u0026rsquo;，并且有以下规律：\n\u0026#39;f\u0026#39; ^ (\u0026#39;m\u0026#39; ^ \u0026#39;f\u0026#39;) = \u0026#39;m\u0026#39; ^ (\u0026#39;f\u0026#39; ^ \u0026#39;f\u0026#39;) = \u0026#39;m\u0026#39; \u0026#39;m\u0026#39; ^ (\u0026#39;m\u0026#39; ^ \u0026#39;f\u0026#39;) = \u0026#39;f\u0026#39; ^ (\u0026#39;m\u0026#39; ^ \u0026#39;m\u0026#39;) = \u0026#39;f\u0026#39; 因此将 sex 字段和 \u0026rsquo;m\u0026rsquo; ^ \u0026lsquo;f\u0026rsquo; 进行异或操作，最后就能反转 sex 字段。\nUPDATEsalarySETsex=CHAR(ASCII(sex)^ASCII(\u0026#39;m\u0026#39;)^ASCII(\u0026#39;f\u0026#39;));SQL Schema DROPTABLEIFEXISTSsalary;CREATETABLEsalary(idINT,NAMEVARCHAR(100),sexCHAR(1),salaryINT);INSERTINTOsalary(id,NAME,sex,salary)VALUES(\u0026#39;1\u0026#39;,\u0026#39;A\u0026#39;,\u0026#39;m\u0026#39;,\u0026#39;2500\u0026#39;),(\u0026#39;2\u0026#39;,\u0026#39;B\u0026#39;,\u0026#39;f\u0026#39;,\u0026#39;1500\u0026#39;),(\u0026#39;3\u0026#39;,\u0026#39;C\u0026#39;,\u0026#39;m\u0026#39;,\u0026#39;5500\u0026#39;),(\u0026#39;4\u0026#39;,\u0026#39;D\u0026#39;,\u0026#39;f\u0026#39;,\u0026#39;500\u0026#39;);620. Not Boring Movies https://leetcode.com/problems/not-boring-movies/description/\nDescription +---------+-----------+--------------+-----------+ | id | movie | description | rating | +---------+-----------+--------------+-----------+ | 1 | War | great 3D | 8.9 | | 2 | Science | fiction | 8.5 | | 3 | irish | boring | 6.2 | | 4 | Ice song | Fantacy | 8.6 | | 5 | House card| Interesting| 9.1 | +---------+-----------+--------------+-----------+ 查找 id 为奇数，并且 description 不是 boring 的电影，按 rating 降序。\n+---------+-----------+--------------+-----------+ | id | movie | description | rating | +---------+-----------+--------------+-----------+ | 5 | House card| Interesting| 9.1 | | 1 | War | great 3D | 8.9 | +---------+-----------+--------------+-----------+ Solution SELECT*FROMcinemaWHEREid%2=1ANDdescription!=\u0026#39;boring\u0026#39;ORDERBYratingDESC;SQL Schema DROPTABLEIFEXISTScinema;CREATETABLEcinema(idINT,movieVARCHAR(255),descriptionVARCHAR(255),ratingFLOAT(2,1));INSERTINTOcinema(id,movie,description,rating)VALUES(1,\u0026#39;War\u0026#39;,\u0026#39;great 3D\u0026#39;,8.9),(2,\u0026#39;Science\u0026#39;,\u0026#39;fiction\u0026#39;,8.5),(3,\u0026#39;irish\u0026#39;,\u0026#39;boring\u0026#39;,6.2),(4,\u0026#39;Ice song\u0026#39;,\u0026#39;Fantacy\u0026#39;,8.6),(5,\u0026#39;House card\u0026#39;,\u0026#39;Interesting\u0026#39;,9.1);596. Classes More Than 5 Students https://leetcode.com/problems/classes-more-than-5-students/description/\nDescription +---------+------------+ | student | class | +---------+------------+ | A | Math | | B | English | | C | Math | | D | Biology | | E | Math | | F | Computer | | G | Math | | H | Math | | I | Math | +---------+------------+ 查找有五名及以上 student 的 class。\n+---------+ | class | +---------+ | Math | +---------+ Solution 对 class 列进行分组之后，再使用 count 汇总函数统计每个分组的记录个数，之后使用 HAVING 进行筛选。HAVING 针对分组进行筛选，而 WHERE 针对每个记录（行）进行筛选。\nSELECTclassFROMcoursesGROUPBYclassHAVINGcount(DISTINCTstudent)\u0026gt;=5;SQL Schema DROPTABLEIFEXISTScourses;CREATETABLEcourses(studentVARCHAR(255),classVARCHAR(255));INSERTINTOcourses(student,class)VALUES(\u0026#39;A\u0026#39;,\u0026#39;Math\u0026#39;),(\u0026#39;B\u0026#39;,\u0026#39;English\u0026#39;),(\u0026#39;C\u0026#39;,\u0026#39;Math\u0026#39;),(\u0026#39;D\u0026#39;,\u0026#39;Biology\u0026#39;),(\u0026#39;E\u0026#39;,\u0026#39;Math\u0026#39;),(\u0026#39;F\u0026#39;,\u0026#39;Computer\u0026#39;),(\u0026#39;G\u0026#39;,\u0026#39;Math\u0026#39;),(\u0026#39;H\u0026#39;,\u0026#39;Math\u0026#39;),(\u0026#39;I\u0026#39;,\u0026#39;Math\u0026#39;);182. Duplicate Emails https://leetcode.com/problems/duplicate-emails/description/\nDescription 邮件地址表：\n+----+---------+ | Id | Email | +----+---------+ | 1 | a@b.com | | 2 | c@d.com | | 3 | a@b.com | +----+---------+ 查找重复的邮件地址：\n+---------+ | Email | +---------+ | a@b.com | +---------+ Solution 对 Email 进行分组，如果并使用 COUNT 进行计数统计，结果大于等于 2 的表示 Email 重复。\nSELECTEmailFROMPersonGROUPBYEmailHAVINGCOUNT(*)\u0026gt;=2;SQL Schema DROPTABLEIFEXISTSPerson;CREATETABLEPerson(IdINT,EmailVARCHAR(255));INSERTINTOPerson(Id,Email)VALUES(1,\u0026#39;a@b.com\u0026#39;),(2,\u0026#39;c@d.com\u0026#39;),(3,\u0026#39;a@b.com\u0026#39;);196. Delete Duplicate Emails https://leetcode.com/problems/delete-duplicate-emails/description/\nDescription 邮件地址表：\n+----+---------+ | Id | Email | +----+---------+ | 1 | john@example.com | | 2 | bob@example.com | | 3 | john@example.com | +----+---------+ 删除重复的邮件地址：\n+----+------------------+ | Id | Email | +----+------------------+ | 1 | john@example.com | | 2 | bob@example.com | +----+------------------+ Solution 只保留相同 Email 中 Id 最小的那一个，然后删除其它的。\n连接查询：\nDELETEp1FROMPersonp1,Personp2WHEREp1.Email=p2.EmailANDp1.Id\u0026gt;p2.Id子查询：\nDELETEFROMPersonWHEREidNOTIN(SELECTidFROM(SELECTmin(id)ASidFROMPersonGROUPBYemail)ASm);应该注意的是上述解法额外嵌套了一个 SELECT 语句，如果不这么做，会出现错误：You can\u0026rsquo;t specify target table \u0026lsquo;Person\u0026rsquo; for update in FROM clause。以下演示了这种错误解法。\nDELETEFROMPersonWHEREidNOTIN(SELECTmin(id)ASidFROMPersonGROUPBYemail);参考：pMySQL Error 1093 - Can\u0026rsquo;t specify target table for update in FROM clause\nSQL Schema 与 182 相同。\n175. Combine Two Tables https://leetcode.com/problems/combine-two-tables/description/\nDescription Person 表：\n+-------------+---------+ | Column Name | Type | +-------------+---------+ | PersonId | int | | FirstName | varchar | | LastName | varchar | +-------------+---------+ PersonId is the primary key column for this table. Address 表：\n+-------------+---------+ | Column Name | Type | +-------------+---------+ | AddressId | int | | PersonId | int | | City | varchar | | State | varchar | +-------------+---------+ AddressId is the primary key column for this table. 查找 FirstName, LastName, City, State 数据，而不管一个用户有没有填地址信息。\nSolution 涉及到 Person 和 Address 两个表，在对这两个表执行连接操作时，因为要保留 Person 表中的信息，即使在 Address 表中没有关联的信息也要保留。此时可以用左外连接，将 Person 表放在 LEFT JOIN 的左边。\nSELECTFirstName,LastName,City,StateFROMPersonPLEFTJOINAddressAONP.PersonId=A.PersonId;SQL Schema DROPTABLEIFEXISTSPerson;CREATETABLEPerson(PersonIdINT,FirstNameVARCHAR(255),LastNameVARCHAR(255));DROPTABLEIFEXISTSAddress;CREATETABLEAddress(AddressIdINT,PersonIdINT,CityVARCHAR(255),StateVARCHAR(255));INSERTINTOPerson(PersonId,LastName,FirstName)VALUES(1,\u0026#39;Wang\u0026#39;,\u0026#39;Allen\u0026#39;);INSERTINTOAddress(AddressId,PersonId,City,State)VALUES(1,2,\u0026#39;New York City\u0026#39;,\u0026#39;New York\u0026#39;);181. Employees Earning More Than Their Managers https://leetcode.com/problems/employees-earning-more-than-their-managers/description/\nDescription Employee 表：\n+----+-------+--------+-----------+ | Id | Name | Salary | ManagerId | +----+-------+--------+-----------+ | 1 | Joe | 70000 | 3 | | 2 | Henry | 80000 | 4 | | 3 | Sam | 60000 | NULL | | 4 | Max | 90000 | NULL | +----+-------+--------+-----------+ 查找薪资大于其经理薪资的员工信息。\nSolution SELECTE1.NAMEASEmployeeFROMEmployeeE1INNERJOINEmployeeE2ONE1.ManagerId=E2.IdANDE1.Salary\u0026gt;E2.Salary;SQL Schema DROPTABLEIFEXISTSEmployee;CREATETABLEEmployee(IdINT,NAMEVARCHAR(255),SalaryINT,ManagerIdINT);INSERTINTOEmployee(Id,NAME,Salary,ManagerId)VALUES(1,\u0026#39;Joe\u0026#39;,70000,3),(2,\u0026#39;Henry\u0026#39;,80000,4),(3,\u0026#39;Sam\u0026#39;,60000,NULL),(4,\u0026#39;Max\u0026#39;,90000,NULL);183. Customers Who Never Order https://leetcode.com/problems/customers-who-never-order/description/\nDescription Customers 表：\n+----+-------+ | Id | Name | +----+-------+ | 1 | Joe | | 2 | Henry | | 3 | Sam | | 4 | Max | +----+-------+ Orders 表：\n+----+------------+ | Id | CustomerId | +----+------------+ | 1 | 3 | | 2 | 1 | +----+------------+ 查找没有订单的顾客信息：\n+-----------+ | Customers | +-----------+ | Henry | | Max | +-----------+ Solution 左外链接\nSELECTC.NameASCustomersFROMCustomersCLEFTJOINOrdersOONC.Id=O.CustomerIdWHEREO.CustomerIdISNULL;子查询\nSELECTNameASCustomersFROMCustomersWHEREIdNOTIN(SELECTCustomerIdFROMOrders);SQL Schema DROPTABLEIFEXISTSCustomers;CREATETABLECustomers(IdINT,NAMEVARCHAR(255));DROPTABLEIFEXISTSOrders;CREATETABLEOrders(IdINT,CustomerIdINT);INSERTINTOCustomers(Id,NAME)VALUES(1,\u0026#39;Joe\u0026#39;),(2,\u0026#39;Henry\u0026#39;),(3,\u0026#39;Sam\u0026#39;),(4,\u0026#39;Max\u0026#39;);INSERTINTOOrders(Id,CustomerId)VALUES(1,3),(2,1);184. Department Highest Salary https://leetcode.com/problems/department-highest-salary/description/\nDescription Employee 表：\n+----+-------+--------+--------------+ | Id | Name | Salary | DepartmentId | +----+-------+--------+--------------+ | 1 | Joe | 70000 | 1 | | 2 | Henry | 80000 | 2 | | 3 | Sam | 60000 | 2 | | 4 | Max | 90000 | 1 | +----+-------+--------+--------------+ Department 表：\n+----+----------+ | Id | Name | +----+----------+ | 1 | IT | | 2 | Sales | +----+----------+ 查找一个 Department 中收入最高者的信息：\n+------------+----------+--------+ | Department | Employee | Salary | +------------+----------+--------+ | IT | Max | 90000 | | Sales | Henry | 80000 | +------------+----------+--------+ Solution 创建一个临时表，包含了部门员工的最大薪资。可以对部门进行分组，然后使用 MAX() 汇总函数取得最大薪资。\n之后使用连接找到一个部门中薪资等于临时表中最大薪资的员工。\nSELECTD.NAMEDepartment,E.NAMEEmployee,E.SalaryFROMEmployeeE,DepartmentD,(SELECTDepartmentId,MAX(Salary)SalaryFROMEmployeeGROUPBYDepartmentId)MWHEREE.DepartmentId=D.IdANDE.DepartmentId=M.DepartmentIdANDE.Salary=M.Salary;SQL Schema DROPTABLEIFEXISTSEmployee;CREATETABLEEmployee(IdINT,NAMEVARCHAR(255),SalaryINT,DepartmentIdINT);DROPTABLEIFEXISTSDepartment;CREATETABLEDepartment(IdINT,NAMEVARCHAR(255));INSERTINTOEmployee(Id,NAME,Salary,DepartmentId)VALUES(1,\u0026#39;Joe\u0026#39;,70000,1),(2,\u0026#39;Henry\u0026#39;,80000,2),(3,\u0026#39;Sam\u0026#39;,60000,2),(4,\u0026#39;Max\u0026#39;,90000,1);INSERTINTODepartment(Id,NAME)VALUES(1,\u0026#39;IT\u0026#39;),(2,\u0026#39;Sales\u0026#39;);176. Second Highest Salary https://leetcode.com/problems/second-highest-salary/description/\nDescription +----+--------+ | Id | Salary | +----+--------+ | 1 | 100 | | 2 | 200 | | 3 | 300 | +----+--------+ 查找工资第二高的员工。\n+---------------------+ | SecondHighestSalary | +---------------------+ | 200 | +---------------------+ 没有找到返回 null 而不是不返回数据。\nSolution 为了在没有查找到数据时返回 null，需要在查询结果外面再套一层 SELECT。\nSELECT(SELECTDISTINCTSalaryFROMEmployeeORDERBYSalaryDESCLIMIT1,1)SecondHighestSalary;SQL Schema DROPTABLEIFEXISTSEmployee;CREATETABLEEmployee(IdINT,SalaryINT);INSERTINTOEmployee(Id,Salary)VALUES(1,100),(2,200),(3,300);177. Nth Highest Salary Description 查找工资第 N 高的员工。\nSolution CREATEFUNCTIONgetNthHighestSalary(NINT)RETURNSINTBEGINSETN=N-1;RETURN(SELECT(SELECTDISTINCTSalaryFROMEmployeeORDERBYSalaryDESCLIMITN,1));ENDSQL Schema 同 176。\n178. Rank Scores https://leetcode.com/problems/rank-scores/description/\nDescription 得分表：\n+----+-------+ | Id | Score | +----+-------+ | 1 | 3.50 | | 2 | 3.65 | | 3 | 4.00 | | 4 | 3.85 | | 5 | 4.00 | | 6 | 3.65 | +----+-------+ 将得分排序，并统计排名。\n+-------+------+ | Score | Rank | +-------+------+ | 4.00 | 1 | | 4.00 | 1 | | 3.85 | 2 | | 3.65 | 3 | | 3.65 | 3 | | 3.50 | 4 | +-------+------+ Solution 要统计某个 score 的排名，只要统计大于等于该 score 的 score 数量。\n   Id score 大于等于该 score 的 score 数量 排名     1 4.1 3 3   2 4.2 2 2   3 4.3 1 1    使用连接操作找到某个 score 对应的大于等于其值的记录：\nSELECT*FROMScoresS1INNERJOINScoresS2ONS1.score\u0026lt;=S2.scoreORDERBYS1.scoreDESC,S1.Id;   S1.Id S1.score S2.Id S2.score     3 4.3 3 4.3   2 4.2 2 4.2   2 4.2 3 4.3   1 4.1 1 4.1   1 4.1 2 4.2   1 4.1 3 4.3    可以看到每个 S1.score 都有对应好几条记录，我们再进行分组，并统计每个分组的数量作为 \u0026lsquo;Rank\u0026rsquo;\nSELECTS1.score\u0026#39;Score\u0026#39;,COUNT(*)\u0026#39;Rank\u0026#39;FROMScoresS1INNERJOINScoresS2ONS1.score\u0026lt;=S2.scoreGROUPBYS1.id,S1.scoreORDERBYS1.scoreDESC,S1.Id;   score Rank     4.3 1   4.2 2   4.1 3    上面的解法看似没问题，但是对于以下数据，它却得到了错误的结果：\n   Id score     1 4.1   2 4.2   3 4.2       score Rank     4.2 2   4.2 2   4.1 3    而我们希望的结果为：\n   score Rank     4.2 1   4.2 1   4.1 2    连接情况如下：\n   S1.Id S1.score S2.Id S2.score     2 4.2 3 4.2   2 4.2 2 4.2   3 4.2 3 4.2   3 4.2 2 4.1   1 4.1 3 4.2   1 4.1 2 4.2   1 4.1 1 4.1    我们想要的结果是，把分数相同的放在同一个排名，并且相同分数只占一个位置，例如上面的分数，Id=2 和 Id=3 的记录都有相同的分数，并且最高，他们并列第一。而 Id=1 的记录应该排第二名，而不是第三名。所以在进行 COUNT 计数统计时，我们需要使用 COUNT( DISTINCT S2.score ) 从而只统计一次相同的分数。\nSELECTS1.score\u0026#39;Score\u0026#39;,COUNT(DISTINCTS2.score)\u0026#39;Rank\u0026#39;FROMScoresS1INNERJOINScoresS2ONS1.score\u0026lt;=S2.scoreGROUPBYS1.id,S1.scoreORDERBYS1.scoreDESC;SQL Schema DROPTABLEIFEXISTSScores;CREATETABLEScores(IdINT,ScoreDECIMAL(3,2));INSERTINTOScores(Id,Score)VALUES(1,4.1),(2,4.1),(3,4.2),(4,4.2),(5,4.3),(6,4.3);180. Consecutive Numbers https://leetcode.com/problems/consecutive-numbers/description/\nDescription 数字表：\n+----+-----+ | Id | Num | +----+-----+ | 1 | 1 | | 2 | 1 | | 3 | 1 | | 4 | 2 | | 5 | 1 | | 6 | 2 | | 7 | 2 | +----+-----+ 查找连续出现三次的数字。\n+-----------------+ | ConsecutiveNums | +-----------------+ | 1 | +-----------------+ Solution SELECTDISTINCTL1.numConsecutiveNumsFROMLogsL1,LogsL2,LogsL3WHEREL1.id=l2.id-1ANDL2.id=L3.id-1ANDL1.num=L2.numANDl2.num=l3.num;SQL Schema DROPTABLEIFEXISTSLOGS;CREATETABLELOGS(IdINT,NumINT);INSERTINTOLOGS(Id,Num)VALUES(1,1),(2,1),(3,1),(4,2),(5,1),(6,2),(7,2);626. Exchange Seats https://leetcode.com/problems/exchange-seats/description/\nDescription seat 表存储着座位对应的学生。\n+---------+---------+ | id | student | +---------+---------+ | 1 | Abbot | | 2 | Doris | | 3 | Emerson | | 4 | Green | | 5 | Jeames | +---------+---------+ 要求交换相邻座位的两个学生，如果最后一个座位是奇数，那么不交换这个座位上的学生。\n+---------+---------+ | id | student | +---------+---------+ | 1 | Doris | | 2 | Abbot | | 3 | Green | | 4 | Emerson | | 5 | Jeames | +---------+---------+ Solution 使用多个 union。\n##处理偶数id，让id减1##例如2,4,6,...变成1,3,5,...SELECTs1.id-1ASid,s1.studentFROMseats1WHEREs1.idMOD2=0UNION##处理奇数id，让id加1。但是如果最大的id为奇数，则不做处理##例如1,3,5,...变成2,4,6,...SELECTs2.id+1ASid,s2.studentFROMseats2WHEREs2.idMOD2=1ANDs2.id!=(SELECTmax(s3.id)FROMseats3)UNION##如果最大的id为奇数，单独取出这个数SELECTs4.idASid,s4.studentFROMseats4WHEREs4.idMOD2=1ANDs4.id=(SELECTmax(s5.id)FROMseats5)ORDERBYid;SQL Schema DROPTABLEIFEXISTSseat;CREATETABLEseat(idINT,studentVARCHAR(255));INSERTINTOseat(id,student)VALUES(\u0026#39;1\u0026#39;,\u0026#39;Abbot\u0026#39;),(\u0026#39;2\u0026#39;,\u0026#39;Doris\u0026#39;),(\u0026#39;3\u0026#39;,\u0026#39;Emerson\u0026#39;),(\u0026#39;4\u0026#39;,\u0026#39;Green\u0026#39;),(\u0026#39;5\u0026#39;,\u0026#39;Jeames\u0026#39;);","permalink":"/collection/2021-12-22-sqldemo/","summary":"SQL 练习 SQL 练习 595. Big Countries 627. Swap Salary 620. Not Boring Movies 596. Classes More Than 5 Students 182. Duplicate Emails 196. Delete Duplicate Emails 175. Combine Two Tables 181. Employees Earning More Than Their Managers 183. Customers Who Never Order 184. Department Highest Salary 176. Second Highest Salary 177. Nth Highest Salary 178. Rank Scores 180. Consecutive Numbers 626. Exchange Seats 595. Big Countries https://leetcode.com/problems/big-countries/description/","title":"【转载】SQL 练习"},{"content":"MySQL  MySQL  一、索引  B+ Tree 原理 MySQL 索引 索引优化 索引的优点 索引的使用条件   二、查询性能优化  使用 Explain 进行分析 优化数据访问 重构查询方式   三、存储引擎  InnoDB MyISAM 比较   四、数据类型  整型 浮点数 字符串 时间和日期   五、切分  水平切分 垂直切分 Sharding 策略 Sharding 存在的问题   六、复制  主从复制 读写分离   参考资料    一、索引 B+ Tree 原理 1. 数据结构 B Tree 指的是 Balance Tree，也就是平衡树。平衡树是一颗查找树，并且所有叶子节点位于同一层。\nB+ Tree 是基于 B Tree 和叶子节点顺序访问指针进行实现，它具有 B Tree 的平衡性，并且通过顺序访问指针来提高区间查询的性能。\n在 B+ Tree 中，一个节点中的 key 从左到右非递减排列，如果某个指针的左右相邻 key 分别是 keyi 和 keyi+1，且不为 null，则该指针指向节点的所有 key 大于等于 keyi 且小于等于 keyi+1。\n\n2. 操作 进行查找操作时，首先在根节点进行二分查找，找到一个 key 所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找出 key 所对应的 data。\n插入删除操作会破坏平衡树的平衡性，因此在进行插入删除操作之后，需要对树进行分裂、合并、旋转等操作来维护平衡性。\n3. 与红黑树的比较 红黑树等平衡树也可以用来实现索引，但是文件系统及数据库系统普遍采用 B+ Tree 作为索引结构，这是因为使用 B+ 树访问磁盘数据有更高的性能。\n（一）B+ 树有更低的树高\n平衡树的树高 O(h)=O(logdN)，其中 d 为每个节点的出度。红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多。\n（二）磁盘访问原理\n操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点。\n如果数据不在同一个磁盘块上，那么通常需要移动制动手臂进行寻道，而制动手臂因为其物理结构导致了移动效率低下，从而增加磁盘数据读取时间。B+ 树相对于红黑树有更低的树高，进行寻道的次数与树高成正比，在同一个磁盘块上进行访问只需要很短的磁盘旋转时间，所以 B+ 树更适合磁盘数据的读取。\n（三）磁盘预读特性\n为了减少磁盘 I/O 操作，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的磁盘旋转时间，速度会非常快。并且可以利用预读特性，相邻的节点也能够被预先载入。\nMySQL 索引 索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。\n1. B+Tree 索引 是大多数 MySQL 存储引擎的默认索引类型。\n因为不再需要进行全表扫描，只需要对树进行搜索即可，所以查找速度快很多。\n因为 B+ Tree 的有序性，所以除了用于查找，还可以用于排序和分组。\n可以指定多个列作为索引列，多个索引列共同组成键。\n适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引。\nInnoDB 的 B+Tree 索引分为主索引和辅助索引。主索引的叶子节点 data 域记录着完整的数据记录，这种索引方式被称为聚簇索引。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。\n\n辅助索引的叶子节点的 data 域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。\n\n2. 哈希索引 哈希索引能以 O(1) 时间进行查找，但是失去了有序性：\n 无法用于排序与分组； 只支持精确查找，无法用于部分查找和范围查找。  InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。\n3. 全文索引 MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。\n查找条件使用 MATCH AGAINST，而不是普通的 WHERE。\n全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。\nInnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。\n4. 空间数据索引 MyISAM 存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。\n必须使用 GIS 相关的函数来维护数据。\n索引优化 1. 独立的列 在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。\n例如下面的查询不能使用 actor_id 列的索引：\nSELECTactor_idFROMsakila.actorWHEREactor_id+1=5;2. 多列索引 在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。例如下面的语句中，最好把 actor_id 和 film_id 设置为多列索引。\nSELECTfilm_id,actor_idFROMsakila.film_actorWHEREactor_id=1ANDfilm_id=1;3. 索引列的顺序 让选择性最强的索引列放在前面。\n索引的选择性是指：不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，每个记录的区分度越高，查询效率也越高。\n例如下面显示的结果中 customer_id 的选择性比 staff_id 更高，因此最好把 customer_id 列放在多列索引的前面。\nSELECTCOUNT(DISTINCTstaff_id)/COUNT(*)ASstaff_id_selectivity,COUNT(DISTINCTcustomer_id)/COUNT(*)AScustomer_id_selectivity,COUNT(*)FROMpayment;staff_id_selectivity: 0.0001 customer_id_selectivity: 0.0373 COUNT(*): 16049 4. 前缀索引 对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。\n前缀长度的选取需要根据索引选择性来确定。\n5. 覆盖索引 索引包含所有需要查询的字段的值。\n具有以下优点：\n 索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。 一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。 对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。  索引的优点   大大减少了服务器需要扫描的数据行数。\n  帮助服务器避免进行排序和分组，以及避免创建临时表（B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，不需要排序和分组，也就不需要创建临时表）。\n  将随机 I/O 变为顺序 I/O（B+Tree 索引是有序的，会将相邻的数据都存储在一起）。\n  索引的使用条件   对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效；\n  对于中到大型的表，索引就非常有效；\n  但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。\n  二、查询性能优化 使用 Explain 进行分析 Explain 用来分析 SELECT 查询语句，开发人员可以通过分析 Explain 结果来优化查询语句。\n比较重要的字段有：\n select_type : 查询类型，有简单查询、联合查询、子查询等 key : 使用的索引 rows : 扫描的行数  优化数据访问 1. 减少请求的数据量  只返回必要的列：最好不要使用 SELECT * 语句。 只返回必要的行：使用 LIMIT 语句来限制返回的数据。 缓存重复查询的数据：使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的。  2. 减少服务器端扫描的行数 最有效的方式是使用索引来覆盖查询。\n重构查询方式 1. 切分大查询 一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。\nDELETEFROMmessagesWHEREcreate\u0026lt;DATE_SUB(NOW(),INTERVAL3MONTH);rows_affected=0do{rows_affected=do_query(\u0026#34;DELETE FROM messages WHERE create \u0026lt; DATE_SUB(NOW(), INTERVAL 3 MONTH) LIMIT 10000\u0026#34;)}whilerows_affected\u0026gt;02. 分解大连接查询 将一个大连接查询分解成对每一个表进行一次单表查询，然后在应用程序中进行关联，这样做的好处有：\n 让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用。 分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余记录的查询。 减少锁竞争； 在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可伸缩。 查询本身效率也可能会有所提升。例如下面的例子中，使用 IN() 代替连接查询，可以让 MySQL 按照 ID 顺序进行查询，这可能比随机的连接要更高效。  SELECT*FROMtagJOINtag_postONtag_post.tag_id=tag.idJOINpostONtag_post.post_id=post.idWHEREtag.tag=\u0026#39;mysql\u0026#39;;SELECT*FROMtagWHEREtag=\u0026#39;mysql\u0026#39;;SELECT*FROMtag_postWHEREtag_id=1234;SELECT*FROMpostWHEREpost.idIN(123,456,567,9098,8904);三、存储引擎 InnoDB 是 MySQL 默认的事务型存储引擎，只有在需要它不支持的特性时，才考虑使用其它存储引擎。\n实现了四个标准的隔离级别，默认级别是可重复读（REPEATABLE READ）。在可重复读隔离级别下，通过多版本并发控制（MVCC）+ Next-Key Locking 防止幻影读。\n主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。\n内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。\n支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。\nMyISAM 设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。\n提供了大量的特性，包括压缩表、空间数据索引等。\n不支持事务。\n不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入（CONCURRENT INSERT）。\n可以手工或者自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数据丢失，而且修复操作是非常慢的。\n如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。\n比较   事务：InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句。\n  并发：MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。\n  外键：InnoDB 支持外键。\n  备份：InnoDB 支持在线热备份。\n  崩溃恢复：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。\n  其它特性：MyISAM 支持压缩表和空间数据索引。\n  四、数据类型 整型 TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT 分别使用 8, 16, 24, 32, 64 位存储空间，一般情况下越小的列越好。\nINT(11) 中的数字只是规定了交互工具显示字符的个数，对于存储和计算来说是没有意义的。\n浮点数 FLOAT 和 DOUBLE 为浮点类型，DECIMAL 为高精度小数类型。CPU 原生支持浮点运算，但是不支持 DECIMAl 类型的计算，因此 DECIMAL 的计算比浮点类型需要更高的代价。\nFLOAT、DOUBLE 和 DECIMAL 都可以指定列宽，例如 DECIMAL(18, 9) 表示总共 18 位，取 9 位存储小数部分，剩下 9 位存储整数部分。\n字符串 主要有 CHAR 和 VARCHAR 两种类型，一种是定长的，一种是变长的。\nVARCHAR 这种变长类型能够节省空间，因为只需要存储必要的内容。但是在执行 UPDATE 时可能会使行变得比原来长，当超出一个页所能容纳的大小时，就要执行额外的操作。MyISAM 会将行拆成不同的片段存储，而 InnoDB 则需要分裂页来使行放进页内。\n在进行存储和检索时，会保留 VARCHAR 末尾的空格，而会删除 CHAR 末尾的空格。\n时间和日期 MySQL 提供了两种相似的日期时间类型：DATETIME 和 TIMESTAMP。\n1. DATETIME 能够保存从 1000 年到 9999 年的日期和时间，精度为秒，使用 8 字节的存储空间。\n它与时区无关。\n默认情况下，MySQL 以一种可排序的、无歧义的格式显示 DATETIME 值，例如“2008-01-16 22:37:08”，这是 ANSI 标准定义的日期和时间表示方法。\n2. TIMESTAMP 和 UNIX 时间戳相同，保存从 1970 年 1 月 1 日午夜（格林威治时间）以来的秒数，使用 4 个字节，只能表示从 1970 年到 2038 年。\n它和时区有关，也就是说一个时间戳在不同的时区所代表的具体时间是不同的。\nMySQL 提供了 FROM_UNIXTIME() 函数把 UNIX 时间戳转换为日期，并提供了 UNIX_TIMESTAMP() 函数把日期转换为 UNIX 时间戳。\n默认情况下，如果插入时没有指定 TIMESTAMP 列的值，会将这个值设置为当前时间。\n应该尽量使用 TIMESTAMP，因为它比 DATETIME 空间效率更高。\n五、切分 水平切分 水平切分又称为 Sharding，它是将同一个表中的记录拆分到多个结构相同的表中。\n当一个表的数据不断增多时，Sharding 是必然的选择，它可以将数据分布到集群的不同节点上，从而缓存单个数据库的压力。\n\n垂直切分 垂直切分是将一张表按列切分成多个表，通常是按照列的关系密集程度进行切分，也可以利用垂直切分将经常被使用的列和不经常被使用的列切分到不同的表中。\n在数据库的层面使用垂直切分将按数据库中表的密集程度部署到不同的库中，例如将原来的电商数据库垂直切分成商品数据库、用户数据库等。\n\nSharding 策略  哈希取模：hash(key) % N； 范围：可以是 ID 范围也可以是时间范围； 映射表：使用单独的一个数据库来存储映射关系。  Sharding 存在的问题 1. 事务问题 使用分布式事务来解决，比如 XA 接口。\n2. 连接 可以将原来的连接分解成多个单表查询，然后在用户程序中进行连接。\n3. ID 唯一性  使用全局唯一 ID（GUID） 为每个分片指定一个 ID 范围 分布式 ID 生成器 (如 Twitter 的 Snowflake 算法)  六、复制 主从复制 主要涉及三个线程：binlog 线程、I/O 线程和 SQL 线程。\n binlog 线程 ：负责将主服务器上的数据更改写入二进制日志（Binary log）中。 I/O 线程 ：负责从主服务器上读取二进制日志，并写入从服务器的中继日志（Relay log）。 SQL 线程 ：负责读取中继日志，解析出主服务器已经执行的数据更改并在从服务器中重放（Replay）。  \n读写分离 主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。\n读写分离能提高性能的原因在于：\n 主从服务器负责各自的读和写，极大程度缓解了锁的争用； 从服务器可以使用 MyISAM，提升查询性能以及节约系统开销； 增加冗余，提高可用性。  读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。\n\n参考资料  BaronScbwartz, PeterZaitsev, VadimTkacbenko, 等. 高性能 MySQL[M]. 电子工业出版社, 2013. 姜承尧. MySQL 技术内幕: InnoDB 存储引擎 [M]. 机械工业出版社, 2011. 20+ 条 MySQL 性能优化的最佳经验 服务端指南 数据存储篇 | MySQL（09） 分库与分表带来的分布式困境与应对之策 How to create unique row ID in sharded databases? SQL Azure Federation – Introduction MySQL 索引背后的数据结构及算法原理 MySQL 性能优化神器 Explain 使用分析 How Sharding Works 大众点评订单系统分库分表实践 B + 树  ","permalink":"/collection/2021-12-22-mysql/","summary":"MySQL MySQL 一、索引 B+ Tree 原理 MySQL 索引 索引优化 索引的优点 索引的使用条件 二、查询性能优化 使用 Explain 进行分析 优化数据访问 重构查询方式 三、存储引擎 InnoDB MyISAM 比较 四、数据","title":"【转载】Mysql"},{"content":"数据库系统原理  数据库系统原理  一、事务  概念 ACID AUTOCOMMIT   二、并发一致性问题  丢失修改 读脏数据 不可重复读 幻影读   三、封锁  封锁粒度 封锁类型 封锁协议 MySQL 隐式与显式锁定   四、隔离级别  未提交读（READ UNCOMMITTED） 提交读（READ COMMITTED） 可重复读（REPEATABLE READ） 可串行化（SERIALIZABLE）   五、多版本并发控制  基本思想 版本号 Undo 日志 ReadView 快照读与当前读   六、Next-Key Locks  Record Locks Gap Locks Next-Key Locks   七、关系数据库设计理论  函数依赖 异常 范式   八、ER 图  实体的三种联系 表示出现多次的关系 联系的多向性 表示子类   参考资料    一、事务 概念 事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。\n\nACID 1. 原子性（Atomicity） 事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。\n回滚可以用回滚日志（Undo Log）来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。\n2. 一致性（Consistency） 数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对同一个数据的读取结果都是相同的。\n3. 隔离性（Isolation） 一个事务所做的修改在最终提交以前，对其它事务是不可见的。\n4. 持久性（Durability） 一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。\n系统发生崩溃可以用重做日志（Redo Log）进行恢复，从而实现持久性。与回滚日志记录数据的逻辑修改不同，重做日志记录的是数据页的物理修改。\n 事务的 ACID 特性概念简单，但不是很好理解，主要是因为这几个特性不是一种平级关系：\n 只有满足一致性，事务的执行结果才是正确的。 在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。 在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。 事务满足持久化是为了能应对系统崩溃的情况。  \nAUTOCOMMIT MySQL 默认采用自动提交模式。也就是说，如果不显式使用START TRANSACTION语句来开始一个事务，那么每个查询操作都会被当做一个事务并自动提交。\n二、并发一致性问题 在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。\n丢失修改 丢失修改指一个事务的更新操作被另外一个事务的更新操作替换。一般在现实生活中常会遇到，例如：T1 和 T2 两个事务都对一个数据进行修改，T1 先修改并提交生效，T2 随后修改，T2 的修改覆盖了 T1 的修改。\n\n读脏数据 读脏数据指在不同的事务下，当前事务可以读到另外事务未提交的数据。例如：T1 修改一个数据但未提交，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。\n\n不可重复读 不可重复读指在一个事务内多次读取同一数据集合。在这一事务还未结束前，另一事务也访问了该同一数据集合并做了修改，由于第二个事务的修改，第一次事务的两次读取的数据可能不一致。例如：T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。\n\n幻影读 幻读本质上也属于不可重复读的情况，T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。\n\n 产生并发不一致性问题的主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。\n三、封锁 封锁粒度 MySQL 中提供了两种封锁粒度：行级锁以及表级锁。\n应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。\n但是加锁需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此封锁粒度越小，系统开销就越大。\n在选择封锁粒度时，需要在锁开销和并发程度之间做一个权衡。\n封锁类型 1. 读写锁  互斥锁（Exclusive），简写为 X 锁，又称写锁。 共享锁（Shared），简写为 S 锁，又称读锁。  有以下两个规定：\n 一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。 一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。  锁的兼容关系如下：\n\n2. 意向锁 使用意向锁（Intention Locks）可以更容易地支持多粒度封锁。\n在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。\n意向锁在原来的 X/S 锁之上引入了 IX/IS，IX/IS 都是表锁，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。有以下两个规定：\n 一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁； 一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。  通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。\n各种锁的兼容关系如下：\n\n解释如下：\n 任意 IS/IX 锁之间都是兼容的，因为它们只表示想要对表加锁，而不是真正加锁； 这里兼容关系针对的是表级锁，而表级的 IX 锁和行级的 X 锁兼容，两个事务可以对两个数据行加 X 锁。（事务 T1 想要对数据行 R1 加 X 锁，事务 T2 想要对同一个表的数据行 R2 加 X 锁，两个事务都需要对该表加 IX 锁，但是 IX 锁是兼容的，并且 IX 锁与行级的 X 锁也是兼容的，因此两个事务都能加锁成功，对同一个表中的两个数据行做修改。）  封锁协议 1. 三级封锁协议 一级封锁协议\n事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁。\n可以解决丢失修改问题，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。\n\n二级封锁协议\n在一级的基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁。\n可以解决读脏数据问题，因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。\n\n三级封锁协议\n在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁。\n可以解决不可重复读的问题，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。\n\n2. 两段锁协议 加锁和解锁分为两个阶段进行。\n可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。串行执行的事务互不干扰，不会出现并发一致性问题。\n事务遵循两段锁协议是保证可串行化调度的充分条件。例如以下操作满足两段锁协议，它是可串行化调度。\nlock-x(A)...lock-s(B)...lock-s(C)...unlock(A)...unlock(C)...unlock(B) 但不是必要条件，例如以下操作不满足两段锁协议，但它还是可串行化调度。\nlock-x(A)...unlock(A)...lock-s(B)...unlock(B)...lock-s(C)...unlock(C) MySQL 隐式与显式锁定 MySQL 的 InnoDB 存储引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定。\nInnoDB 也可以使用特定的语句进行显示锁定：\nSELECT...LOCKInSHAREMODE;SELECT...FORUPDATE;四、隔离级别 未提交读（READ UNCOMMITTED） 事务中的修改，即使没有提交，对其它事务也是可见的。\n提交读（READ COMMITTED） 一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。\n可重复读（REPEATABLE READ） 保证在同一个事务中多次读取同一数据的结果是一样的。\n可串行化（SERIALIZABLE） 强制事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题。\n该隔离级别需要加锁实现，因为要使用加锁机制保证同一时间只有一个事务执行，也就是保证事务串行执行。\n \n五、多版本并发控制 多版本并发控制（Multi-Version Concurrency Control, MVCC）是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。而未提交读隔离级别总是读取最新的数据行，要求很低，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。\n基本思想 在封锁一节中提到，加锁能解决多个事务同时执行时出现的并发一致性问题。在实际场景中读操作往往多于写操作，因此又引入了读写锁来避免不必要的加锁操作，例如读和读没有互斥关系。读写锁中读和写操作仍然是互斥的，而 MVCC 利用了多版本的思想，写操作更新最新的版本快照，而读操作去读旧版本快照，没有互斥关系，这一点和 CopyOnWrite 类似。\n在 MVCC 中事务的修改操作（DELETE、INSERT、UPDATE）会为数据行新增一个版本快照。\n脏读和不可重复读最根本的原因是事务读取到其它事务未提交的修改。在事务进行读取操作时，为了解决脏读和不可重复读问题，MVCC 规定只能读取已经提交的快照。当然一个事务可以读取自身未提交的快照，这不算是脏读。\n版本号  系统版本号 SYS_ID：是一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。 事务版本号 TRX_ID ：事务开始时的系统版本号。  Undo 日志 MVCC 的多版本指的是多个版本的快照，快照存储在 Undo 日志中，该日志通过回滚指针 ROLL_PTR 把一个数据行的所有快照连接起来。\n例如在 MySQL 创建一个表 t，包含主键 id 和一个字段 x。我们先插入一个数据行，然后对该数据行执行两次更新操作。\nINSERTINTOt(id,x)VALUES(1,\u0026#34;a\u0026#34;);UPDATEtSETx=\u0026#34;b\u0026#34;WHEREid=1;UPDATEtSETx=\u0026#34;c\u0026#34;WHEREid=1;因为没有使用 START TRANSACTION 将上面的操作当成一个事务来执行，根据 MySQL 的 AUTOCOMMIT 机制，每个操作都会被当成一个事务来执行，所以上面的操作总共涉及到三个事务。快照中除了记录事务版本号 TRX_ID 和操作之外，还记录了一个 bit 的 DEL 字段，用于标记是否被删除。\n\nINSERT、UPDATE、DELETE 操作会创建一个日志，并将事务版本号 TRX_ID 写入。DELETE 可以看成是一个特殊的 UPDATE，还会额外将 DEL 字段设置为 1。\nReadView MVCC 维护了一个 ReadView 结构，主要包含了当前系统未提交的事务列表 TRX_IDs {TRX_ID_1, TRX_ID_2, \u0026hellip;}，还有该列表的最小值 TRX_ID_MIN 和 TRX_ID_MAX。\n\n在进行 SELECT 操作时，根据数据行快照的 TRX_ID 与 TRX_ID_MIN 和 TRX_ID_MAX 之间的关系，从而判断数据行快照是否可以使用：\n  TRX_ID \u0026lt; TRX_ID_MIN，表示该数据行快照时在当前所有未提交事务之前进行更改的，因此可以使用。\n  TRX_ID \u0026gt; TRX_ID_MAX，表示该数据行快照是在事务启动之后被更改的，因此不可使用。\n  TRX_ID_MIN \u0026lt;= TRX_ID \u0026lt;= TRX_ID_MAX，需要根据隔离级别再进行判断：\n 提交读：如果 TRX_ID 在 TRX_IDs 列表中，表示该数据行快照对应的事务还未提交，则该快照不可使用。否则表示已经提交，可以使用。 可重复读：都不可以使用。因为如果可以使用的话，那么其它事务也可以读到这个数据行快照并进行修改，那么当前事务再去读这个数据行得到的值就会发生改变，也就是出现了不可重复读问题。    在数据行快照不可使用的情况下，需要沿着 Undo Log 的回滚指针 ROLL_PTR 找到下一个快照，再进行上面的判断。\n快照读与当前读 1. 快照读 MVCC 的 SELECT 操作是快照中的数据，不需要进行加锁操作。\nSELECT*FROMtable...;2. 当前读 MVCC 其它会对数据库进行修改的操作（INSERT、UPDATE、DELETE）需要进行加锁操作，从而读取最新的数据。可以看到 MVCC 并不是完全不用加锁，而只是避免了 SELECT 的加锁操作。\nINSERT;UPDATE;DELETE;在进行 SELECT 操作时，可以强制指定进行加锁操作。以下第一个语句需要加 S 锁，第二个需要加 X 锁。\nSELECT*FROMtableWHERE?lockinsharemode;SELECT*FROMtableWHERE?forupdate;六、Next-Key Locks Next-Key Locks 是 MySQL 的 InnoDB 存储引擎的一种锁实现。\nMVCC 不能解决幻影读问题，Next-Key Locks 就是为了解决这个问题而存在的。在可重复读（REPEATABLE READ）隔离级别下，使用 MVCC + Next-Key Locks 可以解决幻读问题。\nRecord Locks 锁定一个记录上的索引，而不是记录本身。\n如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚簇索引，因此 Record Locks 依然可以使用。\nGap Locks 锁定索引之间的间隙，但是不包含索引本身。例如当一个事务执行以下语句，其它事务就不能在 t.c 中插入 15。\nSELECTcFROMtWHEREcBETWEEN10and20FORUPDATE;Next-Key Locks 它是 Record Locks 和 Gap Locks 的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙。它锁定一个前开后闭区间，例如一个索引包含以下值：10, 11, 13, and 20，那么就需要锁定以下区间：\n(-∞,10](10,11](11,13](13,20](20,+∞)七、关系数据库设计理论 函数依赖 记 A-\u0026gt;B 表示 A 函数决定 B，也可以说 B 函数依赖于 A。\n如果 {A1，A2，\u0026hellip; ，An} 是关系的一个或多个属性的集合，该集合函数决定了关系的其它所有属性并且是最小的，那么该集合就称为键码。\n对于 A-\u0026gt;B，如果能找到 A 的真子集 A\u0026rsquo;，使得 A\u0026rsquo;-\u0026gt; B，那么 A-\u0026gt;B 就是部分函数依赖，否则就是完全函数依赖。\n对于 A-\u0026gt;B，B-\u0026gt;C，则 A-\u0026gt;C 是一个传递函数依赖。\n异常 以下的学生课程关系的函数依赖为 {Sno, Cname} -\u0026gt; {Sname, Sdept, Mname, Grade}，键码为 {Sno, Cname}。也就是说，确定学生和课程之后，就能确定其它信息。\n   Sno Sname Sdept Mname Cname Grade     1 学生-1 学院-1 院长-1 课程-1 90   2 学生-2 学院-2 院长-2 课程-2 80   2 学生-2 学院-2 院长-2 课程-1 100   3 学生-3 学院-2 院长-2 课程-2 95    不符合范式的关系，会产生很多异常，主要有以下四种异常：\n 冗余数据：例如 学生-2 出现了两次。 修改异常：修改了一个记录中的信息，但是另一个记录中相同的信息却没有被修改。 删除异常：删除一个信息，那么也会丢失其它信息。例如删除了 课程-1 需要删除第一行和第三行，那么 学生-1 的信息就会丢失。 插入异常：例如想要插入一个学生的信息，如果这个学生还没选课，那么就无法插入。  范式 范式理论是为了解决以上提到四种异常。\n高级别范式的依赖于低级别的范式，1NF 是最低级别的范式。\n1. 第一范式 (1NF) 属性不可分。\n2. 第二范式 (2NF) 每个非主属性完全函数依赖于键码。\n可以通过分解来满足。\n分解前 \n   Sno Sname Sdept Mname Cname Grade     1 学生-1 学院-1 院长-1 课程-1 90   2 学生-2 学院-2 院长-2 课程-2 80   2 学生-2 学院-2 院长-2 课程-1 100   3 学生-3 学院-2 院长-2 课程-2 95    以上学生课程关系中，{Sno, Cname} 为键码，有如下函数依赖：\n Sno -\u0026gt; Sname, Sdept Sdept -\u0026gt; Mname Sno, Cname-\u0026gt; Grade  Grade 完全函数依赖于键码，它没有任何冗余数据，每个学生的每门课都有特定的成绩。\nSname, Sdept 和 Mname 都部分依赖于键码，当一个学生选修了多门课时，这些数据就会出现多次，造成大量冗余数据。\n分解后 \n关系-1\n   Sno Sname Sdept Mname     1 学生-1 学院-1 院长-1   2 学生-2 学院-2 院长-2   3 学生-3 学院-2 院长-2    有以下函数依赖：\n Sno -\u0026gt; Sname, Sdept Sdept -\u0026gt; Mname  关系-2\n   Sno Cname Grade     1 课程-1 90   2 课程-2 80   2 课程-1 100   3 课程-2 95    有以下函数依赖：\n Sno, Cname -\u0026gt; Grade  3. 第三范式 (3NF) 非主属性不传递函数依赖于键码。\n上面的 关系-1 中存在以下传递函数依赖：\n Sno -\u0026gt; Sdept -\u0026gt; Mname  可以进行以下分解：\n关系-11\n   Sno Sname Sdept     1 学生-1 学院-1   2 学生-2 学院-2   3 学生-3 学院-2    关系-12\n   Sdept Mname     学院-1 院长-1   学院-2 院长-2    八、ER 图 Entity-Relationship，有三个组成部分：实体、属性、联系。\n用来进行关系型数据库系统的概念设计。\n实体的三种联系 包含一对一，一对多，多对多三种。\n 如果 A 到 B 是一对多关系，那么画个带箭头的线段指向 B； 如果是一对一，画两个带箭头的线段； 如果是多对多，画两个不带箭头的线段。  下图的 Course 和 Student 是一对多的关系。\n\n表示出现多次的关系 一个实体在联系出现几次，就要用几条线连接。\n下图表示一个课程的先修关系，先修关系出现两个 Course 实体，第一个是先修课程，后一个是后修课程，因此需要用两条线来表示这种关系。\n\n联系的多向性 虽然老师可以开设多门课，并且可以教授多名学生，但是对于特定的学生和课程，只有一个老师教授，这就构成了一个三元联系。\n\n表示子类 用一个三角形和两条线来连接类和子类，与子类有关的属性和联系都连到子类上，而与父类和子类都有关的连到父类上。\n\n参考资料  AbrahamSilberschatz, HenryF.Korth, S.Sudarshan, 等. 数据库系统概念 [M]. 机械工业出版社, 2006. 施瓦茨. 高性能 MYSQL(第3版)[M]. 电子工业出版社, 2013. 史嘉权. 数据库系统概论[M]. 清华大学出版社有限公司, 2006. The InnoDB Storage Engine Transaction isolation levels Concurrency Control The Nightmare of Locking, Blocking and Isolation Levels! Database Normalization and Normal Forms with an Example The basics of the InnoDB undo logging and history system MySQL locking for the busy web developer 浅入浅出 MySQL 和 InnoDB Innodb 中的事务隔离级别和锁的关系  ","permalink":"/collection/2021-12-22-database/","summary":"数据库系统原理 数据库系统原理 一、事务 概念 ACID AUTOCOMMIT 二、并发一致性问题 丢失修改 读脏数据 不可重复读 幻影读 三、封锁 封锁粒度 封锁类型 封锁协议 MySQL 隐式与显式锁","title":"【转载】数据库系统原理"},{"content":" 運命を信じますか\n【相信命运吗】\nそしてそれに従いますか\n【顺从于命运吗】\n私は 私は\n【我，我】\nあなたに従います\n【顺从于你】\n白い鳥が仲良く\n【白鸟友好地】\n水をあびています\n【戏水】\n悪い人は訪ねて来ない\n【没有坏人来访的】\n名も知らぬ湖\n【不知名的湖】\n向こう岸をめがけて\n【瞄准对岸】\n石を投げたあなた\n【扔石头的你】\n波の渦が広がるように\n【就像波浪的漩涡不断在扩张一样】\n私の心も乱れます\n【我也心乱如麻】\nもしかしたらあなたに対して\n【如果对你】\n好意以上の気持を抱いてます\n【有了好感以上的感情】\nそしてそれはふたりにとっては\n【那对我们两个人】\n危険なことかも知れません\n【可能是件危险的事情】\nひとつだけ教えて下さい\n【只告诉我一件事】\n倖せになれるでしょうか\n【我能幸福吗】\n赤い薔薇が一枝\n【一枝红色的蔷薇】 水に浮いています\n【浮在水面】\n風の音もはばかるような\n【风声更加猛烈的】\n名も知らぬ湖\n【不知名的湖】\nひとり何か悩んで\n【一个人烦恼着】\nほほをぬらすあなた\n【湿润了脸颊的你】\n青い色に溶け込むように\n【溶解在这片蓝色里】\n私も一緒に泣いてます\n【我也和你一起哭泣】\nいつも私あなたのためなら\n【我总是有为了你】\nすべて投げ出す\n【抛弃所有】\n覚悟が出来てます\n【的觉悟】\nそしてそれでふたりの間が\n【所以两个人之间】\n終りを告げてもいいのです\n【就算宣告结束也可以】\nひとつだけ教えて下さい\n【只告诉我一件事】\n倖せになれるでしょうか\n【会幸福吗】\n ","permalink":"/blog/2021/12/21/%E9%9F%B3%E4%B9%90%E6%B9%96%E3%81%AE%E6%B1%BA%E5%BF%83/","summary":"運命を信じますか 【相信命运吗】 そしてそれに従いますか 【顺从于命运吗】 私は 私は 【我，我】 あなたに従います 【顺从于你】 白い鳥が仲良く 【白鸟友好地","title":"【音乐】湖の決心"},{"content":" 潮風を頬にうけ\n裸足で駆けてく\nふり向けば白い砂\nわたしの足跡\nほら飲んでごらん\n冷たい水を上げましょう\nほら空をごらん\nカモメも飛ぶわよろしくネ\nどんな淋しい時でも\nわたしは負けないわ\n潮風を頬にうけ\n裸足で駆けてく\nふり向けば白い砂\nわたしの足跡\nほら赤く燃える\n焚火かこんで話すの\nおいでわたしの膝に\nあたたかい夢見るのよ\n悲しい時こそ笑顔で\nみんなを励ますわ\nさざ波がうち寄せる\n小さな珊瑚礁\n見上げれば星空に\n明日が広がる\nどんな淋しい時でも\nわたしは負けないわ\n潮風を頬にうけ\n裸足で駆けてく\nふり向けば白い砂\nわたしの足跡\n ","permalink":"/blog/2021/12/21/%E9%9F%B3%E4%B9%90%E8%A3%B8%E8%B6%B3%E3%81%AE%E3%83%95%E3%83%AD%E3%83%BC%E3%83%8D/","summary":"潮風を頬にうけ 裸足で駆けてく ふり向けば白い砂 わたしの足跡 ほら飲んでごらん 冷たい水を上げましょう ほら空をごらん カモメも飛ぶわよろしくネ どんな淋","title":"【音乐】裸足のフローネ"},{"content":" 静かな山小屋の 朝ごはんは\n木の葉のいいにおい さやさや風よ\nホルディア\nホルディヒヒヤ ホルディクク\nホルディヒヒヤ ホルディクク\nホルディヒヒヤ ホルディクク\nホルディヒヒヤ ホー\n空にはちぎれ雲 スプーンでどうぞ\nバナナものせましょう アイスクリーム\nホルディア\nホルディヒヒヤ ホルディクク\nホルディヒヒヤ ホルディクク\nホルディヒヒヤ ホルディクク\nホルディヒヒヤ ホー\nはるかな山々は 真っ赤に染まる\n谷間に白い霧 ミルクのようだ\nホルディア\nホルディヒヒヤ ホルディクク\nホルディヒヒヤ ホルディクク\nホルディヒヒヤ ホルディクク\nホルディヒヒヤ ホー\n夜です山小屋の 一番のごちそう\nパチパチ燃える火と みんなの歌よ\nホルディア\nホルディヒヒヤ ホルディクク\nホルディヒヒヤ ホルディクク\nホルディヒヒヤ ホルディクク\nホルディヒヒヤ ホー\n  在寂静的山间小屋里 有树叶的芳香，有风儿的沙沙声 度假 度假 嘿嘿呀 度假 库库 度假 嘿嘿呀 度假 库库\n度假 嘿嘿呀 度假 库库\n度假 嘿嘿呀 嚎\n款待天空的是用云做的佳肴，请用勺子品尝吧\n再摆上香蕉和冰淇淋\n度假\n度假 嘿嘿呀 度假 库库\n度假 嘿嘿呀 度假 库库\n度假 嘿嘿呀 度假 库库\n度假 嘿嘿呀 嚎\n将遥远的山峰，染成红色\n山间白色的雾像牛奶一样\n度假\n度假 嘿嘿呀 度假 库库\n度假 嘿嘿呀 度假 库库\n度假 嘿嘿呀 度假 库库\n度假 嘿嘿呀 嚎\n山间小屋的晚餐最丰富\n围着噼噼啪啪的火，大家尽情的歌唱\n度假\n度假 嘿嘿呀 度假 库库\n度假 嘿嘿呀 度假 库库\n度假 嘿嘿呀 度假 库库\n度假 嘿嘿呀 嚎\n ","permalink":"/blog/2021/12/21/%E9%9F%B3%E4%B9%90%E5%B1%B1%E3%81%AE%E3%81%94%E3%81%A1%E3%81%9D%E3%81%86/","summary":"静かな山小屋の 朝ごはんは 木の葉のいいにおい さやさや風よ ホルディア ホルディヒヒヤ ホルディクク ホルディヒヒヤ ホルディクク ホルディヒヒヤ ホルディク","title":"【音乐】山のごちそう"},{"content":" ドはドーナツのド\nレはレモンのレ\nミはみんなのミ\nファはファイトのファ\nソは青い空\nラはラッパのラ\nシは幸せよ\nさあ歌いましょう\nランランラン\nドはドーナツのド\nレはレモンのレ\nミはみんなのミ\nファはファイトのファ\nソは青い空 ラはラッパのラ\nシは幸せよ\nさあ歌いましょう\nドレミファソラシド\nドシラソファミレ\nドミミミソソ\nレファファラシシ\nドミミミソソ\nレファファラシシ……\nソドラファミドレ\nソドラシドレド\nどんなときにも\n列を組んで\nみんな楽しく\nファイトを持って\n空を仰いで\nランララララララー\n幸せの歌\nさあ歌いましょう ドレミファソラシドソド\n  do是甜甜圈的do\nle是柠檬的le\nmi是大家的mi\nfa是战斗的fa\nso是蔚蓝的天空\nla是喇叭的la\nxi是幸福的xi\n那么，大家一起来唱吧\n啷啷啷\ndo是甜甜圈的do\nle是柠檬的le\nmi是大家的mi\nfa是战斗的fa\nso是蔚蓝的天空\nla是喇叭的la\nxi是幸福的xi\n那么大家一起来唱吧\ndo re mi fa so la xi do\ndo xi la fa mi le\ndo mi mi mi so so\nle fa fa la xi xi\ndo mi mi mi so so\nle fa fa la xi xi\nso do la fa mi do le\nso do la si do le do\n无论何时\n都要组成一列\n大家带着\n喜悦和热情\n仰望蓝天\n啦啦啦啦啦啦啦\n让我们一起唱\n幸福之歌吧\ndo le mi fa so lo xi do so do\n 邓丽君这个视频也值得一看！\n .aspect-ratio { position: relative; width: 100%; height: 0; padding-bottom: 75%; } .aspect-ratio iframe { position: absolute; width: 100%; height: 100%; left: 0; top: 0; }    ","permalink":"/blog/2021/12/21/%E9%9F%B3%E4%B9%90%E3%83%89%E3%83%AC%E3%83%9F%E3%81%AE%E6%AD%8C/","summary":"ドはドーナツのド レはレモンのレ ミはみんなのミ ファはファイトのファ ソは青い空 ラはラッパのラ シは幸せよ さあ歌いましょう ランランラン ドはドーナツの","title":"【音乐】ドレミの歌"},{"content":" あなたから苦しみを奪えたその時\n私にも生きてゆく勇気が湧いてくる\nあなたと出会うまでは孤独なさすらい人\nその手のぬくもりを 感じさせて\n愛はいつもララバイ\n旅に疲れた時\nただ心の友と\n私を呼んで\n信じあう心さえどこかに忘れて\n人は何故 過ぎた日の幸せ追いかける\n静かにまぶた閉じて心のドアを開き\n私をつかんだら 涙ふいて\n愛はいつもララバイ\nあなたが弱い時\nただ心の友と\n私を呼んで\n愛はいつもララバイ\n旅に疲れた時\nただ心の友と\n私を呼んで\n  当你的痛苦消失不见时\n我也满怀生存的勇气\n在未遇见你之前一直都是孤单一人\n让我感受双手的温馨\n爱如同催眠曲\n当旅途劳顿时\n只有交心的朋友\n对我呼喊着\n相契的心已忘记身在何处\n人们为何 总是缅怀旧日时光\n静静地闭上眼睛打开心扉\n我所能拥有的 只有泪水\n爱如同催眠曲\n当你虚弱无依时\n只有交心的朋友\n对我呼喊着\n爱如同催眠曲\n当旅途劳顿时\n只有交心的朋友\n对我呼喊着\n ","permalink":"/blog/2021/12/20/%E9%9F%B3%E4%B9%90%E5%BF%83%E3%81%AE%E5%8F%8B/","summary":"あなたから苦しみを奪えたその時 私にも生きてゆく勇気が湧いてくる あなたと出会うまでは孤独なさすらい人 その手のぬくもりを 感じさせて 愛はいつもララ","title":"【音乐】心の友"},{"content":" Dream…\n金色の星屑(ほし)を集め\n君のイニシャル　落書き\nDream…\n悲しみに負けちゃダメよ\n銀の鏡に呪文をかけたの\n夜空にまわしたオルゴール\n夢の中まで\n君を追いかけてあげる\nその手で瞳を抱きしめて\n私　いつだって\nあなたの愛になりたい\nDream…\n眠れないこんな夜は\n月にしずくの　ベランダ\nDream…\n君と　そう　はしゃいだ日は\nパジャマの胸が　まだふるえてるの\n夜空にボートを作るから\n夢の波間で\nも一度踊り出そうよ\n心に魔法をかけて　今\n私　いつだって\nそばにいるのよ\n夜空にまわしたオルゴール\n夢の中まで\n君を追いかけてあげる\nその手で瞳を抱きしめて\n私　いつだって\nあなたの愛になりたい\n  Dream\u0026hellip;\n收集金色的繁星\n胡乱写着你的姓名\nDream\u0026hellip;\n不能输给悲伤哦\n施展银镜的咒语\n夜空中余音袅袅的八音盒\n沁入梦乡\n在不断地追寻着你\n用那双手夺下你的视线\n我总有一天 成为你的所爱\nDream\u0026hellip;\n无眠之夜\n阳台洒着点点月光\u0026hellip;\nDream\u0026hellip;\n你过着多么幸福的日子\n胸口的睡衣仍在颤抖着\n制作一艘游于夜空的小船\n在梦的低潮再一次舞动起来吧\n如今在心中施展起魔法\n我总有一天\n会陪伴在你身旁\n夜空中余音袅袅的八音盒\n沁入梦乡\n在不断追寻着你\n用双手夺下你的视线\n我总有一天\n成为你的所爱\n ","permalink":"/blog/2021/12/20/%E9%9F%B3%E4%B9%90%E6%84%9B%E3%81%AB%E3%81%AA%E3%82%8A%E3%81%9F%E3%81%84/","summary":"Dream… 金色の星屑(ほし)を集め 君のイニシャル 落書き Dream… 悲しみに負けちゃダメよ 銀の鏡に呪文をかけたの 夜空にまわしたオルゴール 夢の","title":"【音乐】愛になりたい"},{"content":"今天很高兴，我认为这是值得纪念的一天，遂记于此。\n首先今天是我二哥结婚，我哥是一个非常努力的人，现在和心爱之人开始相伴终生，我也很开心。这也意味着我们家添加了一位新成员，并且还将会诞生新的成员，我想这方面我爸妈是最高兴的，毕竟二十多年啦～今天还喝了很多酒（我不喜欢酒，但想喝，高兴的是喝了这些，我还感觉脑子很清醒）。今天交了新朋友，高兴～\n","permalink":"/blog/2021/12/19/2021-12-19-%E6%97%A5%E8%AE%B0/","summary":"今天很高兴，我认为这是值得纪念的一天，遂记于此。 首先今天是我二哥结婚，我哥是一个非常努力的人，现在和心爱之人开始相伴终生，我也很开心。这也意","title":"2021 12 19 日记"},{"content":" 从小时候就开始数了。\n数到懂事、数到成熟,\n还没有数清。\n天上的星星为什么数不清呢？\n像记忆和幻想，\n永远背负着固执的谜……\n  不要失望，\n失望会使我们衰老，\n趁我们还年轻，\n抬起头来，让我们数星星；\n也许，我们能数得清；\n也许，我们能看到真相；\n也许，我们能找到希望……\n ","permalink":"/blog/2021/12/17/%E5%A4%B1%E6%9C%9B%E5%92%8C%E5%B8%8C%E6%9C%9B/","summary":"从小时候就开始数了。 数到懂事、数到成熟, 还没有数清。 天上的星星为什么数不清呢？ 像记忆和幻想， 永远背负着固执的谜…… 不要失望， 失望会使我们衰老","title":"《失望和希望》"},{"content":"线性表是一种最基本、最简单的数据结构，数据元素之间仅具有单一的前驱和后继关系。\n一、线性表的逻辑结构 定义：线性表简称表，是 n(n\u0026gt;=0) 个具有相同类型的数据元素的有限序列。\n二、线性表的顺序存储结构——顺序表 顺序表是用一段地址连续的存储单元依次存储线性表的元素。通常使用数组实现。\n用数组存储顺序表，意味着要分配固定长度的数组空间，因此，必须确定数组的长度。\n顺序表中数据元素的地址是其序号的线性函数，只要确定了存储顺序表的起始地址（即基地址），计算任意一个元素的存储地址的时间是相等的，具有这一特点的存储结构称为随机存储结构。\n顺序表具有以下缺点：\n 插入和删除操作需要移动大量元素。在顺序表上做插入和删除操作，等概率情况下，平均要移动表中一半的元素。 表的容量难以确定。由于数组的长度必须事先确定，因为此，当线性表的长度变化较大时，难以确定合适的存储规模。 造成存储空间的“碎片”。数组要求占用连续的存储空间，即使存储单元数超过所需的数目，如果不连续也不能使用，造成存储空间的“碎片”现象。  造成上述顺序表的缺点的根本原因是静态存储分配，为了克服顺序表的缺点，可以采用动态存储分配连存储线性表，也就是采用链接存储结构。\n三、线性表的链接存储结构及实现 单链表 单链表是用一组任意的存储单元存放线性表的元素，这组存储单元可以连续也可以不连续，甚至可以零散分布在内存中的任意位置。每个存储单元在存储数据元素的同时，还必须存储其后继元素所在的地址信息，这个地址信息称为指针。这两部分组成数据元素的存储映射，称为节点。\n单链表只有一个指针域（next）。\n头节点：无论单链表是否为空，头指针始终指向头节点，因此空表和非空表的处理统一了。\n循环链表 在单链表中，如果将终端节点的指针域由空指针改为指向头节点，形成一个环，这种头尾相接的单链表称为循环链表。\n从循环链表中任一节点出发，可以扫描到其他节点，增加了链表操作的灵活性。\n但由于循环链表没有明显的尾端，要格外注意循环条件。通常判断用作循环变量的工作指针是否等于头一个制定指针（头指针或尾指针）。\n双链表 如果希望快速确定表中任一节点的前驱节点，可以在单链表的每个节点中再设置一个指向其前驱节点的指针域，这样就形成了双链表。\n顺序表和链表的比较 时间性能比较 按位置随机访问某个元素，顺序表更快一些，时间性能为 O(1)；相比之下链表需要从头开始遍历扫描，所需要的平均时间为 O(n)。\n在链表进行插入和删除操作不需要移动元素，在给出指向某个位置的指针后，进行插入和删除操作所需的时间仅为 O(1)；在顺序表中进行插入和删除操作需要移动表长一半的元素，平均时间为 O(n)。\n一般规律，如果线性表需要频繁查找却很少进行插入和删除，或其操作和“数据元素在线性表中的位置密切相关时，宜采用顺序表作为存储结构；如果线性表需要频繁进行插入和删除操作，则宜采用链表作为存储结构。\n空间性能比较 作为一般规律，当线性表中元素个数变化较大或未知时，最好采用链表实现；如果事先知道线性表的大致长度，采用顺序表的空间效率会更高。\n","permalink":"/post/2021/12/16/linearlist/","summary":"线性表是一种最基本、最简单的数据结构，数据元素之间仅具有单一的前驱和后继关系。 一、线性表的逻辑结构 定义：线性表简称表，是 n(n\u0026gt;=0) 个具有相同类型的数","title":"线性表"},{"content":"一、语法基础  指针和引用的概念 指针与内存关系 程序编译过程 static、const、#define的用法和区别 C和C++区别 内存模型 内存中的栈和堆分配  二、面对对象基础   面向对象理解\n  析构函数\n  构造函数\n  拷贝构造\n  多态\n  纯虚函数和虚函数\n  虚函数实现机制\n  虚函数表\n  访问限定符 public、private、protected\n  继承原理、虚继承、菱形继承\n  静态绑定和动态绑定\n  new/delete和malloc/free\n  重载、重写和隐藏\n  三、语法进阶  智能指针 左值、右值引用和move语义 类型转换方式 常用的设计模式 线程安全的单例模式 内存溢出和内存泄漏 C++11新特性 静态链接库和动态链接库  四、STL 标准模板库  迭代器、空间配置器理解 常用容器特点、用法以及底层实现vector、list、deque、set、map、unorderedmap  ","permalink":"/post/2021/12/15/cppbase/","summary":"一、语法基础 指针和引用的概念 指针与内存关系 程序编译过程 static、const、#define的用法和区别 C和C++区别 内存模型 内存中的栈和","title":"C++ 基础总结"},{"content":"绘制系统 Qt 的绘制系统可以使用相同的 API 在屏幕和打印设备上进行绘制，并且主要基于 QPainter 、 QPaintDevice 和 QPaintEngine 类。\nQPainter 用于执行绘图操作， QPaintDevice 是二维空间的抽象，可以使用 进行绘制 QPainter ， QPaintEngine 提供了画家用来绘制不同类型设备的接口。 该 QPaintEngine 类是由在内部使用 了QPainter 和 的QPaintDevice ，除非他们创建自己的设备的种类从应用程序员隐藏。\n这种方法的主要好处是所有绘制都遵循相同的绘制管道，从而可以轻松添加对新功能的支持并为不受支持的功能提供默认实现。\n一、绘图示例 通常在 QWidget, QPixmap, QPixture, QPrinter 上面绘图。\n示例1 直接绘制： MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent) { QLabel *label = new QLabel(this); label-\u0026gt;resize(100, 100); QPixmap pixmap(100, 100); pixmap.fill(Qt::gray); QPainter painter(\u0026amp;pixmap); painter.drawRect(10, 10, 80, 80); painter.drawText(20, 30, \u0026#34;Hello World\u0026#34;); label-\u0026gt;setPixmap(pixmap); QVBoxLayout *layout = new QVBoxLayout(); layout-\u0026gt;addWidget(label); this-\u0026gt;setLayout(layout); this-\u0026gt;resize(200, 200); } 运行结果：\n示例2 paintEvent(QPaintEvent *) 函数中绘制： void MainWindow::paintEvent(QPaintEvent *) { QPainter painter(this); painter.setPen(Qt::gray); painter.setBrush(Qt::green); painter.drawRect(10, 10, 50, 50); } 运行结果：\n二、坐标系 坐标系由 QPainter 类控制。绘图设备的默认坐标系的原点位于左上角。 该 X 值增加向右和 Y 值向下增加。 默认单位在基于像素的设备上是一个像素，在打印机上是一个点（1/72 英寸）。注意：原点在 Widget 的左上角而不是正中心，并且每个 Widget 都有自己独立的坐标系。\nQPainter 的逻辑坐标到物理 QPaintDevice 坐标的映射由 QPainter 的转换矩阵、视口和“窗口”处理。 默认情况下，逻辑坐标系和物理坐标系是一致的。 QPainter 还支持坐标变换（例如旋转和缩放）。\n渲染 逻辑表示 图形基元的大小（宽度和高度）始终与其数学模型相对应，忽略绘制它的笔的宽度：\nWindow-Viewport 转换 使用 Window-Viewport 转换，您可以使逻辑坐标系适合您的偏好。 该机制还可用于使绘图代码独立于绘图设备。 例如，您可以通过调用 ，使逻辑坐标从 (-50, -50) 扩展到 (50, 50)，以 (0, 0) 为中心 QPainter::setWindow () 函数 ：\nQPainter painter(this); painter.setWindow(QRect(-50, -50, 100, 100)); 现在，逻辑坐标 (-50,-50) 对应于绘制设备的物理坐标 (0, 0)。 独立于绘画设备，您的绘画代码将始终在指定的逻辑坐标上运行。\n三、常用函数 下图来自《C++ GUI Programming with Qt 4》，列出了 QPainter 常用的画图方法。\n线 - drawLine() 多线段 - drawLines() 折线 - drawPolyline() 多边形 - drawPolygon() 矩形 - drawRect() 圆角矩形 - drawRoundRect() \u0026amp; drawRoundedRect() 圆、椭圆 - drawEllipse() 弧、弦、饼图 - drawArc()、drawChord()、drawPie() 绘制 QPixmap - drawPixmap() 绘制 QImage - drawImage() ","permalink":"/collection/paintsystem/","summary":"绘制系统 Qt 的绘制系统可以使用相同的 API 在屏幕和打印设备上进行绘制，并且主要基于 QPainter 、 QPaintDevice 和 QPaintEngine 类。 QPainter 用于执行绘图操作， QPaintDevice 是二维空间的抽象，可以使用 进","title":"【转载】Qt6 绘制基础"},{"content":"对象模型 标准的 C++ 对象模型为对象范例提供了非常有效的运行时支持。 但是它的静态特性在某些问题领域是不灵活的。 图形用户界面编程是一个需要运行时效率和高度灵活性的领域。 Qt 通过将 C++ 的速度与 Qt 对象模型的灵活性相结合来提供这一点。\nQt 将这些特性添加到 C++ 中：\n 一种非常强大的无缝对象通信机制，称为 信号和槽 可查询和可设计的 对象属性 强大的 事件和事件过滤器 上下文 用于国际化的 字符串翻译 复杂的间隔驱动 计时器 ，可以在事件驱动的 GUI 中优雅地集成许多任务 分层和可查询 对象树 以自然方式组织对象所有权的 受保护的指针 ( QPointer ) 在引用的对象被销毁时自动设置为 0，这与普通的 C++ 指针不同，后者在对象被销毁时变成悬空指针 动态转换 跨库边界 。 支持 自定义类型 创建。\n 许多 Qt 功能是使用标准 C++ 技术实现的，基于 继承 QObject 的 。 其他的，比如对象通信机制和动态属性系统，需要 的 元对象系统 Qt自己的 提供 元对象编译器（moc） 。\n元对象系统是一个 C++ 扩展，使该语言更适合真正的组件 GUI 编程。\n重要类 这些类构成了 Qt 对象模型的基础。\nQt 对象：身份与价值 上面为 Qt 对象模型列出的一些附加功能要求我们将 Qt 对象视为身份，而不是值。 值被复制或分配； 身份被克隆。 克隆意味着创建一个新身份，而不是旧身份的精确副本。 例如，双胞胎有不同的身份。 它们可能看起来相同，但名称不同，位置不同，并且可能拥有完全不同的社交网络。\n那么克隆身份是比复制或分配值更复杂的操作。 我们可以在 Qt 对象模型中看到这意味着什么。\n一个 Qt 对象\u0026hellip;\n 可能有一个唯一的 QObject::objectName ()。 如果我们复制一个 Qt 对象，我们应该给副本起什么名字？ 在 有一个位置 对象层次结构中 。 如果我们复制一个 Qt 对象，该副本应该位于何处？ 可以连接到其他 Qt 对象以向它们发出信号或接收它们发出的信号。 如果我们复制一个 Qt 对象，我们应该如何将这些连接转移到副本？ 可以 新属性 在运行时向其添加未在 C++ 类中声明的 。 如果我们复制一个 Qt 对象，该副本是否应该包括添加到原始对象的属性？\n 由于这些原因，Qt 对象应该被视为身份，而不是值。 身份是克隆的，而不是复制或分配的，克隆身份是比复制或分配值更复杂的操作。 因此， QObject的 和所有子类 的QObject （直接或间接）有自己的 拷贝构造函数和赋值操作符 禁用。\n","permalink":"/collection/object/","summary":"对象模型 标准的 C++ 对象模型为对象范例提供了非常有效的运行时支持。 但是它的静态特性在某些问题领域是不灵活的。 图形用户界面编程是一个需要运行时效率","title":"【转载】Qt6 对象模型"},{"content":"Qt 包含一组丰富的基础使能器，主要来自 Qt Core 模块。 Qt 使用这些促成因素来提供更高级别的 UI 和应用程序开发组件。 以下主题解释了最重要的促成因素，并展示了如何使用它们来实现 Qt 尚未提供的专门功能。\n对象、属性和事件 该 QObject的 类构成Qt的对象模型的基础，是父类的许多Qt类的。 对象模型引入了许多机制，例如元对象系统，它允许运行时内省、操作和调用对象中的属性和方法。 它还作为 Qt 事件系统的基础，这是一种在 之间进行通信的低级方式 QObject 基于 的对象 。 Qt 的信号和槽机制提供了另一种高级通信形式。\n另外， QObject 通过 提供了一个简单的计时机制 QObject::startTimer () 。 或者， QTimer 类为计时器提供高级接口。\n 对象模型\n元对象系统\n物业系统\n事件系统\n信号和插槽\n—— 基于字符串和基于函子的连接之间的差异\n计时器\n 容器类 容器 是一种数据结构，其实例是其他对象的集合。 容器的一些示例是：动态数组、队列、链表和关联数组。 Qt 提供了一组通用的、基于模板的容器类，用于在内存中构造数据。\n有关 请参阅 的完整列表 容器类 更多详细信息， 。\n国际化 Qt 使用 Unicode 来编码可显示的文本字符串。 Unicode 为世界上所有常用的书写系统提供支持，是跨平台开发的理想选择。 还可以使用 Qt 强大的国际化系统编写应用程序，以通过一个代码库支持任意数量的不同语言。\n Qt 中的 Unicode Qt 国际化\n 进程间通信 Qt 提供了几个类来支持进程之间的通信。 您还可以使用 启动和管理外部进程 QProcess 类 。\n Qt中的进程间通信\n 线程 Qt 提供了以安全且独立于平台的方式管理线程和并行代码的功能。\n 线程基础 Qt 中的线程支持\n 平台支持 Qt 允许您编写独立于平台的代码，其中相同的代码库可以在不同平台上编译和部署，而无需任何更改。 如果您需要使用特定于平台的功能并与系统库集成，Qt 也为此提供了解决方案。\nQt 使用 Qt Platform Abstraction (QPA) 与目标平台上的窗口系统集成。 QPA 是窗口系统的抽象，它使得将 Qt 移植到新平台变得简单快捷。 其中一种系统是 Wayland 协议。 Qt 可以与 Wayland 一起用作嵌入式硬件上的轻量级窗口系统，以支持多进程图形用户界面。\nQt 平台抽象使用 Qt 的插件系统。 该插件系统提供 API 以在特定领域扩展 Qt（例如添加对新图像格式、数据库驱动程序等的支持）以及编写您自己的支持第三方插件的可扩展 Qt 应用程序。\n Qt平台抽象 实现原子操作 - 用于新架构 如何创建 Qt 插件 Endian Conversion Functions - 用于处理来自 QtEndian 头文件的字节序的函数\n ","permalink":"/collection/qt-core/","summary":"Qt 包含一组丰富的基础使能器，主要来自 Qt Core 模块。 Qt 使用这些促成因素来提供更高级别的 UI 和应用程序开发组件。 以下主题解释了最重要的促成因素，并展示","title":"【转载】Qt 6 核心内部结构"},{"content":"概述 在本文档中，我们采用自定义类型并描述如何将其集成到 Qt 的对象模型中，以便可以像标准 Qt 类型一样存储它。 然后我们展示如何注册自定义类型以允许它在信号和插槽连接中使用。\n创建自定义类型 在开始之前，我们需要确保我们正在创建的自定义类型满足 QMetaType 强加的所有要求。换言之，它必须提供：\n 公共默认构造函数 公共复制构造函数\n公共析构函数\n 下列 Message类定义包括以下成员：\nclass Message { public: Message() = default; ~Message() = default; Message(const Message \u0026amp;) = default; Message \u0026amp;operator=(const Message \u0026amp;) = default; Message(const QString \u0026amp;body, const QStringList \u0026amp;headers); QStringView body() const; QStringList headers() const; private: QString m_body; QStringList m_headers; }; 该类还提供了一个正常使用的构造函数和两个用于获取私有数据的公共成员函数。\n使用 QMetaType 声明类型 这 Message类只需要一个合适的实现即可使用。 但是，如果没有一些帮助，Qt 的类型系统将无法理解如何存储、检索和序列化此类的实例。 例如，我们将无法存储 Message值 QVariant 中的 。\nQt 中负责自定义类型的类是 QMetaType 。 为了让这个类知道类型，我们在定义它的头文件中的类上 添加 Q_DECLARE_METATYPE() 宏：\nQ_DECLARE_METATYPE(Message); 这使得现在有可能 Message要存储在 QVariant 对象中并稍后检索的值。 有关 请参阅 自定义类型示例 演示此内容的代码， 。\n所述 Q_DECLARE_METATYPE （）宏还使得可以对这些值用作到信号，但是参数 只在直接信号槽连接 。 为了使自定义类型通常可用于信号和插槽机制，我们需要执行一些额外的工作。\n创建和销毁自定义对象 尽管上一节中的声明使该类型可用于直接信号槽连接，但它不能用于排队的信号槽连接，例如在不同线程中的对象之间建立的连接。 这是因为元对象系统不知道如何在运行时处理自定义类型对象的创建和销毁。\n要在运行时创建对象，请调用 qRegisterMetaType () 模板函数将其注册到元对象系统。 这也使得该类型可用于排队的信号槽通信，只要您在使用该类型的第一个连接之前调用它。\nint main(int argc, char *argv[]) { QApplication app(argc, argv); ... qRegisterMetaType\u0026lt;Block\u0026gt;(); ... return app.exec(); } 这种类型后来用于信号槽连接中 window.cpp文件：\nWindow::Window(QWidget *parent) : QWidget(parent), thread(new RenderThread(this)) { ... connect(thread, \u0026amp;RenderThread::sendBlock, this, \u0026amp;Window::addBlock); ... setWindowTitle(tr(\u0026#34;Queued Custom Type\u0026#34;)); } 如果一个类型在没有注册的情况下在排队连接中使用，控制台会打印警告； 例如：\nQObject::connect: Cannot queue arguments of type \u0026#39;Block\u0026#39; (Make sure \u0026#39;Block\u0026#39; is registered using qRegisterMetaType().) 使类型可打印 为调试目的使自定义类型可打印通常非常有用，如下面的代码所示：\n Message message(body, headers); qDebug() \u0026lt;\u0026lt; \u0026#34;Original:\u0026#34; \u0026lt;\u0026lt; message; 这是通过为该类型创建一个流操作符来实现的，该操作符通常在该类型的头文件中定义：\nQDebug operator\u0026lt;\u0026lt;(QDebug dbg, const Message \u0026amp;message); 实现：\nQDebug operator\u0026lt;\u0026lt;(QDebug dbg, const Message \u0026amp;message) { QList\u0026lt;QStringView\u0026gt; pieces = message.body().split(u\u0026#34;\\r\\n\u0026#34;, Qt::SkipEmptyParts); if (pieces.isEmpty()) dbg.nospace() \u0026lt;\u0026lt; \u0026#34;Message()\u0026#34;; else if (pieces.size() == 1) dbg.nospace() \u0026lt;\u0026lt; \u0026#34;Message(\u0026#34; \u0026lt;\u0026lt; pieces.first() \u0026lt;\u0026lt; \u0026#34;)\u0026#34;; else dbg.nospace() \u0026lt;\u0026lt; \u0026#34;Message(\u0026#34; \u0026lt;\u0026lt; pieces.first() \u0026lt;\u0026lt; \u0026#34; ...)\u0026#34;; return dbg.maybeSpace(); } 当然，发送到调试流的输出可以根据您的喜好变得简单或复杂。 请注意，此函数返回的值是 QDebug 对象本身，尽管这通常是通过调用 获得的，该 QDebug 的 maySpace () 成员函数 函数 填充 用空格字符 流以使其更具可读性。\n","permalink":"/collection/qvariant/","summary":"概述 在本文档中，我们采用自定义类型并描述如何将其集成到 Qt 的对象模型中，以便可以像标准 Qt 类型一样存储它。 然后我们展示如何注册自定义类型以允许它","title":"【转载】Qt6 Qvariant 与自定义 Qt 类型"},{"content":" 佛：沙加\n佛：沙加啊\n佛：有什么事让你如此悲伤\n佛：只有六岁的你\n佛：为什么每天都这么坐着\n佛：有什么事情让你如此忧心忡忡\n  沙加：今天\n沙加：我又看到冈底斯河中浮着好几具尸体\n沙加：在河岸上有好多来自印度各地的巡礼者在那里沐浴\n沙加：看他们的样子\n沙加：与其说是求生 还不如说是希望求死一样\n沙加：我所降生的这个国家\n沙加：为什么会这么贫穷呢\n沙加：难道人们是为了受苦受难而来到这个世上的吗\n  佛：沙加\n佛：这就是你悲伤的原因吗\n  沙加：当然了\n沙加：谁会希望一个只有痛苦的人生呢\n  佛：那是不对的\n佛：因为有痛苦\n佛：所以快乐也一定会相应存在\n佛：反过来也是一样的\n佛：美丽的花开了\n佛：可它也总有一天会凋谢\n佛：在这个世界上\n佛：生命是一瞬也不会停止的\n佛：它一直在动着 变着\n佛：这就是无常\n佛：人的一生也是这样的\n  沙加：但是\n沙加：最后还是只有一死……\n沙加：这难道不可以说人生还是被悲伤所支配着吗\n沙加：活着的时候\n沙加：无论是克服痛苦 还是追求爱 追求喜悦\n沙加：最后死亡还是把一切都化为虚无 沙加：那么人是为了什么而生的呢\n沙加：人想要去和死亡这种永恒的东西对抗\n沙加：根本就是不可能的啊\n  佛：沙加\n佛：你忘记了\n  沙加：忘记了？\n  佛：死并不是一切的终结\n佛：死不过是万物变化的一种……\n ","permalink":"/blog/2021/12/12/%E5%9C%A3%E6%96%97%E5%A3%AB%E6%98%9F%E7%9F%A2%E5%86%A5%E7%8E%8B%E5%93%88%E8%BF%AA%E6%96%AF%E5%8D%81%E4%BA%8C%E5%AE%AB%E7%AF%87/","summary":"佛：沙加 佛：沙加啊 佛：有什么事让你如此悲伤 佛：只有六岁的你 佛：为什么每天都这么坐着 佛：有什么事情让你如此忧心忡忡 沙加：今天 沙加：我又看到冈底","title":"《圣斗士星矢——冥王哈迪斯十二宫篇》"},{"content":"一  耶拉：我觉得我好像做了不该做的事情耶\n  玛莉亚：守规矩当然是很重要的事情\n玛莉亚：但是为了交我这个举世无双的朋友\n玛莉亚：而不守规矩的话\n玛莉亚：是不会被上帝责骂的\n  耶拉：为什么跟你交朋友必须爬到高塔上面才行呢……\n  玛莉亚：来吧\n  玛莉亚：啊，好棒哦\n玛莉亚：耶拉\n玛莉亚：你看过阿尔卑斯山的夕阳吗\n  耶拉：我连阿尔卑斯山都没有去过呢\n耶拉：因为我家里面很穷 所以都忙着帮忙家务\n耶拉：我想只有有钱人……\n  玛莉亚：才不呢 因为我父母双亡\n玛莉亚：我是靠着奖学金到师范学校念书才刚刚毕业而已\n玛莉亚：为了庆祝顺利毕业\n玛莉亚：我和宿舍室友到阿尔卑斯山去露营\n玛莉亚：就在那时候\n玛莉亚：我突然决定要当修女\n玛莉亚：所以就马上到这里来了\n  “我到底能做什么呢 “\n“要做什么才好呢 “\n  玛莉亚：我心里的话 玛莉亚：你是第一个知道的喔\n  耶拉：谢谢你 玛利亚\n  桃乐丝修道长：你们两个赶快下来\n  玛莉亚：啊\n  桃乐丝修道长：玛莉亚\n桃乐丝修道长：你非要我随时在你身旁管教你不可吗\n  玛莉亚：对不起 修道长\n 二  玛莉亚：早上好 修道长\n  桃乐丝修道长：从现在到中午为止不准跟任何人说话\n  玛莉亚：是\n  桃乐丝修道长：早上的晨祷 一个半小时\n  桃乐丝修道长：用餐时间必须保持肃静\n  桃乐丝修道长：不可以吹口哨！\n桃乐丝修道长：也不可以吹赞美歌！\n  桃乐丝修道长：不可以帮别人做事\n  桃乐丝修道长：玛莉亚\n桃乐丝修道长：一步一阶你懂不懂啊\n  玛莉亚：可是 修道长 这样比较……\n  桃乐丝修道长：不可以顶嘴 玛莉亚\n  玛莉亚：对不起 修道长\n 三  玛莉亚：如果能在森林里散步 那该多好啊\n玛莉亚：爬山也不错\n  桃乐丝修道长：玛莉亚 玛莉亚 玛莉亚\n  玛莉亚：是\n玛莉亚：对不起 修道长\n玛莉亚：我不应该爬到屋顶上面吹口哨的\n  桃乐丝修道长：玛莉亚\n桃乐丝修道长：事实上你不应该留在这里\n桃乐丝修道长：因为这里的生活\n桃乐丝修道长：对你来说太辛苦了一些\n  玛莉亚：不会 修道长\n玛莉亚：我在这里的生活一点都不觉得辛苦\n  桃乐丝修道长：玛莉亚\n桃乐丝修道长：我想修道院的生活事实上并不适合你\n  玛莉亚：可是 我除了这里之外 我已经没有别的地方可去了\n 四  修道院院长：她是不是 没有其他地方能去了\n  桃乐丝修道长：是的\n  修道院院长：敬爱的上帝\n修道院院长：您希望诺贝鲁克修道院接受玛莉亚吗\n 五  耶拉：玛利亚\n  玛莉亚：啊\n玛莉亚：耶拉\n  耶拉：玛利亚吗\n耶拉：你怎么穿成这个样子啊\n耶拉：院长她叫你回去喔\n  玛莉亚：诶 但是 她不是说不让我住在修道院里了吗\n  耶拉：反正你快点回去就是了\n 六  修道院院长：玛莉亚\n修道院院长：或许你不适合修道院的生活\n修道院院长：但是 我认为上帝是不会拒绝任何人的\n修道院院长：所以玛莉亚\n修道院院长：你不是希望在上帝的庇护之下好好的生活吗\n修道院院长：玛莉亚\n  玛莉亚：是\n  修道院院长：那么你愿意遵守修道院的规矩吗\n  玛莉亚：我愿意\n玛莉亚：没有任何怨言\n  修道院院长：主啊\n修道院院长：请您指导玛莉亚\n修道院院长：让她成为一位称职的修女吧\n  玛莉亚：主啊 感谢您\n玛莉亚：让我继续住在诺贝鲁克修道院里\n玛莉亚：非常感谢您\n玛莉亚：而且我作承诺\n玛莉亚：我再也不吹口哨了\n玛莉亚：也不会跳着爬楼梯\n玛莉亚：也不会从楼梯的扶手上滑下来\n玛莉亚：还有 我再也不会爬到屋顶上去了\n  修道院院长：希望玛莉亚能遵守而且实现她的承诺\n  修道院院长、玛莉亚：阿门\n ","permalink":"/blog/2021/12/12/%E5%B4%94%E6%99%AE%E4%B8%80%E5%AE%B6%E7%89%A9%E8%AF%AD/","summary":"一 耶拉：我觉得我好像做了不该做的事情耶 玛莉亚：守规矩当然是很重要的事情 玛莉亚：但是为了交我这个举世无双的朋友 玛莉亚：而不守规矩的话 玛莉亚：是","title":"《崔普一家物语》"},{"content":" It\u0026rsquo;s a world of laughter, a world of tears\nIt\u0026rsquo;s a world of hopes and a world of fears\nThere\u0026rsquo;s so much that we share\nThat it\u0026rsquo;s time we\u0026rsquo;re aware\nIt\u0026rsquo;s a small world after all\n  It\u0026rsquo;s a small world after all\nIt\u0026rsquo;s a small world after all\nIt\u0026rsquo;s a small world after all\nIt\u0026rsquo;s a small, small world\n  There is just one moon and one golden sun\nAnd a smile means friendship to everyone\nThough the mountains divide\nAnd the oceans are wide\nIt\u0026rsquo;s a small world after all\n  It\u0026rsquo;s a small world after all\nIt\u0026rsquo;s a small world after all\nIt\u0026rsquo;s a small world after all\nIt\u0026rsquo;s a small, small world\n ","permalink":"/blog/2021/12/11/%E9%9F%B3%E4%B9%90its-a-small-world-disney-classics/","summary":"It\u0026rsquo;s a world of laughter, a world of tears It\u0026rsquo;s a world of hopes and a world of fears There\u0026rsquo;s so much that we share That it\u0026rsquo;s time we\u0026rsquo;re aware It\u0026rsquo;s a small world after all It\u0026rsquo;s a small world after all It\u0026rsquo;s a small world after all It\u0026rsquo;s a small world after all It\u0026rsquo;s a small, small world There is just one moon and one golden sun And a","title":"【音乐】It's a Small World - Disney Classics"},{"content":"","permalink":"/blog/2021/12/11/%E9%9F%B3%E4%B9%90%E5%8D%81%E5%88%86%E5%8D%81%E4%BA%8C%E5%90%8B-%E6%9E%97%E5%AD%90%E7%A5%A5/","summary":"","title":"【音乐】十分十二吋 - 林子祥"},{"content":" And I Love You So\nThe people ask me how\nHow I\u0026rsquo;ve lived \u0026rsquo;til now\nI tell them \u0026ldquo;I don\u0026rsquo;t know\u0026rdquo;\n  I guess they understand\nHow lonely life has been\nBut life began again\nThe day you took my hand\n  And yes, I know how lonely life can be\nThe shadows follow me\nAnd the night won\u0026rsquo;t set me free\nBut I don\u0026rsquo;t let the evening get me down\nNow that you\u0026rsquo;re around me\n  And you love me too\nYour thoughts are just for me\nYou set my spirit free\nI\u0026rsquo;m happy that you do\n  The book of life is brief\nAnd once a page is read\nAll but love is dead\nThat is my belief\n  And yes, I know how loveless life can be\nThe shadows follow me\nAnd the night won\u0026rsquo;t set me free\nBut I don\u0026rsquo;t let the evening bring me down\nNow that you\u0026rsquo;re around me\n  And I love you so\nThe people ask me how\nHow I\u0026rsquo;ve lived \u0026rsquo;til now\nI tell them \u0026ldquo;I don\u0026rsquo;t know\u0026rdquo;\n ","permalink":"/blog/2021/12/11/%E9%9F%B3%E4%B9%90and-i-love-you-so-don-mclean/","summary":"And I Love You So The people ask me how How I\u0026rsquo;ve lived \u0026rsquo;til now I tell them \u0026ldquo;I don\u0026rsquo;t know\u0026rdquo; I guess they understand How lonely life has been But life began again The day you took my hand And yes, I know how lonely life can be The shadows follow me And the night won\u0026rsquo;t set me free But I don\u0026rsquo;t let the evening get me down Now","title":"【音乐】And I Love You So - Don McLean"},{"content":" 秋天该很好\n你若尚在场\n秋风即使带凉 亦漂亮\n深秋中的你填密我梦想\n就像落叶飞\n轻敲我窗\n  冬天该很好\n你若尚在场\n天空多灰\n我们亦放亮\n一起坐坐谈谈来日动向\n漠视外间低温\n这样唱\n能同途偶遇在这星球上\n燃亮飘渺人生\n我多么够运\n无人如你逗留我思潮上\n从没再疑问\n这个世界好得很\n  暑天该很好\n你若尚在场\n火一般的太阳在脸上\n烧得肌肤如情\n痕极又痒\n滴着汗的一双\n笑着唱\n能同途偶遇在这星球上\n燃亮飘渺人生\n我多么够运\n无人如你逗留我思潮上\n从没再疑问\n这个世界好得很\n能同途偶遇在这星球上\n是某种缘分\n我多么庆幸\n如离别你亦长处心灵上\n宁愿有遗憾\n亦愿和你远亦近\n  春天该很好\n你若尚在场\n春风仿佛爱情在酝酿\n初春中的你\n撩动我幻想\n就像嫩绿草使\n春雨香\n ","permalink":"/blog/2021/12/11/%E9%9F%B3%E4%B9%90%E6%98%A5%E5%A4%8F%E7%A7%8B%E5%86%AC-%E5%BC%A0%E5%9B%BD%E8%8D%A3/","summary":"秋天该很好 你若尚在场 秋风即使带凉 亦漂亮 深秋中的你填密我梦想 就像落叶飞 轻敲我窗 冬天该很好 你若尚在场 天空多灰 我们亦放亮 一起坐坐谈谈来日动向 漠视外","title":"【音乐】春夏秋冬 - 张国荣"},{"content":" 突然落下的夜晚\n灯火已隔世般阑珊\n昨天已经去得很远\n我的窗前已模糊一片\n大风声 像没发生 太多的记忆\n又怎样放开我的手\n怕你说 那些被风吹起的日子\n在深夜收紧我的心\n日子快消失了一半\n那些梦又怎能做完\n你还在拼命的追赶\n这条路究竟是要去哪儿\n大风声 像没发生 太多的记忆\n又怎样放开我的手\n怕你说 那些被风吹起的日子\n在深夜收紧我的心\n哎呀\n时光真疯狂\n我一路执迷与匆忙\n依稀悲伤\n来不及遗忘 只有待风将她埋葬\n咿呀 咿呀\n待风将她埋葬\n咿呀 咿呀\n待风将她埋葬\n咿呀 咿呀\n我们曾在路上\n咿呀 咿呀\n待风将她埋葬\n ","permalink":"/blog/2021/12/11/%E9%9F%B3%E4%B9%90%E4%B8%94%E5%90%AC%E9%A3%8E%E5%90%9F-%E6%9C%B4%E6%A0%91/","summary":"突然落下的夜晚 灯火已隔世般阑珊 昨天已经去得很远 我的窗前已模糊一片 大风声 像没发生 太多的记忆 又怎样放开我的手 怕你说 那些被风吹起的日子 在深夜收紧我","title":"【音乐】且听风吟 - 朴树"},{"content":" 丘に登って　深呼吸するの\nつくり笑いは得意じゃない\n臆病なのは誰だって同じ\n明日の翼　信じたいね\n風も山も　唄うメロディー\n涙だって　幸せのレッスン\n私らしく　両手を広げて\nSing my song\n  傷つく事や　恋する気持ちを\n恐れるよりも　見つめるのよ\n大切な物　大切な人に\nやさしくなれる それが愛ね\n胸のチャイム　鳴らす予感\n何があるの?　夢の向こう側に\n待っていたい　両手を広げて\nSing my song\n  涙だって　ときめきのレッスン\n青い空に　両手を広げて\nSing my song\n  登上山丘 做個深呼吸\n不要再戴著 笑容假面具\n畏懼膽小 是每個人都存在的\n要相信 明天依然能夠去展翅飛翔\n風與山 也在歌唱著\n盡情流淚吧 必能引導走向幸福\n像我一樣 張開你的雙手\nSing my song\n  令人悲傷 失戀的感覺\n不願去面對 感到很恐慌\n他很重要 是無法能放下的\n這份情 就是溫柔美好的愛之回憶\n內心間 也在動盪著\n夢想的彼岸 究竟擁有怎樣景色\n不要猶豫 張開你的雙手\nSing my song\n  盡情流淚吧 必能釋放所有激昂\n面對天空 張開你的雙手\nSing my song\n ","permalink":"/blog/2021/12/11/%E9%9F%B3%E4%B9%90%E4%B8%A1%E6%89%8B%E3%82%92%E5%BA%83%E3%81%92%E3%81%A6-%E4%BC%8A%E6%9D%B1%E6%83%A0%E9%87%8C/","summary":"丘に登って 深呼吸するの つくり笑いは得意じゃない 臆病なのは誰だって同じ 明日の翼 信じたいね 風も山も 唄うメロディー 涙だって 幸せのレッスン 私らしく 両","title":"【音乐】両手を広げて - 伊東惠里"},{"content":" Сонау алыс ауылда қалды-ау сұйген жар\nАттанарда қош десе алмай болдым- ау зар\nҚайран жалған\n  Кер даланың шөліндеи құлазыды\nКең деуші еді Бұл дұние недеген тар\nҚайран жалған\n  Таңдай татыр шетіңе жетемін бе　Құлагер ат аяңдайды тепеңімде\nҚайран жалған\n  Әзер тапқан алаштан дегдарім- ай\nАй жүзіңді бір көре алмай кетемін бе\nҚайран жалған\n  Көш асады қайқайып қарлы таудан\nЕгеи-егеи ел едік біз нарды сауған\nҚайран жалған\n  Айырды ма шінімен туған жерден\nБозаң дала, сорлаған ел босып ауған\nҚайран жалған\n  我的恋人留在了那遥远的地方，\n上马的时候也未能告别。\n哎这可悲的时代\n  这个世界， 像克尔达拉的沙漠般延伸无尽，\n人人都说世界广大，可为何又这般狭小。\n哎这可悲的时代\n  我能走到你的故乡吗 ——那长着耳蕨的盐碱地，\n黄马在我的牵引下慢慢地走。\n哎这可悲的时代\n  好不容易在人群中找到的恋人啊，\n你明月般的面容，难道再也见不到了吗？\n哎这可悲的时代\n  迁徙的队伍翻过茫茫的雪山，\n我们曾是挤着骆驼奶的幸福民族\n哎这可悲的时代\n  故乡真的已经远去了吗？\n惨白的原野上，苦难的人民四处流亡\n哎这可悲的时代\n ","permalink":"/blog/2021/12/11/%E9%9F%B3%E4%B9%90khayran-jalgan-%E5%93%88%E8%90%A8%E5%85%8B%E6%B0%91%E6%AD%8C/","summary":"Сонау алыс ауылда қалды-ау сұйген жар Аттанарда қош десе алмай болдым- ау зар Қайра","title":"【音乐】Khayran Jalgan - 哈萨克民歌"},{"content":" 淡紅の秋桜が秋の日の\n何気ない陽溜りに揺れている\n此頃涙脆くなった母が\n庭先でひとつ咳をする\n縁側でアルバムを開いては\n私の幼い日の思い出を\n何度も同じ話くり返す\n独言みたいに小さな声で\nこんな小春日和の穏やかな日は\nあなたの優しさが浸みて来る\n明日嫁ぐ私に苦労はしても\n笑い話に時が変えるよ\n心配いらないと 笑った\nあれこれと思い出をたどったら\nいつの日もひとりではなかったと\n今更乍ら我儘な私に\n唇かんでいます\n明日への荷造りに手を借りて\nしばらくは楽し気にいたけれど\n突然涙こぼし元気でと\n何度も何度もくり返す母\nありがとうの言葉をかみしめながら\n生きてみます私なりに\nこんな小春日和の穏やかな日は\nもう少しあなたの子供で\nいさせてください\n  淡红色的秋樱在秋日\n平淡的阳光中摇曳\n此刻 易哭的母亲\n在花园中轻咳一声\n露台上 相册被打开着\n用同样的话语 一遍遍诉说我童年的话语\n自言自语般轻轻道来\n在这风和日丽的秋日\n深深感受着您的温柔\n微笑着 您对明天将披嫁衣的我说\n无论多么辛劳\n所以不要担心\n沉浸在无尽的回忆中\n发现无论如何我都不是一个人\n如今才察觉我的任性\n却只能咬住我的嘴唇\n让您帮忙收拾明日的行李\n母亲啊 您一遍又一遍\n在霎那的快乐后\n突然又溢出泪水 向我说到 多保重啊\n含蓄地表达着谢意\n我会努力走出我的人生之路\n在这风和日丽的秋日\n让我再多在您身边坐一会\n您的女儿\n ","permalink":"/blog/2021/12/11/%E9%9F%B3%E4%B9%90%E7%A7%8B%E6%A1%9C-%E5%B1%B1%E5%8F%A3%E7%99%BE%E6%81%B5/","summary":"淡紅の秋桜が秋の日の 何気ない陽溜りに揺れている 此頃涙脆くなった母が 庭先でひとつ咳をする 縁側でアルバムを開いては 私の幼い日の思い出を 何度も同じ","title":"【音乐】秋桜 - 山口百恵"},{"content":"","permalink":"/blog/2021/12/11/%E9%9F%B3%E4%B9%90forrest-gump-suite-alan-silvestri/","summary":"","title":"【音乐】Forrest Gump Suite - Alan Silvestri"},{"content":"介绍 QList 类是提供动态数组的模板类。该类中的所有函数都是可重入的。另外两个常用的顺序容器 QStack 和 QQueue 继承自 Qlist。\n详细说明 QList 是 Qt 的通用容器类之一。它将其项目存储在相邻的内存位置，并提供基于索引的快速访问。QVector  在 Qt 5 中曾经是一个不同的类，但现在是 QList 的一个简单别名。\nQList 和QVarLengthArray  提供类似的 API 和功能。它们通常可以互换，但会产生性能后果。以下是用例的概述：\n QList 应该是您的默认首选。 QVarLengthArray提供了一个在堆栈上保留空间的数组，但如果需要，可以动态地增长到堆上。用于通常较小的短寿命容器是很好的。 如果您需要一个真正的链表，它保证在列表中间插入恒定时间并使用迭代器到项目而不是索引，请使用 std::list。  ","permalink":"/collection/qlist/","summary":"介绍 QList 类是提供动态数组的模板类。该类中的所有函数都是可重入的。另外两个常用的顺序容器 QStack 和 QQueue 继承自 Qlist。 详细说明 QList 是 Qt 的通用容器类之一。","title":"【转载】Qt6 顺序容器 QList"},{"content":"Qt 中的许多 C++ 类使用隐式数据共享来最大化资源使用并最小化复制。当作为参数传递时，隐式共享类既安全又高效，因为只有一个指向数据的指针被传递，并且只有当函数写入数据时才会复制数据，即copy-on-write。\n概述 共享类由指向共享数据块的指针组成，该共享数据块包含引用计数和数据。\n创建共享对象时，它将引用计数设置为 1。只要新对象引用共享数据，引用计数就会增加，而当对象取消引用共享数据时，引用计数会减少。当引用计数变为零时，共享数据将被删除。\n在处理共享对象时，有两种方法可以复制对象。我们通常谈论深拷贝和浅拷贝。深拷贝意味着复制一个对象。浅拷贝是引用拷贝，即只是指向共享数据块的指针。就内存和 CPU 而言，进行深度复制的成本可能很高。制作浅拷贝非常快，因为它只涉及设置一个指针和增加引用计数。\n隐式共享对象的对象分配（使用 operator=()）是使用浅拷贝实现的。\n共享的好处是程序不需要不必要地复制数据，从而减少内存使用和数据复制。对象可以很容易地被赋值，作为函数参数发送，并从函数中返回。\n隐式共享大多发生在幕后；程序员很少需要担心它。但是，Qt 的容器迭代器与 STL 的容器迭代器具有不同的行为。阅读隐式共享迭代器问题。\n在多线程应用程序中，会发生隐式共享，如线程和隐式共享类中所述。\n在实现您自己的隐式共享类时，请使用QSharedData和QSharedDataPointer类。\n详细的隐式共享 如果对象即将更改并且引用计数大于 1，则隐式共享会自动将对象从共享块中分离。（这通常称为 copy-on-write 或者 value semantics。）\n隐式共享类可以控制其内部数据。在任何修改其数据的成员函数中，它会在修改数据之前自动分离。但是，请注意容器迭代器的特殊情况；请参阅隐式共享迭代器问题。\n 警告：在使用STL 样式的迭代器时，请小心复制隐式共享容器（QMap、QList等）。请参阅隐式共享迭代器问题。\n 示例 QPixmap p1, p2; p1.load(\u0026#34;image.bmp\u0026#34;); p2 = p1; // p1 and p2 share data  QPainter paint; paint.begin(\u0026amp;p2); // cuts p2 loose from p1 paint.drawText(0,50, \u0026#34;Hi\u0026#34;); paint.end(); 在这个例子中，p1 和 p2 共享数据，直到了 p2 被 QPainter::begin() 调用，因为画像素图将修改它。\n所有隐式共享的类 参见 Qt 文档。\n","permalink":"/collection/implicit-sharing/","summary":"Qt 中的许多 C++ 类使用隐式数据共享来最大化资源使用并最小化复制。当作为参数传递时，隐式共享类既安全又高效，因为只有一个指向数据的指针被传递，并且","title":"【转载】Qt6 隐式共享"},{"content":"介绍 Qt 库提供了一组通用的基于模板的容器类。这些类可用于存储制定类型的项。例如，您需要一个可调整大小的 QString 数组，请使用 QList。\n这些容器类被设计为比 STL 容器更轻、更安全且更易于使用。如果您不熟悉 STL，或者更喜欢“Qt 方式”实现，您可以使用这些类而不是 STL 类。\n容器类是 隐式共享的，它们是可重入的，并且它们针对速度、低内存消耗和最小的内联代码扩展进行了优化，从而产生更小的可执行文件。此外，在所有用于访问它们的线程将它们用作只读容器的情况下，它们是线程安全的。\n容器提供了遍历的迭代器。STL 样式的迭代器是最有效的迭代器，可以与 Qt 和 STL 的通用算法一起使用。提供 Java 风格的迭代器是为了向后兼容。\n容器类 Qt 提供以下顺序容器：QList、QStack 和 QQueue。对于大多数应用程序，QList 是最好的类型。它提供了非常快速的追加。如果您确实需要链表，请使用 std::list。QStack 和 QQueue 是提供 LIFO 和 FIFO 语义的便利类。QList和QVector在 Qt 6 中被统一。两者都使用来自QVector的数据模型。QVector现在是QList的别名。\nQt 还提供了这些关联容器：QMap、QMultiMap、QHash、QMultiHash和QSet。“Multi”容器方便地支持与单个键关联的多个值。“散列”容器通过使用散列函数而不是对排序集的二分搜索来提供更快的查找。\n作为特殊情况，QCache 和 QContiguousCache 类在有限的缓存存储中提供了有效的对象散列查找。\n   类 简述     QList  这是迄今为止最常用的容器类。它存储可以通过索引访问的给定类型 (T) 的值列表。在内部，它在内存中的相邻位置存储一组给定类型的值。在列表的前面或中间插入可能会很慢，因为它可能导致大量项目必须在内存中移动一个位置。   QVarLengthArray \u0026lt;T, Prealloc \u0026gt; 这提供了一个低级的可变长度数组。在速度特别重要的地方，它可以代替QList使用。   QStack  这是QList 的一个便利子类，提供“后进先出”(LIFO) 语义。它向QList 中已有的函数添加了以下函数：push ()、pop () 和top ()。   QQueue  这是QList的便利子类，提供“先进先出”(FIFO) 语义。它将以下函数添加到QList 中已经存在的函数中：enqueue ()、dequeue () 和head ()。   QSet  这提供了具有快速查找功能的单值数学集。   QMap \u0026lt;Key, T\u0026gt; 这提供了一个字典（关联数组），将 Key 类型的键映射到 T 类型的值。通常每个键都与单个值相关联。QMap以 Key 顺序存储其数据；如果顺序无关紧要QHash是一个更快的选择。   QMultiMap \u0026lt;Key, T\u0026gt; 这是QMap 的一个方便的子类，它为多值映射提供了一个很好的接口，即一个键可以与多个值相关联的映射。   QHash \u0026lt;Key, T\u0026gt; 这与QMap具有几乎相同的 API ，但提供了明显更快的查找。QHash以任意顺序存储其数据。   QMultiHash \u0026lt;Key, T\u0026gt; 这是QHash 的一个便利子类，它为多值散列提供了一个很好的接口。    算法复杂性 下表总结了顺序容器 QList 的算法复杂度。\n    索引查找 插入 前置 附加     QList  O(1) O(n) O(n) Amort.O(1)     在表中，“Amort.”代表“摊销行为”。例如，“Amort.O(1)”意味着如果你只调用一次函数，你可能会得到 O(n) 的行为，但如果你多次调用它（例如，n 次），平均行为将是 O(1)。\n 下表总结了 Qt 的关联容器和集合的算法复杂度：\n    键查找-平均数 键查找-最差的情况 插入-平均数 插入-最差的情况     QMap\u0026lt;Key, T\u0026gt; O(log n ) O(log n ) O(log n ) O(log n )   QMultiMap\u0026lt;Key, T\u0026gt; O(log n ) O(log n ) O(log n ) O(log n )   QHash\u0026lt;Key, T\u0026gt; Amort.O(1) O( n ) Amort.O(1) O( n )   QSet Amort.O(1) O( n ) Amort.O(1) O( n )    ","permalink":"/collection/qt-containers/","summary":"介绍 Qt 库提供了一组通用的基于模板的容器类。这些类可用于存储制定类型的项。例如，您需要一个可调整大小的 QString 数组，请使用 QList。 这些容器类被设","title":"【转载】Qt6 容器类-概述"},{"content":"（六）  阿塔尼斯：虫群摧毁了我们的家园。\n阿塔尼斯：我高贵的族人们沦为难民。\n阿塔尼斯：但是……\n阿塔尼斯：虫群无法摧毁我们意志。\n阿塔尼斯：因为神圣的卡拉连接着我们每个人的思想……\n阿塔尼斯：让我们在绝望中团结一致。\n  执政官：势不可挡。\n  阿塔尼斯：今天我们将夺回我们的家园……\n阿塔尼斯：夺回我们的遗产。\n  阿塔尼斯：圣堂武士们，我们终于又站在了命运的十字路口。 阿塔尼斯：因为今天，我们将恢复属于星灵的荣耀。 阿塔尼斯：今天我们将重整旗鼓，夺回属于我们自己的家园。\n  圣堂武士：为了艾尔！\n  阿塔尼斯：愿卡拉之光指引我们。\n  赛兰迪丝：舰队已经准备就绪。只等您的命令了，大主教。\n  泽拉图：你们必须立即停止出征！\n  阿塔尼斯：泽拉图……\n  赛兰迪丝：圣堂武士，逮捕这个叛徒！\n  阿塔尼斯：慢着！让他把话说完。\n  泽拉图：最终之战已经来临。 泽拉图：黑暗者埃蒙，它回来了。\n  赛兰迪丝：我们不能相信这个异端！\n  泽拉图：出征艾尔会让我们忽略眼前真正的威胁。 泽拉图：埃蒙的怒火将会吞没整个星系。\n  赛兰迪丝：别忘了，就是因为这个叛徒，艾尔才会沦陷。\n  泽拉图：这份愧疚让我无法释怀……但是阿塔尼斯，我知道如何对抗即将来临的黑暗。\n泽拉图：你必须相信我。\n  阿塔尼斯：我们一起经历了许多，泽拉图。然而已经有太多族人为了此时此刻的到来，付出了生命。\n阿塔尼斯：执行官，准备出战！\n （七）  阿塔尼斯：看来你一直警示的末日之战到来了。告诉我，老朋友，你到底发现了什么？\n  泽拉图：我目睹了万物的毁灭……\n泽拉图：可怕的混合体军团毁灭了一个又一个世界。在黑暗中，一个黑影——埃蒙率领着它们。\n  阿塔尼斯：可你说过有对付他的办法。\n  泽拉图：我获得了一个善意的预示，仿佛一个来自彼岸的古老声音在呼唤着我。“钥石将指引你们找到希望……”\n  阿塔尼斯：钥石？\n  泽拉图：在一道强光中，我看到了钥石的所在地。那正是位于人类星球克哈上的萨尔纳加神器。\n泽拉图：预言提及了萨尔纳加会在末日之战中对抗埃蒙。我相信这个钥石能指引我们见证那一刻。\n  阿塔尼斯：我一直都相信你，泽拉图。但领袖的重任实在让我有心无力。\n阿塔尼斯：我经常怀疑自己是否真的能够扛起这份重任。\n  泽拉图：你的怀疑是多余的，年轻的阿塔尼斯。如果你想成为我们的领袖，你必须建立起自己的信心。\n  阿塔尼斯：你去克哈找詹姆斯·雷诺拿到钥石。我来指挥我们的军队进行备战。\n阿塔尼斯：等你回来，圣堂武士将随时候命。\n阿塔尼斯：En taro Tassadar，老朋友。\n  泽拉图：En taro Artanis，兄弟。\n ","permalink":"/blog/2021/11/30/%E6%98%9F%E9%99%85%E4%BA%89%E9%9C%B8%E8%99%9A%E7%A9%BA%E4%B9%8B%E9%81%97/","summary":"（六） 阿塔尼斯：虫群摧毁了我们的家园。 阿塔尼斯：我高贵的族人们沦为难民。 阿塔尼斯：但是…… 阿塔尼斯：虫群无法摧毁我们意志。 阿塔尼斯：因为神圣","title":"《星际争霸——虚空之遗》"},{"content":"（四）  雷诺：莎拉？\n雷诺：不……\n  凯瑞甘：我要救你出去。\n  雷诺：你都干了什么？\n  凯瑞甘：我是……迫不得已。\n  雷诺：这话去和芬尼科斯说，去和被你杀害的人说。\n  凯瑞甘：你发誓说你会杀了刀锋女王。\n凯瑞甘：你曾是唯一相信我的人。\n凯瑞甘：你现在……还相信我吗？\n  凯瑞甘：我爱你，吉姆。永远别忘记。\n  雷诺：我们结束了。\n （五）  凯瑞甘：我现在看清了我真正的敌人。\n凯瑞甘：他在虚空中等待着我，\n凯瑞甘：拥有着我无法想象的力量……\n凯瑞甘：为了对抗他，我放弃了所有的一切。\n凯瑞甘：我的人性、\n凯瑞甘：我的身份、\n凯瑞甘：还有我爱的男人。 凯瑞甘：但我不会独自去面对他的。 凯瑞甘：我即是虫群。\n ","permalink":"/blog/2021/11/30/%E6%98%9F%E9%99%85%E4%BA%89%E9%9C%B8%E8%99%AB%E7%BE%A4%E4%B9%8B%E5%BF%83/","summary":"（四） 雷诺：莎拉？ 雷诺：不…… 凯瑞甘：我要救你出去。 雷诺：你都干了什么？ 凯瑞甘：我是……迫不得已。 雷诺：这话去和芬尼科斯说，去和被你杀害的人","title":"《星际争霸——虫群之心》"},{"content":"交易  阿克图尔斯：据说人在被剥夺了自由后……\n阿克图尔斯：……才能真正了解自己\n阿克图尔斯：我在想，你有多了解自己呢？\n  副官：囚犯，向前走上平台。\n  阿克图尔斯：626号囚犯……\n阿克图尔斯：谋杀、掠夺、叛国 阿克图尔斯：今天……你出狱了。\n阿克图尔斯：但你很快就会明白…… 阿克图尔斯：……自由也是有代价的。\n  副官：战斗护甲焊接……并锁定完毕。\n  阿克图尔斯：监狱将伴你同行，这身护甲就是你新的牢房。\n阿克图尔斯：别误会——战争即将开始。\n阿克图尔斯：它带来了功名荣耀……\n阿克图尔斯：也带来了阴森恐怖。\n阿克图尔斯：芬利先生——自由在召唤你。\n  泰凯斯：来吧……好戏开场了。\n 大预言  泽拉图：虫群的到来早有预言……\n泽拉图：而星灵——神之长子，则奋起反抗。\n泽拉图：如今我们的创世者萨尔纳加……回来了。\n泽拉图：但回归是为了拯救……？\n泽拉图：……还是毁灭？\n  凯瑞甘：（笑声）\n凯瑞甘：我就知道，最终你会来的。\n  泽拉图：你的出现亵渎了这里，凯瑞甘。\n  凯瑞甘：你能听到吗，泽拉图？群星间的低语。\n凯瑞甘：星系会随他们的到来而燃烧。\n  泽拉图：也许……\n泽拉图：……但你看不到了！\n  凯瑞甘：拜托，我们的恩怨微不足道。\n凯瑞甘：一场势不可挡的风暴正在袭来。\n凯瑞甘：这场湮灭，我们应该共同面对。\n  泽拉图：休想！\n  凯瑞甘：命运无法改变，\n凯瑞甘：末日正在临近，\n凯瑞甘：当它降临时，\n凯瑞甘：我会欣然接受。\n  泽拉图：预言尚未可知。\n泽拉图：希望永不湮灭。\n 火与怒  雷诺：你还能走啊，将军。\n  沃菲尔德：不知道还能坚持多久。\n  雷诺：呵。\n  沃菲尔德：我带来了一件礼物。\n沃菲尔德：萨尔纳加神器组装好了。但愿它物有所值。\n  泰凯斯：显然，我可不想把性命都压在这些外星垃圾上。\n  雷诺：泰凯斯，如果我孤注一掷，那早就完蛋了。这里危机四伏，相互支持才让我们走到今天。\n  沃菲尔德：不知道是运气好还是傻人有傻命——我还没见过像你们这样就能成功的。\n  雷诺：那东西可能是阻止刀锋女王的关键——但想要成功必须付出血汗的代价！\n雷诺：经历了这么多，历尽艰辛与磨难……\n雷诺：……我明白了一件事——相互依靠才能完成这项任务。\n雷诺：即使是付出生命的代价。\n雷诺：……因为有些东西值得我们去奋斗。\n ","permalink":"/blog/2021/11/29/%E6%98%9F%E9%99%85%E4%BA%89%E9%9C%B8%E8%87%AA%E7%94%B1%E4%B9%8B%E7%BF%BC/","summary":"交易 阿克图尔斯：据说人在被剥夺了自由后…… 阿克图尔斯：……才能真正了解自己 阿克图尔斯：我在想，你有多了解自己呢？ 副官：囚犯，向前走上平台。 阿","title":"《星际争霸——自由之翼》"},{"content":"人族帝国的皇帝—— 阿克图拉斯一世的加冕仪式  人类同胞们，\n我来此召集你们，是要让你们了解目前的形势。\n每个人都应该意识到我们此时所遭受到的危机，\n我们彼此互相争斗，\n为了共和历史的微小冲突而被分散。\n现在，更大的危险正向我们靠近。\n这股威胁将会毁灭我们的所有成就。\n现在该是我们以国家或是个人的身份， 放下我们之间的仇恨，协同一致。\n一场无法打赢的战争已经迫在眉睫，\n而我们必须到更好的行星上找寻定居场所，\n以免我们在转瞬之间就被战争所淹没。\n联盟已经不存在了；\n它曾经的团结和保护力量也成了一个幻影……一个回忆。\n在我们还没打倒敌人之前，你们会向谁去寻求保护？\n异形侵略者的破坏力量已经是显而易见。\n我们看到了我们的家乡和村落在神族精准的攻击下毁灭。\n我们看到了莫逆之交的朋友和挚爱之人在噩梦般的虫族手中丧生。\n尽管它们是前所未有和无法想象的，但这就是我们此时的处境。\n我的人类同胞们，该是集合起来创立一个新时代的时候了。\n在团结中才会产生力量；许多反对组织已经加入了我们。\n我们所有人将会凝聚成一股无法分割的力量，并且只服从于一个王座之下。\n在这个王座之上，我将看着你们。\n从这一天开始，再也不要让人类之间彼此交战，\n再也没有任何组织来破坏这个新的开始。\n并且再也不要让任何人试图利用异形的力量……\n别让人类的敌人挡在我们的路上，\n我们最后一定会胜利的，不计任何代价。\n——阿克图尔斯·蒙斯克\n X-1  陆战队员1：谁是这个地方的主管？\n陆战队员1：空中支援到哪里去了？\n  陆战队员2指了指天上。\n  阿列克斯：嗯，杰拉德，对于你把我从工作岗位上硬拉出来，\n阿列克斯：我想你会给我一个好理由的。\n  杰拉德：我的好阿列克斯，你的伏特加在等你。\n杰拉德：站到我身边来，看看这些你就知道了。\n  阿列克斯：杰拉德，我知道是有关虫族的事， 阿列克斯：我们看过带子几百遍了……\n  杰拉德：你什么都没看到！\n杰拉德：在实验室解剖死虫是一回事， 杰拉德：用我们的人去撕碎它们却是另一回事。 杰拉德：你必须把眼睛睁亮来对待这件事。 杰拉德：一旦开始之后，就再也没有退路了。 杰拉德：你准备好踏上这条路了吗，阿列克斯？\n  阿列克斯：是……是的，我准备好了，我伟大的将军。\n  杰拉德：好，好。我就知道我可以信任你。\n  马士汀：将军。殖民基地在数分钟之内就会被攻下。我们要插手吗？\n  杰拉德：带我们回到轨道上，马士汀。我们看够了。\n 人族  虫族！\n这个极少被我们说起的可怕种族，再一次让所有人笼罩在恐怖的阴影之下。\n但是现在，我们可以高枕无忧了，因为我们的军队已经占领了他们位于查尔的老家。\n从我们与虫族为敌开始，到现在已经过了数个月的时间。而现在联邦军队已经完全控制了查尔行星，也就是传说中的虫族恶毒的主宰的摇篮。主宰本身是一个巨大而活生生的大脑的形态，可以对手下无数的虫族部队下达命令，相信它们的目标就是地球本身。\n一旦进入攻击之后，我们受过高度训练的联邦部队将能够全力歼灭这些野兽般的虫族。\n即使是最残暴的战斗种族，也无法打倒银河系中最强大的军事科技。\n在查尔行星上的虫族被全面摧毁，而它们的损失将近百万。\n但是，任何战争都有伤亡，不过联邦部队的损伤去很小，舰队的中将斯图可夫在对查尔行星的最后进攻中奉献出他的生命。\n追悼仪式在地球联邦旗舰亚历山大号举行，斯图可夫中将真正理解了牺牲的意义。 然而他的牺牲并非全然白费。主宰就是这场战争中最大的战利品。即使是现在，联邦部队的精神力和威力强大的药剂还在让这个生物活在沉睡之中。我们将持续对主脑进行更深入的研究，以确保地球联邦和所有人类后世的和平。\n——UEN：地球联邦网络 特别报道 最新战况\n 虫族  我又一次站在敌人破碎的尸体上……\n胜利，并非没有代价。\n来自地球的联邦舰队已经被摧毁了。\n而主宰也已经在查尔行星的灰烬之下死亡了。\n至于我的盟友们，我想我应该给他们一个缓刑的机会。\n我要慢慢地消磨他们的意志，和他们的力量。\n最后他们终将是属于我的，因为我就是刀锋女皇。\n再也没有人能够脱离我的统治。\n——凯瑞甘\n  亲爱的海莲娜，\n现在，我们被击败的消息已经传回地球了。\n我们被送到此处来驯服的生物，看来是无法驯服了。\n而我们被送到此处来收回的殖民地，也比我们想象的要更为强大。\n不管 听到什么与这个地方有关的传言，请记住：\n阿列克斯并不是在战场中光荣捐躯的。\n是我杀了他。我的自傲杀了他。\n现在，我的自傲一样在折磨着我。\n你再也不会看到我了，海莲娜。\n告诉我们的孩子，我爱他们，\n告诉他们，父亲是为了保护他们的未来而死的。\n永别了。\n——杰拉德\n ","permalink":"/blog/2021/11/29/%E6%98%9F%E9%99%85%E4%BA%89%E9%9C%B8%E6%AF%8D%E5%B7%A2%E4%B9%8B%E6%88%98/","summary":"人族帝国的皇帝—— 阿克图拉斯一世的加冕仪式 人类同胞们， 我来此召集你们，是要让你们了解目前的形势。 每个人都应该意识到我们此时所遭受到的危机， 我","title":"《星际争霸——母巢之战》"},{"content":"《长腿叔叔》 https://www.bilibili.com/bangumi/play/ep94176\n《崔普一家物語》 https://www.bilibili.com/video/BV1cb411P7N\n《红发安妮》 https://www.bilibili.com/video/BV12W411m7jJ\n《阿尔卑斯山的少女》 https://www.bilibili.com/bangumi/play/ep60826\n《佩琳物语》 https://www.bilibili.com/bangumi/play/ep81529\n","permalink":"/blog/2021/11/27/%E4%B8%96%E7%95%8C%E5%90%8D%E4%BD%9C%E5%89%A7%E5%9C%BA%E7%B3%BB%E5%88%97%E6%8E%A8%E8%8D%90/","summary":"《长腿叔叔》 https://www.bilibili.com/bangumi/play/ep94176 《崔普一家物語》 https://www.bilibili.com/video/BV1cb411P7N 《红发安妮》 https://www.bilibili.com/video/BV12W411m7jJ 《阿尔卑斯山的少女》 https://www.bilibili.com/bangumi/play/ep60826 《佩琳物语》 https://www.bilibili.com/bangumi/play/ep81529","title":"世界名作剧场系列推荐"},{"content":"前两天一位朋友向我分享了他的学生在校运会跑步的场景，选手们迎着终点跑去，赛道旁鼓气呐喊声连绵不绝。好怀念，在阳光下奔跑的时光。\n跑步本身是没什么乐趣的，只会让身体负荷加重，还会带来肌肉酸痛等问题，但总有人乐此不疲。我曾经也热衷于长跑，也参加过不少比赛。但我并不喜欢这项运动。一步，两步，抬起，放下，腿像绑了沙袋一样沉重。一圈，两圈，十圈，二十圈，我真的不想跑，但是又不想停下来。因为，这是我清醒时让大脑放空的最好方式。当风吹在我脸上的时候，脑海里什么都没有。耳边一阵阵呐喊欢呼，我心里非常安静。\n我曾听过一句最让我恐惧的话，“别大口呼吸，会死的”。是的，每个人都在害怕。害怕孤独，却只能感知自己，这算是人类最大的悲哀了吧？然而，无论如何置身于阳光下，黑暗，总会来临，掩盖世界，熄灭每一颗跳动的心。这是无法逃避的现实，越是逃避，便越沉浸在黑暗中。我们能做的只有接受黑暗，追求光明。因为黑暗是个体宿命，但，光明，却是世界。\n回想那段时光，在黑夜里，阳光却如此相近。\n","permalink":"/blog/2021/11/21/%E5%9C%A8%E9%98%B3%E5%85%89%E4%B8%8B%E5%A5%94%E8%B7%91/","summary":"前两天一位朋友向我分享了他的学生在校运会跑步的场景，选手们迎着终点跑去，赛道旁鼓气呐喊声连绵不绝。好怀念，在阳光下奔跑的时光。 跑步本身是没什","title":"在阳光下奔跑"},{"content":"前情提要 完成前面的工作后，我们的网站是下图这样的，非常符合极简之美。不过空荡荡的网站不是我们想要的，接下来我们就开始最核心的部分：修改网站内容。\n一、准备文本编辑工具 （1）下载文本编辑工具。创作当然离不开文本的编辑，那么一款高效好用的文本编辑工具就非常重要了。这里我强烈推荐一个常用的工具 Visual Studio Code，它可以多文件管理。点击 https://code.visualstudio.com/Download 可以直达官网下载。接下来的讲述会使用到 VSCode，如果你选择其他文本编辑器，也无妨，找到对应的文件修改即可。\n（2）用 VSCode 打开 blog 文件夹。打开 VSCode 后，点击左上角文件菜单，然后点击打开文件夹，选择 D:/hugo/site/blog 文件夹。\n（3）我们需要关注 content 文件夹、public 文件夹和 config.yaml 文件即可。content 存放网站的所有内容，我们平时写文章会在里面创建；public 存放网站的源代码，我们使用 hugo 命令时它会自动生成，我们需要将它上传到 Github ；config.yaml 是网站的配置文件，我们网站的基本信息都会在里面配置。\n二、网站预览 用命令窗口进入网站 blog 根目录，执行 hugo server。打开浏览器，访问 localhost:1313。\n三、创建菜单栏 可以看到我们的网站现在有五个菜单，如果你前面在网站配置把菜单改成中文的话，那么将是[主页]、[关于]、[分类]、[标签]、[订阅]。[主页]不用多说了，[分类]、[标签]、[订阅]是自动管理的，如果不需要的话可以在网站目录的 config.yaml 里删掉，[关于]现在点击的话，是访问不了的，因为我们还没有创建对应的文件夹或文件。\n（1）打开 themes/hugo-ivy/exampleSite 文件夹，这是 hugo-ivy 主题作者提供的示例网站。复制其中的 content 文件夹下的所有文件和文件夹，放到我们网站根目录下的 content文件夹下面。\n（2）修改 config.yaml 文件，添加文章和记录两个菜单。对应的文件夹是 post 和 note。\n（3）这样，再回到浏览器上看。因为我们把示例的文章也复制过来了，所以网站已经有文章显示了。而我们添加的[文章]和[记录]文章也完成了。如果你需要添加其他菜单，可以参考现有的：在 content 文件夹下新建文件夹，然后在 config.yaml 文件中添加修改。\n四、新建文章 我们可以复制 content/post 或者 content/note 下的文件，然后修改里面的标题、作者、日期、分类、标签等等，因为我们使用 hugo server 预览网站，所以可以在浏览器上 localhost:1313 实时查看修改后的效果。不过更常见的做法是通过命令的方式来创建，下面演示在[文章]菜单下创建一篇文章。\n（1）同样，在重新打开一个 cmd 命令窗口，进入网站根目录（blog)。和之前的做法一样这里就不贴图片了。\n(2)执行 hugo new post/2021-11-18.md 命令，post 是存放的目标文件夹，2021-11-18.md 是将要生成的文件，文件名可以随意，注意不要使用中文。\n(3)在 VSCode 里面修改文件内容。\n五、推送到 Github 平台 （1）在 cmd 窗口，在网站根目录（blog）下先执行 hugo 生成网站源代码到 public 目录，然后执行 cd pulic 进入 public 目录。\n（2）分别执行 git add . 和 git commit -m \u0026quot;update\u0026quot; 和 git push完成上传。\n六、完成 上传成功后，等一小会就可以通过 “你的 github 用户名.github.io” 域名访问你的网站啦。到这里，最基本的流程已经走完了，现在可以开始自行探索了！当然，还有很多内容会在后续补充，本系列教程仍存在不足的地方，如果你遇到问题可以联系我。祝愉快~\n","permalink":"/post/2021/11/18/%E4%BF%AE%E6%94%B9%E8%8F%9C%E5%8D%95%E6%A0%8F%E5%92%8C%E6%96%87%E7%AB%A0%E5%88%9B%E4%BD%9C/","summary":"前情提要 完成前面的工作后，我们的网站是下图这样的，非常符合极简之美。不过空荡荡的网站不是我们想要的，接下来我们就开始最核心的部分：修改网站内","title":"修改菜单栏和文章创作"},{"content":"一、在本地创建网站 （1）使用 Hugo 建立网站。打开命令窗口，进入 D:\\hugo\\site 目录（便捷方法：在文件资源管理器中进入相应目录，单击地址栏右边空白地方，在最左边输入 cmd  加空格，回车。这样打开命令窗口的同时，进入了相应的目录），执行命令 hugo new site blog ，如出现 Congratulations! 提示则成功。（此时可在文件资源管理器中查看生成的文件，blog 是任意取的一个文件夹名字，但为了方便教程工作，请统一）\n二、下载主题模板（以 hugo-ivy ）为例 （1）接着回到刚刚的命令窗口，输入执行 cd blog\\themes 进入 themes 目录。\n（2）下载主题模板（ hugo-ivy ）。接上述步骤，在命令窗口中 执行 git clone https://github.com/yihui/hugo-ivy.git 来下载 hugo.386 主题。下载完成后，blog/themes 文件夹里面就可以看到下载好的主题了。\n三、修改网站配置 将 themes/hugo-ivy/exampleSite 文件夹中的 config.yaml 文件复制到文件夹 blog 下，并删除原有的 config.toml 。用记事本或者其他文本编辑工具，根据需要修改相应的内容。\n四、网站本地预览 用命令窗口进入 blog 目录，先执行 hugo 生成网页文件，再执行 hugo server 开启预览。打开浏览器，访问 localhost:1313 。（注意，这个命令窗口需要保持到你不需要预览网站的时候，届时可以用两次 Ctrl + c 停止，或者直接关闭窗口）\n五、将网站推送到 Github 平台 （2）打开命令窗口，进入 blog\\public 目录，分别执行\ngit init git add . git commit -m \u0026#34;first commit\u0026#34; git remote add origin https://github.com/你的Github名字/你的Github名字.github.io.git git push --set-upstream origin master 输入 Github 账号名，密码，完成上传。\n（3）测试。访问 github.com 网站，在你之前创建的仓库可以看到刚刚上传的文件。访问提供的 https://你的Github账户名.github.io 访问你的网站，如果没有之前预览的网页，可以等待一会再刷新。\n","permalink":"/post/2021/11/17/%E6%90%AD%E5%BB%BA/","summary":"一、在本地创建网站 （1）使用 Hugo 建立网站。打开命令窗口，进入 D:\\hugo\\site 目录（便捷方法：在文件资源管理器中进入相应目录，单击地址栏右边空白地方，在最左边","title":"搭建"},{"content":"一  “为什么？”玛丽问。\n  “你是问我，为什么忽然打算好好学习了？”\n  “对。”\n  高桥双手端着咖啡杯，眯起眼睛望着她的脸，就像从窗缝里窥视房间内部。“就是说，你是当真想听到回答才问的？”\n  “当然。一般来说，人们都是想听到回答才提问的吧？”\n  “按道理是。但也有不少人只是出于礼貌才提问的。”\n  “那我就搞不懂了，我干嘛得出于礼貌向你提问呢？“\n  “那倒是。”高桥略一沉吟，将咖啡杯放回小碟子里，发出一声清脆的响声，“我的说明有两个版本，一个长的一个短的，你想听哪一个？“\n  ”中间的。“\n  “知道啦。一个中等尺寸的回答。”\n 二  “可是……”\n  “可是?\u0026quot;\n  “你好好想想。”玛丽说，“我问你‘是不是对爱丽深有兴趣？’你却回答‘我想是有兴趣’。漏掉了一个深字。我觉得好像有什么东西被你弃之不管了。”\n  高桥感慨道：“你好细心啊。”\n  玛丽无言地等待对方说下去。\n  高桥不知道该如何作答，有些犹豫。”呃……是啊，跟你姐姐面对面长谈时，渐渐地，一种奇妙的感觉袭上心来。一开始我并没有注意到，可是随着时间过去，这种感觉越来越强烈。该怎么说呢？那是好像自己没被放在眼里的感觉。她明明近在眼前，可又好像远在几公里之外。“\n  玛丽仍然一言不发。她轻咬嘴唇，等待下面的话。高桥花时间寻找合适的措辞。\n  “简而言之，不管我说什么话，都不可能进入她的心里。在我和浅井爱丽之间，好像横着一道由透明海绵构筑的地层，我口中说出的话，在穿越那里的时候几乎被吸干了全部养分。在真正意义上，她根本没在听我说什么。说着说着，这种情形变得显而易见。这么一来，她说出的话也不能顺利地传递到我这边来。那实在是非常奇妙的感觉。”\n ","permalink":"/blog/2021/11/16/%E5%A4%A9%E9%BB%91%E4%BB%A5%E5%90%8E/","summary":"一 “为什么？”玛丽问。 “你是问我，为什么忽然打算好好学习了？” “对。” 高桥双手端着咖啡杯，眯起眼睛望着她的脸，就像从窗缝里窥视房间内部。“就","title":"《天黑以后》"},{"content":"The Invitation by Oriah  ——〔加拿大〕 Oriah（译者：野竹林）\n  It doesn\u0026rsquo;t interest me\nwhat you do for a living.\nI want to know\nwhat you ache for\nand if you dare to dream\nof meeting your heart\u0026rsquo;s longing.\n  你为生存做了些什么，我不关心；\n我想知道，\n你的追求，\n你是否敢于梦想去触碰你那内心的渴望。\n  It doesn\u0026rsquo;t interest me\nhow old you are.\nI want to know\nif you will risk\nlooking like a fool\nfor love\nfor your dream\nfor the adventure of being alive.\n  你的年龄多大，我不关心；\n我想知道，\n你是否愿意像傻瓜一样不顾风险，\n为了爱，梦想还有活着就该有的冒险。\n  It doesn\u0026rsquo;t interest me\nwhat planets are\nsquaring your moon\u0026hellip;\nI want to know\nif you have touched\nthe centre of your own sorrow\nif you have been opened\nby life\u0026rsquo;s betrayals\nor have become shrivelled and closed\nfrom fear of further pain.\n  我不关心，是什么行星牵引着你的月亮，\n我想知道，\n你是否已触及自己悲伤的中心，\n是否因生活的种种背叛而心胸开阔，\n抑或因为害怕更大的痛苦而消沉封闭！\n  I want to know if you can sit with pain mine or your own\nwithout moving to hide it\nor fade it\nor fix it.\n  我想知道，\n你是否能面对痛苦——我的或者你自己的，\n而不必去隐藏、涂抹或修饰。\n  I want to know\nif you can be with joy\nmine or your own\nif you can dance with wildness and let the ecstasy fill you\nto the tips of your fingers and toes\nwithout cautioning us\nto be careful\nto be realistic\nto remember the limitations\nof being human.\n  我想知道，\n你是否能享受快乐——我的或者你自己的，\n你是否能充满野性地舞蹈，让你从指端到足尖都被狂喜所充满，\n而不会告诫我们要小心、要现实、要记住做人的禁忌。\n  It doesn\u0026rsquo;t interest me\nif the story you are telling me\nis true.\nI want to know if you can\ndisappoint another\nto be true to yourself.\nIf you can bear\nthe accusation of betrayal\nand not betray your own soul.\nIf you can be faithless\nand therefore trustworthy.\n  我并不关心你告诉我的故事是否真实，\n我想知道，\n你是否能为了真实地对待自己而不怕别人失望，\n你是否能承受背叛的指责而不出卖自己的灵魂。\n我想知道，你是否能抛弃曾经的信念，而因此值得信赖。\n  I want to know if you can see Beauty\neven when it is not pretty\nevery day.\nAnd if you can source your own life\nfrom its presence.\n  我想知道，\n你是否能发现美，即使它每天都不漂亮，\n你是否能从它的存在中追寻你自己生命的源头。\n  I want to know\nif you can live with failure\nyours and mine and still stand at the edge of the lake\nand shout to the silver of the full moon,\n\u0026ldquo;Yes.\u0026rdquo;\n  我想知道，\n你是否能与失败相伴——你的和我的，\n却依然可以站立在湖边对着银色的满月放生大喊\n“是的，就是这样！”\n  It doesn\u0026rsquo;t interest me\nto know where you live\nor how much money you have.\nI want to know if you can get up after the night of grief and despair\nweary and bruised to the bone\nand do what needs to be done\nto feed the children.\n  我不关心你在哪里生活或者你拥有多少金钱，\n我想知道，\n在一个悲伤、绝望、厌世和痛彻骨髓的夜晚之后，\n你是否能起床，为养育孩子做那些需要的事情。\n  It doesn\u0026rsquo;t interest me\nwho you know\nor how you came to be here.\nI want to know if you will stand\nin the centre of the fire\nwith me\nand not shrink back.\n  我不关心你是谁，你是如何来到这里，\n我想知道，你是否愿同我一起站在烈焰的中心，毫不退缩。\n  It doesn\u0026rsquo;t interest me\nwhere or what or with whom\nyou have studied.\nI want to know\nwhat sustains you\nfrom the inside\nwhen all else falls away.\n  我不关心你在哪里受到教育、你学了什么或者你同谁一起学习，\n我想知道，\n当一切都背叛了你，是什么在内心支撑着你前行。\n  I want to know\nif you can be alone\nwith yourself\nand if you truly like\nthe company you keep\nin the empty moments.\n  我想知道，\n你是否能孤独地面对你自己，\n你是否真正喜欢那个你独自一人时交谈的声音。\n ","permalink":"/blog/2021/11/16/%E4%BD%A0%E4%B8%BA%E7%94%9F%E5%AD%98%E5%81%9A%E4%BA%9B%E4%BB%80%E4%B9%88%E6%88%91%E4%B8%8D%E5%85%B3%E5%BF%83/","summary":"The Invitation by Oriah ——〔加拿大〕 Oriah（译者：野竹林） It doesn\u0026rsquo;t interest me what you do for a living. I want to know what you ache for and if you dare to dream of meeting your heart\u0026rsquo;s longing. 你为生存做了些什么，我不关心； 我想","title":"《你为生存做些什么，我不关心》"},{"content":"刚刚一口气读完了一本小说《天黑以后》。我特别喜欢这样的阅读方式，从头读到尾，酣畅淋漓。然而每当我稍读到稍有蕴意或难懂的文字时，下方便被画了\u0026quot;重点\u0026quot;！这种感觉就像是品尝佳肴时一口吃到了苍蝇！想起了益辉的文非加粗描红不能读也？ 奈何,连纸质书也要沦陷了吗？\n","permalink":"/blog/2021/11/16/%E6%96%87%E9%9D%9E%E5%8A%A0%E7%B2%97%E6%8F%8F%E7%BA%A2%E4%B8%8D%E8%83%BD%E8%AF%BB%E4%B9%9F/","summary":"刚刚一口气读完了一本小说《天黑以后》。我特别喜欢这样的阅读方式，从头读到尾，酣畅淋漓。然而每当我稍读到稍有蕴意或难懂的文字时，下方便被画了\u0026","title":"文非加粗描红不能读也？"},{"content":"一、注册 Github 帐号 （1）.前往 github.com 注册一个帐号。（注意：慎重考虑注册的用户名，如果你不购买别的域名，这个用户名将是你网站域名的一部分）\n（2）在 Github 中创建一个名为 你的仓库名字.github.io 的仓库。\n二、安装 Git （1）下载安装。前往 这里 ，点击下载 Git-**-64-bit.exe。然后安装，不懂的话一直 next 。\n（2）配置。在 win10 搜索 cmd ，打开命令提示符，输入 git config --global user.email \u0026quot;你注册Github所用的邮箱\u0026quot; 回车执行，再输入 git config --global user.name \u0026quot;你的昵称\u0026quot; 回车执行。\n注意：这种方式打开命令窗口会默认进入 C 盘的用户目录。如果需要切换到其他目录，比如我们后面所用的 D:/hugo/site/blog 目录，则需要先执行 D: 切换盘符，然后执行 cd hugo/site/blog，其中 cd 就是进入目录的命令，后面是需要进入的文件夹，有时候我们需要返回上一层目录，则可以执行 cd .. 来完成。后面会有相关操作。\n三、安装 Hugo （1）首先在 D 盘创建一个新文件夹 hugo，然后在里面创建 bin 和 site 两个文件夹。bin 将用来放 Hugo 的可执行文件，site 将用来放你的网站的源代码。\n（2）前往https://github.com/spf13/hugo/releases，找到并下载 hugo_Windows-64bit.zip。解压，如果是一个 hugo_windows_amd64.exe 文件，将它改名为 hugo.exe。\n（3）将这个 hugo.exe 文件移动到刚刚创建的 bin 文件夹里。\n（4）配置环境变量。在 win10 搜索环境变量，进去找到系统变量中的 Path，双击编辑，在弹出的界面点新建，然后将 D:\\hugo\\bin 复制进去，最后连续确定。\n（5）验证。重新打开命令窗口（关闭上一步骤使用的），输入执行 hugo help，如果你能看到下图所示的 Hugo 帮助文档，就证明配置成功，否则重新执行上一步骤。\n","permalink":"/post/2021/11/15/%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/","summary":"一、注册 Github 帐号 （1）.前往 github.com 注册一个帐号。（注意：慎重考虑注册的用户名，如果你不购买别的域名，这个用户名将是你网站域名的一部分） （2）在 Github 中","title":"准备工作"},{"content":"教程开始前，先来介绍一下最终的成果，以便确认是否符合你的需求。本篇教程以 Hugo 和 Github Pages 为基础，创建一个静态的网站。这个过程仅需要一台联网的电脑，不需要其他花费（注意：如果你想自定义域名，则需要自行购买域名，后面会有相关介绍）。下文提到的概念理论只需要有一个模糊的认识就足够了，不需要理解透彻，因为在后续文章中会具体介绍其用法，届时就会有更直观的认识了。\nHugo 和 Github Pages 稍后会介绍，我们先来了解什么是静态网站。静态网站是由静态网页文件（也就是HTML文件)组成，它不需要服务器运行，也不需要数据库。我们将组成网站的这些网页文件上传到服务器上，别人就可以在互联网上通过这台服务器的地址或域名（例如 www.lzxqaq.com)访问这些网页文件，这就是静态网站的大致原理。\n不过，这里所说的服务器并非我们日常所用的电脑，因为我们日常所用的电脑都是在局域网里，是不能让整个互联网的人都能访问到的。所以一般都要用所谓的云服务器，例如阿里云服务器、华为云服务器等等。不过现在有一些平台提供了免费的站点服务，我们就不需要购买昂贵的服务器了。例如本教程中使用的 Github Pages 服务，我们可以将网站托管到 Github 平台上，让平台帮我们把网站跑起来并在互联网上可以访问。\n这里提到的 Github 是一个代码托管平台，也是全世界最大的开源社区。在本教程中，我们只需要知道，它是帮我们帮网站跑起来的就行了。我们在自己的电脑上创建网站，然后将这些网页文件上传到 Github 平台，而 Github 会帮我们运行网站，这样网站就可以访问了。另外，我们还需要在 Github 下载网站主题（这会在后续介绍）。如何将我们的网站文件上传到 Github 或者从 Github 下载东西呢？这里我们会用到 Git 这个工具。\n那么如何建立网站呢？需要去学习网页技术吗？答案是不需要，我们将使用静态网站生成器来完成这项繁琐的工作。在本教程里，我们会使用 Hugo 这款出色的静态网站生成器。我们只需要挑选别人制作好的博客模板，根据某种规则去生成网站就好了（这里说的规则可以简单理解成约定好的文本格式，我们在约定好的文本格式下写文字，网站生成器会将这些文字翻译成网页文件）。所以我们只需要关注网站的文本，也就是展示的文章那些。（理想状态下，就类似我们写微博、发说说，编辑好文本发送出去就可以了）\n简单来说，我们的工作流程是：在自己的电脑上，用一个静态网站生成器工具生成网页文件，然后将网站文件上传到某个平台上，这样别人就可以访问我们的网站了。如果修改网站（比如添加文章），也是重复上述步骤：重新生成网页文件，重新上传。\n后续文章我会细述搭建网站的具体步骤，尽可能考虑新手建站的情况。如果你在这过程中遇到问题，欢迎在评论中指出或着与我联系。\n","permalink":"/post/2021/11/14/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/","summary":"教程开始前，先来介绍一下最终的成果，以便确认是否符合你的需求。本篇教程以 Hugo 和 Github Pages 为基础，创建一个静态的网站。这个过程仅需要一台联网的电脑，不","title":"基础概念"},{"content":"回顾过去，我刚接触互联网时，还是 2G 时代，那时各类论坛博客和聊天室正蓬勃发展。这种跨越时空的交流方式让我感到非常新奇，看着屏幕吐出文字的时候，就感觉打开了一个新世界的大门。通过一根根网线，就可以将世界连起来，人们可以在其中感知世界并畅所欲言。有趣的是，当时还是小学生的我，已经在一款网页文字游戏中建立队伍，和几十位素不相识的伙伴一起在游戏江湖里打拼了……\n不过随着QQ、微信和微博等便捷交流平台的发展，传统博客和论坛逐渐淡出人们的视线。然而人们在选择这些便捷的平台时，也被其束缚着。特别是在内容分发推荐和主流媒体导流的当下，人们获取信息的的渠道看似变多了，但是这过程已经从主动变成了被动，我不认为这是什么好事。\n“I web, therefore I am a spiderman.”，这是 hugo-ivy 主题作者谢益辉在他 blogdown一书提到的个人网站的作用，我深以为然。在当下，个人网站用来交流分享、内容创造或者记录人生仍是一个非常棒的选择。\n值得高兴的是，个人网站搭建技术从未停下发展的脚步，现在搭建一个个人网站已经是一件很容易的事了～如果你拥有了它，那么你便在这嘈杂的网络世界有了一方净土。这需要感谢开源，感谢前人的努力。因为他们的努力，让搭建网站这类技术活变得更简单，让这世界充满自由与奉献的星光。\n但即便如此，为了更自由、更多元化的需求，搭建和管理网站仍需要足够的耐心，特别是对于不了解这方面的人。为了前人的付出让更多的人知晓，让自由的表达有更多选择，我在这里开启系列教程，将搭建个人网站的步骤一一讲述。虽然有很多人做过类似的工作，但我还是希望我能做得更详细、更简单，为有需要的朋友省下一番功夫。注意，本系列教程默认读者为零基础的读者，所以会涉及很多基础概念，有一定基础的读者建议去查找其他教程。同时，因为技术会不停地发展，本教程的一些信息可能已经过时，如果你发现任何问题或者有改进建议，请在评论（需要注册 Github 帐号）指出或者联系我，我会及时更新。在此，感谢支持。\n 当你面对一个陌生领域的挑战时，最困难的往往是开始动手这个决定。\n ","permalink":"/post/2021/11/14/%E5%BC%80%E7%AF%87/","summary":"回顾过去，我刚接触互联网时，还是 2G 时代，那时各类论坛博客和聊天室正蓬勃发展。这种跨越时空的交流方式让我感到非常新奇，看着屏幕吐出文字的时候，","title":"开篇"},{"content":"还在想什么呢？不创造价值，谈什么需求？果然还是要马上行动起来！\n","permalink":"/blog/2021/11/14/%E5%B9%B4%E8%BD%BB%E4%BA%BA%E8%A6%81%E5%A4%9A%E5%81%9A%E4%BA%8B%E5%95%8A/","summary":"还在想什么呢？不创造价值，谈什么需求？果然还是要马上行动起来！","title":"年轻人要多做事啊"},{"content":"一、构建 构建时添加 QT += testlib 。\n二、测试类 测试类必须从 QObject 继承，头文件 include \u0026lt;QTest\u0026gt; ，并将测试函数声明 private slot\n三、QVERIFY(condition) 宏 检查 condition（条件）是否为真。如果为真，则继续执行。如果没有，则测试日志中会记录失败，并且不会进一步执行测试。\n如果需要在测试失败报告中加入附加信息，可以使用 QVERIFY2(condition, message)。\n如果需要测试日志有更详细的输出，可以使用 QCOMPARE(actual, expected)。\n四、QCOMPARE(actual, expected)宏 使用相等运算符将 actual （实际值）与 expected （预期值）进行比较。如果实际和预期匹配，则继续执行。如果不是，则在测试日志中记录失败，并且测试函数返回而不尝试任何后续检查。\n如果比较失败，QCOMPARE() 会尝试输出值的内容，因此可以从测试日志中看到比较失败的原因。\n对于你自己的类，你可以使用 QTest::toString () 来格式化输出到测试日志中的值。具体可参考 Qt 文档;\n五、可执行文件 如果需要将测试用例成为独立的可执行文件，需要添加以下两行：\nQTEST_MAIN(YourClassName) #include \u0026#34;yourfilename.moc\u0026#34; ","permalink":"/post/2021/10/13/qt%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/","summary":"一、构建 构建时添加 QT += testlib 。 二、测试类 测试类必须从 QObject 继承，头文件 include \u0026lt;QTest\u0026gt; ，并将测试函数声明 private slot 三、QVERIFY(condition) 宏 检查 con","title":"Qt单元测试基础笔记"},{"content":"Qt 测试最佳实践 我们建议您为错误修复和新功能添加 Qt 测试。在您尝试修复错误之前，添加一个回归测试（理想情况下是自动的），该测试在修复之前失败，表现出错误，并在修复之后通过。在开发新功能时，添加测试以验证它们是否按预期工作。\n符合一组编码标准将使 Qt 自动测试更有可能在所有环境中可靠地工作。例如，有些测试需要从磁盘读取数据。如果没有为如何完成设置标准，则某些测试将无法移植。例如，假设其测试数据文件位于当前工作目录中的测试仅适用于源代码构建。在影子构建中（在源目录之外），测试将无法找到其数据。\n以下章节包含了编写Qt测试的指南。\n 一般原则 编写可靠的测试 改进测试输出 编写可测试的代码 设置测试机  一般原则 下面的章节提供了编写单元测试的一般指南。\n 验证测试 赋予测试函数描述性的名称 编写自带的测试函数 测试全栈 让测试快速完成 使用数据驱动的测试 使用覆盖工具 选择适当的机制来排除测试 避免Q_ASSERT  验证测试 编写并提交你的测试以及你的修复或新功能到一个新的分支上。一旦你完成了,你可以检查出你的工作所基于的分支,然后把你的新测试的测试文件检查到这个分支。这可以让你验证测试是否在前一个分支上失败了,因此确实抓住了一个错误或测试了一个新功能。\n例如，如果使用Git版本控制系统，则修复 QDateTime 类中的错误的工作流程可能如下所示：\n 1.为您的修订和测试创建一个分支： git checkout -b fix-branch 5.14\n2.编写一个测试并修复错误。\n3.用修复版和新的测试版进行构建和测试,以验证新的测试版是否能通过修复版。\n4.将修复程序和测试添加到您的分支： git add tests/auto/corelib/time/qdatetime/tst_qdatetime.cpp src/corelib/time/qdatetime.cpp\n5.提交修复程序并测试您的分支机构： git commit -m \u0026lsquo;Fix bug in QDateTime\u0026rsquo;\n6.要验证测试是否确实捕获了需要您修复的内容，请检出您自己的分支所基于的分支： git checkout 5.14\n7.仅将测试文件检出到5.14分支： git checkout fix-branch \u0026ndash; tests/auto/corelib/time/qdatetime/tst_qdatetime.cpp\n现在只有测试在fix-branch上。其余的源代码树仍在5.14上。\n8.构建并运行测试,以验证它在5.14上失败,因此确实抓住了一个错误。\n9.您现在可以返回到fix分支： git checkout fix-branch\n10.或者，您可以在5.14上将工作树恢复到干净状态： git checkout HEAD \u0026ndash; tests/auto/corelib/time/qdatetime/tst_qdatetime.cpp\n 当你在审查一个变更时,你可以调整这个工作流程,以检查该变更是否确实带有测试它确实修复的问题。\n为测试函数提供描述性名称 命名测试用例很重要。测试名称出现在测试运行的失败报告中。对于数据驱动的测试，数据行的名称也会出现在失败报告中。这些名字让阅读报告的人初步了解出了什么问题。\n测试函数名称应该让函数试图测试的内容一目了然。不要简单地使用错误跟踪标识符，因为如果替换错误跟踪器，标识符就会过时。此外，并非所有用户都可以访问某些错误跟踪器。当测试代码的后续读者可能对错误报告感兴趣时，您可以在测试的相关部分旁边的评论中提及它。\n同样，在编写数据驱动的测试时，为测试用例提供描述性名称，表明每个测试用例关注功能的哪个方面。不要简单地给测试用例编号，也不要使用错误跟踪标识符。阅读测试输出的人将不知道数字或标识符的含义。如果相关，您可以在提及错误跟踪标识符的测试行上添加注释。\n编写自包含的测试函数 在一个测试程序中，测试功能应该相互独立，并且它们不应该依赖于之前已经运行过的测试功能。您可以通过使用tst_foo testname.\n不要在多个测试中重复使用被测类的实例。测试实例（例如小部件）不应该是测试的成员变量，但最好在堆栈上实例化，以确保即使测试失败也能进行适当的清理，这样测试不会相互干扰。\n测试全栈 如果 API 是根据可插拔或特定于平台的后端来实现的，这些后端执行繁重的工作，请确保编写涵盖代码路径一直到后端的测试。使用模拟后端测试上层 API 部分是将 API 层中的错误与后端隔离的好方法，但它是对使用真实世界数据运行实际实现的测试的补充。\n使测试快速完成 测试不应因不必要的重复、使用不当的大量测试数据或引入不必要的空闲时间而浪费时间。\n对于单元测试尤其如此，其中每一秒额外的单元测试执行时间都会使跨多个目标的分支的 CI 测试花费更长的时间。请记住，单元测试与负载和可靠性测试是分开的，其中需要大量的测试数据和更长的测试运行时间。\n基准测试通常会多次执行相同的测试，应位于单独的tests/benchmarks目录中，并且不应与功能单元测试混合使用。\n使用数据驱动测试 数据驱动的测试可以更轻松地为后期错误报告中发现的边界条件添加新测试。\n使用数据驱动的测试而不是在测试中按顺序测试多个项目可以节省非常相似的代码的重复，并确保即使较早的案例失败也能测试后续案例。它还鼓励系统和统一的测试，因为对每个数据样本应用相同的测试。\n使用覆盖工具 使用诸如Froglogic Coco Code Coverage或gcov 之类的覆盖工具来帮助编写测试，以覆盖被测试函数或类中尽可能多的语句、分支和条件。在新功能的开发周期中越早完成此操作，稍后在重构代码时就越容易捕获回归。\n选择适当的机制来排除测试 选择适当的机制来排除不适用的测试很重要：QSKIP ()，使用条件语句排除部分测试功能，或不为特定平台构建测试。\n使用QSKIP () 来处理在运行时发现整个测试函数在当前测试环境中不适用的情况。当只跳过测试函数的一部分时，可以使用条件语句，可选择qDebug()调用以报告跳过不适用部分的原因。\n数据驱动测试的测试功能或数据行可以限于特定平台，或使用#if. 但是，在使用跳过测试功能时要注意moc限制#if。该moc预处理器不具备访问所有builtin被经常用于编译器的特征检测编译器的宏。因此，moc预处理器条件的结果可能与其余代码看到的结果不同。这可能会导致moc为实际编译器跳过的测试槽生成元数据，或省略实际编译到类中的测试槽的元数据。在第一种情况下，测试将尝试运行未实现的插槽。在第二种情况下，即使应该尝试运行测试槽，测试也不会尝试。\n如果整个测试程序不适用于特定平台或除非启用了特定功能，最好的方法是使用父目录的.pro文件来避免构建测试。例如，如果tests/auto/gui/someclass测试对 macOS 无效，请将以下行添加到tests/auto/gui.pro：\nmac*: SUBDIRS -= someclass 避免Q_ASSERT 该Q_ASSERT宏将导致程序中止时断言的情况false，但前提是软件始建于调试模式。在 release 和 debug-and-release 版本中，Q_ASSERT什么都不做。\nQ_ASSERT 应该避免，因为它使测试的行为取决于是否正在测试调试版本，并且因为它会导致测试立即中止，跳过所有剩余的测试函数并返回不完整或格式错误的测试结果。\n它还会跳过本应在测试结束时进行的任何拆卸或整理，因此可能会使工作区处于不整洁状态，这可能会导致进一步测试的复杂化。\n应Q_ASSERT使用QCOMPARE () 或QVERIFY () 宏变体而不是 。它们使当前测试报告失败并终止，但允许执行剩余的测试功能和整个测试程序正常终止。QVERIFY2 () 甚至允许在测试日志中记录描述性错误消息。\n编写可靠的测试 以下部分提供了编写可靠测试的指南：\n 避免验证步骤中的副作用 避免固定超时 谨防依赖于时间的行为 避免位图捕获和比较  避免验证步骤中的副作用 在使用QCOMPARE ()、QVERIFY () 等执行自动测试中的验证步骤时，应避免副作用。验证步骤中的副作用会使测试难以理解。此外，当测试更改为使用QTRY_VERIFY ()、QTRY_COMPARE () 或QBENCHMARK ()时，他们可以很容易地以难以诊断的方式破坏测试。这些可以多次执行传递的表达式，从而重复任何副作用。\n当副作用不可避免时，确保在测试函数结束时恢复先前的状态，即使测试失败。这通常需要使用在函数返回时恢复状态的 RAII（资源获取即初始化）类或cleanup()方法。不要简单地将恢复代码放在测试结束时。如果部分测试失败，此类代码将被跳过并且不会恢复之前的状态。\n避免固定超时 避免使用硬编码超时，例如QTest::qWait () 来等待某些条件变为真。考虑使用QSignalSpy类、QTRY_VERIFY () 或QTRY_COMPARE () 宏，或将QSignalSpy类与QTRY_宏变体结合使用。\n该qWait()函数可用于在执行某些操作和等待该操作触发的某些异步行为完成之间设置一段固定时间的延迟。例如，更改小部件的状态，然后等待小部件重新绘制。但是，当在工作站上编写的测试在设备上执行时，此类超时通常会导致失败，在这种情况下，预期行为可能需要更长时间才能完成。在最慢的测试平台上将固定超时增加到比所需值大几倍的值并不是一个好的解决方案，因为它会减慢所有平台上的测试运行速度，特别是对于表驱动测试。\n如果被测代码在异步行为完成时发出 Qt 信号，更好的方法是使用QSignalSpy类通知测试函数现在可以执行验证步骤。\n如果没有 Qt 信号，请使用QTRY_COMPARE()和QTRY_VERIFY()宏，它会定期测试指定的条件，直到它变为真或达到某个最大超时。这些宏可防止测试花费比必要时间更长的时间，同时避免在工作站上编写测试并随后在嵌入式平台上执行时出现中断。\n如果没有 Qt 信号，并且您正在编写测试作为开发新 API 的一部分，请考虑 API 是否可以从添加报告异步行为完成的信号中受益。\n谨防依赖于时间的行为 一些测试策略容易受到某些类的时间相关行为的影响，这可能导致测试仅在某些平台上失败或不返回一致的结果。\n这方面的一个例子是文本输入小部件，它通常有一个闪烁的光标，可以根据捕获位图时光标的状态使捕获的位图的比较成功或失败。这又可能取决于执行测试的机器的速度。\n在测试根据计时器事件更改其状态的类时，在执行验证步骤时需要考虑基于计时器的行为。由于依赖于时序的行为多种多样，因此没有针对此测试问题的单一通用解决方案。\n对于文本输入小部件，潜在的解决方案包括禁用光标闪烁行为（如果 API 提供该功能），在捕获位图之前等待光标处于已知状态（例如，如果 API提供一个)，或者从位图比较中排除包含光标的区域。\n避免位图捕获和比较 虽然有时需要通过捕获和比较位图来验证测试结果，但它可能非常脆弱且需要大量劳动。\n例如，特定小部件在不同平台上可能有不同的外观或具有不同的小部件样式，因此可能需要多次创建参考位图，然后在未来随着 Qt 支持的平台集的发展进行维护。因此，进行影响位图的更改意味着必须在每个支持的平台上重新创建预期的位图，这将需要访问每个平台。\n位图比较也会受到测试机器的屏幕分辨率、位深度、活动主题、配色方案、小部件样式、活动区域设置（货币符号、文本方向等）、字体大小、透明度效果和选择等因素的影响的窗口管理器。\n在可能的情况下，使用编程方式，例如验证对象和变量的属性，而不是捕获和比较位图。\n改进测试输出 以下部分提供了生成可读且有用的测试输出的指南：\n 显式忽略预期警告 显式忽略预期警告 编写结构良好的诊断代码  显式忽略预期警告 如果预期测试会导致 Qt 在控制台上输出警告或调试消息，则应调用QTest::ignoreMessage () 将该消息从测试输出中过滤掉，如果没有输出消息，则测试失败。\n如果只有在调试模式下构建 Qt 时才会输出这样的消息，请使用QLibraryInfo::isDebugBuild () 来确定 Qt 库是否是在调试模式下构建的。使用#ifdef QT_DEBUG是不够的，因为它只会告诉您测试是否是在调试模式下构建的，并且不能保证 Qt 库也是在调试模式下构建的。\n避免打印来自自动测试的调试消息 自动测试不应产生任何未处理的警告或调试消息。这将允许 CI Gate 将新警告或调试消息视为测试失败。\n在开发过程中添加调试消息很好，但是在签入测试之前应该禁用或删除这些消息。\n编写结构良好的诊断代码 如果测试失败，任何有用的诊断输出都应该是常规测试输出的一部分，而不是被注释掉、被预处理器指令禁用或仅在调试版本中启用。如果在持续集成期间测试失败，与启用诊断代码和再次测试相比，在 CI 日志中包含所有相关的诊断输出可以为您节省大量时间。特别是，如果故障发生在您的桌面上没有的平台上。\n测试中的诊断消息应该使用 Qt 的输出机制，例如qDebug()and qWarning()，而不是stdio.horiostream.h输出机制。后者绕过 Qt 的消息处理并阻止-silent命令行选项抑制诊断消息。这可能会导致在大量调试输出中隐藏重要的失败消息。\n编写可测试的代码 以下部分提供了编写易于测试的代码的指南：\n 打破依赖 将所有类编译到库中  打破依赖 单元测试的想法是单独使用每个类。由于许多类实例化了其他类，因此不可能单独实例化一个类。因此，您应该使用一种称为依赖注入的技术，它将对象创建与对象使用分开。工厂负责构建对象树。其他对象通过抽象接口操作这些对象。\n这种技术适用于数据驱动的应用程序。对于 GUI 应用程序，这种方法可能很困难，因为对象经常被创建和销毁。为了验证依赖于抽象接口的类的正确行为，可以使用模拟。例如，请参阅Googletest Mocking (gMock) 框架。\n将所有类编译到库中 在中小型项目中，构建脚本通常会列出所有源文件，然后一次性编译可执行文件。这意味着测试的构建脚本必须再次列出所需的源文件。\n在脚本中只列出一次源文件和头文件来构建静态库会更容易。然后该main()函数将链接到静态库以构建可执行文件，并且测试将链接到静态库。\n对于在构建多个程序时使用相同源文件的项目，将共享类构建到每个程序（包括测试程序）可以在运行时加载的动态链接（或共享对象）库中可能更合适. 同样，将编译后的代码放在库中有助于避免重复描述组合哪些组件来制作各种程序。\n设置测试机 以下部分讨论由测试机设置引起的常见问题：\n 屏幕保护程序 系统对话框 显示使用 窗口管理器  所有这些问题通常都可以通过明智地使用虚拟化来解决。\n屏幕保护程序 屏幕保护程序可能会干扰 GUI 类的某些测试，从而导致测试结果不可靠。应禁用屏幕保护程序以确保测试结果一致和可靠。\n系统对话框 操作系统或其他正在运行的应用程序意外显示的对话框可能会从自动测试中涉及的小部件中窃取输入焦点，从而导致不可重现的故障。\n典型问题的示例包括 macOS 上的在线更新通知对话框、病毒扫描程序的误报、病毒签名更新等计划任务、推送到工作站的软件更新以及在堆栈顶部弹出窗口的聊天程序。\n显示使用 某些测试使用测试机器的显示器、鼠标和键盘，因此如果机器同时用于其他用途或并行运行多个测试，则可能会失败。\nCI 系统使用专用测试机来避免此问题，但如果您没有专用测试机，则可以通过在第二台显示器上运行测试来解决此问题。\n在 Unix 上，还可以在嵌套或虚拟 X 服务器上运行测试，例如 Xephyr。例如，要在 Xephyr 上运行整套测试，请执行以下命令：\nXephyr :1 -ac -screen 1920x1200 \u0026gt;/dev/null 2\u0026gt;\u0026amp;1 \u0026amp; sleep 5 DISPLAY=:1 icewm \u0026gt;/dev/null 2\u0026gt;\u0026amp;1 \u0026amp; cd tests/auto make DISPLAY=:1 make -k -j1 check NVIDIA 二进制驱动程序的用户应该注意 Xephyr 可能无法提供 GLX 扩展。强制 Mesa libGL 可能会有所帮助：\nexport LD_PRELOAD=/usr/lib/mesa-diverted/x86_64-linux-gnu/libGL.so.1 但是，当在 Xephyr 和具有不同 libGL 版本的真实 X 服务器上运行测试时，QML 磁盘缓存可能会使测试崩溃。为避免这种情况，请使用QML_DISABLE_DISK_CACHE=1.\n或者，使用屏幕外插件：\nTESTARGS=\u0026#34;-platform offscreen\u0026#34; make check -k -j1 窗口管理器 在 Unix 上，至少有两个自动测试（tst_examples和tst_gestures）需要运行窗口管理器。因此，如果在嵌套的 X-server 下运行这些测试，您还必须在该 X-server 中运行窗口管理器。\n您的窗口管理器必须配置为自动定位显示器上的所有窗口。一些窗口管理器，例如 Tab Window Manager (twm)，具有手动定位新窗口的模式，这会阻止测试套件在没有用户交互的情况下运行。\n注意： Tab Window Manager 不适合运行完整的 Qt 自动测试套件，因为tst_gestures自动测试会导致它忘记其配置并恢复到手动窗口放置。\n","permalink":"/collection/2021-10-13-2/","summary":"Qt 测试最佳实践 我们建议您为错误修复和新功能添加 Qt 测试。在您尝试修复错误之前，添加一个回归测试（理想情况下是自动的），该测试在修复之前失败，表","title":"【转载】Qt测试最佳实践"},{"content":"  ——趙子健\n    我那些残梦 灵异九霄\n徒忙漫奋斗 满目沧桑\n在滑翔之后 完美坠落\n在四维宇宙 炫目遨游\n    我那些烂曲 流窜九州\n云游魂飞奏 音愤符吼\n在宿命身后 不停挥手\n视死如归仇 毫无保留\n    黑色的不是夜晚\n是漫长的孤单\n看脚下一片黑暗\n望头顶星光璀璨\n叹世万物皆可盼\n唯真爱最短暂\n失去的永不复返\n世守恒而今倍还\n    摇旗呐喊的热情\n携光阴渐远去\n人世间悲喜烂剧\n昼夜轮播不停\n纷飞的滥情男女\n情仇爱恨别离\n一代人终将老去\n但总有人正年轻\n  ","permalink":"/blog/2021/09/28/%E7%81%AB%E8%BD%A6%E9%A9%B6%E5%90%91%E4%BA%91%E5%A4%96%E6%A2%A6%E5%AE%89%E9%AD%82%E4%BA%8E%E4%B9%9D%E9%9C%84/","summary":"——趙子健 我那些残梦 灵异九霄 徒忙漫奋斗 满目沧桑 在滑翔之后 完美坠落 在四维宇宙 炫目遨游 我那些烂曲 流窜九州 云游魂飞奏 音愤符吼 在宿命身后 不停挥手 视死","title":"火车驶向云外，梦安魂于九霄"},{"content":"前些天中秋假期，我和几个朋友出去玩。泡温泉的时候，一位久未见面的朋友一针见血地指出我胖了好多！\n是啊，以前我还是挺瘦的，从去年疫情在家开始，体重就压抑不住狂涨了，一直心念的减肥计划也没怎么实施。\n即便如此，我还是要说，其实我对吃并无多大兴趣。可能我真得了厌食症。我曾和一位朋友讨论过，饥饿是一种怎样的感觉，因为那时我单知道饿了，肚子会咕咕叫，但别的反应却是没有。后来我才知道，肚子饿了，会全身乏力，还会明显感觉到胃在“造反”。\n无论如何，这终究是不对的。我们不能只盯着自己的盘子，我们得关心粮食和蔬菜，关心别人的胃口。“客从远方来，遗我双鲤鱼，中有尺素书，长跪读素书，书中意如何？上言加餐饭，下言长相思。”\n在这方面我算是糟透了吧，很多时候我都在思考和朋友的关系。我QQ空间还留着一个留言，那时初中我同桌对我说，我一个朋友也没有，因为我总欺负她。〒▽〒\n其实我也有一肚子“愿君勉强多饭之”，但是话到嘴边，无处说，无法说。这就是生活的无奈吧。\n努力加餐，勿念之！\n","permalink":"/blog/2021/09/23/%E4%BD%A0%E5%90%83%E4%BA%86%E5%90%97/","summary":"前些天中秋假期，我和几个朋友出去玩。泡温泉的时候，一位久未见面的朋友一针见血地指出我胖了好多！ 是啊，以前我还是挺瘦的，从去年疫情在家开始，体","title":"你吃了吗"},{"content":" 神啊\n全知全能的神啊\n请你告诉我\n哪里需要我\n我要到哪里去\n怎样才能给他人带来快乐？\n ","permalink":"/blog/2021/08/09/%E7%A5%9E%E7%9A%84%E6%97%A8%E6%84%8F/","summary":"神啊 全知全能的神啊 请你告诉我 哪里需要我 我要到哪里去 怎样才能给他人带来快乐？","title":"神的旨意"},{"content":"在我看来，在小说故事的表现能力上看，动画是优于文字的，而影视则是最末。为什么是这样？我举个例子。这个例子关于小说《绿山墙的安妮》和动画《红发少女安妮》。（没看过的朋友一定要去看哦）\n在我看完动画之后，深受触动，想找原小说继续看。因为原著作者是加拿大作家，语言不通，我只好找来翻译版本。但是看了一段，感觉和自己预期落差很大。举个典型的例子，故事中的安妮给那个苹果树大道取名，在小说翻译版本中，有译为”白色的欢乐之路”的、也有译为“喜悦雪路”、“愉悦之路”等等，贝瑞家的池塘，有译为“阳光水湖”、“闪光小湖”等等。这样的文字，不但让人难以理解、更不能让人产生“内心颤动”的感觉。而在动画中，它们被译为“喜悦的银白色长廊”、“波光粼粼之湖”。“喜悦的银白色长廊”、“波光粼粼之湖”显然更具备画面感，也更容易让人理解安妮的形象。那为什么会产生这样的差距呢？是那些小说里翻译家的水平比不上动画里的汉译组吗？\n我认为不是，问题出于文字和动画表现能力的差异上。文字描述更难让人发挥想象力，那些小说的翻译家，他们难以想象那个画面，自然就更难表达出来。而动画里不同，简单勾勒的线条、鲜明的色彩，朦胧的画面和丰富的想象力在人的脑海里迸发，所以“喜悦的银白色长廊”和“波光粼粼之湖”的出现也不足为奇了。\n当然了，如何要考虑细枝末节的话，先前的结论就存在争议了。比如说恰当的文字描述和糟糕的动画效果。恰倒好处的文字的表现力并不见得比动画弱，而现在那些精美程度可以和影视剧相较高下的动画，也不见得给人多大的想象空间，影视剧就不提了，我认为它们扼杀了人类的想象力。\n","permalink":"/blog/2021/07/29/%E6%96%87%E5%AD%97vs%E5%8A%A8%E7%94%BB/","summary":"在我看来，在小说故事的表现能力上看，动画是优于文字的，而影视则是最末。为什么是这样？我举个例子。这个例子关于小说《绿山墙的安妮》和动画《红发","title":"文字vs动画"},{"content":"提高质量和生产率是软件工程要解决的核心问题。\n软件开发：正确性、健壮性、可靠性、效率、易用性、可读性（可理解性）、可扩展性、可复用性、兼容性、可移植性等。\n只记录实际目前为止比较困惑的。\n头文件的结构 1.为了防止头文件被重复引用，应当用 ifndef/define/endif 结构产生预处理块。\n2.用 #include\u0026lt;filename.h\u0026gt;格式来引用非标准库的头文件（编译器将会从标准库目录开始搜索；用 #include\u0026lt;Îy \u0026ldquo;filename.h\u0026rdquo; 格式来引用非标准库的头文件（编译器将从用户的工作目录开始搜索）。（注：一般将 \u0026lt;\u0026gt; 格式的放在前， \u0026ldquo;\u0026ldquo;格式的放在后，为了统一风格）\n3.头文件只存放“声明”而不存放“定义”。（C++中，类的成员函数可以在声明的同时被定义，并且自动成为内联函数。但这样做会造成风格不一致，弊大于利！\n4.不提倡使用全局变量，尽量不要在头文件中出现 extern int value 这类声明。\n头文件作用：   （1）通过头文件来调用库功能。在很多场合，源代码不便（或不准）向用户公布，只要向用户提供头文件和二进制的库即可。用户只需要按照头文件中的借口声明来调用库的功能，而不必关心接口怎么实现的。编译器会从库中提取相应的代码。\n  （2）头文件能加强类型安全检查。如果某个接口被实现或被使用时，其方式与头文件中的声明不一致，编译器就会指出错误，这一简单的规则能大大减轻程序员调试、改错的负担。\n  目录结构 如果一个软件的头文件数目比较多（如超过十个），通常应将头文件和定义文件分别保存于不同的目录，以便于维护。\n例如可将头文件保存于 include 目录，将定义文件保存于 source 目录（可以是多级目录）。\n如果某些头文件是私有的，它不会被用户的程序直接饮用，则没有必要公开其“声明”，可以把这些私有的头文件和定义文件存放于同一个目录。\n空行 1.类声明之后、函数定义结束之后要加空行。\n2.在一个函数体内，逻辑上密切相关的语句之间不加空行，其他地方应加空行分割。\n代码行 1.一行代码只做一件事情，如只定义一个变量，或只写一条语句。\n2.if、for、while、do 等语句自占一行，执行语句不得紧跟其后。不论执行语句有多少都要加{}。这样可以防止书写失误。（注：也为了统一风格）\n3.尽可能在定义变量的同时初始化该变量（就近原则）。（注：这样可以减少被野指针折磨的痛苦，强烈建议）\n代码行内的空格 1.关键字之后要留一个空格。像 if、for、while 等关键字之后应留一个空格再跟左括号 \u0026lsquo;(\u0026rsquo;，以突出关键字。\n2.函数名之后不要留空格，紧跟左括号\u0026rsquo;(\u0026rsquo;，以与关键字区别。\n3.\u0026rsquo;(\u0026lsquo;向后紧跟，\u0026rsquo;)\u0026rsquo;、‘，’、‘；’向前紧跟，紧跟处不留空格。\n4.\u0026rsquo;,\u0026lsquo;之后要留空格，如果\u0026rsquo;;\u0026lsquo;不是一行的结束符号，其后要留空格，如for(initialization; condition; update)。\n5.【建议】对于表达式比较长的 for 语句和 if 语句，为了紧凑起见可以适当地去掉一些空格。（注：如果真的长到影响阅读，可以考虑）\n对齐 1.‘{{’h和‘}}’应独占一行并且位于同一列，同时与引用它们的语句左对齐。\n长行拆分 1.代码行最大长度应控制在 70 至 80 个字符以内。\n2.【强烈】长表达式要在低优先级操作符处拆分成新行，操作符放在新行之首。\n","permalink":"/post/2021/07/16/%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97-%E6%9C%AA%E5%AE%8C%E5%BE%85%E7%BB%AD/","summary":"提高质量和生产率是软件工程要解决的核心问题。 软件开发：正确性、健壮性、可靠性、效率、易用性、可读性（可理解性）、可扩展性、可复用性、兼容性、","title":"开发指南-未完待续"},{"content":"前段时间，我又有了新的伙伴——小橙！\n它还转过去了。别看它背面黑不溜秋的，头顶却长着一撮橙色的头发。而且它可是有着不少巧妙的设计，顶部有开口可以放羽毛球拍，夹层刚好可以放我 13 寸的 matebook。身材不大不小刚刚好。\n这张图片是我今天打球去早了，等人的时候给它拍的。也有一段时间没和我的高中伙伴打球了，时间改变了许多事，唯独没变的是，他还记着提醒我不要忘记场地和时间！是的，以前我是一个“咕咕咕”，还是那种“你觉得我会鸽，然后我还真的鸽了……”。\n回到今天的主题，羽毛球是一项老少咸宜的运动，不仅能强身健体，还可以和朋友放松交流，而且还能减肥～接下来就聊聊我和羽毛球的一些有趣过往。\n我从高一开始接触羽毛球，那时候，学校羽毛球场特别多，但玩的人也特别多。所以每当放学铃声响起的时候，都要“biu”的一声，冲出教室，去到球场上占着。当时，教学楼外就有几个球场，那就是我们的主战场，我们从教室的窗户上可以轻易地看到下面球场的情况。虽然是室外的场地，有时候也会受到风的影响，不过我们也没那么多讲究，一伙人打着玩。那会，我算是球场熟面孔了。去到那里不管有没有认识的，能加队就一起玩了。我还记得一个初中部的小伙子。时常找我搭伙加双打。虽然那会技术上没什么长进，但就很快乐。后来分班了，我发现新同学里有两位（开头所说高中伙伴便是其一）打羽毛球很厉害，我觉得很酷，就经常和他们打球，边打边学，很有意思。\n羽毛球让我结识了许多朋友，在他们身上，在羽毛球这项运动上，我也学到许多东西。特别记得，我的第一位羽毛球老师，他在第一节课里，言行身教地教我们羽毛球必须遵守的原则和羽毛球必胜诀窍。前者是：尊重你的对手、尊重这项运动，后者是找到并针对对手的弱点。\n这是一个数十年球场经验的前辈总结出来的道理，开始我以为这很简单，慢慢的，我很庆幸曾受过他的教导。为了让前辈的球场哲学让更多的人知晓，我在前辈的基础上编写了《球场快乐指南》，望与诸君共勉。\n《球场快乐指南》  （强制）尊重你的对手 （强制）尊重该运动 （建议）对手亦好友，且行且珍惜。  ","permalink":"/blog/2021/07/10/%E7%90%83%E5%9C%BA%E5%BF%AB%E4%B9%90%E6%8C%87%E5%8D%97/","summary":"前段时间，我又有了新的伙伴——小橙！ 它还转过去了。别看它背面黑不溜秋的，头顶却长着一撮橙色的头发。而且它可是有着不少巧妙的设计，顶部有开口可","title":"《球场快乐指南》"},{"content":"前段时间，我决定自制一些饮品，为这沉闷而又炽热的夏日增添一些色彩。说做就做，先看成品。\n1.莓莓酸奶冰(不可描述的食物) 材料：草莓、蓝莓、金桔柠檬、鲜牛奶\n灵感源自《明日之后》的草莓酸奶冰（草莓、蜂蜜、牛奶、冰块），我用鲜牛奶替代了酸奶， 加了蓝莓，没有蜂蜜，最黑暗的是，为了添加酸的味道，我加了金桔柠檬……好家伙，酸中带苦。还有，原本刚做好的时候还是挺好看的，结果我拿去冰冻之后， 成了这个样子……\n2.草莓奶昔 材料：草莓、鲜牛奶\n有了上面的教训，这次终于正常点了。美中不足的是草莓籽太多了，而且甜度不够，还感觉有些稠（可能因为没加水）。\n3.火龙果奶昔\n材料：火龙果、鲜牛奶\n这个也是拿去冷冻之后的样子，喝起来味道有些古怪，这个搭配要再斟酌斟酌……\n","permalink":"/blog/2021/07/10/%E8%8E%93%E8%8E%93%E9%85%B8%E5%A5%B6%E5%86%B0/","summary":"前段时间，我决定自制一些饮品，为这沉闷而又炽热的夏日增添一些色彩。说做就做，先看成品。 1.莓莓酸奶冰(不可描述的食物) 材料：草莓、蓝莓、金桔","title":"莓莓酸奶冰"},{"content":"一、存活    操作 含义     i Insert 模式，按 ESC 回到 Normal 模式。   x 删除当前光标所在的一个字符。   :wq 保存退出   dd 删除当前行，并存到剪切板   p 粘贴剪切板   hjkl 左下上右   :help  显示相关命令的帮助    二、感觉良好 1.各种插入模式\n   操作 含义     a 在光标后插入   o 在当前行后插入一个新行   O 在当前行前插入一个新行   cw 替换从光标所在位置到一个单词结尾的字符    2.简单的光标移动\n   操作 含义     0 数字零，到行头   ^ 到本行第一个不是 blank 字符的位置（blank 字符就是空格、tab、换行、回车等）   $ 到本行行尾   g_ 到本行最后一个不是 blank 字符的位置   /pattern 搜索 pattern 的字符串（多个匹配时，按 n 到下一个）    3.拷贝/粘贴\n   操作 含义     p 粘贴   yy 拷贝当前行    4.撤销反撤销\n   操作 含义     u 撤销   ctrl-r 反撤销    5.打开/保存/退出/改变文件（Buffer)\n   操作 含义     :e \u0026lt;path/to/file\u0026gt; 打开一个文件   :w 保存   :saveas \u0026lt;path/to/file\u0026gt; 另存为   :x, ZZ 或 :wq 保存并退出(:x仅在需要时保存)   :q! 退出不保存   :qa! 强行退出所有正在编辑的文件   :n， :bn 下一个文件   :bp 上一个文件    三、更好、更强、更快 未完待续 ","permalink":"/post/2021/07/10/vim-%E6%93%8D%E4%BD%9C%E5%A4%87%E5%BF%98/","summary":"一、存活 操作 含义 i Insert 模式，按 ESC 回到 Normal 模式。 x 删除当前光标所在的一个字符。 :wq 保存退出 dd 删除当前行，并存到剪切板 p 粘贴剪切板 hjkl 左下上右 :help 显示相关","title":"vim 操作备忘"},{"content":"最近到处都可以看到中国共产党建党100周年的口号标语，本来这些和我一个吃瓜群众毫无关系，但是今天在单位被拉去凑人头参加活动。完了憋不住，想来这里嚷嚷两句。\n参加的活动是玩得很开心，领导的讲话也很振奋人心。但我总觉得哪里不对。噢，原来是没听到习大大的“不忘初心，牢记使命”。不对啊，现在不兴喊这个了吗？我赶紧翻了翻《中国共产党宣言》，不看不知道，一看吓一跳。上面怎么写着马云、马化腾的名字，是因为他们去中南海议政了吗？啊，怎么还有我的名字！我只是一个工地搬砖的，可不敢写在上面污人眼睛啊。赶紧擦了擦。噢，原来是看错了，上面写的是“资本家”和“无产阶级”……哎，眼睛蒙得太厉害了。\n另外，说一个最近的倒霉事。因为我发现最近 Github Pages 经常打不开（本网站就挂在上面），考虑到最近的政治趋势，国内封杀国外资源是迟早的事，所以趁着华为云 618 活动，我买了一年云对象存储服务。但是，用它之后访问资源的速度居然比不过免费的 Github + jsDriver ！除非我再来一个 CDN 加速服务，但是这个高昂的价格劝退了我。还好，我的服务器还有两年优惠期，还能撑一撑。\n “华为牛掰！支持华为！华为万岁！支持国产！”\n“你买华为什么东西了，用脚支持吗？这样喊两句，华为的东西能便宜点吗？没有你瞎嚷嚷啥呢！”\n PS:我目前使用的所有云产品都是“中华有为”的，仅仅是因为性价比的缘故，亦如大多国企、事业单位使用“美帝良心想”一样。\n","permalink":"/blog/2021/07/07/%E7%9E%8E%E5%9A%B7%E5%9A%B7/","summary":"最近到处都可以看到中国共产党建党100周年的口号标语，本来这些和我一个吃瓜群众毫无关系，但是今天在单位被拉去凑人头参加活动。完了憋不住，想来","title":"瞎嚷嚷"},{"content":"小黑是我的雨伞。前段时间，小黑同学不见了。当我意识到这点的时候，它已经从我的世界上消失了，我怎么也找不到它。在它不见的那段时间里，我很伤心，然后就有了——大黑。直到两个星期之后，它就那么突然地出现在我的面前。原来，它在我背包里……很好，我的战友，又回来了。\n小白是我家的新成员——一只白色的宠物狗。第一次和它见面时，它就往我身上扑。我看它身上脏兮兮的，而我穿着白衣服，但犹豫了一下，还是没有躲开。它很聪明，非常爱玩。不过我爸妈不怎么喜欢它，因为它经常会在房间里大小便（这可能是因为没人管它）。在多数时间里，它总趴在地上发呆，而且它的姿势有些奇特，要么是两手前伸搭在门沿，头枕在手上，要么像乌龟那样，四肢伸开，头侧在一边。每当有客人来的时候，它就很兴奋，到处瞎跑，往人身上扑。没人搭理它的时候，它就自个趴着发呆。不过它不喜欢自己待着，每次我回家的时候，它总会来我房间。我看电脑的时候，它在旁边趴着；我睡觉的时候，它也在旁边趴着。哎，也不知道你的家人是否尚在，是否挂念着你。\n说说近况，这周回家，我妈说我胖了好多。这句话很少见，但确实我也感觉到最近胖了不少。究其原因，一是饮食问题，二是缺少运动，二者关系密切。变胖原因一：自从上次我哥过来看我，给我带来了一个小冰箱、一个电磁炉和一些厨具，我自以为可以在厨房里大展拳脚了，结果真是一言难尽。从买菜、下厨到清洁收拾，花费的时间比较多，更关键的是，做出来的味道效果不太理想，这就很打击。而且因为买菜（特别是肉类）不好买太少，所以经常是：好不容易做出来的，含着泪也要吃完（肥胖++）……变胖原因二：晚上忙完厨房的时候，已经身心疲惫了。这个时候，运动的事情只能妥协了。\n近期计划：\n  尽量减少厨房事务，认清事实，以后闲下来的时候再好好学厨艺吧！\n  坚持运动，每天至少半小时。\n  茶艺计划。是的，厨艺不行转投茶艺～计划学着做一些果汁、柠檬茶、奶茶之类的。结果估计在下一篇文章见晓。期待^_^\n  时间管理。保证每天足够的代码实践啊（着急：），以后还要加上阅读的时间。我没有时间了！\n  ","permalink":"/blog/2021/07/03/%E7%BD%97%E5%B0%8F%E9%BB%91%E5%92%8C%E7%BD%97%E5%B0%8F%E7%99%BD/","summary":"小黑是我的雨伞。前段时间，小黑同学不见了。当我意识到这点的时候，它已经从我的世界上消失了，我怎么也找不到它。在它不见的那段时间里，我很伤心，","title":"罗小黑和罗小白"},{"content":" “嗰個人嘅樣好怪啊”\n“我都見到，好似隻狗咁哦”\n 刚刚做了个噩梦，梦到火烧到了脚，但是眼睛却怎么也挣不开，慌张之时我在心头默念：“我一定要醒来”，两下之后，眼睛猛地睁开了。只见墙上映着一道微弱的光，忽闪忽闪。\n字数有点少了不好看，那就拿来凑个数吧，《人生啊，就是这么无常……》\n","permalink":"/blog/2021/06/12/%E5%81%9A%E5%92%A9%E5%95%8A/","summary":"“嗰個人嘅樣好怪啊” “我都見到，好似隻狗咁哦” 刚刚做了个噩梦，梦到火烧到了脚，但是眼睛却怎么也挣不开，慌张之时我在心头默念：“我一定要醒来”","title":"做咩啊"},{"content":" “30°C，依旧是骑着 BWM 上班的一天，虽然它是山寨的，虽然兜里只有十块钱，但听着周杰伦的《超人不会飞》，就感觉自己也超屌的~”\n 前两天在哔哩哔哩投了两个视频，其中一个是关于网站搭建的。这个视频从计划到完成耗时两周（其实实际动手只花了两天），再次验证了计划在脑海里没有行动，就永远是空想。\n其实今年一月初我也做过这样的视频，当时主要是自己搭建网站的操作演示，因为用的环境是 Linux ，可能不适合大众。那个视频的播放量也是挺少，远没有我当时另一个介绍 Manjaro 的视频高（估计大多数人是冲着视频配图来的，后来我把视频删了）。\n为什么我对这件事这么热衷呢？其实我做完第一期视频之后，就不打算再续作了，但前段时间我意外发现本站一个读者，看到我那些个教程，也跟着搭网站，甚至把我的网站源码也复制过去了（其实我最初也是这么干的）。不过因为我把原主题改得乱七八糟了，可能会对他搭建网站造成一定的影响，所以我把自己网站整理之后给他发了一个邮件致歉，同时也给出了修改后的示例网站。也正是这个读者激发了我创作第二期教程的动力，不过现在看来效果依旧不好啊。\n实际上，我不仅写了文章，投了视频，还向身边的一些朋友推荐过，但是可惜的是并没有人感兴趣。可能也是自己太急功近利了些。是的，我做这些是有目的的。它来源于我脑海里的一个想法，不过目前尚没有实现的条件，就不说出来惊扰大家了。（读者还没有几个，你瞎操啥心）。\n是吧，现在自己最大的问题就是太沉不住气了，还是要脚踏实地做事啊。唉，自己的话影响力不高，那就借用益辉他老人家的话结尾吧：“我不和没有个人主页的人说话”。\n 益辉：“我没有说过，别瞎说，别赖我！”\n我：“我说你有你就有！”\n ","permalink":"/blog/2021/06/10/%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA%E4%B8%80%E4%BA%8C%E4%BA%8B/","summary":"“30°C，依旧是骑着 BWM 上班的一天，虽然它是山寨的，虽然兜里只有十块钱，但听着周杰伦的《超人不会飞》，就感觉自己也超屌的~” 前两天在哔哩哔哩","title":"网站搭建一二事"},{"content":"前言 小白篇和前面正经篇的区别是，懒人篇专门针对基础更浅（或者更懒的）朋友而设计，在这里不会新建一个网站，而是下载我预先准备好的示例网站，在这个示例上面做扩展。这样也是为了避免新手成功创建网站时，面对空荡荡的网站不知所措的尴尬。\n准备工作（与前篇一致） 1.注册 Github 帐号。前往 github.com 注册一个 Github 帐号。（友情提示：认真考虑注册时的用户名，它将是你网站网址的一部分）\n补充：Github 是一个代码托管平台（远程仓库），你可以将网站的源代码放在上面，Github Pages 是一个免费的静态网站服务，你将网站的源文件放在上面，它会提供一个链接，使互联网上的人都能访问你的网站。\n2.准备Git。\n（1）下载安装。前往 这里 ，点击下载 Git-**-64-bit.exe。然后安装，不懂的话一直 next 。\n（2）配置。在 win10 搜索 cmd ，打开命令提示符，输入 git config --global user.email \u0026quot;你注册Github所用的邮箱\u0026quot; 回车执行，再输入 git config --global user.name \u0026quot;你的昵称\u0026quot; 回车执行。\n3.安装 Hugo。（官方教程可看这里)\n（1）首先在 D 盘创建一个新文件夹 Hugo，然后在里面创建 bin 和 sites两个文件夹。bin 将用来放 Hugo 的可执行文件，sites 将用来放你的网站的源代码。\n（2）前往这里，找到并下载 hugo_Windows-64bit.zip。解压，如果是一个 hugo_windows_amd64.exe 文件，将它改名为 hugo.exe。\n（3）将这个 hugo.exe 文件移动到刚刚创建的 bin 文件夹里。\n（4）配置环境变量。方法1:在 win10 搜索 cmd，右键以管理员身份打开命令提示符，将 setx \u0026quot;Path\u0026quot; \u0026quot;%PATH%;D:\\Hugo\\bin\u0026quot; /m 复制粘贴上去，回车（输入命令后需回车执行，后文不再赘述）。 方法2：在 win10 搜索环境变量，进去找到系统变量中的 Path，-\u0026gt;编辑-\u0026gt;新建，然后将 D:\\Hugo\\bin 复制进去，确定。\n（5）验证。重新打开命令提示符（关闭上一步骤使用的），输入执行 hugo help，如果你能看到 hugo 的帮助文档，就验证成功，否则检查上述步骤是否出错。\n开始 1.建立博客网站\n（1）下载示例网站。打开命令提示符，执行 D: 切换 D 盘，然后执行 cd D:\\Hugo\\sites 进入 D:\\Hugo\\sites 目录（便捷方法：在文件资源管理器中进入相应目录，单击地址栏右边空白地方，在文本最左输入 cmd  加空格，回车），执行命令 git clone https://gitee.com/lzxqaq/demosite.git ，如最后出现 ** 100% ** 完成 则成功。（此时可在文件资源管理器中查看下载的文件夹 demosite）\n（2）预览。紧接上一步，在命令提示符中执行 cd demosite 进入 demosite 目录，先执行 hugo ，再执行 hugo server。打开浏览器，输入网址访问 localhost:1313。\n2.将网站展示文件存放到 Github 远程仓库。\n（1）在 Github 中创建一个名为 你的仓库名字.github.io 的仓库，在设置中检查 Github Pages。\n（2）打开命令提示符，进入 demosite\\public 目录，分别执行\ngit init git add . git commit -m \u0026#34;first commit\u0026#34; git remote add origin https://github.com/你的Github名字/你的Github名字.github.io.git git push --set-upstream origin master 输入账号名，密码，完成上传。\n（3）测试。访问 github.com 网站，在你之前创建的仓库可以看到刚刚上传的文件。随后检查 Github Pages 设置，打开网址 https://你的Github账户名.github.io 访问你的网站，如果没有之前预览的网页，可以等待一会再刷新。\n3.自定义域名（可选、需要一定的时间）\n（1）购买域名。在华为云、阿里云等服务商购买域名。注意：国内购买域名需要实名认证。\n（2）配置。访问 github.com 网站，进入你的仓库，在 setting 中找到 Github Pages，在 Custom domain 输入框中输入你的域名，保存。\n（3）测试。访问你的域名。\n","permalink":"/post/2021/06/01/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99%E5%B0%8F%E7%99%BD%E7%AF%87/","summary":"前言 小白篇和前面正经篇的区别是，懒人篇专门针对基础更浅（或者更懒的）朋友而设计，在这里不会新建一个网站，而是下载我预先准备好的示例网站，在这","title":"从零开始搭建个人网站——小白篇"},{"content":"前言 “码出高效，码出质量”。本文整理了比较常见的 C++ 编程规范，主要来源于华为《软件编程规范总则》。\n（一）排版 1.程序块要采用缩进风格编写，缩进的空格数位 4 个。对齐只用空格键，不适用tab键。\n2.相对独立的程序块之间、变量说明之后必须加空行。\n3.较长的语句（\u0026gt;80 字符）要分成多行书写，长表达式要在低优先级操作符划分新行，操作符放在新行之首。\n4.if、for、do、while、case、switch、default 等语句自占一行，且执行语句部分无论多少都要加括号 {}。\n（二）注释 1.一般情况下，源程序有效注释量必须在 20% 以上。\n2.说明性文件（如头文件 .h 文件、.inc 文件、.def 文件等）头部应进行注释，注释必须列出：版权说明、版本号、生成日期、作者、内容、功能、与其他头文件关系、修改日志等，头文件注释中还应有函数功能简要说明。\n3.源文件头部应进行注释，列出：版权说明、版本号、生成日期、作者、模块目的/功能、主要函数及其功能、修改日志等。\n4.函数头部应进行注释，列出：函数的目的/功能、输入参数、输出参数、返回值、调用关系（函数、表）等。\n5.边写代码边注释，修改代码同时修改响应的注释。不再有用的注释 要删除。\n6.注释格式尽量统一，建议使用“/…………/”。\n7.注释应考虑程序易读性，建议使用中文。\n（三）标识符命名 1.命名规范必须与所使用的系统风格保持一致，并在同一项目中统一，比如采用 UNIX 的全小写加下划线风格或大小写混排的方式，不要将两种方式混合使用。用作特殊标识如标识成员变量或全局变量的 m_ 和 g_，其后加上大小写混排的方式是允许的。\n示例：Add_User 不允许，add_user、AddUser、m_AddUser允许。\n2.用正确的反义词组命名具有互斥意义的变量或相反动作的函数等。\n说明：以下是一些在软件中常用的反义词组。\nadd / remove begin / end create / destroy\ninsert /delete first / last get / release\nincrement / decrement put / get\nadd /delete lock unlock open /close\nmin / max old /new stat / stop\nnext /previous source / target show / hide\nsend / receive source / destination cut /paste up / down\n示例：\nint min_sum;\nint max_sum;\nint add_user( BYTE *user_name );\nint delete_user( BYTE *user_name);\n（四）可测性 1.使用断言来发现软件问题，提高代码可测性。\n（五）程序效率 1.多重循环中，应将最忙的循环放在最内层。\n2.尽量减少循环嵌套层次。\n3.尽量使用乘法或其他方法代替除法特别是浮点运算中的除法（占用较多 CPU 资源）。\n（六）质量保证 1.防止引用已经释放的内存空间。\n2.过程/函数中分配的内存，在过程/函数退出之前要释放。\n3.过程/函数中申请的（为打开文件而使用的）文件句柄，在过程/函数退出之前要关闭。\n4.防止内存操作越界。\n5.编程时，要防止差 1 错误。（\u0026lt;=、\u0026lt;等注意）\n6.if 语句尽量加上 else 分支，switch 语句必须有 default 分支。\n7.Unix 下，多线程的子线程退出必需采用主动退出的方式，即子线程应 return 出口。\n8.时刻注意表达式是否会上溢、下溢。使用变量时要注意其边界值的情况。\n","permalink":"/post/2021/05/28/%E8%A7%84%E7%BA%A6-c-%E7%BC%96%E7%A8%8B%E7%AF%87/","summary":"前言 “码出高效，码出质量”。本文整理了比较常见的 C++ 编程规范，主要来源于华为《软件编程规范总则》。 （一）排版 1.程序块要采用缩进风格编写，缩进","title":"【规约】 C++ 编程篇"},{"content":"前言 “码出高效，码出质量”。本文整理了比较常见的 Java 编程规范，主要来源于《阿里巴巴 Java 开发手册》。\n（一）命名风格 1.【强制】类名使用 UpperCamelCase风格，但以下情形例外：DO / BO / DTO / VO / AO / PO / UID等。 正例：MarcoPolo / UserDO / XmlService / TcpUdpDeal /TaPromotion\n2.【强制】方法名、参数名、成员变量、局部变量都统一使用 lowerCamelCase 风格，必须遵从驼峰形式。\n正例：localValue / getHttpMessage() / inputUserId\n3.【强制】常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。\n正例：MAX_STOCK_COUNT\n4.【强制】抽象类命名使用 Abstract 或 Base 开头；异常类命名使用 Exception 结尾；测试类命名以它要测试的类的名称开始，以 Test 结尾。\n5.【强制】类型与中括号紧挨起来表示数组。\n正例：int[] arrayDemo;\n6.【强制】POJO 类中布尔类型的变量，都不要加 is 前缀。\n7.【强制】包名统一使用小写，点分隔符之间有且只有一个自然语义的英语单词。包名统一使用单数形式，但是类名如果有复数含义，类名可以使用复数形式。\n正例：应用工具类包名为 com.alibaba.ai.util、类名为 MessageUtils。\n8.【强制】杜绝完全不规范的缩写，任何自定义编程元素在命名时，使用尽量完整的单词组合来表达其意。\n9.【推荐】如果模块、接口、类、方法使用了设计模式，在命名时需体系那具体模式。\n10.【推荐】接口类的方法和属性不要加任何修饰符号（public 也不要加），保持代码整洁，并加上有效的 Javadoc 注释。\n11.【强制】对于 Service 和 DAO 类，基于 SOA 的理念，暴露出来的一定时接口，内部的实现类用 Impl 的后缀与接口区别。\n正例：CacheServiceImpl 实现 CacheService。\n12.【参考】各层命名规约： A）Service/DAO 层方法命名规约\n1）获取单个对象的方法用 get 做前缀。\n2）获取多个对象的方法用 list 做前缀，复数形式结尾如： listObjects。\n3）获取统计值的方法用 count 做前缀。\n4）插入的方法用 save/insert 做前缀\n5）删除的方法用 remove/delete 做前缀\n6）修改的方法用 update 做前缀\nB）领域模型命名规约\n1）数据对象：xxxDO，xxx 即为数据表名。\n2）数据传输对象：xxxDTO，xxx 为业务领域相关的名称。\n3）展示对象：xxxVO，xxx 一般为网页名称。\n4) POJO 是 DO/DTO/BO/VO 的统称，禁止命名为 xxxPOJO。\n13.【强制】不允许任何魔法值（即未经预先i当以的常量）出现在代码中。\n反例：String key = \u0026ldquo;ID#taobao_\u0026rdquo; + tradeId;\n14.【强制】代码格式，具体见下面正例。 正例：\n public static void main(String[] args) {\r// 缩进4个空格，注释内空1格\rString say = \u0026#34;hello\u0026#34;;\r// 运算符左右必须有一个空格\rint flag = 0;\r// 关键词 if 与括号之间必须有一个空格\rif (flag == 0) {\rSystem.out.println(say);\r}\r// 左大括号前加空格且不换行，左大括号后换行。\rif (flag == 0) {\rSystem.out.println(\u0026#34;world\u0026#34;);\r// 右大括号前换行，右大括号后有 else，不用换行、\r}\relse {\rSystem.out.printLn(\u0026#34;ok\u0026#34;);\r}\r} ","permalink":"/post/2021/05/28/%E8%A7%84%E7%BA%A6-java-%E7%BC%96%E7%A8%8B%E7%AF%87/","summary":"前言 “码出高效，码出质量”。本文整理了比较常见的 Java 编程规范，主要来源于《阿里巴巴 Java 开发手册》。 （一）命名风格 1.【强制】类名使用 UpperC","title":"【规约】 Java 编程篇"},{"content":"前言 “码出高效，码出质量”。本文整理了比较常见的 MySQL 数据库编程规范，主要来源于《阿里巴巴 Java 开发手册》。\n(一)建表规约 1.【强制】表达是与否概念的字段，必须使用 is_xxx 的方式命名，数据类型是 unsigned tinying(1 表示是，0 表示否)。\n说明：任何字段如果为非负数，必须是 unsigned。\n注意：POJO 类中任何布尔类型的变量，都不要加 is 前缀，所以，需要在  设置从 is_xxx 到 Xxx 的映射关系。数据库表示是与否的值，使用 tinyint 类型，坚持 is_xxx 的命名方式是为了明确其取值含义与范围。\n正例：表达逻辑删除的字段名 is_deleted，1 表示删除，0 表示未删除。\n2.【强制】表名、字段名必须使用小写字母或数字，禁止出现数字开头，禁止两个下划线中间只出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。\n说明:MySQL 在 Windows 下不区分大小写，但在 Linux 下默认是区分大小写。因此，数据库名、表名、字段名，都不允许出现任何大小写字母，避免节外生枝。\n正例：aliyun_admin, rdc_config, level3_name 反例：AliyunAdmin, rdcConfig, level_3_name\n3.【强制】表明不使用复数名词。 说明：表名应该仅仅表示表里面的实体内容，不应该表示实体数量，对应于 DO 类名也是单数形式，符合表达习惯。\n4.【强制】主键索引名为 pk_字段名；唯一索引名为 uk_字段名；普通索引名则为 idx_字段名。\n说明：pk_ 即 primary key；uk_ 即 unique key；idx_ 即 index 的简称。\n5.【小数类型】为 decimal，禁止使用 float 和 double。\n说明：float 和 double 在存储的时候，存在精度损失的问题，很可能在值的比较时，得不到正确的结果。如果存储的数据范围超 decimal 的范围，建议将数据拆成整数和小数分开存储。\n6.【强制】如果存储的字符串长度几乎相等，使用 char 定长字符串类型。\n7.【强制】varchar 是可变字符串，不与先分配存储控件，长度不要超过 5000，如果存储长度大于此值，定义字段类型为 text,独立出来一张表，用主键来对应，避免影响其他字段索引效率。\n8.【强制】表必备三字段：id, gmt_create, gmt_modified。\n说明：其中 id 必为主键，类型为 bigint unsigned、单表自增、步长为 1。gmt_create，gmt_modified 的类型均为 datetime 类型，前者现在时表示主动创建，后者过去分词表示被动更新。\n9.【推荐】表的命名最好是加上”业务名称_表的作用“。\n正例：alipay_task / force_project / trade_config\n10.【推荐】库名与应用名称尽量一致。\n11.【推荐】字段允许适当冗余，以提高查询性能，但必须考虑数据一致。冗余字段应遵循：\n1）不是频繁修改的字段。\n2）不是 varchar 超长字段，更不能是 text 字段。\n正例：商品类目名称使用频率高，字段长度短，名称基本一成不变，可在相关联的表中冗余存储类目名称，避免关联查询。\n12.【参考】合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检索速度。\n正例： 人 150岁之内 tinyint unsigned 1字节 无符号值：0 到 255\n龟 数百岁 smallint unsigned 2字节 无符号值：0 到65535\n（二）索引规约 1.【强制】业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引。\n说明：不要以为唯一索引影响了 insert 速度，这个速度的损耗可以忽略，但提高查找速度是明显的；另外，只要没有唯一索引，必定有脏数据产生（墨菲定律）。\n2.【强制】超过三个表禁止 join。需要 join 的字段，数据类型必须绝对一致；多表关联查询时，保证被关联的字段有索引。\n说明：join 需要注意表索引、SQL 性能。\n3.【强制】在 varchar 字段上建立索引时，必须根据文本区分度指定索引长度。\n4.【强制】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。\n说明：索引文件具有 B-Tree 的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。\n5.【推荐】利用覆盖索引来进行查询操作，避免回表。\n6.【参考】创建索引时避免有如下极端误解：\n1）宁滥勿缺。认为一个查询就需要建一个索引。\n2）宁缺毋滥。认为索引会消耗空间、严重拖慢更新和新增速度。\n3）抵制唯一索引。认为业务的唯一性一律需要在应用层通过”先查后插“方式解决。\n（三）SQL 语句 1.【强制】不要使用 count(列名) 或 count(常量) 来替代 count(*)。\n2.【强制】使用 ISNULL() 来判断是否为 NULL 值。\n3.【强制】不得使用外键和级联，一切外键概念不必在应用层解决。 说明：外键与级联更新使用于单机低并发，不适合分布式、高并发集群；级联更新时强阻塞，存在数据库过呢更新风暴的风险；外键影响数据库的插入速度。\n4.【推荐】尽量避免 in 操作，若使用也需评估 in 后边的集合元素数量，控制在 1000 个之内。\n","permalink":"/post/2021/05/28/%E8%A7%84%E7%BA%A6-mysql-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AF%87/","summary":"前言 “码出高效，码出质量”。本文整理了比较常见的 MySQL 数据库编程规范，主要来源于《阿里巴巴 Java 开发手册》。 (一)建表规约 1.【强制】表达是与否概念","title":"【规约】 MySQL 数据库篇"},{"content":" 我的天空 为何挂满 湿的泪\n我的天空 为何总 灰的脸\n《天空》\n 今天看到王菲的一张专辑，名叫《只爱陌生人》，感觉很有意思。\n时间总是悄悄溜走，写上篇文章的情形还历历在目，恍惚昨日。\n先说一下我的近况吧。也许是这些日里都没有好好睡午觉，今天中午趴在桌子睡了一阵，起来瞬间感觉头似千斤重，整个下午都昏昏沉沉，脑袋隐隐作痛。所以一下班我就早早走了，也不知道领导有没有记到小本本上。\n回到住处，煮些东西，吃完就听着音乐躺下睡了。然而终究思绪万千，难梦难醒。约莫一个小时，还是觉得头痛难忍，于是就决定去附近的篮球场打会球。最近我每天都会去那里打球，好像哪天不去，这一天都过得不真实。不过今天确实有些晚了，平时在那儿玩闹的小孩都不见了踪影。于是我只能压低声音投球，免得扰人清梦。\n最后说一下近期的计划吧。首先就是好好上班了（生活所迫啊），然后多交一些朋友（长期目标），最后，把我手头上做的事情做完。最近我有个想法，把大学几年里做过的、尚有意义的东西，整理出来。说来也是惭愧啊，从大一的第一个控制台程序，到最后的毕业设计项目，都不尽如意。\n","permalink":"/blog/2021/05/25/%E5%8F%AA%E7%88%B1%E9%99%8C%E7%94%9F%E4%BA%BA/","summary":"我的天空 为何挂满 湿的泪 我的天空 为何总 灰的脸 《天空》 今天看到王菲的一张专辑，名叫《只爱陌生人》，感觉很有意思。 时间总是悄悄溜走，写上篇文章的情","title":"只爱陌生人"},{"content":"前言 这是以前的一个实训周作业，核心是哈夫曼编码和解码，软件界面由 QT 实现。代码量很小，比较简单。\n源代码： https://gitee.com/lzxqaq/zxhan.git\n介绍：https://lzxqaq.com/post/zxhan/\n算法参考：Huffman压缩真正的C++实现\n运行环境：Linux 系统（Windows系统下运行尚有 bug ),开发环境为 QT Creator。\n运行截图：\n 核心实现 void create_node_array();//构造包含字符及其频率的数组 void create_pq();//构造优先级队列 void create_huffman_tree();//构造哈夫曼树 void create_map_table(Node* node,bool);//根据哈夫曼树建立哈夫曼映射表 bool calculate_huffman_codes();//计算哈夫曼编码 bool do_compress();//开始压缩 bool rebuid_huffman_tree();//从哈夫曼编码文件中重构哈夫曼树 void decode_huffman();//根据重构的哈夫曼树解码文件 后续 该项目仍有许多不足之处，如果你对该项目有任何意见或建议，欢迎联系我。如有任何问题，亦可与我一同探讨。\n","permalink":"/post/2021/05/25/%E5%81%9A%E7%82%B9%E6%9C%89%E8%B6%A3%E7%9A%84c-%E5%81%9A%E4%B8%80%E4%B8%AA%E5%93%88%E5%A4%AB%E6%9B%BC%E5%8E%8B%E7%BC%A9%E8%BD%AF%E4%BB%B6/","summary":"前言 这是以前的一个实训周作业，核心是哈夫曼编码和解码，软件界面由 QT 实现。代码量很小，比较简单。 源代码： https://gitee.com/lzxqaq/zxhan.git 介绍：https://lzxqaq.","title":"[做点有趣的]C++做一个哈夫曼压缩软件"},{"content":"一小时，体验人生百态。\n最近在玩一款名叫《一小时人生》的游戏，国内手机移植版名为\u0026quot;希望之村\u0026quot;，有兴趣可以查查这游戏的来历，很有意思。作为一个游戏老玩家，我玩过很多游戏，但说让我印象深刻的还是要提到它。\n首先介绍一下游戏基本的设定。《一小时人生》，游戏开始，玩家将会以“夏娃”（成年女性，开创者）或者“婴儿”（幼年期无生存能力，必须由他人抚养）的身份诞生在一个原始世界，成年女性会在某个不确定的时间诞生“婴儿”，在老年的时候就会失去生育能力。在游戏里，玩家每分钟会成长一岁，最高寿命为60岁，期间可能会因为饥饿、野兽袭击或疾病等原因致死而结束游戏。\n既然说人生百态，目标不同，那这人生的玩法就很多了，具体怎么玩我就不多说了，有兴趣可以自行体验。下面分享一些我在游戏中遇到的趣事。（注：下列故事出现的人物称呼均为游戏中玩家关系）。\n一 这张图片的背景是：我作为夏娃的儿子诞生，能下地走路独自进食后，我便开始忙于生计，制造各种农具，种植果树。但因为环境恶劣，也或许是能力不足的缘故，随着人口的增多，我的兄弟姐妹在接下来的几次饥荒中丧生，母亲也化为了白骨。时间流逝，我渐渐意识到，这个世界仅剩我一人，在我死后这个世界便再也没有人记得曾有过这样一个家族，我的工作也便没有了价值。于是我放弃了工作，靠着附近的野果度日。最后，白发苍苍的我，忍受了漫长的孤寂，站在母亲的白骨前，等待死亡（我连埋葬都不会）……\n二 为了免受饥饿的困扰，我刻意到人少的地方作为夏娃诞生，苦练种植技术。当积累了足够经验后，因饥荒而导致种族灭绝的情况已经得到改善。然而环境探索和资源采集的过程中，自己或亲人时常被野兽袭击，因为缺乏医疗手段，鲜活的生命转瞬便消失在眼前。于是，我决定奋起反抗，用武器与热血对抗冰冷的大自然。同时也考虑到整个家族的生存大计，我选择在农业发展到一定阶段，自己也不能为家族创造更多价值的时候，拿起早已准备好的武器，向大自然最凶恶的野兽-巨熊，发起挑战！但即使是青壮年面对野兽，也需要足够多的勇气与体魄，更何况垂垂老矣的我，结局不言而喻……\n三 这是一个情节复杂，值得思考的故事，光看图片可能不能理解，且听我细细讲来。\n这一世我作为夏娃的女儿诞生，但当我睁开眼之后，便吓出一身冷汗！原来我诞生在一个香蕉地，附近有一地的香蕉皮，在旁边还有一位刚能走动的姐姐（她也是一位传奇人物，后面会讲述她的故事）。\n显然，这位母亲是一位流浪者，俗称香蕉人，即到处流浪，靠食野果为生。她的生平经历，我无从得知，她的所思所感，我亦无暇顾及。只知道她在我诞生后便放弃了自己的生命，是姐姐靠采摘附近的香蕉把我养大。但是资源终究会消耗完，这样的生活注定不能长久，我们不能让后代延续这样的悲剧。于是，我和姐姐同时做了一个决定，离开这里！我们相约到一个合适的地方共建家园，但是，显然幸运女神没有怜顾我们，我们迷路分离了。这也是流浪者后代的悲剧，在野外恶劣环境下，没有路引，迷失是注定的命运。\n令我宽慰的是，在分开不远处我便找到一个环境不错的地方，同时找到了一些珍稀的果树——覆盘子，这也算是不幸中的万幸。于是我就地开展工作，开启了农耕时代。忙碌一生之后，我凭借附近的丰富资源，建立了一片果园，可以维持后代一定人口的生计。\n然而，这看似美好的结局，其中的经历却骇人听闻。\n看回第一张照片，我的三位儿子全部饿死，而其中一位，更是我亲手杀死。是的，我是那刽子手，但假如重来一次，我可能还是会作出同样的选择。在那时，我正全身心投入果园的建设之中，然而果园尚无产出，附近的野果资源却已经消耗殆尽了，饥荒迫在眉睫。这时，他诞生了。当然，我可以带着他离开这里，和我的母亲一样，去当一段时间的流浪者、香蕉人。但是，饥荒不会与你讲述人间的伦理道德，它会在到来的一瞬间夺取整个家族的命脉，让整个家族从此分崩离析，尸横遍野。于是，我把他放在了野外，加紧投身果园的工作中……\n这仅仅只是一次饥荒的缩影，在我的众多儿女，只有一位能颐养天年，长寿而死（图二死于年老者，她也肩起繁衍大任，延续了家族的命脉），其余大都死于饥荒的侵袭。在这些死于饥荒的人中，有一位令我心中有愧，不得不提。他诞生之时，同样面临着饥饿的局面。在我准备再当一次刽子手时，我在他眼中看到了生命的执着。于是，我对他说，“以后要努力工作”，他被留下了。后来，他造农具，搜集资源，忙活一生，最后年迈时饥饿而死，而死前的遗言是：“娘养了我，已经报答完了……”。\n我终究还是免不了归于尘土，是非对错对我来说已无半毫关系，只留在历史长河中成为后人评判的谈资。但令我感动的是，在我故去之后，我那位女儿在晚年时，仍纪念着我，拜托她的子孙帮我立碑……\n历史人物终究受限于时代背景，从而带上了一些悲剧色彩，我那位传奇的姐姐也不外如是。在那些年里，我一直放不下寻找姐姐的执念。到了晚年的时候，子孙已经可以肩负大任，果园也已经健康运作，我交代完工作后，便开始在四周扩散寻找。一天，儿子突然跟我说，“带上吃的，快跟我来”。我跟着他，穿过一片没有食物资源的“生命禁区”，来到了他口中所说的“遗迹”。那里是一个荒废的营地，种植着稀少衰败的果树，四周散落着破旧的农具，以及大量的狩猎工具。地上还有一具白骨，儿子很高兴，他说可以狩猎了。而我却顿时眼中泛泪，说：“这是我姐姐建造的家，地上的是你表哥“。是的，凭借对血脉的感应，我认出了那一具白骨是姐姐的儿子，这荒废的营地就是姐姐建造的家园。虽然我没有亲眼所见，但这里发生的一幕，我却感到无比熟悉……回顾姐姐的一生，为了延续生命，她乐观、执着、坚强，面对恶劣的生存环境，她走向了一条不一样的道路——狩猎。她也许比我更具智慧与勇气，但命运没有眷顾她……\n未完待续 ","permalink":"/blog/2021/05/09/%E4%B8%80%E5%B0%8F%E6%97%B6%E4%BA%BA%E7%94%9F/","summary":"一小时，体验人生百态。 最近在玩一款名叫《一小时人生》的游戏，国内手机移植版名为\u0026quot;希望之村\u0026quot;，有兴趣可以查查这游戏的来历，","title":"《一小时人生》"},{"content":"现在是 5 月 9 日 12 时 55 分。刚刚十一点左右回到住处，躺了一会，发现肚子不太舒服。不知道是刚吃的香辣鸡肉卷的锅，还是奶茶太冰的原因，或者是今天坐七八个小时公交影响。不过不管是哪个原因，经过慎重考虑（？），本人郑重立 flag：\n 奶茶少冰 拒绝某汉堡店 不再吃辣  想到这里，不由地想起前面写的一篇文章，《追》。哈哈哈，开篇的信誓旦旦，现在竟成了赤裸裸的打脸现场。难搞。\n人生就是不断打脸的过程，下一秒的我，可长点记性吧。\n","permalink":"/blog/2021/05/09/%E6%89%93%E8%84%B8/","summary":"现在是 5 月 9 日 12 时 55 分。刚刚十一点左右回到住处，躺了一会，发现肚子不太舒服。不知道是刚吃的香辣鸡肉卷的锅，还是奶茶太冰的原因，或者是今天坐七","title":"打脸"},{"content":"介绍 本项目是一个很久以前的实训周项目，由我和我的组员 ljr 共同实现。整个项目思路清晰，整体难度不大，但是很多细节需要花功夫。本项目仍存在一些不足的地方，后续可能会进行优化，现在我将项目源代码和一些实现思路开源公布。\n源代码：https://gitee.com/lzxqaq/CrazyArcade\n文章介绍：https://lzxqaq.com/post/java/paopaotang/\n程序运行： 在终端下进入执行程序所在目录，执行 java -jar CrazyArcade.jar 或者双击 CrazyArcade.jar，或者在开发环境中打开源代码，运行 GameStart.java的 main 方法。\n运行环境：Linux、Windows均可。开发环境：IDEA。\n演示视频：\n运行截图：\n  功能 本项目实现的功能如下：\n 绘制游戏启动界面、结束界面、地图、主角、道具 实现泡泡爆炸 实现双主角PK（积分制） 实现道具掉落和相应属性加成 实现游戏音效和背景音乐  其中我们对游戏玩法做了调整，大致如下:\n我们把游戏设计为双人pk积分赛模式，在这个模式里面，玩家只要率先达到一定分数既可以赢得比赛。玩家可以通过炸箱子可以得到少量的分数，也可以通过炸掉对手然后戳破包围对手的水泡得到大量分数。而玩家如果被泡泡爆炸击中，会被泡泡包裹一段时间，在这段时间内不可以移动和放泡泡，需要等时间过去或者被对手戳破水泡才能获得自由。但如果玩家被自己放的泡泡炸中，会扣一定的分数。\n思路和架构 整个项目采用 MVC 架构，将项目整体分为数据模型层（M）、视图层（V）、控制层（C）。M层负责元素的创建、存储、管理，V层负责所有元素的显示（24帧/秒），C层负责交互（监听用户的操作），同时负责控制游戏的进程。\n选择MVC架构最主要的原因是让这个游戏项目具有良好的可扩展性和更新功能，当然了，一个好的游戏也需要良好的交互功能，漂亮的UI设计。\n架构设计图：\n 包结构 未完待续……\n核心实现 未完待续……\n后续 该项目仍有许多不足之处，如果你对该项目有任何意见或建议，欢迎联系我。如有任何问题，亦可与我一同探讨。\n","permalink":"/post/2021/05/08/%E5%81%9A%E7%82%B9%E6%9C%89%E8%B6%A3%E7%9A%84java%E5%BC%80%E5%8F%91%E6%B3%A1%E6%B3%A1%E5%A0%82%E6%B8%B8%E6%88%8Fmvc%E6%9E%B6%E6%9E%84/","summary":"介绍 本项目是一个很久以前的实训周项目，由我和我的组员 ljr 共同实现。整个项目思路清晰，整体难度不大，但是很多细节需要花功夫。本项目仍存在一些不足","title":"[做点有趣的]Java开发泡泡堂游戏（MVC架构）"},{"content":" 从明天开始，做一个幸福的人\n喂马、劈柴，周游世界\n从明天开始，关心粮食和蔬菜\n《面朝大海，春暖花开》\n 我刚刚躺在床上胡思乱想的时候，脑海里冒出一些东西。\n我终于意识到为何对这房子墙壁的粉刷配色感到熟悉了。是它，《Dark Season》。这个电影多次出现用小孩做残忍实验的片段，所用密闭房间就和我的房间很像。有点慌，怎么办，窗户那边一直传来莫名响动。我要不要睁开眼看一看？\n","permalink":"/blog/2021/05/05/%E5%A4%B1%E7%9C%A0/","summary":"从明天开始，做一个幸福的人 喂马、劈柴，周游世界 从明天开始，关心粮食和蔬菜 《面朝大海，春暖花开》 我刚刚躺在床上胡思乱想的时候，脑海里冒出一些东","title":"失眠"},{"content":"很长一段时间没来更新了，这期间并非无事可写，而是诸多事宜终究只能留于心底，随时光消散。\n值得一提的是，前段时间突然发现我 Github 帐号多了一个粉丝，这可是一件稀奇事。查探一番后，惊讶的发现，他也在使用 hugo-ivy 这个主题搭建博客。原来，他应该是看到我那篇完成了一半的博客搭建教程（现在补充完整了）……真是尴尬，我当时只写了个大概，然后就直接鸽了……不得不说，虽然有些意外，但是还是有些开心。\n回到当下，今天要开始独自租房生活了，值得纪念。同时，这也注定了今晚是一个难眠夜啊。从今天开始，就要独自居住在一个陌生的地方生活。过去不再有，前途飘忽不定。这样的画面，换作很多年前的我，想必是开心的吧。多年期盼终成真，然而人却不再是。任何事都会有代价，选择了，就要去承担。\n不管怎么样，当我写到这里，新的一天已经到来。而明天，是未知，也是希望。\n “好好完成工作，好好度过每一天。蒙德的生活不就是如此吗？”\n ","permalink":"/blog/2021/05/04/%E6%96%B0%E7%94%9F%E6%B4%BB/","summary":"很长一段时间没来更新了，这期间并非无事可写，而是诸多事宜终究只能留于心底，随时光消散。 值得一提的是，前段时间突然发现我 Github 帐号多了一个粉丝，这","title":"新生活"},{"content":" 去年, 不曾有过什么事，\n前年, 不曾有过什么事，\n大前年, 也不曾有过什么事。\n《斜阳》\n 今天手机又坏了，这足以让我心情胸沉闷到整晚睡不着。:)\n忽然想起很多年前的一个朋友，她有时会在晚修的时候跟我开玩笑说，“白天我是女神，晚上呢，是女神经”。我开始不是很懂，但感觉她很聪明，所以也很佩服她。\n人是多么奇怪的生物啊，其实我对人一点也不懂。我不知道别人脑海真正的想法是什么。我在想，应该怎么样才能和另一颗心交流呢？\n","permalink":"/blog/2021/02/18/%E6%99%9A/","summary":"去年, 不曾有过什么事， 前年, 不曾有过什么事， 大前年, 也不曾有过什么事。 《斜阳》 今天手机又坏了，这足以让我心情胸沉闷到整晚睡不着。:) 忽然想起","title":"晚"},{"content":"准备工作 1.注册 Github 帐号。前往 github.com 注册一个 Github 帐号。（友情提示：认真考虑注册时的用户名，它将是网址的一部分）\n补充：Github 是一个代码托管平台（远程仓库），你可以将网站的源代码放在上面，Github Pages 是一个免费的静态网站服务，你将网站的源文件放在上面，它会提供一个链接，使互联网上的人都能访问你的网站。\n2.准备Git。\n（1）下载安装。前往 这里 ，点击下载 Git-**-64-bit.exe。然后安装，不懂的话一直 next 。\n（2）配置。在 win10 搜索 cmd ，打开命令提示符，输入 git config --global user.email \u0026quot;你注册Github所用的邮箱\u0026quot; 回车执行，再输入 git config --global user.name \u0026quot;你的昵称\u0026quot; 回车执行。\n3.安装 Hugo。（官方教程可看这里)\n（1）首先在 D 盘创建一个新文件夹 Hugo，然后在里面创建 bin 和 sites两个文件夹。bin 将用来放 Hugo 的可执行文件，sites 将用来放你的网站的源代码。\n（2）前往这里，找到并下载 hugo_Windows-64bit.zip。解压，如果是一个 hugo_windows_amd64.exe 文件，将它改名为 hugo.exe。\n（3）将这个 hugo.exe 文件移动到刚刚创建的 bin 文件夹里。\n（4）配置环境变量。方法1:在 win10 搜索 cmd，右键以管理员身份打开命令提示符，将 setx \u0026quot;Path\u0026quot; \u0026quot;%PATH%;D:\\Hugo\\bin\u0026quot; /m 复制粘贴上去，回车（输入命令后需回车执行，后文不再赘述）。 方法2：在 win10 搜索环境变量，进去找到系统变量中的 Path，-\u0026gt;编辑-\u0026gt;新建，然后将 D:\\Hugo\\bin 复制进去，确定。\n（5）验证。重新打开命令提示符（关闭上一步骤使用的），输入执行 hugo help，如果你能看到 hugo 的帮助文档，就验证成功，否则检查上述步骤是否出错。\n开始 1.建立博客网站\n（1）使用 Hugo 建立网站。打开命令提示符，执行 D: 切换 D 盘，然后执行 cd D:\\Hugo\\sites 进入 D:\\Hugo\\sites 目录（便捷方法：在文件资源管理器中进入相应目录，单击地址栏右边空白地方，在最左边输入 cmd  加空格，回车），执行命令 hugo new site blog ，如出现 Congratulations! 提示则成功。（此时可在文件资源管理器中查看生成的文件）\n（2）下载主题模板（以 Hugo.386 为例）。接上述步骤，在命令提示符中 执行 git clone https://gitlab.com/maxlefou/hugo.386 themes/hugo.386 来下载 hugo.386 主题。\n（3）配置。将 hugo.386\\exampleSite 文件夹中的 theme.toml 文件复制到文件夹 blog 中，替换原本的。根据需要修改其中的内容。\n（4）预览。命令提示符进入 blog 目录，先执行 hugo ，再执行 hugo server。打开浏览器，访问 localhost:1313。\n2.将网站展示文件存放到 Github 远程仓库。\n（1）在 Github 中创建一个名为 你的仓库名字.github.io 的仓库，在设置 setting 中检查 Github Pages。\n（2）打开命令提示符，进入 blog\\public 目录，分别执行\ngit init git add . git commit -m \u0026#34;first commit\u0026#34; git remote add origin https://github.com/你的Github名字/你的Github名字.github.io.git git push --set-upstream origin master 输入账号名，密码，完成上传。\n（3）测试。访问 github.com 网站，在你之前创建的仓库可以看到刚刚上传的文件。随后检查 Github Pages 设置，访问提供的 https://你的Github账户名.github.io 访问你的网站，如果没有之前预览的网页，可以等待一会再刷新。\n3.自定义域名（可选、需要一定的时间）\n（1）购买域名。在华为云、阿里云等服务商购买域名。注意：国内购买域名需要实名认证。\n（2）配置。访问 github.com 网站，进入你的仓库，在 setting 中找到 Github Pages，在 Custom domain 输入框中输入你的域名，保存。\n（3）测试。访问你的域名。\n","permalink":"/post/2021/02/18/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99win10githubhugo/","summary":"准备工作 1.注册 Github 帐号。前往 github.com 注册一个 Github 帐号。（友情提示：认真考虑注册时的用户名，它将是网址的一部分） 补充：Github 是一个代码托管平台（","title":"从零开始搭建个人网站（win10,Github,Hugo）"},{"content":"最近我打算在 Windows 上录些视频，考虑过后决定重新装一下 Windows 10。\n距离上次决心完全抛弃 Windows 已经过去大半年了，除了开始时遇到很多问题，之后的心情一直欢乐无比。然而这两天重装 Windows 的经历却再次让我抓狂。\n本以为有着丰富的安装操作系统经验（惨痛经历）的我，装个 Windows 还不是小菜一碟～但，事实上我又被狠狠打脸了。从一个非 Windows 环境装 Windows 系统遭遇的问题之多，让我没办法淡定了……\n整个过程遇到问题很多，最恶心也是最常见的就是装 Windows 的时候，会破坏原有其他操作系统的引导。我想流氓软件里 Windows 也算老大了吧。另外还有差点让我气笑了，微软官网检测到我当前用的不是 Windows 系统，居然不让我下载装 Windows 需要的工具安装包，美名其曰：“怕我下载错了”。这是玩霸道总裁还是别有用心？绝了！\n这次之后，奇怪的知识增加了，而且装系统用的U盘也倍增了，以后应该不会再有类似这样的窘境了。\n “好像，你上次也是这样说的？”\n ","permalink":"/blog/2021/02/18/%E4%B8%87%E6%81%B6%E4%B9%8B%E6%BA%90%E7%98%9F%E7%97%98%E6%AD%BB/","summary":"最近我打算在 Windows 上录些视频，考虑过后决定重新装一下 Windows 10。 距离上次决心完全抛弃 Windows 已经过去大半年了，除了开始时遇到很多问题，之后的心情一直欢乐无","title":"万恶之源——“瘟痘死”"},{"content":"一、概览 Java 的 I/O 大概可以分成以下几类：\n 磁盘操作：File 字节操作：InputStream 和 OutputStream 对象操作：Serializable 网络操作：Socket 新的输入/输出：NIO  二、磁盘操作 File 类可以用于表示文件和目录的信息，但是它不表示文件的内容。 递归地列出一个目录的所有文件：\npublic static void listAllFiles(File dir){ if(dir == null || !dir.exists()){ return ; } if(dir.isFile()) { System.out.println(dir.getName()); return ; } for (File:file : dir.listFiles()) { listAllFiles(file); } } 从 Java 7 开始，可以使用 Paths 和 Files 代替 File。\n三、字节操作 实现文件复制 public static void copuFile(String src, String dist) throws IOException { FileInputStream in = new FileInputStream(src); FileOutputStream out = new FileOutStream(dist); byte[] buffer = new byte[20 * 1024]; int cnt; // read() 最多读 buffer.length 个字节 // 返回的是实际读取的个数 // 返回 -1 的时候表示读到 eof,即文件结尾 while ((cnt = in.read(buffer, 0, buffer.length)) != -1) { out.write(buffer, 0, cnt); } in.close(); out.close(); } 装饰者模式 Java I/O 使用了装饰者模式来实现。\n实例化一个具有缓存功能的字节流对象时，只需要在 FileInputStream 对象上再套一层 BufferedInputStream 对象即可。\n七、NIO 新的输入/输出（NIO）库是在 JDK1.4中引入的，弥补了原来的 I/O 的不足，提供了高速的、面向块的 I/O。\n","permalink":"/post/2021/01/12/java-i/o/","summary":"一、概览 Java 的 I/O 大概可以分成以下几类： 磁盘操作：File 字节操作：InputStream 和 OutputStream 对象操作：Serializable 网络操作：Soc","title":"Java I/O"},{"content":"一、使用线程 有三种使用线程的方法：\n 实现 Runnable 接口； 实现 Callable接口； 继承 Tread 类；  实现 Runnable 接口 需要实现接口中的 run() 方法。\npublic class MyRunnable implements Runnable { @Override public void run(){ // ... } } 使用 Runnable 实例再创建一个 Thread 实例，然后调用 Thread 实例的 start() 方法来启动线程。\npublic static void main(String[] args){ MyRunnable instance = new MyRunnable(); Thread thread = new Thread(instance); thread.start(); } 实现 Callable 接口 与 Runnable 相比，Callable 可以有返回值，返回值通过 FutureTask 进行封装。\npublic class MyCallable implements Callable\u0026lt;Integer\u0026gt; { public Integer call(){ return 123; } } public static void main(String[] args) throws ExecutionException,InterruptedException { MyCallable mc = new MyCallble(); FutureTask\u0026lt;Integer\u0026gt; ft = new FutureTask\u0026lt;\u0026gt;(mc); Thread thread = new Thread(ft); thread.start(); System.out.println(ft.get()); } 继承 Thread 类 同样也是需要实现 run() 方法，因为 Thread 类也实现了 Runnable 接口。\n当调用 start() 方法启动一个线程时，虚拟机会将该线程放入就绪队列中等待被调度，当一个线程被调度时会执行该线程的 run() 方法。\npublic class MyThread extends Thread { public void run() { // ... } } public static void main(String[] args) { MyThread mt = new MyThread(); mt.start(); } 实现接口 VS 继承 Thread 实现接口会更好一些，因为：\n Java 不支持多重继承，可以实现多个接口。 继承整个 Thread 类开销过大。  四、互斥同步 Java 提供了两种锁机制来控制多个线程对共享资源的互斥访问，第一个是 JVM 实现的 synchronized，而另一个是 JDK 实现的 ReentrantLock。\nsynchronized 1.同步一个代码块 public void func() { synchronized (this) { // ... } } 它只作用于同一个对象，如果调用两个对象上的同步代码块，就不会进行同步。\n对于以下代码，使用 ExecutorService 执行了两个线程，由于调用的是同一个对象的同步代码块，因此这两个线程会进行同步，当一个线程进入同步语句块时，另一个线程就必须等待。\npublic class SynchronizedExample { public void func1() { synchronized (this) { for (int i = 0; i \u0026lt; 10; i++) { System.out.print(i + \u0026#34; \u0026#34;); } } } } public static void main(String[] args) { SynchronizedExample e1 = new SynchronizedExample(); ExecutorService executorService = Executors.newCachedThreadPool(); executorService.execute(() -\u0026gt; e1.func1()); executorService.execute(() -\u0026gt; e1.func1()); } 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 对于以下代码，两个线程调用了不同对象的同步代码块，因此这两个线程就不需要同步。从输出结果可以看出，两个线程交叉执行。\npublic static void main(String[] args) { SynchronizedExample e1 = new SynchronizedExample(); SynchronizedExample e2 = new SynchronizedExample(); ExecutorService executorService = Executors.newCachedThreadPool(); executorService.execute(() -\u0026gt; e1.func1()); executorService.execute(() -\u0026gt; e2.func1()); } 0 0 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9 2.同步一个方法 public synchronized void func() { // ... } 它和同步代码块一样，作用于同一个对象\n3.同步一个类 public void func() { synchronized (SynchronizedExample.class) { // ... } } 作用于整个类，也就是说两个线程调用同一个类的不同对象上的这种同步语句块，也会进行同步。\npublic class SynchronizedExample { public void func2() { synchronized (SynchronizedExample.class) { for (int i = 0; i \u0026lt; 10; i++) { System.out.print(i + \u0026#34; \u0026#34;); } } } } public static void main(String[] args) { SynchronizedExample e1 = new SynchronizedExample(); SynchronizedExample e2 = new SynchronizedExample(); ExecutorService executorService = Executors.newCachedThreadPool(); executorService.execute(() -\u0026gt; e1.func2()); executorService.execute(() -\u0026gt; e2.func2()); } 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 4.同步一个静态方法 public synchronized static void fun() { // ... } 作用于整个类。\nReentrantLock ReentrantLock 是 java.util.concurrent（J.U.C)包中的锁。\npublic class LockExample { private Lock lock = new ReentrantLock(); public void func() { lock.lock(); try { for (int i = 0; i \u0026lt; 10; i++) { System.out.print(i + \u0026#34; \u0026#34;); } } finally { lock.unlock(); // 确保释放锁，从而避免发生死锁。 } } } public static void main(String[] args) { LockExample lockExample = new LockExample(); ExecutorService executorService = Executors.newCachedThreadPool(); executorService.execute(() -\u0026gt; lockExample.func()); executorService.execute(() -\u0026gt; lockExample.func()); } 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 使用选择 除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized。这是因为 synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。并且使用 synchronized 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放。\n六、线程状态 新建 可运行 阻塞 无限期等待 死亡 ","permalink":"/post/2021/01/09/java-%E5%B9%B6%E5%8F%91/","summary":"一、使用线程 有三种使用线程的方法： 实现 Runnable 接口； 实现 Callable接口； 继承 Tread 类； 实现 Runnable 接口 需要实现接口中的 run() 方法。 public class MyRunnable implements Runnable { @Override public void run(){ // ...","title":"Java 并发"},{"content":" “一切的答案，都在奈落之底。” 《来自深渊》\n 人类从未停止对未知事物的探寻。对内，不断剖析人的身体构造、思想信仰；对外，不断探索宇宙的边际，寻找那遥远处的未知。人从哪里来，往哪里去。如果不能解答这些问题，就不能认识到自身的存在意义。\n","permalink":"/blog/2021/01/07/%E5%A5%88%E8%90%BD%E4%B9%8B%E5%BA%95/","summary":"“一切的答案，都在奈落之底。” 《来自深渊》 人类从未停止对未知事物的探寻。对内，不断剖析人的身体构造、思想信仰；对外，不断探索宇宙的边际，寻找","title":"奈落之底"},{"content":" 从前 现在 过去了 再不来\n红红落叶 长埋 尘土内 开始 终结 总是 没变改\n天边的你 漂泊 白云外\n《一生所爱》\n ","permalink":"/blog/2021/01/03/%E9%A3%9E%E8%9B%BE%E6%89%91%E7%81%AB%E5%91%BD%E8%BF%90/","summary":"从前 现在 过去了 再不来 红红落叶 长埋 尘土内 开始 终结 总是 没变改 天边的你 漂泊 白云外 《一生所爱》","title":"飞蛾扑火——命运"},{"content":"现在是凌晨两点半。\n在刚刚写好上一篇文章的时候，突然恶心呕吐……应该是今天吃的东西的锅。今天蒸了网购的腊肠，吃完就感觉隐隐不舒服，只是没想到后来越来越严重。\n万一我挂了，这要归咎于朴朴上那些黑心的商家，望后来者哀之而鉴之……\n","permalink":"/blog/2021/01/02/%E4%BA%8B%E6%95%85/","summary":"现在是凌晨两点半。 在刚刚写好上一篇文章的时候，突然恶心呕吐……应该是今天吃的东西的锅。今天蒸了网购的腊肠，吃完就感觉隐隐不舒服，只是没想到后","title":"事“故”"},{"content":"现在，2020 年已成为过去。在这里我不想总结过去，也不想展望未来，而是记录此刻的想法。\n我的记忆力和我的听力一样不靠谱，这个问题由来已久。有得就有失，选择性遗忘有时候是保护自己的一种方式，但也有着它的代价。因此，这也是我一直以来想用文字来记录的原因。人生无常且短暂，无论是积极的、愉悦的，还是负面的、痛苦的事物、想法，都应该被记录下来。\n昨天是在单位实习的最后一天。在这期间我遇到不少很棒的人，有许多很照顾我的朋友。是啊，刚出来社会都会有许多困惑。对我来说可能最困扰的应该是：人为什么而活？这个问题由来已久，对我来说可以追溯到……好吧，具体时间已经忘记了，但是我还记得当时的情形：我坐在一个石板上，时不时抬头望天空（小时候对神秘的宇宙真的很感兴趣）。显然当时的我不可能得出答案，不过却引起了一个子问题的思考:死亡是什么？当时我得出了一个结论，这个结论到现在我也认同：死亡会令你失去感知能力和思考能力。没办法感知这世界，感知身边的喜怒哀乐，没办法去思考。这是多可惜、多令人害怕的事情。\n现在，我期望家人朋友都平安快乐地生活。同时人生不容易，我总得在世界上留下自己的声音。\n","permalink":"/blog/2021/01/01/2021-%E5%B9%B4%E7%9A%84%E5%BC%80%E5%A7%8B/","summary":"现在，2020 年已成为过去。在这里我不想总结过去，也不想展望未来，而是记录此刻的想法。 我的记忆力和我的听力一样不靠谱，这个问题由来已久。有得","title":"2021 年的开始"},{"content":" 一、基础 二、创建表 三、修改表 四、插入 五、更新 六、删除 七、查询  DISTINCT LIMIT   八、排序 九、过滤 十、通配符 十一、计算字段 十二、函数  汇总 文本处理 日期和时间处理 数值处理   十三、分组 十四、子查询 十五、连接  内连接 自连接 自然连接 外连接   十六、组合查询 十七、视图 十八、存储过程 十九、游标 二十、触发器 二十一、事务管理 二十二、字符集 二十三、权限管理  一、基础 模式定义了数据如何存储、存储怎么样的数据以及数据如何分解等信息，数据库和表都有模式。\n主键的值不允许修改，也不允许复用（不能将已经删除的主键值赋给新数据行的主键）。\nSQL，（Structred Query Language)，标准 SQL 由 ANSI 标准委员会管理，从而被称为 ANSI SQL。各个 DBMS 都有自己的实现，如 PL/SQL、Transact-SQL 等。\nSQL 语句不区分大小写，但是数据库表名、列名和值是否区分依赖于具体的 DBMS 以及配置。\nSQL 支持以下三种注释：\n### 注释 SELECT * FROM mytable; -- 注释 /* 注释1 注释2 */ 数据库创建与使用：\nCREATE DATABASE test; USE test; 二、创建表 CREATE TABLE mytable ( # int 类型，不为空，自增 id INT NOT NULL AUTO_INCREMENT, # int 类型，不可为空，默认值为1，不为空 col1 INT NOT NULL DEFAULT 1, # 变长字符串类型，最常为 45 个字符，可以为空 col2 VARCHAR(45) NULL, # 日期类型，可为空 col3 DATE NULL, # 设置主健为 id PRIMARY KEY (`id`) ); 三、修改表 添加列\nALTER TABLE mytable ADD col CHAR(20); 删除列\nALTER TABLE mytable DROP COLUMN col; 删除表\nDROP TABLE mytable; 四、插入 普通插入\nINSERT INTO mytable(col1, col2) VALUES(val1,val2); 插入检索出来的数据\nINSERT INTO mytable1(col1, col2) SELECT col1, col2 FROM mytable2; 将一个表的内容插入到一个新表\nCREATE TABLE newtable AS SELECT * FROM mytable; 五、更新 UPDATE mytable SET col = val WHERE id = 1; 六、删除 DELETE FROM mytable WHERE id = 1; TRUNCATE TABLE table 可以清空表，也就是删除所有行。\nTRUNCATE TABLE mytable; 使用更新和删除操作时一定要用 WHERE 字句，不然会把整张表的数据都损坏。用 SELECT 语句进行测试，防止错误删除。\n七、查询 DISTINCT 相同值只会出现一次。它作用与所有列，也就是说所有列的值都想同时才算相同。\nSELECT DISTINCT col1, col2 FROM mytable; LIMIT 限制返回的行数。可以有两个参数，第一个参数为起始行，从 0 开始；第二个参数为返回的总行数。\n返回前五行：\nSELECT * FROM mytable LIMIT 5; SELECT * FROM mytable LIMIT 0, 5; 返回第3～5行：\nSELECT * FROM mytable LIMIT 2, 3; 八、排序  ASC：升序（默认） DESC：降序 可以按多个列进行排序，并且为每个列指定不同的排序方式：  SELECT * FROM mytable ORDER BY col1 DESC, col2 ASC; 九、过滤 不进行过滤的数据非常大，导致通过网络传输了多余的数据，从而浪费了网络带宽。因此尽量使用 SQL 语句来过滤不必要的数据，而不是传输所有的数据到客户端中然后由客户端进行过滤。\nSELECT * FROM mytable WHERE col IS NULL; 下表显示了 WHERE 字句可用的操作符。\n   操作符 说明     = 等于   \u0026lt; 小于   \u0026gt; 大于   \u0026lt;\u0026gt;!= 不等于   \u0026lt;=!\u0026gt; 小于等于   \u0026gt;=!= 大于等于   BETWEEN 在两个值之间   IS NULL 为 NULL 值    应该注意到，NULL 和 0、空字符串都不同。\nAND 和 OR 用于连接多个过滤条件。优先处理 AND，当一个过滤表达式涉及到多个 AND 和 OR 时，可以使用（）来决定优先级，时的优先级关系更清晰。\nIN 操作符用于匹配一组值，其后也可以接一个 SELECT 子句，从而匹配子查询得到的一组值。\nNOT 操作符用于否定一个条件。\n十、通配符 通配符也是用在过滤语句中，但它只能用于文本字段。\n % 匹配 \u0026gt;=0 个任意字符； _ 匹配 ==1 个任意字符； [] 可以匹配集合内的字符，例如 [ab]将匹配字符 a 或者 b。用脱字符 ^ 可以对其进行否定，也就是不匹配集合内的字符。\n使用 LIKE 来进行通配符匹配。  SELECT * FROM mytable WHERE col LIKE \u0026#39;[^AB]%\u0026#39;; -- 不以 A 和 B 开头的任意文本 不要滥用通配符，通配符位于开头处匹配会非常慢。\n十一、计算字段 在数据库服务器上完成数据的转换和格式化的工作往往比客户端上快得多，并且转换和格式化后的数据量更少的话可以减少网络通信量。\n计算字段通常需要使用 AS 来取别名，否则输出的时候字段名为计算表达式。\nSELECT col1 * col2 AS alias FROM mytable; CONCAT() 用于连接两个字段。许多数据库会使用空格把一个值填充为列宽，因此连接的结果会出现一些不必要的空格，使用 TRIM() 可以去除首尾空格。\nSELECT CONCAT(TRIM(col1), \u0026#39;(\u0026#39;, TRIM(col2), \u0026#39;)\u0026#39;) AS concat_col FROM mytable; 十二、函数 各个 DBMS 的函数都是不相同的，因此不可移植，以下主要是 MySQL 的函数。\n汇总 AVG()\t返回某列的平均值\nCOUNT()\t返回某列的行数\nMAX()\t返回某列的最大值\nMIN()\t返回某列的最小值\nSUM()\t返回某列值之和\nAVG() 会忽略 NULL 行。\n使用 DISTINCT 可以汇总不同的值。\nSELECT AVG(DISTINCT col1) AS avg_col FROM mytable; 文本处理 LEFT()\t左边的字符\nRIGHT()\t右边的字符\nLOWER()\t转换为小写字符\nUPPER()\t转换为大写字符\nLTRIM()\t去除左边的空格\nRTRIM()\t去除右边的空格\nLENGTH()\t长度\nSOUNDEX()\t转换为语音值\n其中， SOUNDEX() 可以将一个字符串转换为描述其语音表示的字母数字模式。\nSELECT * FROM mytable WHERE SOUNDEX(col1) = SOUNDEX(\u0026#39;apple\u0026#39;) 日期和时间处理  日期格式：YYYY-MM-DD 时间格式：HH:MM:SS  ADDDATE()\t增加一个日期（天、周等）\nADDTIME()\t增加一个时间（时、分等）\nCURDATE()\t返回当前日期\nCURTIME()\t返回当前时间\nDATE()\t返回日期时间的日期部分\nDATEDIFF()\t计算两个日期之差\nDATE_ADD()\t高度灵活的日期运算函数\nDATE_FORMAT()\t返回一个格式化的日期或时间串\nDAY()\t返回一个日期的天数部分\nDAYOFWEEK()\t对于一个日期，返回对应的星期几\nHOUR()\t返回一个时间的小时部分\nMINUTE()\t返回一个时间的分钟部分\nMONTH()\t返回一个日期的月份部分\nNOW()\t返回当前日期和时间\nSECOND()\t返回一个时间的秒部分\nTIME()\t返回一个日期时间的时间部分\nYEAR()\t返回一个日期的年份部分\nmysql\u0026gt; SELECT NOW(); 2018-4-14 20:25:11 数值处理 SIN()\t正弦 COS()\t余弦 TAN()\t正切 ABS()\t绝对值 SQRT()\t平方根 MOD()\t余数 EXP()\t指数 PI()\t圆周率 RAND()\t随机数\n十三、分组 把具有相同的数据值的行放在同一组中。\n可以对同一分组数据使用汇总函数进行处理，例如求分组数据的平均值等。\n指定的分组字段除了能按该字段进行分组，也会自动按该字段进行排序。\nSELECT col, COUNT(*) AS num FROM mytable GROUP BY col; GROUP BY 自动按分组字段进行排序，ORDER BY 也可以按汇总字段来进行排序。\nSELECT col, COUNT(*) AS num FROM mytable GROUP BY col ORDER BY num; 分组规定：\n GROUP BY 子句出现在 WHERE 子句之后，ORDER BY 子句之前； 除了汇总字段外，SELECT 语句中的每一字段都必须在 GROUP BY 子句中给出； NULL 的行会单独分为一组； 大多数 SQL 实现不支持 GROUP BY 列具有可变长度的数据类型。  十四、子查询 子查询中只能返回一个字段的数据。\n可以将子查询的结果作为 WHRER 语句的过滤条件：\nSELECT * FROM mytable1 WHERE col1 IN (SELECT col2 FROM mytable2); 下面的语句可以检索出客户的订单数量，子查询语句会对第一个查询检索出的每个客户执行一次：\nSELECT cust_name, (SELECT COUNT(*) FROM Orders WHERE Orders.cust_id = Customers.cust_id) AS orders_num FROM Customers ORDER BY cust_name; 十五、连接 连接用于连接多个表，使用 JOIN 关键字，并且条件语句使用 ON 而不是 WHERE。\n连接可以替换子查询，并且比子查询的效率一般会更快。\n可以用 AS 给列名、计算字段和表名取别名，给表名取别名是为了简化 SQL 语句以及连接相同表。\n内连接 内连接又称等值连接，使用 INNER JOIN 关键字。\nSELECT A.value, B.value FROM tablea AS A INNER JOIN tableb AS B ON A.key = B.key; 可以不明确使用 INNER JOIN，而使用普通查询并在 WHERE 中将两个表中要连接的列用等值方法连接起来。\nSELECT A.value, B.value FROM tablea AS A, tableb AS B WHERE A.key = B.key; 自连接 自连接可以看成内连接的一种，只是连接的表是自身而已。\n一张员工表，包含员工姓名和员工所属部门，要找出与 Jim 处在同一部门的所有员工姓名。\n子查询版本\nSELECT name FROM employee WHERE department = ( SELECT department FROM employee WHERE name = \u0026#34;Jim\u0026#34;); 自连接版本\nSELECT e1.name FROM employee AS e1 INNER JOIN employee AS e2 ON e1.department = e2.department AND e2.name = \u0026#34;Jim\u0026#34;; 自然连接 自然连接是把同名列通过等值测试连接起来的，同名列可以有多个。\n内连接和自然连接的区别：内连接提供连接的列，而自然连接自动连接所有同名列。\nSELECT A.value, B.value FROM tablea AS A NATURAL JOIN tableb AS B; 外连接 外连接保留了没有关联的那些行。分为左外连接，右外连接以及全外连接，左外连接就是保留左表没有关联的行。\n十六、组合查询 使用 UNION 来组合两个查询，如果第一个查询返回 M 行，第二个查询返回 N 行，那么组合查询的结果一般为 M+N 行。\n每个查询必须包含相同的列、表达式和聚集函数。\n默认会去除相同行，如果需要保留相同行，使用 UNION ALL。\n只能包含一个 ORDER BY 子句，并且必须位于语句的最后。\nSELECT col FROM mytable WHERE col = 1 UNION SELECT col FROM mytable WHERE col =2; 十七、视图 视图是虚拟的表，本身不包含数据，也就不能对其进行索引操作。\n对视图的操作和对普通表的操作一样。\n视图具有如下好处：\n 简化复杂的 SQL 操作，比如复杂的连接； 只使用实际表的一部分数据； 通过只给用户访问视图的权限，保证数据的安全性； 更改数据格式和表示。  CREATE VIEW myview AS SELECT Concat(col1, col2) AS concat_col, col3*col4 AS compute_col FROM mytable WHERE col5 = val; 十八、存储过程 存储过程可以看成是对一系列 SQL 操作的批处理。\n使用存储过程的好处：\n 代码封装，保证了一定的安全性； 代码复用； 由于是预先编译，因此具有很高的性能。 命令行中创建存储过程需要自定义分隔符，因为命令行是以 ; 为结束符，而存储过程中也包含了分号，因此会错误把这部分分号当成是结束符，造成语法错误。  包含 in、out 和 inout 三种参数。\n给变量赋值都需要用 select into 语句。\n每次只能给一个变量赋值，不支持集合的操作。\ndelimiter // create procedure myprocedure( out ret int ) begin declare y int; select sum(col1) from mytable into y; select y*y into ret; end // delimiter ; call myprocedure(@ret); select @ret; 十九、游标 在存储过程中使用游标可以对一个结果集进行移动遍历。\n游标主要用于交互式应用，其中用户需要对数据集中的任意行进行浏览和修改。\n使用游标的四个步骤：\n 声明游标，这个过程没有实际检索出数据； 打开游标； 取出数据； 关闭游标；  delimiter // create procedure myprocedure(out ret int) begin declare done boolean default 0; declare mycursor cursor for select col1 from mytable; # 定义了一个 continue handler，当 sqlstate \u0026#39;02000\u0026#39; 这个条件出现时，会执行 set done = 1 declare continue handler for sqlstate \u0026#39;02000\u0026#39; set done = 1; open mycursor; repeat fetch mycursor into ret; select ret; until done end repeat; close mycursor; end // delimiter ; 二十、触发器 触发器会在某个表执行以下语句时而自动执行：DELETE、INSERT、UPDATE。\n触发器必须指定在语句执行之前还是之后自动执行，之前执行使用 BEFORE 关键字，之后执行使用 AFTER 关键字。BEFORE 用于数据验证和净化，AFTER 用于审计跟踪，将修改记录到另外一张表中。\nINSERT 触发器包含一个名为 NEW 的虚拟表。\nCREATE TRIGGER mytrigger AFTER INSERT ON mytable FOR EACH ROW SELECT NEW.col into @result; SELECT @result; -- 获取结果 DELETE 触发器包含一个名为 OLD 的虚拟表，并且是只读的。\nUPDATE 触发器包含一个名为 NEW 和一个名为 OLD 的虚拟表，其中 NEW 是可以被修改的，而 OLD 是只读的。\nMySQL 不允许在触发器中使用 CALL 语句，也就是不能调用存储过程。\n二十一、事务管理 基本术语：\n 事务（transaction）指一组 SQL 语句； 回退（rollback）指撤销指定 SQL 语句的过程； 提交（commit）指将未存储的 SQL 语句结果写入数据库表； 保留点（savepoint）指事务处理中设置的临时占位符（placeholder），你可* 以对它发布回退（与回退整个事务处理不同）。  不能回退 SELECT 语句，回退 SELECT 语句也没意义；也不能回退 CREATE 和 DROP 语句。\nMySQL 的事务提交默认是隐式提交，每执行一条语句就把这条语句当成一个事务然后进行提交。当出现 START TRANSACTION 语句时，会关闭隐式提交；当 COMMIT 或 ROLLBACK 语句执行后，事务会自动关闭，重新恢复隐式提交。\n设置 autocommit 为 0 可以取消自动提交；autocommit 标记是针对每个连接而不是针对服务器的。\n如果没有设置保留点，ROLLBACK 会回退到 START TRANSACTION 语句处；如果设置了保留点，并且在 ROLLBACK 中指定该保留点，则会回退到该保留点。\nSTART TRANSACTION // ... SAVEPOINT delete1 // ... ROLLBACK TO delete1 // ... COMMIT 二十二、字符集 基本术语：\n 字符集为字母和符号的集合； 编码为某个字符集成员的内部表示； 校对字符指定如何比较，主要用于排序和分组。  除了给表指定字符集和校对外，也可以给列指定：\nCREATE TABLE mytable (col VARCHAR(10) CHARACTER SET latin COLLATE latin1_general_ci ) DEFAULT CHARACTER SET hebrew COLLATE hebrew_general_ci; 可以在排序、分组时指定校对：\nSELECT * FROM mytable ORDER BY col COLLATE latin1_general_ci; 二十三、权限管理 MySQL 的账户信息保存在 mysql 这个数据库中。\nUSE mysql; SELECT user FROM user; 创建账户\n新创建的账户没有任何权限。\nCREATE USER myuser IDENTIFIED BY \u0026#39;mypassword\u0026#39;; 修改账户名\nRENAME USER myuser TO newuser; 删除账户\nDROP USER myuser; 查看权限\nSHOW GRANTS FOR myuser; 授予权限\n账户用 username@host 的形式定义，username@% 使用的是默认主机名。\nGRANT SELECT, INSERT ON mydatabase.* TO myuser; 删除权限\nGRANT 和 REVOKE 可在几个层次上控制访问权限：\n 整个服务器，使用 GRANT ALL 和 REVOKE ALL； 整个数据库，使用 ON database.*； 特定的表，使用 ON database.table； 特定的列； 特定的存储过程。  REVOKE SELECT, INSERT ON mydatabase.* FROM myuser; 更改密码\n必须使用 Password() 函数进行加密。\nSET PASSWROD FOR myuser = Password(\u0026#39;new_password\u0026#39;); ","permalink":"/collection/2020-12-31-sql/","summary":"一、基础 二、创建表 三、修改表 四、插入 五、更新 六、删除 七、查询 DISTINCT LIMIT 八、排序 九、过滤 十、通配符 十一、计算字段 十二、函数 汇总 文本处理 日期和时间处理","title":"【转载】SQL 语法"},{"content":"如果你对 Linux 感兴趣但还不了解，想知道 Linux 的不同发行版之间的区别，我的这些经历应该对你有帮助。\n我最初使用的是 Ubuntu，它以前经常被推荐为 Linux 入门选择。用了很长一段时间，它给我最大的感受是不稳定和笨重。会经常收到系统内部崩溃的通知，而且另一个问题是装其他显卡驱动时很艰难（做深度学习、玩游戏等等会用到），令我几度崩溃 T_T 。所以，我认为 Ubuntu 对新手非常不友好；\n后来我开始尝试 Deepin 系统，这是一款由国内深之度公司推出的发行版，预装软件最符合国人习惯，而且上手简单，系统不需要怎么配置就能拥有漂亮的界面。但是很快我就不能忍受它的软件源的落后。软件获取、维护便捷本该是 Linux 系统的一大优点，它可以为很多工作带来便利。\n接着我来到 Arch 的世界。遗憾的是 Arch Linux 我在尝试的中途便放弃了。它确实很棒，从零开始定制操作系统很诱人，但是因为时间关系，我需要的是能快速上手，成为主力的操作系统。\n最后，我接触到了很多人推荐的 Manjaro，它是为了让用户更方便使用的 Arch 衍生版。安装之后确实让我很惊喜，它完美符合我对操作系统的需求：上手简单、使用高效、美。而且尝试过后我才知道 Arch 系的软件仓库 AUR 有多强大。AUR 是一个社区维护的软件包仓库，有了它，你可以轻易获取到很多想要的软件。因此我很推荐使用 Manjaro。\n（顺便提一下最稳定发行版之一的 CentOS。当我想在服务器上尝试它时，它就被官宣抛弃了……）\n","permalink":"/post/2020/12/26/linux-%E4%B8%8D%E5%90%8C%E5%8F%91%E8%A1%8C%E7%89%88%E7%9A%84%E9%80%89%E6%8B%A9/","summary":"如果你对 Linux 感兴趣但还不了解，想知道 Linux 的不同发行版之间的区别，我的这些经历应该对你有帮助。 我最初使用的是 Ubuntu，它以前经常被推荐为 Linux 入门","title":"Linux 不同发行版的选择"},{"content":"参考自 CyC2018/CS-Notes\n 一、运行时数据区域  程序计数器 Java 虚拟机栈 本地方法栈 堆 方法区 运行时常量池 直接内存   二、垃圾收集  判断一个对象是否可被回收 引用类型 垃圾收集算法 垃圾收集器   三、内存分配和回收策略  Minor Gc 和 Full Gc 内存分配策略 Full GC 的触发条件   四、类加载机制  类的生命周期 类加载过程 类初始化时机 类与类加载器 类加载器分类 双亲委派模型 自定义类加载器实现    一、运行时数据区域  程序计数器  记录正在执行的虚拟机字节码指令的地址（如果正在执行的是本地方法则为空）。\nJava 虚拟机栈  每个 Java方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。\n可以通过 -Xss 这个虚拟机参数来指定每个线程的 Java 虚拟机栈内存大小，在 JDK 1.4 中默认为 256K，而在 JDK1.5+ 默认为 1M：\njava -Xss2M HaskTheJava 该区域可能抛出以下异常：\n 当线程请求的栈深度超过最大值，会抛出 StackOverflowError 异常； 栈进行动态扩展的时如果无法申请到足够的内存，会抛出 OutofMemoryError 异常。  本地方法栈 本地方法栈与 Java 虚拟机栈类似，他们之间的区别只不过是本地方法栈为本地方法服务。\n本地方法一般是用其他语言（C、C++或汇编语言等等）编写的，并且被编译为基于本机硬件和操作系统的程序，对待这些方法需要特别处理。\n堆  所有对象都在这里分配内存，是垃圾收集的主要区域（\u0026ldquo;GC堆\u0026rdquo;）。\n现代的垃圾收集器基本都是采用分代收集算法，其主要的思想是针对不同类型的对象采用不同的垃圾回收算法。可以将堆分成两块：\n 新生代 老年代  堆不需要连续内存，并且可以动态增加其内存，增加失败会抛出 OutOfMemoryError 异常。\n可以通过 -Xms 和 -Xmx 这两个虚拟机参数来指定一个程序的堆内存大小，第一个参数设置初始值，第二个参数设置最大值。\njava -Xms1M -Xmx2M HackTheJava 方法区 用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。\n和堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出 OutOfMemoryError 异常。\n对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载，但是一般比较难实现。\nHotSpot 虚拟机把它当成永久代来进行垃圾回收。但很难确定永久代的大小，因为它受到很多因素影响，并且每次 Full GC 之后永久代的大小都会改变，所以经常会抛出 OutOfMemoryError 异常。为了更容易管理方法区，从 JDK 1.8 开始，移除永久代，并把方法区移至元空间，它位于本地内存，而不是虚拟机内存。\n方法区是一个 JVM 规范，永久代与元空间都是其一种实现方式。在 JDK 1.8 之后，原来永久代的数据被分到了堆和元空间中。元空间存储类的元信息，静态变量和常量池等放入堆中。\n运行时常量池 运行时常量池是方法区的一部分。\nClass 文件中的常量池（编译器生成的字面量和符号引用）会在类加载后被放入这个区域。\n除了在编译期生成的常量，还允许动态生成，例如 String 类的 intern()。\n直接内存 在 JDK 1.4 中新引入了 NIO 类，它可以使用 Native 函数库直接分配堆外内存。\n二、垃圾回收 垃圾收集主要是针对堆和方法区进行。程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期，线程结束之后就会消失，因此不需要对这三个区域进行垃圾回收。\n判断一个对象是否可被回收 1.引用技术算法 （相互引用时，两个对象都无法被回收）\n2.可达性分析 以 GC Roots为起始点进行搜索，可达的对象都是存活的，不可达的对象可被回收。 Java 虚拟机使用该算法来判断对象是否可被回收，GC Roots 一般包含以下内容：\n 虚拟机栈中局部变量表中引用的对象 本地方法栈 JNI 中引用的对象 方法区中类静态属性引用的对象 方法区中的常量引用的对象  3.方法区的回收 因为方法区主要存放永久代对象，而永久代对象的回收率比新生代低很多，所有在方法区上进行回收性价比不高。\n主要是对常量池的回收和对类的卸载。\n4.finalize() 类似 C++ 的析构函数，用于关闭外部资源。最好别用，用try-finally等。\n引用类型 1.强引用 被强引用关联的对象不会被回收。\n使用 new 一个新对象来创建强引用。\n2.软引用 3.弱引用 4.虚引用 垃圾收集算法 1.标记-清除 2.标记-整理 3.复制 4.分代收集 根据对象存活周期将内存划分为几块，不痛块采用适当的收集算法。\n一般将堆分为新生代和老生代。\n 新生代使用：复制算法 老生代使用：标记-清除 或者 标记-整理 算法  四、类加载机制 类是在运行期间第一次使用时动态加载的，而不是一次性加载所有类。因为如果一次性加载，那么会占用很多的内存。\n类的生命周期 包括以下阶段：\n 加载 验证 准备 解析 初始化 使用 卸载  ","permalink":"/collection/2020-12-25jvm/","summary":"参考自 CyC2018/CS-Notes 一、运行时数据区域 程序计数器 Java 虚拟机栈 本地方法栈 堆 方法区 运行时常量池 直接内存 二、垃圾收集 判断一个对象是否可被回收 引用类型 垃圾收集算法","title":"【转载】Java 虚拟机"},{"content":"是夜，黑暗逐渐笼罩大地，劳累了一天的人们也逐渐睡去。然而，在一个狭窄凌乱的房间里，还泛着些许微光。他坐在书桌前，浑然不觉窗外传来的阵阵寒意，只因思绪沉浸在先前发生的一幕……\n时间回到傍晚时分，他从单位回到了住处。那是一个旧小区，狭窄昏暗的楼梯，忽闪忽闪的楼道灯光，仿佛在陈述着它久远的历史。与往常一样，他翻了翻手机未读信息，便倒睡在床上。枕着按摩枕，戴上热敷眼罩，再给耳朵塞上耳机，最后躺在床上，仿佛在仙境一般舒适，全然忘记了白天的劳累。渐渐地，伴着歌声的旋律，逐渐进入了一种半梦半醒的状态……梦中不知时间流逝，恍惚之间，他从这种状态中醒来。下床，然后走到浴室。忽然，他觉察到某个地方不对劲。猛地低头，发现鞋子有了异样……\n显然，这并非他的鞋子。问题是，它从什么时候出现在他的脚下，或者说什么时候出现在他的床边……未知的诡异感让他一下子清醒，多年的侦探思维派上用场。压下心头思绪，他将它放回室友的鞋架位置，仿佛当做无事发生，而实则开始暗自思索。“刚回来时便穿错了？不对，根据平时放鞋的习惯位置和鞋子的明显差异，可能很小。”“那它从一开始就在那里了？还是，在他睡觉的时候……”\n不寻常的事物从不单独出现，他开始联想最近发生的不平常的事件。“最近深夜无人的客厅常常传来响动、室友某天早起出门后便再没回来……”细细琢磨，平日里安静的环境里隐藏着许多未知的事物。到底发生了什么，又是因何而起，这一切是道德的沦丧还是人性的泯灭……等等！啊，他明白了，猛地转身。原来，这诡异的根源，这诡异的根源，就在他的背后……\n “什么，精神损失费？放心，我会在夜深的时候去送给你的……”\n ","permalink":"/blog/2020/12/25/%E5%A4%A7%E6%81%90%E6%80%96/","summary":"是夜，黑暗逐渐笼罩大地，劳累了一天的人们也逐渐睡去。然而，在一个狭窄凌乱的房间里，还泛着些许微光。他坐在书桌前，浑然不觉窗外传来的阵阵寒意，","title":"大恐怖"},{"content":"参考自 CyC2018/CS-Notes\n 一、概览  Collection Map    一、概览  容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map存储着键值对（两个对象）的映射表。\nCollection  1.Set\n TreeSet: 基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet, HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。 HashSet: 基于哈希表的实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。 LinkedHashSet: 具有 HashSet 的查找效率，并且内部使用双向链表维护元素的插入顺序。  2.List\n ArrayList： 基于动态数组实现，支持随机访问。 Vector： 和 ArrayList 类似，但它是线程安全的。 LinkedList： 基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用做栈、队列和双向队列。  3.Queue\n LinkedList：可以用它来实现双向队列。 PriorityQueue：基于堆结构实现，可以用它来实现优先队列。  Map   TreeMap：基于红黑树实现 HashMap：基于哈希表实现 hashTable：和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程同时写入 HashTable 不会导致数据不一致。它是遗留类，不应该去使用它，而是使用 ConcurrentHashMap 来支持线程安全，ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。 LinkedHashMap：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。  ","permalink":"/collection/2020-12-24-collection/","summary":"参考自 CyC2018/CS-Notes 一、概览 Collection Map 一、概览 容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map存储着键值对（两个对象）的映射表。 Collection 1.Set TreeSet: 基","title":"【转载】Java 容器"},{"content":"晚上不开心，就会睡不好，睡不好早上就会早早起床，早起本身和它带来的结果（如吃上热腾腾的早餐）又会让人开心。\n晚上很开心，就会睡得香，睡得香早上就不愿意起床，赖床本身和它带来的结果（如迟到）又会让人不开心。\n所以，在晚上的时候要开心好，还是不开心好？\n “唉，我看你是想找不开心！”\n ","permalink":"/blog/2020/12/17/%E5%BC%80%E5%BF%83/","summary":"晚上不开心，就会睡不好，睡不好早上就会早早起床，早起本身和它带来的结果（如吃上热腾腾的早餐）又会让人开心。 晚上很开心，就会睡得香，睡得香早上","title":"开心"},{"content":"今年的冬天也是格外的冷。\n有时候讨厌冬天，因为自身仿佛不会发热，所以总感觉冷。有时候喜欢冬天，寒冷时刻刺激着大脑，提醒着要清醒。\n今天晚上吃了两根玉米，本以为清水一煮，简单了事。结果，还是吃着还是生的，但是已经不想再动手煮了。\n此情此景，我想起了那个卖火柴的小女孩。在那时候，想必她也没那么容易睡着吧，她会想些什么呢？是在想她爱的人还是爱她的人呢？\n","permalink":"/blog/2020/12/16/%E5%8D%96%E7%81%AB%E6%9F%B4%E7%9A%84%E5%B0%8F%E5%A5%B3%E5%AD%A9/","summary":"今年的冬天也是格外的冷。 有时候讨厌冬天，因为自身仿佛不会发热，所以总感觉冷。有时候喜欢冬天，寒冷时刻刺激着大脑，提醒着要清醒。 今天晚上吃了两","title":"卖火柴的小女孩"},{"content":"对于 java.lang.String 类，我相信很多人印象里都是它不能被改变。通过查看源码，可以知道 String 有一个 final char 数组的变量，这个变量初始化之后便不能重新赋值。虽然这个变量引用的 char 数组的值虽然可以改变，但是String 类中并没有主动修改 这个 char 数组的方法。这就是通常所说 String 类不可变的依据。\n然而在学习反射的时候，我产生了一个疑问：我们不可以通过反射修改 String 内部的 char 数组的值吗？答案是可以的，了解 Java 反射的人很容易就做到这点。那为什么还说 String 不可变呢？在思考过后，我得出一个答案：String 的不可变说的是一种约束规范。换句话说，String 的不可变是有好处的。在实际工作中，代码是自己写来用的，没有人会费劲给自己找麻烦，而没有任何益处。\n事情到这里就完了？不，最近我再去了解 String 、String Pool（字符串常量池）的时候，又有了一些疑惑，于是亲手操刀给String 来了一次手术。最后也是加深了对 String 的理解，也验证了上面的观点。先上代码（如果你对任一实验结果感到疑惑，没关系，请带着疑惑来看后面的对照实验）：\n //实验1 String s1 = \u0026#34;1\u0026#34;; Field valueField = String.class.getDeclaredField(\u0026#34;value\u0026#34;); valueField.setAccessible(true); char[] value = (char[]) valueField.get(s1); value[0] = \u0026#39;2\u0026#39;; System.out.println(s1); //2 System.out.println((s1 == \u0026#34;1\u0026#34;)); //true 上述实验 1 做的事情就是：用 s1 = \u0026quot;1\u0026quot;  的方式创建字符串，用反射修改它的值为 \u0026quot;2\u0026quot;,最后用它与 \u0026quot;1\u0026quot; 比较，结果是 true 。琢磨琢磨，再看下一段代码：\n //实验2 String s2 = new String(\u0026#34;1\u0026#34;); Field valueField = String.class.getDeclaredField(\u0026#34;value\u0026#34;); valueField.setAccessible(true); char[] value2 = (char[]) valueField.get(s2); value2[0] = \u0026#39;2\u0026#39;; System.out.println(s2); //2 System.out.println((s2 == \u0026#34;1\u0026#34;)); //false 上述实验 2 和实验 1 唯一的区别是字符串创建方式，实验2是通过 new String(\u0026quot;1\u0026quot;) 方式创建，实验1是通过 = \u0026quot;1\u0026quot; 的方式创建。而实验2的结果： s2 == \u0026quot;1\u0026quot; 是 false 。\n到这里，可以停一会了。很多技术文章中都做过类似上面的实验（通过比较创建方式的区别、反射修改等)，来分析 String 、String Pool 的原理和设计理念。但我总觉得以此说明最终的结论还不够严谨、或者说还不够直观。接下来请看——魔鬼实验：\n //实验3 String s1 = \u0026#34;1\u0026#34;; Field valueField = String.class.getDeclaredField(\u0026#34;value\u0026#34;); valueField.setAccessible(true); char[] value = (char[]) valueField.get(s1); value[0] = \u0026#39;2\u0026#39;; System.out.println(s1); //2 System.out.println((s1 == \u0026#34;1\u0026#34;)); //true System.out.println(\u0026#34;1\u0026#34;); //2 不难发现，实验3仅仅只是在实验1的基础上输出了 \u0026quot;1\u0026quot; 的值。然而 \u0026quot;1\u0026quot; 输出的值为 2，这样的结果，也许有人会困惑，没关系,看完几个对比实验，相信你会对相关理论（String 、String Pool 等）有了更直观的认识。接下来，请看终极实验：\n //实验4 String s2 = new String(\u0026#34;1\u0026#34;); Field valueField = String.class.getDeclaredField(\u0026#34;value\u0026#34;); valueField.setAccessible(true); char[] value2 = (char[]) valueField.get(s2); value2[0] = \u0026#39;2\u0026#39;; System.out.println(s2); //2 System.out.println((s2 == \u0026#34;1\u0026#34;)); //false System.out.println(\u0026#34;1\u0026#34;); //2 同样的，上述实验 4 只是在实验 2 的基础上输出了 \u0026quot;1\u0026quot; 的值。结果 \u0026quot;1\u0026quot; 的值还是 2。\n结论：\n基于对 String 类和字符串常量池（String Pool） 的了解，我对以上实验作出解释（详细理论下回贴出）:\n实验 3 中 字符串 s1 通过直接赋值字符串常量 \u0026quot;1\u0026quot; 的方式创建，因此 s1 会直接引用字符串常量池中 \u0026quot;1\u0026quot; 对应的对象。对 s1 的修改，也就是对常量池中 \u0026quot;1\u0026quot; 对象的修改，因此 s1 和 \u0026quot;1\u0026quot; 的值都是修改后的 2，而 s1 == \u0026quot;1\u0026quot; 也是 true,因为它们是同一个对象的引用。\n实验 4 中 字符串 s2 通过 new String(\u0026quot;1\u0026quot;)的方式创建，因此，s2 会被新建在堆中，并且，s2 的 char 数组变量会直接引用字符串常量池中 \u0026ldquo;1\u0026quot;对象的 char 数组，也就是说虽然 s2 是新创建的对象，但是 s2 里存储字符的 char 数组是创建时传进来的字符串常量 \u0026quot;1\u0026quot; 的 char 数组。因此，s2 修改 char 数组,\u0026quot;1\u0026quot; 的也会变。s2 和 \u0026quot;1\u0026quot; 的值都是修改后的 2 。而 s2 == \u0026quot;1\u0026quot; 是 false 的，因为它们引用的不是同一个对象。\n最终结论，String 类真的是“不可以”变的！因为这不仅仅是它的特点，更是它的设计初衷。（任何想通过反射修改它的人都应该被拉去祭天)\n如果你发现任何问题，请联系我。\n","permalink":"/post/2020/12/15/string-%E7%B1%BB%E7%9C%9F%E7%9A%84%E4%B8%8D%E5%8F%AF%E4%BB%A5%E6%94%B9%E5%8F%98%E5%90%97/","summary":"对于 java.lang.String 类，我相信很多人印象里都是它不能被改变。通过查看源码，可以知道 String 有一个 final char 数组的变量，这个变量初始化之后便不能重新赋值。虽然这个变量引","title":"String 类真的不可以改变吗？"},{"content":"参考自 CyC2018/CS-Notes\n 一、数据类型  基本类型 包装类型 缓存池   二、String  概述 不可变的好处 String,StringBuffer and StringBuilder StringPoll new String(\u0026ldquo;abc\u0026rdquo;)   三、运算  参数传递 float与double 隐式类型转换 switch   四、关键字  final static   五、Object通用方法  概览 equals() hashCode() toString() clone()   六、继承  访问权限 抽象类和接口 super 重载和重写   七、反射 八、异常 九、泛型 十、注解 十一、特性  一、数据类型  基本类型   byte/8 char/16 short/16 int/32 float/32 long/64 double/64 boolean/~  boolean 只有两个值：true、flase,可以使用 1 bit 来存储，但是具体大小没有明确规定。JVM 会在编译时期将 boolean 类型的数据转换为 int，使用 1 来表示 true， 0 表示 false。JVM 支持 boolean 数组，但是是通过读写 byte 数组来实现的。\n包装类型  基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱和拆箱完成。\nInteger x = 2; //装箱 调用了 Integer.valueOf(2) int y = x; // 拆箱 调用了 x.intValue() 缓存池  new Integer(123) 与 Integer.valueOf(123)的区别在于：\n new Integer(123) 每次都会创建一个对象； Integer.valueOf(123) 会使用缓存池中的对象，调用会取得同一个对象的引用。  Integer x = new Integer(123); Integer y = new Integer(123); System.out.println(x == y); //false Integer z = Integer.valueOf(123); Integer k = Integer.valueOf(123); System.out.println(z == k); //true valueOf() 方法的实现，就是先判断值是否存在缓存池中，如果在的话就直接返回缓存池的内容。\npublic static Integer valueOf(int i){ if(i \u0026gt;= IntegerCache.low \u0026amp;\u0026amp; i \u0026lt;= IntegerCache.high){ return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); } } 在 Java 8 中，Integer 缓存池的大小默认为 -128~127。\n编译器会在自动装箱过程中调用 valueOf()方法，因此多个值相同且值在缓存池范围内的 Integer 实例使用自动装箱来创建，那么就会引用相同的对象。\nInteger m = 123; Integer n = 123; System.out.priintln(m == n); //true 基本类型对应的缓冲池如下：\n boolean values true and false all byte values short values between -128 and 127 int values between -128 and 127 char in the range \\u0000 to \\u007F  在使用这些基本类型对应的包装类型时，如果该数值范围在缓冲范围内，就可以直接使用缓冲池中的对象。\n在 JDK 1.8 所有的数值类型缓冲池中，Integer 的缓冲池 IntegerCache 很特殊，这个缓冲池的下界是 -128，上界默认是 127，但是这个上界是可以调的，在启动 JVM 的时候，通过 -XX:AutoBoxCacheMax=\u0026lt;size\u0026gt; 来指定 IntegerCache 的大小，该选项在 JVM 初始化的时候会设定一个名为 java.lang.IntegerCache.high 系统属性，然后 IntegerCache 初始化的时候就会读取该系统属性来决定上界。\n二、String  概览 String 被声明为 final,因此不可被继承。(Integer 等包装类也不能被继承)\n在 Java 8 中，String 内部使用 char 数组存储数据。\npublic final class String implements java.io.Serializable, Comparable\u0026lt;String\u0026gt;, CharSequence { private final char value[]; } 在 Java 9 之后，String 类的实现改用 byte 数组存储字符串，同时使用 coder 来标识使用的编码。\npublic final class String implements java.io.Serializable, Comparable\u0026lt;String\u0026gt;, CharSequence { private final byte[] value; private final byte coder; } value 数组被声明为 final，这意味着 value 数组初始化之后就不能在引用其他数组，并且 String 内部没有改变 value 数组的方法。这些表明 String 不能更改的约束规范。实际上可以通过反射来修改 String 内部 value 数组的值，但是这样的做法毫无意义，而且会引发错误。\n不可变的好处 1.可以缓存 hash 值\n因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性使得 hash 值也不可变，因此只需要进行一次计算。\n2.String Pool 的需要\n如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。\n3.安全性\nString 经常作为参数，String 不可变性可以保证参数不可变。\n4.线程安全\nString 不可变性天生具备线程安全，可以在多个线程中安全使用。\nString,StringBuffer,and StringBuilder 1.可变性\n String 不可变 StringBuffer 和 StringBuilder 可变  2.线程安全\n String 不可变，因此是线程安全的 StringBuilder 不是线程安全的 StringBuffer 是线程安全的，内部使用 synchronized 进行同步  String Pool 字符串常量池(String Pool) 保存着所有字符串字面量(literal strings) ,这些字面量在编译时期就确定。不仅如此，还可以使用 String 的 intern() 方法在运行过程将字符串添加到 String Pool中。\n当一个字符串调用 intern() 方法时，如果 String Pool 中已存在一个字符串和该字符串相等(使用 equals() 方法进行确定)，那么就会返回 String Pool 中字符串的引用；否则，就会在 String Poll 中添加一个新的字符串，并返回这个新字符串的引用。\nString s1 = new String(\u0026#34;aaa\u0026#34;); String s2 = new String(\u0026#34;aaa\u0026#34;); System.out.println(s1 == s2); //false String s3 = s1.intern(); String s4 = s2.intern(); System.out.println(s3 == s4); //true 如果是采用 \u0026ldquo;bbb\u0026rdquo; 这种字面量的形式创建字符串，会自动将字符串放入 String Pool 中。\nString s5 = \u0026#34;bbb\u0026#34;; String s6 = \u0026#34;bbb\u0026#34;; System.out.println(s5 == s6); //true 在 Java 7 之前，String Pool被放在运行时常量池中，它属于永久代。而在 Java 7 ，String Pool 被移到堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误。\nnew String(\u0026ldquo;abc\u0026rdquo;) 使用这种方式一共会创建两个字符串对象（前提是 String Pool 中还没有 \u0026ldquo;abc\u0026rdquo; 字符串对象）。\n \u0026ldquo;abc\u0026rdquo; 属于字符串字面量，因此在编译时期会在 String Pool 中创建一个字符串对象，指向这个 \u0026ldquo;abc\u0026rdquo; 字符串字面量。 而使用 new 的方式会在堆中创建一个字符串对象。\n创建一个测试类，其 main 方法中使用这种方式来创建字符串对象。   public class NewStringTest { public static void main(String[] args){ String s = new String(\u0026#34;abc\u0026#34;); } } 使用 javap -verbose 进行反编译，得到以下内容：\n// ... Constant pool: // ... #2 = Class #18 // java/lang/String #3 = String #19 // abc // ... #18 = Utf8 java/lang/String #19 = Utf8 abc // ... public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack=3, locals=2, args_size=1 0: new #2 // class java/lang/String 3: dup 4: ldc #3 // String abc 6: invokespecial #4 // Method java/lang/String.\u0026#34;\u0026lt;init\u0026gt;\u0026#34;:(Ljava/lang/String;)V 9: astore_1 // ... 在 Constant Pool 中，#19 存储这字符串字面量 \u0026ldquo;abc\u0026rdquo;, #3 是 String Pool 的字符串对象，它指向 #19 这个字符串字面量。在 main 方法中， 0: 行使用 new #2 在堆中创建一个字符串对象，并且使用 ldc #3 将 String Pool 中的字符串对象作为 String 构造函数的参数。\n以下是 String 构造函数的源码，可以看到，在将一个字符串对象作为另一个字符串对象的构造函数参数时，并不会完全复制 value 数组内容，而是都会指向同一个 value 数组。\npublic String(String original){ this.value = original.value; this.hash = original.hash; } 三、运算 参数传递 以下代码中 Dog dog 的dog是一个指针，存储的是对象的地址。在将一个参数传入一个方法时，本质上是将对象的地址以值得方式传递到形参中。\npublic class Dog { String name; Dog(String name) { this.name = name; } String getName() { return this.name; } String getObjectAddress() { return super.toString(); } } 在方法中改变对象的字段值会改变原对象该字段值，因为引用的是同一个对象。\nclass PassByValueExample { public static void main(String[] args) { Dog dog = new Dog(\u0026#34;A\u0026#34;); func(dog); System.out.println(dog.getName()); // B } private static void func(Dog dog) { dog.setName(\u0026#34;B\u0026#34;); } } 但是在方法中将指针引用了其它对象，那么此时方法里和方法外的两个指针指向了不同的对象，在一个指针改变其所指向对象的内容对另一个指针所指向的对象没有影响。\npublic class PassByValueExample { public static void main(String[] args) { Dog dog = new Dog(\u0026#34;A\u0026#34;); System.out.println(dog.getObjectAddress()); // Dog@4554617c func(dog); System.out.println(dog.getObjectAddress()); // Dog@4554617c System.out.println(dog.getName()); // A } private static void func(Dog dog) { System.out.println(dog.getObjectAddress()); // Dog@4554617c dog = new Dog(\u0026#34;B\u0026#34;); System.out.println(dog.getObjectAddress()); // Dog@74a14482 System.out.println(dog.getName()); // B } } float 与 double Java 不能隐式执行向下转型，因为这会使得精度降低。\n1.1 字面量属于 double 类型，不能直接将 1.1 直接赋值给 float 变量，因为这是向下转型。\n// float f = 1.1; 1.1f 字面量才是 float 类型。\nfloat f = 1.1f; 隐式类型转换 因为字面量 1 是 int 类型，它比 short 类型精度要高，因此不能隐式地将 int 类型向下转型为 short 类型。\nshort s1 = 1; //s1 = s1 + 1; 但是使用 += 或者 ++ 运算符会执行隐式类型转换。\ns1 += 1; s1++; 上面的语句相当于将 s1 + 1 的计算结果进行了向下转型：\ns1 = (short)(s1 + 1); switch 从 Java 7 开始，可以在 switch 条件判断语句中使用 String 对象。\nswitch 不支持 long、float、double，是因为 switch 的设计初衷是对那些只有少数几个值的类型进行等值判断，如果值过于复杂，那么还是用 if 比较合适。\n四、关键字 final 1.数据\n声明数据为常量，可以是编译时的常量，也可以是在运行时被初始化后不能被改变的常量。\n 对于基本类型，final 使数值不变； 对于引用类型，final 使引用不变，也就不能引用其他对象，但是被引用的对象本身是可以修改的。  final int x = 1; //x = 3; // cannot assign value to final variable \u0026#39;x\u0026#39; final A y = new A(); y.a = 1; 2.方法\n声明方法不能被子类重写。\nprivate 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法。\n3.类 声明类不允许被继承。\nstatic 1.静态变量\n 静态变量： 又被称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，可以直接通过类名来访问它。静态变量在内存中只存在一份。 实例变量： 每创建一个实例就会产生一个实例变量，它与该实例同生共死。  public class A { private int x; // 实例变量 private static int y; // 静态变量 public static void main(String[] args) { // int x = A.x; // Non-static field \u0026#39;x\u0026#39; cannot be referenced from a static context A a = new A(); int x = a.x; int y = A.y; } } 2.静态方法\n静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法。\npublic abstract class A { public static void func1(){} } 只能访问所属类的静态字段和静态方法，方法中不能有 this 和 super 关键字，因为这两个关键字与具体对象关联。\npublic class A { private static int x; private int y; public static void func1(){ int a = x; // int b = y; // Non-static field \u0026#39;y\u0026#39; cannot be referenced from a static context // int b = this.y; //\u0026#39;A.this\u0026#39; cannot be referenced from a static context } } 3.静态语句块\n静态语句块在类初始化时运行一次。\npublic class A { static { System.out.println(\u0026#34;123\u0026#34;); } public static void main(String[] args) { A a1 = new A(); A a2 = new A(); } } 123 4.静态内部类\n非静态内部类依赖于外部类的实例，也就是说需要先创建外部类的实例，才能用这个实例去创建非静态内部类。而静态内部类不需要。\npublic class OuterClass { class InnerClass { } static class StaticInnerClass { } public static void main(String[] args) { //InnerClass innerClass = new InnerClass(); // \u0026#39;OuterClass.this\u0026#39; cannot be referenced from a static context OuterClass outerClass = new OuterClass(); InnerClass innerClass = outerClass.new InnerClass(); StaticInnerClass staticInnerClass = new StaticInnerClass(); } } 静态内部类不能访问外部类的非静态的变量和方法。\n5.静态导包 在使用静态变量和方法时不用再指明 ClassName,从而简化代码，但可读性大大降低。\n6.初始化顺序\n静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。\npublic static String staticField = \u0026#34;静态变量\u0026#34;; static { System.out.println(\u0026#34;静态语句块\u0026#34;); } public String field = \u0026#34;实例变量\u0026#34;; { System.out.println(\u0026#34;普通语句块\u0026#34;); } 最后才是构造函数的初始化。\npublic InitialOrderTest(){ System.out.println(\u0026#34;构造函数\u0026#34;); } 存在继承的情况下，初始化顺序为：\n 父类（静态变量、静态语句块） 子类（静态变量、静态语句块） 父类（实例变量、普通语句块） 父类（构造函数） 子类（实例变量、普通语句块） 子类（构造函数）  五、Object 通用方法 概述 public native int hashCode() public boolean equals(Object obj) protected native Object clone() throws CloneNotSupportedException public String toString() public final native Class\u0026lt;?\u0026gt; getClass() protected void finalize() throws Throwable public final native void notify() public final native void notifyAll() public final native void wait(long timeout) throws InterruptedException public final void wait(long timeout, int nanos) throws InterruptedException public final void wait() throws InterruptedException equals() 1.等价关系\n两个对象具有等价关系，需要满足以下五个条件：自反性、对称性、传递性、一致性、与 null 的比较（对任何不是 null 的对象 x 调用 x.equals(null) 结果都为flase)\n2.等价于相等\n 对于基本类型，== 判断两个值是否相等，基本类型没有 equals() 方法。 对于引用类型，== 判断两个变量是否引用同一个对象，而 equals() 判断引用的对象是否等价。  Integer x = new Integer(1); Integer y = new Integer(1); System.out.println(x.equals(y)); // true System.out.println(x == y); // false 3.实现\n 检查是否为同一个对象的引用，如果是直接返回 true； 检查是否是同一个类型，如果不是，直接返回 false； 将 Object 对象进行转型； 判断每个关键域是否相等  public class EqualExample { private int x; private int y; private int z; public EqualExample(int x, int y, int z){ this.x = x; this.y = y; this.z = z; } @Override public boolean equals(Object o){ if(this == o) return true; if(o == null || getClass() != o.getClass()) return false; EqualExample that = (EqualExample) o; if(x != that.x) return false; if(y != that.y) return false; return z == that.z; } } hashCode() hashCode() 返回哈希值，而 equals() 是用来判断两个对象是否等价。等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价，这是因为计算哈希值具有随机性，两个值不同的对象可能计算出相同的哈希值。\n在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，保证等价的两个对象哈希值也相等。\nHashSet 和 HashMap 等集合类使用了 hashCode() 方法来计算对象应该存储的位置，因此要将对象添加到这些集合类中，需要让对应的类实现 hashCode() 方法。\n下面的代码中，新建了两个等价的对象，并将它们添加到 HashSet 中，我们希望将两个对象当成一样的，只在集合中添加一个对象。但是 EqualExample 没有实现 hashCode() 方法，因此两个对象的哈希值是不同的，最终导致集合添加了两个等价的对象。\nEqualExample e1 = new EqualExample(1,1,1); EqualExample e2 = new EqualExample(1,1,1); System.out.println(eq.equal(e2)); // true HashSet\u0026lt;EqualExample\u0026gt; set = new HashSet\u0026lt;\u0026gt;(); set.add(e1); set.add(e2); System.out.println(set.size()); // 2 理想的哈希函数应当具有均匀性 ，即不相等的对象应当均匀分布到所有可能的哈希值上。这就要求了哈希函数要把所有域的值都考虑进来。可以将每个域都当成 R 进制的某一位，然后组成一个 R 进制的整数。\nR 一般取 31，它是一个奇素数。\ntoString() 默认返回 类名@十六进制数 这种形式，其中 @ 后面的数值为散列码的无符号十六进制表示。\nclone() 1.cloneable clone() 是 Object 的 protected 方法，它不是 public，一个类不显式去重写 clone()，其他类就不能直接去调用该类实例的 clone() 方法。\n2.浅拷贝 拷贝对象和原始对象的引用类型引用同一个对象。\n3.深拷贝 拷贝对象和原始对象的引用类型引用不同的对象。\n4.clone的替代方案 使用 clone() 方法既复杂又有风险，最好别用，使用拷贝构造函数或拷贝工厂来拷贝一个对象。\n六、继承  访问权限  Java 中有三个访问权限修饰符：private、protected 以及 public，如果不加访问修饰符，表示包级可见。\n抽象类与接口  1.抽象类 抽象类和抽象方法都使用 abstract 关键字进行声明。如果一个类中包含抽象方法，那么该类必须声明为抽象类。\n抽象类不能被实例化，只能被继承。\n2.接口 接口是抽象类的延伸，在 Java 8 之前，它可以看成是一个完全抽象的类，也就是说它不能有任何的方法实现。\n从 Java 8开始，接口也可以拥有默认的方法实现，这是因为不支持默认方法的接口的维护成本太高了。\n接口的成员（字段+方法）默认都是 public的，并且不允许定义为 private 或 protected。从 Java 9 开始，允许将方法定义为 private，这样就能定义某些复用的代码又不会把方法暴露出去。\n接口的字段默认都是 static 和 final 的。\n3.抽象类与接口比较  从设计层面上看，抽象类提供一种 IS-A 关系，而接口更像一种 LIKE-A 关系。 从使用上看，一个类可以实现多个接口，但是不能继承多个抽象类。 接口的字段只能是 static 和 final 类型的，而抽象类的字段没有这种限制。 接口的成员只能是 public 的，而抽象类的成员可以有多种访问权限。  在很多情况下，接口优先于抽象类。因为接口没有抽象类严格的类层次结构要求，可以灵活地为一个类添加行为。并且从 Java 8 开始，接口也可以有默认的方法实现，使得接口的成本也变得很低。\nsuper  访问父类的构造函数。super()。 访问父类的成员。  重写与重载  1.重写 存在于继承体系中，指子类实现了一个与父类在方法声明上完全相同的一个方法。\n2.重载 存在于一个类中，指一个方法与已经存在的方法名称上相同，但是参数类型、个数、顺序至少有一个不同。\n应该注意的是，返回值不同，其他都相同不算是重载。\n七、反射 每个类都有一个 Class 对象，包含了与类有关的信息。当编译一个新类时，会产生一个同名的 .class 文件，该文件内容保存着 Class 对象。\n类加载相当于 Class 对象的加载，类在第一次使用时才动态加载到 JVM 中。也可以使用 Class.forname(\u0026ldquo;com.mysql.jdbc.Driver\u0026rdquo;) 这种方式来控制类的加载，该方法会返回一个 Class 对象。\n反射可以提供运行时的类信息，并且这个类可以在运行时才加载进来，甚至在编译时期该类的.class不存在也可以加载进来。\n反射的优点：\n 可扩展性 可视化开发环境： 如IDE,从反射中可用的类型信息中受益，帮助程序员编写正确的代码。 调试器和测试工具  反射的缺点：\n 性能开销 安全限制 内部暴露  八、异常 九、泛型 十、注解 十一、特性 ","permalink":"/collection/2020-12-15-base/","summary":"参考自 CyC2018/CS-Notes 一、数据类型 基本类型 包装类型 缓存池 二、String 概述 不可变的好处 String,StringBuffer and StringBuilder StringPoll new String(\u0026ldquo;abc\u0026rdquo;) 三、运算 参数传递 float与double 隐式类型转换 switch","title":"【转载】Java 基础"},{"content":" 这一生也在进取\n这分钟却挂念谁\n我会说是唯独你不可失去\n《追》\n 今天没签单位的就业协议。我在想什么呢？到底什么是我想要的呢？\n 你为生存做些什么，我不关心  ——〔加拿大〕 Oriah（译者：野竹林）\n  你为生存做了些什么，我不关心；\n我想知道，\n你的追求，\n你是否敢于梦想去触碰你那内心的渴望。\n  你的年龄多大，我不关心；\n我想知道，\n你是否愿意像傻瓜一样不顾风险，\n为了爱，梦想还有活着就该有的冒险。\n  我不关心，是什么行星牵引着你的月亮，\n我想知道，\n你是否已触及自己悲伤的中心，\n是否因生活的种种背叛而心胸开阔，\n抑或因为害怕更大的痛苦而消沉封闭！\n  我想知道，\n你是否能面对痛苦——我的或者你自己的，\n而不必去隐藏、涂抹或修饰。\n  我想知道，\n你是否能享受快乐——我的或者你自己的，\n你是否能充满野性地舞蹈，让你从指端到足尖都被狂喜所充满，\n而不会告诫我们要小心、要现实、要记住做人的禁忌。\n  我并不关心你告诉我的故事是否真实，\n我想知道，\n你是否能为了真实地对待自己而不怕别人失望，\n你是否能承受背叛的指责而不出卖自己的灵魂。\n我想知道，你是否能抛弃曾经的信念，而因此值得信赖。\n  我想知道，\n你是否能发现美，即使它每天都不漂亮，\n你是否能从它的存在中追寻你自己生命的源头。\n  我想知道，\n你是否能与失败相伴——你的和我的，\n却依然可以站立在湖边对着银色的满月放生大喊\n“是的，就是这样！”\n  我不关心你在哪里生活或者你拥有多少金钱，\n我想知道，\n在一个悲伤、绝望、厌世和痛彻骨髓的夜晚之后，\n你是否能起床，为养育孩子做那些需要的事情。\n  我不关心你是谁，你是如何来到这里，\n我想知道，你是否愿同我一起站在烈焰的中心，毫不退缩。\n  我不关心你在哪里受到教育、你学了什么或者你同谁一起学习，\n我想知道，\n当一切都背叛了你，是什么在内心支撑着你前行。\n  我想知道，\n你是否能孤独地面对你自己，\n你是否真正喜欢那个你独自一人时交谈的声音。\n The Invitation   It doesn\u0026rsquo;t interest me\nwhat you do for a living.\nI want to know\nwhat you ache for\nand if you dare to dream\nof meeting your heart\u0026rsquo;s longing.\n  It doesn\u0026rsquo;t interest me\nhow old you are.\nI want to know\nif you will risk\nlooking like a fool\nfor love\nfor your dream\nfor the adventure of being alive.\n  It doesn\u0026rsquo;t interest me\nwhat planets are\nsquaring your moon\u0026hellip;\nI want to know\nif you have touched\nthe centre of your own sorrow\nif you have been opened\nby life\u0026rsquo;s betrayals\nor have become shrivelled and closed\nfrom fear of further pain.\n  I want to know if you can sit with pain mine or your own\nwithout moving to hide it\nor fade it\nor fix it.\n  I want to know\nif you can be with joy\nmine or your own\nif you can dance with wildness and let the ecstasy fill you\nto the tips of your fingers and toes\nwithout cautioning us\nto be careful\nto be realistic\nto remember the limitations\nof being human.\n  It doesn\u0026rsquo;t interest me\nif the story you are telling me\nis true.\nI want to know if you can\ndisappoint another\nto be true to yourself.\nIf you can bear\nthe accusation of betrayal\nand not betray your own soul.\nIf you can be faithless\nand therefore trustworthy.\n  I want to know if you can see Beauty\neven when it is not pretty\nevery day.\nAnd if you can source your own life\nfrom its presence.\n  I want to know\nif you can live with failure\nyours and mine and still stand at the edge of the lake\nand shout to the silver of the full moon,\n\u0026ldquo;Yes.\u0026rdquo;\n  It doesn\u0026rsquo;t interest me\nto know where you live\nor how much money you have.\nI want to know if you can get up after the night of grief and despair\nweary and bruised to the bone\nand do what needs to be done\nto feed the children.\n  It doesn\u0026rsquo;t interest me\nwho you know\nor how you came to be here.\nI want to know if you will stand\nin the centre of the fire\nwith me\nand not shrink back.\n  It doesn\u0026rsquo;t interest me\nwhere or what or with whom\nyou have studied.\nI want to know\nwhat sustains you\nfrom the inside\nwhen all else falls away.\n  I want to know\nif you can be alone\nwith yourself\nand if you truly like\nthe company you keep\nin the empty moments.\n 黑暗，总会如期而至。闭上眼之后的每一秒都是未知，而未知容易让人恐惧。\n但转念一想，未知不正是活着的证据，人生的乐趣吗？\n","permalink":"/blog/2020/12/15/%E8%BF%BD/","summary":"这一生也在进取 这分钟却挂念谁 我会说是唯独你不可失去 《追》 今天没签单位的就业协议。我在想什么呢？到底什么是我想要的呢？ 你为生存做些什么，我不关","title":"追"},{"content":" 明明知道烈焰焚身的痛苦，\n明明知道短暂的光芒过后，\n仍是无尽的黑暗，\n为何你还是，\n一心向前？\n  是火焰的温暖给予你力量，\n还是黑夜的漫长令你恐慌？\n  我想知道，\n当灰烬落地，\n你是否找到心中的答案？\n我想知道，\n当火花再次摇晃，\n你是否还会煽动翅膀？\n ","permalink":"/blog/2020/12/14/%E9%A3%9E%E8%9B%BE%E6%89%91%E7%81%AB%E7%BC%98%E8%B5%B7/","summary":"明明知道烈焰焚身的痛苦， 明明知道短暂的光芒过后， 仍是无尽的黑暗， 为何你还是， 一心向前？ 是火焰的温暖给予你力量， 还是黑夜的漫长令你恐慌？ 我想知","title":"飞蛾扑火——缘起"},{"content":" 我 回头再望某年，\n象失色照片 乍现眼前。\n—— 《风再起时》\n 刚看完《寻找失去的未来》。啊，我是谁，我在哪,我昨天都做了什么？\n在未来的一天，过去的所有都被遗忘，欢乐和痛苦终化为岁月的尘埃。只是，那时的我，又会变成什么样呢？现在的我，又是什么呢，现在的我，又在追求什么呢？\n“没有未来的未来，不是我想要的未来~”可惜我不是那神原秋人，未来也不知道有没有“未来”。既然未来不可言，那我便讲述一下过去吧。\n相较于“网瘾少年”，我更愿意把小时候的我称为“网上冲浪者”。那时候，最喜欢做的事情就是自个在某个地方，用一部能上网的手机，进入各种游戏聊天室、论坛。在那里，可以接触五湖四海的人们，跟不同的人交流，了解别人。当然，与之而来的苦恼就是每个月的流量费用。\n说起网瘾少年，另一个词也不得不提，那就是“中二病”。和很多患者一样，以前的我总认为自己拥有一种超能力，它就像《冰海战记》里的阿谢拉特那样，看一眼就能“知其人”的能力。\n “嗯？你不是一直都是近视眼吗？”\n  “因为看淡了世间事，所以模糊了双眼。\u0026quot;\n  “喂，120 吗，这里有个病人需要抢救一下。”\n ","permalink":"/blog/2020/12/10/%E8%BF%87%E5%8E%BB%E4%B8%8E%E6%9C%AA%E6%9D%A5/","summary":"我 回头再望某年， 象失色照片 乍现眼前。 —— 《风再起时》 刚看完《寻找失去的未来》。啊，我是谁，我在哪,我昨天都做了什么？ 在未来的一天，过去的所有","title":"过去与未来"},{"content":"我是谁 我喜欢打羽毛球，它经常被我打得支离破碎，它也一直虐得我死去活来；喜欢跑步时风吹在脸上的感觉；喜欢逛博客乱翻帖子；喜欢看动漫，比如世界名作剧场系列的《崔普一家物语》、《红发安妮》、《长腿叔叔》等等；喜欢听很多歌，最喜欢的歌手是张国荣。\n本站架构 本站目前采用 Hugo（一个静态网站生成器）作为后台系统，使用 Github Pages 服务，源码托管在 Github 上。本站主题是 hugo-ivy 和 hugo-xmin 乱搭而成，作者 Yihui Xie。\n如果你也打算建立这样的博客网站，但是不知道从哪里开始，请看从零开始的博客建站之旅。\n其他链接  Github ：这是我的 Github 仓库地址。 Gitee ：这是我的 Gitee 仓库地址。  联系我  微信：就在这一行下面的注释里，如果你知道怎么找的话。 (~￣▽￣)~   邮箱：lzx@lzxqaq.com  ","permalink":"/about/","summary":"我是谁 我喜欢打羽毛球，它经常被我打得支离破碎，它也一直虐得我死去活来；喜欢跑步时风吹在脸上的感觉；喜欢逛博客乱翻帖子；喜欢看动漫，比如世界名","title":""},{"content":"待办事项   blogup 集成 Hugo。\n  blogup 实现新建网站、日志文章功能。\n  blogup 集成 Git。\n  blogup 设计实现 Git 管理插件。\n  定制一个 Hugo 主题。\n  持续计划   阅读。\n  写小说。\n  练吉他。\n  已完成   blogup 设计整体框架。\n  blogup 完成文本编辑功能。\n  blogup 完成文档资源管理功能。\n  ","permalink":"/todo/","summary":"待办事项 blogup 集成 Hugo。 blogup 实现新建网站、日志文章功能。 blogup 集成 Git。 blogup 设计实现 Git 管理插件。 定制一个 Hugo 主题。 持续计划 阅读。 写小说。 练吉他。 已完","title":""},{"content":"罗泽勋 联系方式 微信：BaiGei-Wan\n邮箱：lzx@lzxqaq.com；\n主页：https://lzxqaq.com；\n住址：现居住于广东省广州市增城区\n主要工作 C++ 客户端/后台开发\n教育背景  2017.09 ~ 2021.06 华南师范大学，软件工程专业，工学学士  工作经历 工作  2021.07 至今，某研究所 软件工程师  实习  2020.10 ~ 2021.06 某研究所 软件工程师  ","permalink":"/vitae/","summary":"罗泽勋 联系方式 微信：BaiGei-Wan 邮箱：lzx@lzxqaq.com； 主页：https://lzxqaq.com； 住址：现居住于广东省","title":""}]