<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Qt 核心 on 罗泽勋</title>
    <link>/series/qt-%E6%A0%B8%E5%BF%83/</link>
    <description>Recent content in Qt 核心 on 罗泽勋</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Mon, 13 Dec 2021 08:08:17 +0800</lastBuildDate><atom:link href="/series/qt-%E6%A0%B8%E5%BF%83/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>【转载】Qt6 对象模型</title>
      <link>/collection/object/</link>
      <pubDate>Mon, 13 Dec 2021 08:08:17 +0800</pubDate>
      
      <guid>/collection/object/</guid>
      <description>对象模型 标准的 C++ 对象模型为对象范例提供了非常有效的运行时支持。 但是它的静态特性在某些问题领域是不灵活的。 图形用户界面编程是一个需要运行时效率</description>
    </item>
    
    <item>
      <title>【转载】Qt 6 核心内部结构</title>
      <link>/collection/qt-core/</link>
      <pubDate>Mon, 13 Dec 2021 08:00:25 +0800</pubDate>
      
      <guid>/collection/qt-core/</guid>
      <description>Qt 包含一组丰富的基础使能器，主要来自 Qt Core 模块。 Qt 使用这些促成因素来提供更高级别的 UI 和应用程序开发组件。 以下主题解释了最重要的促成因素，并展示</description>
    </item>
    
    <item>
      <title>【转载】Qt6 Qvariant 与自定义 Qt 类型</title>
      <link>/collection/qvariant/</link>
      <pubDate>Mon, 13 Dec 2021 07:29:55 +0800</pubDate>
      
      <guid>/collection/qvariant/</guid>
      <description>概述 在本文档中，我们采用自定义类型并描述如何将其集成到 Qt 的对象模型中，以便可以像标准 Qt 类型一样存储它。 然后我们展示如何注册自定义类型以允许它</description>
    </item>
    
    <item>
      <title>【转载】Qt6 隐式共享</title>
      <link>/collection/implicit-sharing/</link>
      <pubDate>Wed, 01 Dec 2021 22:48:45 +0800</pubDate>
      
      <guid>/collection/implicit-sharing/</guid>
      <description>Qt 中的许多 C++ 类使用隐式数据共享来最大化资源使用并最小化复制。当作为参数传递时，隐式共享类既安全又高效，因为只有一个指向数据的指针被传递，并且</description>
    </item>
    
  </channel>
</rss>
