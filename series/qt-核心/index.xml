<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Qt 核心 on 罗泽勋</title>
    <link>/series/qt-%E6%A0%B8%E5%BF%83/</link>
    <description>Recent content in Qt 核心 on 罗泽勋</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Mon, 13 Dec 2021 08:08:17 +0800</lastBuildDate><atom:link href="/series/qt-%E6%A0%B8%E5%BF%83/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>【转载】Qt6 对象模型</title>
      <link>/collection/object/</link>
      <pubDate>Mon, 13 Dec 2021 08:08:17 +0800</pubDate>
      
      <guid>/collection/object/</guid>
      <description>对象模型 标准的 C++ 对象模型为对象范例提供了非常有效的运行时支持。 但是它的静态特性在某些问题领域是不灵活的。 图形用户界面编程是一个需要运行时效率</description>
    </item>
    
    <item>
      <title>【转载】Qt 6 核心内部结构</title>
      <link>/collection/qt-core/</link>
      <pubDate>Mon, 13 Dec 2021 08:00:25 +0800</pubDate>
      
      <guid>/collection/qt-core/</guid>
      <description>Qt 包含一组丰富的基础使能器，主要来自 Qt Core 模块。 Qt 使用这些促成因素来提供更高级别的 UI 和应用程序开发组件。 以下主题解释了最重要的促成因素，并展示</description>
    </item>
    
    <item>
      <title>【转载】Qt6 Qvariant 与自定义 Qt 类型</title>
      <link>/collection/qvariant/</link>
      <pubDate>Mon, 13 Dec 2021 07:29:55 +0800</pubDate>
      
      <guid>/collection/qvariant/</guid>
<<<<<<< HEAD
      <description>
        <![CDATA[
        <h3 id="概述">概述</h3>
<p>在本文档中，我们采用自定义类型并描述如何将其集成到 Qt 的对象模型中，以便可以像标准 Qt 类型一样存储它。 然后我们展示如何注册自定义类型以允许它在信号和插槽连接中使用。</p>
<h3 id="创建自定义类型">创建自定义类型</h3>
<p>在开始之前，我们需要确保我们正在创建的自定义类型满足 QMetaType 强加的所有要求。换言之，它必须提供：</p>
<blockquote>
<p>公共默认构造函数 <br>
公共复制构造函数<br>
公共析构函数</p>
</blockquote>
<p>下列 Message类定义包括以下成员：</p>
<pre tabindex="0"><code>class Message
{
public:
    Message() = default;
    ~Message() = default;
    Message(const Message &amp;) = default;
    Message &amp;operator=(const Message &amp;) = default;

    Message(const QString &amp;body, const QStringList &amp;headers);

    QStringView body() const;
    QStringList headers() const;

private:
    QString m_body;
    QStringList m_headers;
};
</code></pre><p>该类还提供了一个正常使用的构造函数和两个用于获取私有数据的公共成员函数。</p>
<h3 id="使用-qmetatype-声明类型">使用 QMetaType 声明类型</h3>
<p>这 Message类只需要一个合适的实现即可使用。 但是，如果没有一些帮助，Qt 的类型系统将无法理解如何存储、检索和序列化此类的实例。 例如，我们将无法存储 Message值 QVariant 中的 。</p>
<p>Qt 中负责自定义类型的类是 QMetaType 。 为了让这个类知道类型，我们在定义它的头文件中的类上 添加 Q_DECLARE_METATYPE() 宏：</p>
<pre tabindex="0"><code>Q_DECLARE_METATYPE(Message);
</code></pre><p>这使得现在有可能 Message要存储在 QVariant 对象中并稍后检索的值。 有关 请参阅 自定义类型示例 演示此内容的代码， 。</p>
<p>所述 Q_DECLARE_METATYPE （）宏还使得可以对这些值用作到信号，但是参数 只在直接信号槽连接 。 为了使自定义类型通常可用于信号和插槽机制，我们需要执行一些额外的工作。</p>
<h3 id="创建和销毁自定义对象">创建和销毁自定义对象</h3>
<p>尽管上一节中的声明使该类型可用于直接信号槽连接，但它不能用于排队的信号槽连接，例如在不同线程中的对象之间建立的连接。 这是因为元对象系统不知道如何在运行时处理自定义类型对象的创建和销毁。</p>
<p>要在运行时创建对象，请调用 qRegisterMetaType () 模板函数将其注册到元对象系统。 这也使得该类型可用于排队的信号槽通信，只要您在使用该类型的第一个连接之前调用它。</p>
<pre tabindex="0"><code>int main(int argc, char *argv[])
{
    QApplication app(argc, argv);
    ...
    qRegisterMetaType&lt;Block&gt;();
    ...
    return app.exec();
}
</code></pre><p>这种类型后来用于信号槽连接中 window.cpp文件：</p>
<pre tabindex="0"><code>Window::Window(QWidget *parent)
    : QWidget(parent), thread(new RenderThread(this))
{
    ...
    connect(thread, &amp;RenderThread::sendBlock,
            this, &amp;Window::addBlock);
    ...
    setWindowTitle(tr(&quot;Queued Custom Type&quot;));
}
</code></pre><p>如果一个类型在没有注册的情况下在排队连接中使用，控制台会打印警告； 例如：</p>
<pre tabindex="0"><code>QObject::connect: Cannot queue arguments of type 'Block'
(Make sure 'Block' is registered using qRegisterMetaType().)
</code></pre><h3 id="使类型可打印">使类型可打印</h3>
<p>为调试目的使自定义类型可打印通常非常有用，如下面的代码所示：</p>
<pre tabindex="0"><code>    Message message(body, headers);
    qDebug() &lt;&lt; &quot;Original:&quot; &lt;&lt; message;
</code></pre><p>这是通过为该类型创建一个流操作符来实现的，该操作符通常在该类型的头文件中定义：</p>
<pre tabindex="0"><code>QDebug operator&lt;&lt;(QDebug dbg, const Message &amp;message);
</code></pre><p>实现：</p>
<pre tabindex="0"><code>QDebug operator&lt;&lt;(QDebug dbg, const Message &amp;message)
{
    QList&lt;QStringView&gt; pieces = message.body().split(u&quot;\r\n&quot;, Qt::SkipEmptyParts);
    if (pieces.isEmpty())
        dbg.nospace() &lt;&lt; &quot;Message()&quot;;
    else if (pieces.size() == 1)
        dbg.nospace() &lt;&lt; &quot;Message(&quot; &lt;&lt; pieces.first() &lt;&lt; &quot;)&quot;;
    else
        dbg.nospace() &lt;&lt; &quot;Message(&quot; &lt;&lt; pieces.first() &lt;&lt; &quot; ...)&quot;;
    return dbg.maybeSpace();
}
</code></pre><p>当然，发送到调试流的输出可以根据您的喜好变得简单或复杂。 请注意，此函数返回的值是 QDebug 对象本身，尽管这通常是通过调用 获得的，该 QDebug 的 maySpace () 成员函数 函数 填充 用空格字符 流以使其更具可读性。</p>

        
        ]]>
      </description>
=======
      <description>概述 在本文档中，我们采用自定义类型并描述如何将其集成到 Qt 的对象模型中，以便可以像标准 Qt 类型一样存储它。 然后我们展示如何注册自定义类型以允许它</description>
>>>>>>> 35a30928abf5c3213b754024efc550556652db2d
    </item>
    
    <item>
      <title>【转载】Qt6 隐式共享</title>
      <link>/collection/implicit-sharing/</link>
      <pubDate>Wed, 01 Dec 2021 22:48:45 +0800</pubDate>
      
      <guid>/collection/implicit-sharing/</guid>
<<<<<<< HEAD
      <description>
        <![CDATA[
        <p>Qt 中的许多 C++ 类使用隐式数据共享来最大化资源使用并最小化复制。当作为参数传递时，隐式共享类既安全又高效，因为只有一个指向数据的指针被传递，并且只有当函数写入数据时才会复制数据，即copy-on-write。</p>
<h3 id="概述">概述</h3>
<p>共享类由指向共享数据块的指针组成，该共享数据块包含引用计数和数据。</p>
<p>创建共享对象时，它将引用计数设置为 1。只要新对象引用共享数据，引用计数就会增加，而当对象取消引用共享数据时，引用计数会减少。当引用计数变为零时，共享数据将被删除。</p>
<p>在处理共享对象时，有两种方法可以复制对象。我们通常谈论深拷贝和浅拷贝。深拷贝意味着复制一个对象。浅拷贝是引用拷贝，即只是指向共享数据块的指针。就内存和 CPU 而言，进行深度复制的成本可能很高。制作浅拷贝非常快，因为它只涉及设置一个指针和增加引用计数。</p>
<p>隐式共享对象的对象分配（使用 operator=()）是使用浅拷贝实现的。</p>
<p>共享的好处是程序不需要不必要地复制数据，从而减少内存使用和数据复制。对象可以很容易地被赋值，作为函数参数发送，并从函数中返回。</p>
<p>隐式共享大多发生在幕后；程序员很少需要担心它。但是，Qt 的容器迭代器与 STL 的容器迭代器具有不同的行为。阅读隐式共享迭代器问题。</p>
<p>在多线程应用程序中，会发生隐式共享，如线程和隐式共享类中所述。</p>
<p>在实现您自己的隐式共享类时，请使用QSharedData和QSharedDataPointer类。</p>
<h3 id="详细的隐式共享">详细的隐式共享</h3>
<p>如果对象即将更改并且引用计数大于 1，则隐式共享会自动将对象从共享块中分离。（这通常称为 copy-on-write 或者 value semantics。）</p>
<p>隐式共享类可以控制其内部数据。在任何修改其数据的成员函数中，它会在修改数据之前自动分离。但是，请注意容器迭代器的特殊情况；请参阅隐式共享迭代器问题。</p>
<blockquote>
<p>警告：在使用STL 样式的迭代器时，请小心复制隐式共享容器（QMap、QList等）。请参阅隐式共享迭代器问题。</p>
</blockquote>
<h3 id="示例">示例</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++">QPixmap p1, p2;
p1.load(<span style="color:#e6db74">&#34;image.bmp&#34;</span>);
p2 <span style="color:#f92672">=</span> p1;                        <span style="color:#75715e">// p1 and p2 share data
</span><span style="color:#75715e"></span>
QPainter paint;
paint.begin(<span style="color:#f92672">&amp;</span>p2);               <span style="color:#75715e">// cuts p2 loose from p1
</span><span style="color:#75715e"></span>paint.drawText(<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">50</span>, <span style="color:#e6db74">&#34;Hi&#34;</span>);
paint.end();
</code></pre></div><p>在这个例子中，p1 和 p2 共享数据，直到了 p2 被 QPainter::begin() 调用，因为画像素图将修改它。</p>
<h3 id="所有隐式共享的类">所有隐式共享的类</h3>
<p>参见 <a href="https://doc.qt.io/qt-6/implicit-sharing.html">Qt 文档</a>。</p>

        
        ]]>
      </description>
=======
      <description>Qt 中的许多 C++ 类使用隐式数据共享来最大化资源使用并最小化复制。当作为参数传递时，隐式共享类既安全又高效，因为只有一个指向数据的指针被传递，并且</description>
>>>>>>> 35a30928abf5c3213b754024efc550556652db2d
    </item>
    
  </channel>
</rss>
