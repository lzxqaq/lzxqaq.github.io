<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>C/C&#43;&#43; 基础 on 罗泽勋</title>
    <link>/series/c/c&#43;&#43;-%E5%9F%BA%E7%A1%80/</link>
    <description>Recent content in C/C&#43;&#43; 基础 on 罗泽勋</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language><atom:link href="/series/c/c++-%E5%9F%BA%E7%A1%80/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>【转载】C Primer 之 new, delete</title>
      <link>/collection/cprimer04/</link>
      <pubDate>Thu, 30 Dec 2021 07:13:11 +0800</pubDate>
      
      <guid>/collection/cprimer04/</guid>
      <description>转载自https://github.com/andycai/cprimer new和delete运算符用于动态分配和撤销内存的运算符 (1) new用</description>
    </item>
    
    <item>
      <title>【转载】C Primer 之 char*, char[], string</title>
      <link>/collection/cprimer03/</link>
      <pubDate>Thu, 30 Dec 2021 07:12:45 +0800</pubDate>
      
      <guid>/collection/cprimer03/</guid>
<<<<<<< HEAD
      <description>
        <![CDATA[
        <p>转载自<a href="https://github.com/andycai/cprimer">https://github.com/andycai/cprimer</a></p>
<h2 id="31-char-char-string">3.1 char*, char[], string</h2>
<p>在C中，并没有字符串这个数据类型，而是使用字符数组来保存字符串。C字符串实际上就是一个以null('\0')字符结尾的字符数组，null字符表示字符串的结束。需要注意的是：只有以null字符结尾的字符数组才是C字符串，否则只是一般的C字符数组。</p>
<p>C字符串定义时可以利用&quot;=&ldquo;号进行初始化，但是以后不能利用&rdquo;=&ldquo;对C字符串进行赋值。对C字符串的操作需要通过&quot;string&quot;文件中定义的字符串处理函数。例如：</p>
<pre><code>//字符串的初始化
char a[11] = &quot;huanying&quot;;
//字符串的赋值
strcpy(a,&quot;nihao&quot;)
//获取字符串的长度，不包括'\0'在内
strlen(a);
printf(&quot;%s&quot;,a);
</code></pre>
<p>在C中也可以使用字符指针来访问一个字符串,通过字符指针指向存放字符串数组的首元素地址来进行访问.
char *a = &ldquo;nihao&rdquo;;
printf(&quot;%s&rdquo;,a);</p>
<p>在C++中则把字符串封装成了一种数据类型string,可以直接声明变量并进行赋值等字符串操作。以下是C字符串和C++中string的区别：</p>
<pre><code>                             C字符串                 string对象
所需的头文件名称       	&lt;string&gt;或&lt;string.h&gt;        	&lt;string&gt;或&lt;string.h&gt;
为什么需要头文件       	为了使用字符串函数            为了使用string类
如何声明                 char name[20];              string name;
如何初始化               char name[20]=&quot;nihao&quot;;   	string name = &quot;nihao&quot;;
必须声明字符串长度么？		是                          否
使用一个null字符么？     	是                          否
怎样实现字符串赋值      	strcpy(name,&quot;John&quot;);        name = &quot;John&quot;;
其他优点               	更快                        更易于使用，优选方案
可以赋一个比现有字符更 	不能                        可以
长的字符串么？  
</code></pre>
<h3 id="1-c常用字符串函数">(1) C++常用字符串函数</h3>
<pre><code>char s1[]=&quot;I am a student&quot;;
char s2[20]=&quot;teacher&quot;;
char s3[]=&quot;student&quot;;
int result;
char s4[20],*p;
</code></pre>
<ol>
<li>
<p>串长度 int strlen(char *str)</p>
<p>cout&laquo;strlen(s1)&laquo;endl; 输出14
cout&laquo;strlen(s2)&laquo;endl; 输出7</p>
</li>
<li>
<p>串拷贝 char *strcpy(char *str1,char *str2)</p>
<p>strcpy(s4,s2);   //s4为&quot;teacher&quot;</p>
</li>
<li>
<p>串连接 char *strcat(char <em>str1,char</em>str2)</p>
<p>strcat(s2,s3); //s2为&quot;teacherstudent&quot;</p>
</li>
<li>
<p>串比较 int strcmp(char *str1,char *str) //比较的是对应字符的ASCII码值，如果str1&gt;str2,返回1</p>
<p>result=strcmp(s2,s3);   //result&gt;0
result=strcmp(s2,s2);   //result=0
result=strcmp(s3,s2);   //result&lt;0</p>
</li>
<li>
<p>串定位 char *strchr(char *str,char ch)</p>
<p>p=strchr(s1,&rsquo;s');    //找到返回字符在字串中的位置，否则返回-1
strcpy(p,s2);      //s1为&quot;I am a teacher&quot;</p>
</li>
<li>
<p>在一个串中查找是否存在和另一个串相等的子串</p>
</li>
<li>
<p>截取子串形成一个新串</p>
</li>
</ol>
<h3 id="2-字符串的输入">(2) 字符串的输入</h3>
<ol>
<li>
<p>方法一：使用输入操符来填充一个C字符串变量
例如：
char a[80];
cin&raquo;a;
注：以这种方式来读取C字符串时，会忽略最初的空白字符(空格、制表符和换行符)，而且输入会在下一个空格或者换行符处停止。</p>
</li>
<li>
<p>方法二：使用预定义函数getline获取整行输入(包括空格)
getline函数有两个参数：第一个参数用于接收输入的C字符串变量；第二个参数用于规定getline最多能接收的字符个数。
例如:
char a[80];
cin.getline(a,80);
当遇到行结束的时候，输入才会停止。</p>
</li>
</ol>
<h3 id="3-c-string类的输入">(3) C++ string类的输入</h3>
<ol>
<li>方法一：和C字符串输入的方法一相同。</li>
<li>方法二：使用getline函数。</li>
</ol>
<p>例如：</p>
<pre><code>string a;
getline(cin,a);
</code></pre>
<h3 id="4-string对象和c字符串之间的转换">(4) string对象和C字符串之间的转换</h3>
<p>可以将C字符串存储在string类型的变量中，例如：</p>
<pre><code>char a[] = &quot;nihao&quot;;
string b;
b=a;
</code></pre>
<p>但string对象不能自动的转换为C字符串，需要进行显式的类型转换，需要用到string类的成员函数c_str().
例如：</p>
<pre><code>strcpy(a,b.c_str());
</code></pre>
<h3 id="5-字符串到数字的转换">(5) 字符串到数字的转换</h3>
<p>atoi函数获取一个C字符串参数，返回对应的int值。如果参数不与一个int值对应，atoi就会返回0。atoi函数在文件为cstdlib的库中。如果数字太大，不能转换成int类型的值，可以使用atol将字符串转换为long类型的值。
例如:</p>
<pre><code>atoi(&quot;1234&quot;);   //返回整数1234
atoi(&quot;#123&quot;);   //返回0
</code></pre>
<h2 id="导航">导航</h2>
<ul>
<li><a href="00.md">目录</a></li>
<li>上一章：<a href="02.md">Chapter 2 - pointers, refrence</a></li>
<li>下一章：<a href="04.md">Chapter 4 - uint8_t, uint16_t, uint32_t, uint64_t</a></li>
</ul>

        
        ]]>
      </description>
=======
      <description>转载自https://github.com/andycai/cprimer 3.1 char*, char[], string 在C中，并没有字符串这个数据类型，而是使用字符数组来保存字</description>
>>>>>>> 35a30928abf5c3213b754024efc550556652db2d
    </item>
    
    <item>
      <title>【转载】C Primer 之 指针和引用</title>
      <link>/collection/cprimer02/</link>
      <pubDate>Thu, 30 Dec 2021 07:12:43 +0800</pubDate>
      
      <guid>/collection/cprimer02/</guid>
<<<<<<< HEAD
      <description>
        <![CDATA[
        <p>转载自<a href="https://github.com/andycai/cprimer">https://github.com/andycai/cprimer</a></p>
<h2 id="21-refrence-引用">2.1 refrence 引用</h2>
<p>引用是C++中的概念，初学者容易把引用和指针混淆一起。以下程序中，n 是 m 的一个引用（reference），m 是被引用物（referent）。</p>
<pre><code>int m; 
int &amp;n = m;
</code></pre>
<p>n 相当于 m 的别名（绰号），对 n 的任何操作就是对m的操作。所以 n 既不是 m 的拷贝，也不是指向 m 的指针，其实 n 就是 m 它自己。</p>
<p><strong>引用的规则：</strong></p>
<ul>
<li>引用被创建的同时必须被初始化（指针则可以在任何时候被初始化）。</li>
<li>不能有NULL引用，引用必须与合法的存储单元关联（指针则可以是NULL）。</li>
<li>一旦引用被初始化，就不能改变引用的关系（指针则可以随时改变所指的对象）。</li>
</ul>
<p>以下示例程序中，k 被初始化为 i 的引用。语句 k = j 并不能将 k 修改成为 j 的引用，只是把 k 的值改变成为6。由于 k 是 i 的引用，所以 i 的值也变成了6。</p>
<pre><code>int i = 5; 
int j = 6; 
int &amp;k = i; 
k = j; // k和i的值都变成了6; 
</code></pre>
<p><strong>引用的主要功能是传递函数的参数和返回值</strong>。</p>
<p>C++语言中，函数的参数和返回值的传递方式有三种：<strong>值传递、指针传递和引用传递</strong>。</p>
<h3 id="1-以下是值传递的示例程序">(1) 以下是&quot;值传递&quot;的示例程序</h3>
<p>由于Func1函数体内的x是外部变量n的一份拷贝，改变x的值不会影响n, 所以n的值仍然是0。</p>
<pre><code>void Func1(int x) 
{ 
	x = x + 10; 
} 
... 
int n = 0; 
Func1(n); 
cout &lt;&lt; &quot;n = &quot; &lt;&lt; n &lt;&lt; endl; // n = 0 
</code></pre>
<h3 id="2-以下是指针传递的示例程序">(2) 以下是&quot;指针传递&quot;的示例程序</h3>
<p>由于Func2函数体内的x是指向外部变量n的指针，改变该指针的内容将导致n的值改变，所以n的值成为10。</p>
<pre><code>void Func2(int *x) 
{ 
	(* x) = (* x) + 10; 
} 
... 
int n = 0; 
Func2(&amp;n); 
cout &lt;&lt; &quot;n = &quot; &lt;&lt; n &lt;&lt; endl; // n = 10 
</code></pre>
<h3 id="3-以下是引用传递的示例程序">(3) 以下是&quot;引用传递&quot;的示例程序</h3>
<p>由于Func3函数体内的x是外部变量n的引用，x和n是同一个东西，改变x等于改变n，所以n的值成为10。</p>
<pre><code>void Func3(int &amp;x) 
{ 
	x = x + 10; 
} 
... 
int n = 0; 
Func3(n); 
cout &lt;&lt; &quot;n = &quot; &lt;&lt; n &lt;&lt; endl; // n = 10 
</code></pre>
<p>对比上述三个示例程序，<strong>会发现&quot;引用传递&quot;的性质象&quot;指针传递&quot;，而书写方式象&quot;值传递&quot;</strong>。</p>
<p>实际上&quot;引用&quot;可以做的任何事情&quot;指针&quot;也都能够做，为什么还要&quot;引用&quot;这东西？ 
答案是&quot;用适当的工具做恰如其分的工作&quot;。</p>
<p>指针能够毫无约束地操作内存中的任何东西，尽管指针功能强大，但是非常危险。</p>
<p>如果的确只需要借用一下某个对象的&quot;别名&quot;，那么就用&quot;引用&quot;，而不要用&quot;指针&quot;，以免发生意外。</p>
<h2 id="导航">导航</h2>
<ul>
<li><a href="00.md">目录</a></li>
<li>上一章：<a href="01.md">Chapter 1 - const, inline，static, this</a></li>
<li>下一章：<a href="03.md">Chapter 3 - char*, char[], string</a></li>
</ul>

        
        ]]>
      </description>
=======
      <description>转载自https://github.com/andycai/cprimer 2.1 refrence 引用 引用是C++中的概念，初学者容易把引用和指针混淆一起。以下</description>
>>>>>>> 35a30928abf5c3213b754024efc550556652db2d
    </item>
    
    <item>
      <title>【转载】C Primer 之 const, inline, static, this</title>
      <link>/collection/cprimer01/</link>
      <pubDate>Thu, 30 Dec 2021 07:12:38 +0800</pubDate>
      
      <guid>/collection/cprimer01/</guid>
      <description>转载自https://github.com/andycai/cprimer 1.1 const (1) const 基础 如果const关键字不涉及到指针，我们很好理解，下面是</description>
    </item>
    
    <item>
      <title>C&#43;&#43; 基础总结</title>
      <link>/post/2021/12/15/cppbase/</link>
      <pubDate>Wed, 15 Dec 2021 12:35:27 +0800</pubDate>
      
      <guid>/post/2021/12/15/cppbase/</guid>
      <description>一、语法基础 指针和引用的概念 指针与内存关系 程序编译过程 static、const、#define的用法和区别 C和C++区别 内存模型 内存中的栈和</description>
    </item>
    
  </channel>
</rss>
