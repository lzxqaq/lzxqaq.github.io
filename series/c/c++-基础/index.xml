<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>C/C&#43;&#43; 基础 on Zexun Luo | 罗泽勋</title>
    <link>/series/c/c&#43;&#43;-%E5%9F%BA%E7%A1%80/</link>
    <description>Recent content in C/C&#43;&#43; 基础 on Zexun Luo | 罗泽勋</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <atom:link href="/series/c/c&#43;&#43;-%E5%9F%BA%E7%A1%80/" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>C/C&#43;&#43;基础</title>
      <link>/post/2022/01/11/cc-base/</link>
      <pubDate>Tue, 11 Jan 2022 23:20:27 +0800</pubDate>
      <author>罗泽勋</author>
      <guid>/post/2022/01/11/cc-base/</guid>
      <description>
        <![CDATA[
        <h3 id="一const">一、const</h3>
<h4 id="作用">作用：</h4>
<ul>
<li>修饰变量，说明该变量不可变;</li>
<li>修饰指针，分为指向常量的指针和指针常量；</li>
<li>常量引用，用于行参类型，即避免了拷贝，又避免了函数对值的修改；</li>
<li>修饰成员函数，说明该成员函数不能修改成员变量。</li>
</ul>
<h4 id="使用">使用</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++">
<span style="color:#75715e">// 类
</span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span>
{
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> a;                <span style="color:#75715e">// 常对象成员，只能在初始化列表赋值
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#75715e">// 构造函数
</span><span style="color:#75715e"></span>    A() { };
    A(<span style="color:#66d9ef">int</span> x) <span style="color:#f92672">:</span> a(x) { };        <span style="color:#75715e">// 初始化列表
</span><span style="color:#75715e"></span>
    <span style="color:#75715e">// const可用于对重载函数的区分
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">getValue</span>();             <span style="color:#75715e">// 普通成员函数
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">getValue</span>() <span style="color:#66d9ef">const</span>;       <span style="color:#75715e">// 常成员函数，不得修改类中的任何数据成员的值
</span><span style="color:#75715e"></span>};

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">function</span>()
{
    <span style="color:#75715e">// 对象
</span><span style="color:#75715e"></span>    A b;                        <span style="color:#75715e">// 普通对象，可以调用全部成员函数
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">const</span> A a;                  <span style="color:#75715e">// 常对象，只能调用常成员函数、更新常成员变量
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">const</span> A <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>a;            <span style="color:#75715e">// 常指针
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">const</span> A <span style="color:#f92672">&amp;</span>q <span style="color:#f92672">=</span> a;             <span style="color:#75715e">// 常引用
</span><span style="color:#75715e"></span>
    <span style="color:#75715e">// 指针
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">char</span> greeting[] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Hello&#34;</span>;
    <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> p1 <span style="color:#f92672">=</span> greeting;                <span style="color:#75715e">// 指针变量，指向字符数组变量
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> p2 <span style="color:#f92672">=</span> greeting;          <span style="color:#75715e">// 指针变量，指向字符数组常量
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> <span style="color:#66d9ef">const</span> p3 <span style="color:#f92672">=</span> greeting;          <span style="color:#75715e">// 常指针，指向字符数组变量
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> <span style="color:#66d9ef">const</span> p4 <span style="color:#f92672">=</span> greeting;    <span style="color:#75715e">// 常指针，指向字符数组常量
</span><span style="color:#75715e"></span>}

<span style="color:#75715e">// 函数
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">function1</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> Var);           <span style="color:#75715e">// 传递过来的参数在函数内不可变
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">function2</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> Var);         <span style="color:#75715e">// 参数指针所指内容为常量
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">function3</span>(<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> <span style="color:#66d9ef">const</span> Var);         <span style="color:#75715e">// 参数指针为常指针
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">function4</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">&amp;</span> Var);          <span style="color:#75715e">// 引用参数在函数内为常量
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// 函数返回值
</span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">function5</span>();      <span style="color:#75715e">// 返回一个常数
</span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> <span style="color:#a6e22e">function6</span>();     <span style="color:#75715e">// 返回一个指向常量的指针变量，使用：const int *p = function6();
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">function7</span>();     <span style="color:#75715e">// 返回一个指向变量的常指针，使用：int* const p = function7();
</span><span style="color:#75715e"></span>
</code></pre></div><h3 id="static">static</h3>
<h4 id="作用-1">作用</h4>
<ul>
<li>修饰普通变量，修改变量的存储区域和生命周期，使变量存储在静态区，在 main 函数运行前就分配了空间，如果有初始值就用初始值初始化它，如果没有初始值，系统用默认值初始化它。</li>
<li>修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命名函数重名，可以将函数定为 static。</li>
<li>修饰成员变量，修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员。</li>
<li>修饰成员函数，使得成员函数不需要生成对象就可以访问该函数，但是在 static 函数内不能访问非静态成员。</li>
</ul>
<h3 id="this-指针">this 指针</h3>
<ul>
<li>this 指针是一个隐含于每一个非静态成员函数中的特殊指针。它指向正在被该成员函数操作的那个对象。</li>
<li>当对一个对象调用成员函数时，编译程序先将对象的地址赋给 this 指针，然后调用成员函数，每次成员函数存取数据成员时，由隐含使用 this 指针。</li>
<li>当一个成员函数被调用时，自动向它传递一个隐含的参数，该参数是一个指向这个成员函数所在的对象的指针。</li>
<li>this 指针被隐含地声明为: ClassName const this<code>，这意味着不能给 </code>this<code>指针赋值；在</code>ClassName<code>类的</code>const<code> 成员函数中，</code>this<code> 指针的类型为：</code>const ClassName const，这说明不能对 this 指针所指向的这种对象是不可修改的（即不能对这种对象的数据成员进行赋值操作）；</li>
<li>this 并不是一个常规变量，而是个右值，所以不能取得 this 的地址（不能 &amp;this）。</li>
<li>在以下场景中，经常需要显式引用 this 指针：
<ul>
<li>
<p>为实现对象的链式引用；</p>
</li>
<li>
<p>为避免对同一对象进行赋值操作；</p>
</li>
<li>
<p>在实现一些数据结构时，如 <code>list</code>。</p>
</li>
</ul>
</li>
</ul>
<h3 id="inline-内联函数">inline 内联函数</h3>
<h4 id="特征">特征</h4>
<ul>
<li>
<p>相当于把内联函数里面的内容写在调用内联函数处；</p>
</li>
<li>
<p>相当于不用执行进入函数的步骤，直接执行函数体；</p>
</li>
<li>
<p>相当于宏，却比宏多了类型检查，真正具有函数特性；</p>
</li>
<li>
<p>不能包含循环、递归、switch 等复杂操作；</p>
</li>
<li>
<p>在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数。</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++">
<span style="color:#75715e">// 声明1（加 inline，建议使用）
</span><span style="color:#75715e"></span><span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">functionName</span>(<span style="color:#66d9ef">int</span> first, <span style="color:#66d9ef">int</span> secend,...);

<span style="color:#75715e">// 声明2（不加 inline）
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">functionName</span>(<span style="color:#66d9ef">int</span> first, <span style="color:#66d9ef">int</span> secend,...);

<span style="color:#75715e">// 定义
</span><span style="color:#75715e"></span><span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">functionName</span>(<span style="color:#66d9ef">int</span> first, <span style="color:#66d9ef">int</span> secend,...) {<span style="color:#75715e">/****/</span>};

<span style="color:#75715e">// 类内定义，隐式内联
</span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span> {
    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">doA</span>() { <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>; }         <span style="color:#75715e">// 隐式内联
</span><span style="color:#75715e"></span>}

<span style="color:#75715e">// 类外定义，需要显式内联
</span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span> {
    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">doA</span>();
}
<span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">int</span> A<span style="color:#f92672">::</span>doA() { <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>; }   <span style="color:#75715e">// 需要显式内联
</span><span style="color:#75715e"></span>
</code></pre></div><h4 id="编译器对-inline-函数的处理步骤">编译器对 inline 函数的处理步骤</h4>
<ul>
<li>
<p>将 inline 函数体复制到 inline 函数调用点处；</p>
</li>
<li>
<p>为所用 inline 函数中的局部变量分配内存空间；</p>
</li>
<li>
<p>将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中；</p>
</li>
<li>
<p>如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 GOTO）。</p>
</li>
</ul>
<h4 id="优缺点">优缺点</h4>
<p>优点</p>
<ul>
<li>
<p>内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。</p>
</li>
<li>
<p>内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会。</p>
</li>
<li>
<p>在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能。</p>
</li>
<li>
<p>内联函数在运行时可调试，而宏定义不可以。</p>
</li>
</ul>
<h4 id="缺点">缺点</h4>
<ul>
<li>
<p>代码膨胀。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。</p>
</li>
<li>
<p>inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接。</p>
</li>
<li>
<p>是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。</p>
</li>
</ul>
<h4 id="虚函数virtual可以是内联函数inline吗">虚函数（virtual）可以是内联函数（inline）吗？</h4>
<blockquote>
<p>Are &ldquo;inline virtual&rdquo; member functions ever actually &ldquo;inlined&rdquo;?<br>
答案：http://www.cs.technion.ac.il/users/yechiel/c++-faq/inline-virtuals.html</p>
</blockquote>
<ul>
<li>
<p>虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。</p>
</li>
<li>
<p>内联是在编译器建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。</p>
</li>
<li>
<p>inline virtual 唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 Base::who()），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。</p>
</li>
</ul>
<h4 id="虚函数内联使用">虚函数内联使用</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;  </span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Base</span>
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> who()
    {
        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;I am Base</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
    }
    <span style="color:#66d9ef">virtual</span> <span style="color:#f92672">~</span>Base() {}
};
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Derived</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Base
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">void</span> who()  <span style="color:#75715e">// 不写inline时隐式内联
</span><span style="color:#75715e"></span>    {
        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;I am Derived</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
    }
};

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
    <span style="color:#75715e">// 此处的虚函数 who()，是通过类（Base）的具体对象（b）来调用的，编译期间就能确定了，所以它可以是内联的，但最终是否内联取决于编译器。 
</span><span style="color:#75715e"></span>    Base b;
    b.who();

    <span style="color:#75715e">// 此处的虚函数是通过指针调用的，呈现多态性，需要在运行时期间才能确定，所以不能为内联。  
</span><span style="color:#75715e"></span>    Base <span style="color:#f92672">*</span>ptr <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Derived();
    ptr<span style="color:#f92672">-&gt;</span>who();

    <span style="color:#75715e">// 因为Base有虚析构函数（virtual ~Base() {}），所以 delete 时，会先调用派生类（Derived）析构函数，再调用基类（Base）析构函数，防止内存泄漏。
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">delete</span> ptr;
    ptr <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;

    system(<span style="color:#e6db74">&#34;pause&#34;</span>);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
} 
</code></pre></div><h3 id="assert">assert()</h3>
<p>断言，是宏，而非函数。assert 宏的原型定义在 &lt;assert.h&gt;（C）、<cassert>（C++）中，其作用是如果它的条件返回错误，则终止程序执行。可以通过定义 NDEBUG 来关闭 assert，但是需要在源代码的开头，include &lt;assert.h&gt; 之前。</p>
<h4 id="使用-1">使用</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#75715e">#define NDEBUG          </span><span style="color:#75715e">// 加上这行，则 assert 不可用
</span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;assert.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
assert( p <span style="color:#f92672">!=</span> NULL );    <span style="color:#75715e">// assert 不可用
</span></code></pre></div><h3 id="sizeof">sizeof()</h3>
<ul>
<li>
<p>sizeof 对数组，得到整个数组所占空间大小。</p>
</li>
<li>
<p>sizeof 对指针，得到指针本身所占空间大小。</p>
</li>
</ul>
<h3 id="pragma-packn">pragma pack(n)</h3>
<p>设定结构体、联合以及类成员变量以 n 字节方式对齐</p>
<h4 id="使用-2">使用</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#75715e">#pragma pack(push)  </span><span style="color:#75715e">// 保存对齐状态
</span><span style="color:#75715e"></span><span style="color:#75715e">#pragma pack(4)     </span><span style="color:#75715e">// 设定为 4 字节对齐
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">test</span>
{
    <span style="color:#66d9ef">char</span> m1;
    <span style="color:#66d9ef">double</span> m4;
    <span style="color:#66d9ef">int</span> m3;
};

<span style="color:#75715e">#pragma pack(pop)   </span><span style="color:#75715e">// 恢复对齐状态
</span></code></pre></div><h3 id="位域">位域</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++">Bit mode: <span style="color:#ae81ff">2</span>;    <span style="color:#75715e">// mode 占 2 位
</span></code></pre></div><p>类可以将其（非静态）数据成员定义为位域（bit-field），在一个位域中含有一定数量的二进制位。当一个程序需要向其他程序或硬件设备传递二进制数据时，通常会用到位域。</p>
<ul>
<li>
<p>位域在内存中的布局是与机器有关的</p>
</li>
<li>
<p>位域的类型必须是整型或枚举类型，带符号类型中的位域的行为将因具体实现而定</p>
</li>
<li>
<p>取地址运算符（&amp;）不能作用于位域，任何指针都无法指向类的位域</p>
</li>
</ul>
<h3 id="volatile">volatile</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#66d9ef">volatile</span> <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>; 
</code></pre></div><ul>
<li>
<p>volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以使用 volatile 告诉编译器不应对这样的对象进行优化。</p>
</li>
<li>
<p>volatile 关键字声明的变量，每次访问时都必须从内存中取出值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值）</p>
</li>
<li>
<p>const 可以是 volatile （如只读的状态寄存器）</p>
</li>
<li>
<p>指针可以是 volatile</p>
</li>
</ul>
<h3 id="extern-c">extern &ldquo;C&rdquo;</h3>
<ul>
<li>
<p>被 extern 限定的函数或变量是 extern 类型的</p>
</li>
<li>
<p>被 extern &ldquo;C&rdquo; 修饰的变量和函数是按照 C 语言方式编译和连接的</p>
</li>
</ul>
<p>extern &ldquo;C&rdquo; 的作用是让 C++ 编译器将 extern &ldquo;C&rdquo; 声明的代码当作 C 语言代码处理，可以避免 C++ 因符号修饰导致代码不能和C语言库中的符号进行链接的问题。</p>
<h4 id="c-使用">&ldquo;C&rdquo; 使用</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#75715e">#ifdef __cplusplus
</span><span style="color:#75715e"></span><span style="color:#66d9ef">extern</span> <span style="color:#e6db74">&#34;C&#34;</span> {
<span style="color:#75715e">#endif
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">memset</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>, <span style="color:#66d9ef">int</span>, size_t);

<span style="color:#75715e">#ifdef __cplusplus
</span><span style="color:#75715e"></span>}
<span style="color:#75715e">#endif
</span></code></pre></div><h3 id="struct-和-typedef-struct">struct 和 typedef struct</h3>
<h4 id="c-中">C 中</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#75715e">//C
</span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> Student {
    <span style="color:#66d9ef">int</span> age; 
} S;
</code></pre></div><p>等价于</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#75715e">//C
</span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> Student { 
    <span style="color:#66d9ef">int</span> age; 
};

<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> Student S;
</code></pre></div><p>此时 S 等价于 struct Student，但两个标识符名称空间不相同。</p>
<p>另外还可以定义与 struct Student 不冲突的 void Student() {}。</p>
<h4 id="c-中-1">C++ 中</h4>
<p>由于编译器定位符号的规则（搜索规则）改变，导致不同于C语言。</p>
<p>一、如果在类标识符空间定义了 struct Student {&hellip;};，使用 Student me; 时，编译器将搜索全局标识符表，Student 未找到，则在类标识符内搜索。</p>
<p>即表现为可以使用 Student 也可以使用 struct Student，如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#75715e">// cpp
</span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Student</span> { 
    <span style="color:#66d9ef">int</span> age; 
};

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">f</span>( Student me );       <span style="color:#75715e">// 正确，&#34;struct&#34; 关键字可省略
</span></code></pre></div><p>二、若定义了与 Student 同名函数之后，则 Student 只代表函数，不代表结构体，如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Student</span> { 
    <span style="color:#66d9ef">int</span> age; 
} S;

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Student</span>() {}           <span style="color:#75715e">// 正确，定义后 &#34;Student&#34; 只代表此函数
</span><span style="color:#75715e"></span>
<span style="color:#75715e">//void S() {}               // 错误，符号 &#34;S&#34; 已经被定义为一个 &#34;struct Student&#34; 的别名
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    Student(); 
    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Student</span> me;      <span style="color:#75715e">// 或者 &#34;S me&#34;;
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}

</code></pre></div><h3 id="c-中-struct-和-class">C++ 中 struct 和 class</h3>
<p>总的来说，struct 更适合看成是一个数据结构的实现体，class 更适合看成是一个对象的实现体。</p>
<p>区别</p>
<ul>
<li>
<p>最本质的一个区别就是默认的访问控制</p>
<p>1.默认的继承访问权限。struct 是 public 的，class 是 private 的。</p>
<p>2.struct 作为数据结构的实现体，它默认的数据访问控制是 public 的，而 class 作为对象的实现体，它默认的成员变量访问控制是 private 的。</p>
</li>
</ul>
<h3 id="union-联合">union 联合</h3>
<p>联合（union）是一种节省空间的特殊的类，一个 union 可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值。当某个成员被赋值后其他成员变为未定义状态。联合有如下特点：</p>
<ul>
<li>
<p>默认访问控制符为 public</p>
</li>
<li>
<p>可以含有构造函数、析构函数</p>
</li>
<li>
<p>不能含有引用类型的成员</p>
</li>
<li>
<p>不能继承自其他类，不能作为基类</p>
</li>
<li>
<p>不能含有虚函数</p>
</li>
<li>
<p>匿名 union 在定义所在作用域可直接访问 union 成员</p>
</li>
<li>
<p>匿名 union 不能包含 protected 成员或 private 成员</p>
</li>
</ul>
<p>-全局匿名联合必须是静态（static）的</p>
<h4 id="使用-3">使用</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">union</span> <span style="color:#a6e22e">UnionTest</span> {
    UnionTest() <span style="color:#f92672">:</span> i(<span style="color:#ae81ff">10</span>) {};
    <span style="color:#66d9ef">int</span> i;
    <span style="color:#66d9ef">double</span> d;
};

<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">union</span> {
    <span style="color:#66d9ef">int</span> i;
    <span style="color:#66d9ef">double</span> d;
};

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    UnionTest u;

    <span style="color:#66d9ef">union</span> {
        <span style="color:#66d9ef">int</span> i;
        <span style="color:#66d9ef">double</span> d;
    };

    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> u.i <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;  <span style="color:#75715e">// 输出 UnionTest 联合的 10
</span><span style="color:#75715e"></span>
    <span style="color:#f92672">::</span>i <span style="color:#f92672">=</span> <span style="color:#ae81ff">20</span>;
    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">::</span>i <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;  <span style="color:#75715e">// 输出全局静态匿名联合的 20
</span><span style="color:#75715e"></span>
    i <span style="color:#f92672">=</span> <span style="color:#ae81ff">30</span>;
    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> i <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;    <span style="color:#75715e">// 输出局部匿名联合的 30
</span><span style="color:#75715e"></span>
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="explicit显式构造函数">explicit（显式）构造函数</h3>
<p>explicit 修饰的构造函数可用来防止隐式转换</p>
<h4 id="explicit-使用">explicit 使用</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Test1</span>
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    Test1(<span style="color:#66d9ef">int</span> n)            <span style="color:#75715e">// 普通构造函数
</span><span style="color:#75715e"></span>    {
        num<span style="color:#f92672">=</span>n;
    }
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">int</span> num;
};

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Test2</span>
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">explicit</span> Test2(<span style="color:#66d9ef">int</span> n)   <span style="color:#75715e">// explicit（显式）构造函数
</span><span style="color:#75715e"></span>    {
        num<span style="color:#f92672">=</span>n;
    }
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">int</span> num;
};

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
    Test1 t1<span style="color:#f92672">=</span><span style="color:#ae81ff">12</span>;            <span style="color:#75715e">// 隐式调用其构造函数，成功
</span><span style="color:#75715e"></span>    Test2 t2<span style="color:#f92672">=</span><span style="color:#ae81ff">12</span>;            <span style="color:#75715e">// 编译错误，不能隐式调用其构造函数
</span><span style="color:#75715e"></span>    Test2 t2(<span style="color:#ae81ff">12</span>);           <span style="color:#75715e">// 显式调用成功
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="friend-友元类和友元函数">friend 友元类和友元函数</h3>
<ul>
<li>
<p>能访问私有成员</p>
</li>
<li>
<p>破坏封装性</p>
</li>
<li>
<p>友元关系不可传递</p>
</li>
<li>
<p>友元关系的单向性</p>
</li>
<li>
<p>友元声明的形式及数量不受限制</p>
</li>
</ul>
<h3 id="using">using</h3>
<h4 id="using-声明">using 声明</h4>
<p>一条 using 声明 语句一次只引入命名空间的一个成员。它使得我们可以清楚知道程序中所引用的到底是哪个名字。如：</p>
<pre tabindex="0"><code>using namespace_name::name;
</code></pre><h4 id="构造函数的-using-声明c11">构造函数的 using 声明【C++11】</h4>
<p>在 C++11 中，派生类能够重用其直接基类定义的构造函数。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Derived</span> <span style="color:#f92672">:</span> Base {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">using</span> Base<span style="color:#f92672">::</span>Base;
    <span style="color:#75715e">/* ... */</span>
};
</code></pre></div><p>如上 using 声明，对于基类的每个构造函数，编译器都生成一个与之对应（形参列表完全相同）的派生类构造函数。生成如下类型构造函数：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++">derived(parms) <span style="color:#f92672">:</span> base(args) { }
</code></pre></div><h4 id="using-指示">using 指示</h4>
<p>using 指示 使得某个特定命名空间中所有名字都可见，这样我们就无需再为它们添加任何前缀限定符了。如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#66d9ef">using</span> namespace_name name;
</code></pre></div><h4 id="尽量少使用-using-指示-污染命名空间">尽量少使用 <code>using 指示</code> 污染命名空间</h4>
<blockquote>
<p>一般说来，使用 using 命令比使用 using 编译命令更安全，这是由于它只导入了制定的名称。如果该名称与局部名称发生冲突，编译器将发出指示。using编译命令导入所有的名称，包括可能并不需要的名称。如果与局部名称发生冲突，则局部名称将覆盖名称空间版本，而编译器并不会发出警告。另外，名称空间的开放性意味着名称空间的名称可能分散在多个地方，这使得难以准确知道添加了哪些名称。</p>
</blockquote>
<h3 id="using-使用">using 使用</h3>
<p>尽量少使用 using 指示</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</code></pre></div><p>应该多使用 using 声明</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#66d9ef">int</span> x;
std<span style="color:#f92672">::</span>cin <span style="color:#f92672">&gt;&gt;</span> x ;
std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> x <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</code></pre></div><p>或者</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#66d9ef">using</span> std<span style="color:#f92672">::</span>cin;
<span style="color:#66d9ef">using</span> std<span style="color:#f92672">::</span>cout;
<span style="color:#66d9ef">using</span> std<span style="color:#f92672">::</span>endl;
<span style="color:#66d9ef">int</span> x;
cin <span style="color:#f92672">&gt;&gt;</span> x;
cout <span style="color:#f92672">&lt;&lt;</span> x <span style="color:#f92672">&lt;&lt;</span> endl;
</code></pre></div><h3 id="-范围解析运算符">:: 范围解析运算符</h3>

        
        ]]>
      </description>
    </item>
    
    
    
    <item>
      <title>【转载】C Primer 之 new, delete</title>
      <link>/post/2021/12/30/cprimer04/</link>
      <pubDate>Thu, 30 Dec 2021 07:13:11 +0800</pubDate>
      <author>罗泽勋</author>
      <guid>/post/2021/12/30/cprimer04/</guid>
      <description>
        <![CDATA[
        <p>转载自<a href="https://github.com/andycai/cprimer">https://github.com/andycai/cprimer</a></p>
<p>new和delete运算符用于动态分配和撤销内存的运算符</p>
<h3 id="1-new用法">(1) new用法</h3>
<ol>
<li>开辟单变量地址空间</li>
</ol>
<ol>
<li>
<p>new int;  //开辟一个存放数组的存储空间,返回一个指向该存储空间的地址.int *a = new int 即为将一个int类型的地址赋值给整型指针a.</p>
</li>
<li>
<p>int *a = new int(5) 作用同上,但是同时将整数赋值为5</p>
</li>
</ol>
<ol start="2">
<li>
<p>开辟数组空间</p>
<p>一维:</p>
<pre><code> int *a = new int[100];  // 开辟一个大小为100的整型数组空间
</code></pre>
<p>二维:</p>
<pre><code> int **a = new int[5][6]
</code></pre>
<p>三维及其以上:依此类推</p>
</li>
</ol>
<p>一般用法: new 类型 [初值]</p>
<h3 id="2-delete用法">(2) delete用法</h3>
<ol>
<li>
<p>int *a = new int;</p>
<pre><code> delete a;   //释放单个int的空间
</code></pre>
</li>
<li>
<p>int *a = new int[5];</p>
<pre><code> delete [] a; //释放int数组空间
</code></pre>
</li>
</ol>
<p>要访问new所开辟的结构体空间,无法直接通过变量名进行,只能通过赋值的指针进行访问。</p>
<p>用new和delete可以动态开辟，撤销地址空间。在编程序时,若用完一个变量(一般是暂时存储的数组)，下次需要再用，但却又想省去重新初始化的功夫，可以在每次开始使用时开辟一个空间，在用完后撤销它。</p>
<h2 id="导航">导航</h2>
<ul>
<li><a href="00.md">目录</a></li>
<li>上一章：<a href="04.md">Chapter 4 - uint8_t, uint16_t, uint32_t, uint64_t</a></li>
</ul>

        
        ]]>
      </description>
    </item>
    
    
    
    <item>
      <title>【转载】C Primer 之 char*, char[], string</title>
      <link>/post/2021/12/30/cprimer03/</link>
      <pubDate>Thu, 30 Dec 2021 07:12:45 +0800</pubDate>
      <author>罗泽勋</author>
      <guid>/post/2021/12/30/cprimer03/</guid>
      <description>
        <![CDATA[
        <p>转载自<a href="https://github.com/andycai/cprimer">https://github.com/andycai/cprimer</a></p>
<h2 id="31-char-char-string">3.1 char*, char[], string</h2>
<p>在C中，并没有字符串这个数据类型，而是使用字符数组来保存字符串。C字符串实际上就是一个以null('\0')字符结尾的字符数组，null字符表示字符串的结束。需要注意的是：只有以null字符结尾的字符数组才是C字符串，否则只是一般的C字符数组。</p>
<p>C字符串定义时可以利用&quot;=&ldquo;号进行初始化，但是以后不能利用&rdquo;=&ldquo;对C字符串进行赋值。对C字符串的操作需要通过&quot;string&quot;文件中定义的字符串处理函数。例如：</p>
<pre><code>//字符串的初始化
char a[11] = &quot;huanying&quot;;
//字符串的赋值
strcpy(a,&quot;nihao&quot;)
//获取字符串的长度，不包括'\0'在内
strlen(a);
printf(&quot;%s&quot;,a);
</code></pre>
<p>在C中也可以使用字符指针来访问一个字符串,通过字符指针指向存放字符串数组的首元素地址来进行访问.
char *a = &ldquo;nihao&rdquo;;
printf(&quot;%s&rdquo;,a);</p>
<p>在C++中则把字符串封装成了一种数据类型string,可以直接声明变量并进行赋值等字符串操作。以下是C字符串和C++中string的区别：</p>
<pre><code>                             C字符串                 string对象
所需的头文件名称       	&lt;string&gt;或&lt;string.h&gt;        	&lt;string&gt;或&lt;string.h&gt;
为什么需要头文件       	为了使用字符串函数            为了使用string类
如何声明                 char name[20];              string name;
如何初始化               char name[20]=&quot;nihao&quot;;   	string name = &quot;nihao&quot;;
必须声明字符串长度么？		是                          否
使用一个null字符么？     	是                          否
怎样实现字符串赋值      	strcpy(name,&quot;John&quot;);        name = &quot;John&quot;;
其他优点               	更快                        更易于使用，优选方案
可以赋一个比现有字符更 	不能                        可以
长的字符串么？  
</code></pre>
<h3 id="1-c常用字符串函数">(1) C++常用字符串函数</h3>
<pre><code>char s1[]=&quot;I am a student&quot;;
char s2[20]=&quot;teacher&quot;;
char s3[]=&quot;student&quot;;
int result;
char s4[20],*p;
</code></pre>
<ol>
<li>
<p>串长度 int strlen(char *str)</p>
<p>cout&laquo;strlen(s1)&laquo;endl; 输出14
cout&laquo;strlen(s2)&laquo;endl; 输出7</p>
</li>
<li>
<p>串拷贝 char *strcpy(char *str1,char *str2)</p>
<p>strcpy(s4,s2);   //s4为&quot;teacher&quot;</p>
</li>
<li>
<p>串连接 char *strcat(char <em>str1,char</em>str2)</p>
<p>strcat(s2,s3); //s2为&quot;teacherstudent&quot;</p>
</li>
<li>
<p>串比较 int strcmp(char *str1,char *str) //比较的是对应字符的ASCII码值，如果str1&gt;str2,返回1</p>
<p>result=strcmp(s2,s3);   //result&gt;0
result=strcmp(s2,s2);   //result=0
result=strcmp(s3,s2);   //result&lt;0</p>
</li>
<li>
<p>串定位 char *strchr(char *str,char ch)</p>
<p>p=strchr(s1,&rsquo;s');    //找到返回字符在字串中的位置，否则返回-1
strcpy(p,s2);      //s1为&quot;I am a teacher&quot;</p>
</li>
<li>
<p>在一个串中查找是否存在和另一个串相等的子串</p>
</li>
<li>
<p>截取子串形成一个新串</p>
</li>
</ol>
<h3 id="2-字符串的输入">(2) 字符串的输入</h3>
<ol>
<li>
<p>方法一：使用输入操符来填充一个C字符串变量
例如：
char a[80];
cin&raquo;a;
注：以这种方式来读取C字符串时，会忽略最初的空白字符(空格、制表符和换行符)，而且输入会在下一个空格或者换行符处停止。</p>
</li>
<li>
<p>方法二：使用预定义函数getline获取整行输入(包括空格)
getline函数有两个参数：第一个参数用于接收输入的C字符串变量；第二个参数用于规定getline最多能接收的字符个数。
例如:
char a[80];
cin.getline(a,80);
当遇到行结束的时候，输入才会停止。</p>
</li>
</ol>
<h3 id="3-c-string类的输入">(3) C++ string类的输入</h3>
<ol>
<li>方法一：和C字符串输入的方法一相同。</li>
<li>方法二：使用getline函数。</li>
</ol>
<p>例如：</p>
<pre><code>string a;
getline(cin,a);
</code></pre>
<h3 id="4-string对象和c字符串之间的转换">(4) string对象和C字符串之间的转换</h3>
<p>可以将C字符串存储在string类型的变量中，例如：</p>
<pre><code>char a[] = &quot;nihao&quot;;
string b;
b=a;
</code></pre>
<p>但string对象不能自动的转换为C字符串，需要进行显式的类型转换，需要用到string类的成员函数c_str().
例如：</p>
<pre><code>strcpy(a,b.c_str());
</code></pre>
<h3 id="5-字符串到数字的转换">(5) 字符串到数字的转换</h3>
<p>atoi函数获取一个C字符串参数，返回对应的int值。如果参数不与一个int值对应，atoi就会返回0。atoi函数在文件为cstdlib的库中。如果数字太大，不能转换成int类型的值，可以使用atol将字符串转换为long类型的值。
例如:</p>
<pre><code>atoi(&quot;1234&quot;);   //返回整数1234
atoi(&quot;#123&quot;);   //返回0
</code></pre>
<h2 id="导航">导航</h2>
<ul>
<li><a href="00.md">目录</a></li>
<li>上一章：<a href="02.md">Chapter 2 - pointers, refrence</a></li>
<li>下一章：<a href="04.md">Chapter 4 - uint8_t, uint16_t, uint32_t, uint64_t</a></li>
</ul>

        
        ]]>
      </description>
    </item>
    
    
    
    <item>
      <title>【转载】C Primer 之 指针和引用</title>
      <link>/post/2021/12/30/cprimer02/</link>
      <pubDate>Thu, 30 Dec 2021 07:12:43 +0800</pubDate>
      <author>罗泽勋</author>
      <guid>/post/2021/12/30/cprimer02/</guid>
      <description>
        <![CDATA[
        <p>转载自<a href="https://github.com/andycai/cprimer">https://github.com/andycai/cprimer</a></p>
<h2 id="21-refrence-引用">2.1 refrence 引用</h2>
<p>引用是C++中的概念，初学者容易把引用和指针混淆一起。以下程序中，n 是 m 的一个引用（reference），m 是被引用物（referent）。</p>
<pre><code>int m; 
int &amp;n = m;
</code></pre>
<p>n 相当于 m 的别名（绰号），对 n 的任何操作就是对m的操作。所以 n 既不是 m 的拷贝，也不是指向 m 的指针，其实 n 就是 m 它自己。</p>
<p><strong>引用的规则：</strong></p>
<ul>
<li>引用被创建的同时必须被初始化（指针则可以在任何时候被初始化）。</li>
<li>不能有NULL引用，引用必须与合法的存储单元关联（指针则可以是NULL）。</li>
<li>一旦引用被初始化，就不能改变引用的关系（指针则可以随时改变所指的对象）。</li>
</ul>
<p>以下示例程序中，k 被初始化为 i 的引用。语句 k = j 并不能将 k 修改成为 j 的引用，只是把 k 的值改变成为6。由于 k 是 i 的引用，所以 i 的值也变成了6。</p>
<pre><code>int i = 5; 
int j = 6; 
int &amp;k = i; 
k = j; // k和i的值都变成了6; 
</code></pre>
<p><strong>引用的主要功能是传递函数的参数和返回值</strong>。</p>
<p>C++语言中，函数的参数和返回值的传递方式有三种：<strong>值传递、指针传递和引用传递</strong>。</p>
<h3 id="1-以下是值传递的示例程序">(1) 以下是&quot;值传递&quot;的示例程序</h3>
<p>由于Func1函数体内的x是外部变量n的一份拷贝，改变x的值不会影响n, 所以n的值仍然是0。</p>
<pre><code>void Func1(int x) 
{ 
	x = x + 10; 
} 
... 
int n = 0; 
Func1(n); 
cout &lt;&lt; &quot;n = &quot; &lt;&lt; n &lt;&lt; endl; // n = 0 
</code></pre>
<h3 id="2-以下是指针传递的示例程序">(2) 以下是&quot;指针传递&quot;的示例程序</h3>
<p>由于Func2函数体内的x是指向外部变量n的指针，改变该指针的内容将导致n的值改变，所以n的值成为10。</p>
<pre><code>void Func2(int *x) 
{ 
	(* x) = (* x) + 10; 
} 
... 
int n = 0; 
Func2(&amp;n); 
cout &lt;&lt; &quot;n = &quot; &lt;&lt; n &lt;&lt; endl; // n = 10 
</code></pre>
<h3 id="3-以下是引用传递的示例程序">(3) 以下是&quot;引用传递&quot;的示例程序</h3>
<p>由于Func3函数体内的x是外部变量n的引用，x和n是同一个东西，改变x等于改变n，所以n的值成为10。</p>
<pre><code>void Func3(int &amp;x) 
{ 
	x = x + 10; 
} 
... 
int n = 0; 
Func3(n); 
cout &lt;&lt; &quot;n = &quot; &lt;&lt; n &lt;&lt; endl; // n = 10 
</code></pre>
<p>对比上述三个示例程序，<strong>会发现&quot;引用传递&quot;的性质象&quot;指针传递&quot;，而书写方式象&quot;值传递&quot;</strong>。</p>
<p>实际上&quot;引用&quot;可以做的任何事情&quot;指针&quot;也都能够做，为什么还要&quot;引用&quot;这东西？
答案是&quot;用适当的工具做恰如其分的工作&quot;。</p>
<p>指针能够毫无约束地操作内存中的任何东西，尽管指针功能强大，但是非常危险。</p>
<p>如果的确只需要借用一下某个对象的&quot;别名&quot;，那么就用&quot;引用&quot;，而不要用&quot;指针&quot;，以免发生意外。</p>
<h2 id="导航">导航</h2>
<ul>
<li><a href="00.md">目录</a></li>
<li>上一章：<a href="01.md">Chapter 1 - const, inline，static, this</a></li>
<li>下一章：<a href="03.md">Chapter 3 - char*, char[], string</a></li>
</ul>

        
        ]]>
      </description>
    </item>
    
    
    
    <item>
      <title>【转载】C Primer 之 const, inline, static, this</title>
      <link>/post/2021/12/30/cprimer01/</link>
      <pubDate>Thu, 30 Dec 2021 07:12:38 +0800</pubDate>
      <author>罗泽勋</author>
      <guid>/post/2021/12/30/cprimer01/</guid>
      <description>
        <![CDATA[
        <p>转载自<a href="https://github.com/andycai/cprimer">https://github.com/andycai/cprimer</a></p>
<h2 id="11-const">1.1 const</h2>
<h3 id="1-const-基础">(1) const 基础</h3>
<p>如果const关键字不涉及到指针，我们很好理解，下面是涉及到指针的情况：</p>
<pre><code>int b = 500;
const int* a = &amp;b; [1]
int const *a = &amp;b; [2]
int* const a = &amp;b; [3]
const int* const a = &amp;b; [4]
</code></pre>
<p>如果你能区分出上述四种情况，那么，恭喜你，你已经迈出了可喜的一步。不知道，也没关系，我们可以参考《Effective c++》Item21上的做法，
如果 const 位于星号的左侧，则 const 就是用来修饰指针所指向的变量，即指针指向为常量；如果 const 位于星号的右侧，const 就是修饰指针本身，即指针本身是常量。</p>
<p>因此，[1]和[2]的情况相同，都是指针所指向的内容为常量（const放在变量声明符的位置无关），这种情况下不允许对内容进行更改操作，如不能*a = 3；[3]为指针本身是常量，而指针所指向的内容不是常量，这种情况下不能对指针本身进行更改操作，如a++是错误的；[4]为指针本身和指向的内容均为常量。</p>
<h3 id="2-作为参数">(2) 作为参数</h3>
<pre><code>void display(const double&amp; r);
void display(const double* r);
</code></pre>
<p>说明:</p>
<ol>
<li>在引用或者指针参数的时候使用 const 限制是有意义的，而对于值传递的参数使用 const 则没有意义</li>
<li>保证引用的变量的值不被改变</li>
<li>const 在 double 前或者后面意思相同，只是不同的人的写法不同</li>
</ol>
<h3 id="3-const对象">(3) const对象</h3>
<p>声明为 const 的对象只能访问类中声明为 const 的成员函数，不能调用其它成员函数。</p>
<h3 id="4-const成员函数">(4) const成员函数</h3>
<pre><code>类型说明符 函数名(参数表) const;
void print(int i) const;
</code></pre>
<p>说明:</p>
<ol>
<li>const 是函数类型的一个组成部分，因此在实现部分也要带 const 关键字</li>
<li>常成员函数不能更新对象的数据成员，也不能调用该类中没有用 const 修饰的成员函数</li>
</ol>
<h3 id="5-使用const的一些建议">(5) 使用const的一些建议</h3>
<ol>
<li>要大胆的使用 const，这将给你带来无尽的益处，但前提是你必须搞清楚原委</li>
<li>要避免最一般的赋值操作错误，如将 const 变量赋值，具体可见思考题</li>
<li>在参数中使用 const 应该使用引用或指针，而不是一般的对象实例，原因同上</li>
<li>const 在成员函数中的三种用法（参数、返回值、函数）要很好的使用</li>
<li>不要轻易的将函数的返回值类型定为 const</li>
<li>除了重载操作符外一般不要将返回值类型定为对某个对象的 const 引用</li>
</ol>
<h2 id="12-inline">1.2 inline</h2>
<h3 id="1-预处理宏">(1) 预处理宏</h3>
<p>介绍内联函数之前，有必要介绍一下预处理宏。内联函数的功能和预处理宏的功能相似。相信大家都用过预处理宏，我们会经常定义一些宏，如：</p>
<pre><code>#define TABLE_COMP(x) ((x)&gt;0 ? (x) : 0) 
</code></pre>
<p>就定义了一个宏。</p>
<p>为什么要使用宏呢？因为函数的调用必须要将程序执行的顺序转移到函数所存放在内存中的某个地址，将函数的程序内容执行完后，再返回到转去执行该函数前的地方。这种转移操作要求在转去执行前要保存现场并记忆执行的地址，转回后要恢复现场，并按原来保存地址继续执行。因此，函数调用要有一定的时间和空间方面的开销，于是将影响其效率。而宏只是在预处理的地方把代码展开，不需要额外的空间和时间方面的开销，所以调用一个宏比调用一个函数更有效率。</p>
<p>但是宏也有很多的不尽人意的地方。</p>
<ol>
<li>宏不能访问对象的私有成员。</li>
<li>宏的定义很容易产生二意性。</li>
</ol>
<p>我们举个例子：</p>
<pre><code>#define TABLE_MULTI(x) (x*x) 
</code></pre>
<p>我们用一个数字去调用它，TABLE_MULTI(10)，这样看上去没有什么错误，结果返回100，是正确的，但是如果我们用TABLE_MULTI(10+10)去调用的话，我们期望的结果是400，而宏的调用结果是(10+10*10+10)，结果是120，这显然不是我们要得到的结果。避免这些错误的方法，<strong>一定要给宏的参数都加上括号</strong>。</p>
<pre><code>#define TABLE_MULTI(x) ((x)*(x)) 
</code></pre>
<p>这样可以确保不会出错，但是，即使使用了这种定义，这个宏依然有可能出错，例如使用TABLE_MULTI(a++)调用它，他们本意是希望得到(a+1)<em>(a+1)的结果，而实际上呢？我们可以看看宏的展开结果: (a++)</em>(a++)，如果a的值是４，我们得到的结果是5<em>6=30。而我们期望的结果是5</em>5=25,这又出现了问题。事实上，在一些C的库函数中也有这些问题。例如: Toupper(*pChar++)就会对pChar执行两次++操作，因为Toupper实际上也是一个宏。</p>
<h3 id="2-inline-函数">(2) inline 函数</h3>
<p>我们可以看到宏有一些难以避免的问题，怎么解决呢？</p>
<p>下面就是用我要介绍的内联函数来解决这些问题，我们可以使用内联函数来取代宏的定义。而且事实上我们可以用内联函数完全取代预处理宏。</p>
<p>内联函数和宏的区别在于，宏是由预处理器对宏进行替代，而内联函数是通过编译器控制来实现的。而且内联函数是真正的函数，只是在需要用到的时候，内联函数像宏一样的展开，所以取消了函数的参数压栈，减少了调用的开销。你可以象调用函数一样来调用内联函数，而不必担心会产生于处理宏的一些问题。</p>
<p>我们可以用 inline 来定义内联函数，不过，<strong>任何在类的声明部分定义的函数都会被自动的认为是内联函数</strong>。</p>
<p>在函数声明或定义中函数返回类型前加上关键字 inline 即把min（）指定为内联。</p>
<pre><code>inline int min(int first, int secend) {/****/};
</code></pre>
<p>我们可以把它作为一般的函数一样调用。但是执行速度确比一般函数的执行速度要快。inline 函数对编译器而言必须是可见的，以便它能够在调用点内展开该函数。与非inline函数不同的是，inline函数必须在调用该函数的每个文本文件中定义。当然，对于同一程序的不同文件，如果C++ inline函数出现的话，其定义必须相同。</p>
<p>对于由两个文件compute.c和draw.c构成的程序来说，程序员不能定义这样的min()函数，它在compute.c中指一件事情，而在draw.c中指另外一件事情。如果两个定义不相同，程序将会有未定义的行为。</p>
<p>为保证不会发生这样的事情，建议把inline函数的定义放到头文件中。在每个调用该inline函数的文件中包含该头文件。这种方法保证对每个inline函数只有一个定义，且程序员无需复制代码，并且不可能在程序的生命期中引起无意的不匹配的事情。</p>
<h3 id="3-inline-函数的编程风格">(3) inline 函数的编程风格</h3>
<p>关键字inline 必须与函数定义体放在一起才能使函数成为内联，仅将 inline 放在函数声明前面不起任何作用。如下风格的函数Foo 不能成为内联函数：</p>
<pre><code>inline void Foo(int x, int y);   
// inline 仅与函数声明放在一起   
void Foo(int x, int y){}  
</code></pre>
<p>而如下风格的函数Foo 则成为内联函数：</p>
<pre><code>void Foo(int x, int y);   
inline void Foo(int x, int y)   
// inline 与函数定义体放在一起{} 
</code></pre>
<p>所以说，C++ inline函数是一种“用于实现的关键字”，而不是一种“用于声明的关键字”。一般地，用户可以阅读函数的声明，但是看不到函数的定义。尽管在大多数教科书中内联函数的声明、定义体前面都加了inline 关键字，但我认为inline 不应该出现在函数的声明中。这个细节虽然不会影响函数的功能，但是体现了高质量C++/C 程序设计风格的一个基本原则：声明与定义不可混为一谈，用户没有必要、也不应该知道函数是否需要内联。</p>
<p>定义在类声明之中的成员函数将自动地成为内联函数，例如：</p>
<pre><code>class A  
{  
public:
	void Foo(int x, int y) { }   
	// 自动地成为内联函数  
} 
</code></pre>
<p>将成员函数的定义体放在类声明之中虽然能带来书写上的方便，但不是一种良好的编程风格，上例应该改成：</p>
<pre><code>// 头文件  
class A  
{  
public:  
	void Foo(int x, int y);  
}  
// 定义文件  
inline void A::Foo(int x, int y){}  
</code></pre>
<p>内联函数在C++类中，应用最广的，应该是用来定义存取函数。我们定义的类中一般会把数据成员定义成私有的或者保护的，这样，外界就不能直接读写我们类成员的数据了。对于私有或者保护成员的读写就必须使用成员接口函数来进行。如果我们把这些读写成员函数定义成内联函数的话，将会获得比较好的效率。</p>
<pre><code>Class sample {
Private:
	int nTest;
Public:
	int readtest(){ return nTest;}
	Void settest(int I) {nTest=I;}
} 
</code></pre>
<p>当然，内联函数也有一定的局限性。就是函数中的执行代码不能太多了，如果，<strong>内联函数的函数体过大，一般的编译器会放弃内联方式</strong>，而采用普通的方式调用函数。这样，内联函数就和普通函数执行效率一样了。</p>
<h2 id="13-static">1.3 static</h2>
<h3 id="1-隐藏">(1) 隐藏</h3>
<p>当我们同时编译多个文件时，所有未加 static 前缀的全局变量和函数都具有全局可见性。</p>
<h3 id="2-保持变量内容的持久">(2) 保持变量内容的持久</h3>
<p>存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。共有两种变量存储在静态存储区：全局变量和 static 变量，只不过和全局变量比起来，static 可以控制变量的可见范围，说到底 static 还是用来隐藏的。</p>
<h3 id="3-默认初始化为-0">(3) 默认初始化为 0</h3>
<p>其实全局变量也具备这一属性，因为全局变量也存储在静态数据区。在静态数据区，内存中所有的字节默认值都是 <strong>0x00</strong>，某些时候这一特点可以减少程序员的工作量。</p>
<h2 id="14-this-指针">1.4 this 指针</h2>
<p>先要理解class的意思。class应该理解为一种类型，像int和char一样，是用户自定义的类型。（虽然比 int 和 char 这样 built-in 类型复杂的多，但首先要理解它们一样是类型)。用这个类型可以来声明一个变量，比如int x, myclass my等等。这样就像变量 x 具有 int 类型一样，变量 my 具有 myclass 类型。</p>
<p>理解了这个，就好解释 this 了，my 里的 this 就是指向 my 的指针。如果还有一个变量myclass mz，mz 的 this 就是指向 mz 的指针。这样就很容易理解this 的类型应该是 myclass *，而对其的解引用 *this 就应该是一个 myclass 类型的变量。</p>
<p>通常在class定义时要用到类型变量自身时，因为这时候还不知道变量名（为了通用也不可能固定实际的变量名），就用this这样的指针来使用变量自身。</p>
<h3 id="1-this指针的用处">(1) this指针的用处</h3>
<p>一个对象的 this 指针并不是对象本身的一部分，不会影响sizeof(对象)的结果。this作用域是在类内部，当在类的非静态成员函数中访问类的非静态成员的时候，编译器会自动将对象本身的地址作为一个隐含参数传递给函数。也就是说，即使你没有写上 this 指针，编译器在编译的时候也是加上 this 的，它作为非静态成员函数的隐含形参，对各成员的访问均通过 this 进行。</p>
<p>例如，调用 date.SetMonth(9) &lt;===&gt; SetMonth(&amp;date, 9)，this帮助完成了这一转换。</p>
<h3 id="2-this指针的使用">(2) this指针的使用</h3>
<p>一种情况就是，在类的非静态成员函数中返回类对象本身的时候，直接使用 return *this；另外一种情况是当参数与成员变量名相同时，如this-&gt;n = n （不能写成n = n）。</p>
<h3 id="3-this指针程序示例">(3) this指针程序示例</h3>
<p>this指针是存在与类的成员函数中,指向被调用函数所在的类实例的地址。根据以下程序来说明 this 指针：</p>
<pre><code>#include&lt;iostream.h&gt;
class Point
{ 
  int x, y;
public:
  Point(int a, int b) { x=a; y=b;}
  Void MovePoint( int a, int b){ x+=a; y+=b;}
  Void print(){ cout&lt;&lt;&quot;x=&quot;&lt;&lt;x&lt;&lt;&quot;y=&quot;&lt;&lt;y&lt;&lt;endl;}
};
void main( )
{
   Point point1( 10,10);
   point1.MovePoint(2,2);
   point1.print( );
}
</code></pre>
<p>当对象 point1 调用 MovePoint(2,2) 函数时，即将 point1 对象的地址传递给了 this 指针。</p>
<p>MovePoint 函数的原型应该是 void MovePoint( Point *this, int a, int b);第一个参数是指向该类对象的一个指针，我们在定义成员函数时没看见是因为这个参数在类中是隐含的。这样point1的地址传递给了 this，所以在 MovePoint 函数中便显式的写成：</p>
<pre><code>void MovePoint(int a, int b) { this-&gt;x +=a; this-&gt; y+= b;}
</code></pre>
<p>即可以知道，point1调用该函数后，也就是point1的数据成员被调用并更新了值。即该函数过程可写成 point1.x+= a; point1. y + = b;</p>
<h3 id="4-关于this指针的一个精典回答">(4) 关于this指针的一个精典回答</h3>
<p>当你进入一个房子后，你可以看见桌子、椅子、地板等，但是房子你是看不到全貌了。对于一个类的实例来说，你可以看到它的成员函数、成员变量，但是实例本身呢？this 是一个指针，它时时刻刻指向你这个实例本身。</p>
<h2 id="导航">导航</h2>
<ul>
<li><a href="00.md">目录</a></li>
<li>下一章：<a href="02.md">Chapter 2 - pointers, refrence</a></li>
</ul>

        
        ]]>
      </description>
    </item>
    
    
    
    <item>
      <title>C&#43;&#43; 基础总结</title>
      <link>/post/2021/12/15/cppbase/</link>
      <pubDate>Wed, 15 Dec 2021 12:35:27 +0800</pubDate>
      <author>罗泽勋</author>
      <guid>/post/2021/12/15/cppbase/</guid>
      <description>
        <![CDATA[
        <h3 id="一语法基础">一、语法基础</h3>
<ul>
<li>指针和引用的概念</li>
<li>指针与内存关系</li>
<li>程序编译过程</li>
<li>static、const、#define的用法和区别</li>
<li>C和C++区别</li>
<li>内存模型</li>
<li>内存中的栈和堆分配</li>
</ul>
<h3 id="二面对对象基础">二、面对对象基础</h3>
<ul>
<li>
<p>面向对象理解</p>
</li>
<li>
<p>析构函数</p>
</li>
<li>
<p>构造函数</p>
</li>
<li>
<p>拷贝构造</p>
</li>
<li>
<p>多态</p>
</li>
<li>
<p>纯虚函数和虚函数</p>
</li>
<li>
<p>虚函数实现机制</p>
</li>
<li>
<p>虚函数表</p>
</li>
<li>
<p>访问限定符 public、private、protected</p>
</li>
<li>
<p>继承原理、虚继承、菱形继承</p>
</li>
<li>
<p>静态绑定和动态绑定</p>
</li>
<li>
<p>new/delete和malloc/free</p>
</li>
<li>
<p>重载、重写和隐藏</p>
</li>
</ul>
<h3 id="三语法进阶">三、语法进阶</h3>
<ul>
<li>智能指针</li>
<li>左值、右值引用和move语义</li>
<li>类型转换方式</li>
<li>常用的设计模式</li>
<li>线程安全的单例模式</li>
<li>内存溢出和内存泄漏</li>
<li>C++11新特性</li>
<li>静态链接库和动态链接库</li>
</ul>
<h3 id="四stl-标准模板库">四、STL 标准模板库</h3>
<ul>
<li>迭代器、空间配置器理解</li>
<li>常用容器特点、用法以及底层实现vector、list、deque、set、map、unorderedmap</li>
</ul>

        
        ]]>
      </description>
    </item>
    
    
  </channel>
</rss>
