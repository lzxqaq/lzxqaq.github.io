<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    <title>Java 并发 | Zexun Luo | 罗泽勋</title>

    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">    
<meta name="viewport" content="width=device-width,minimum-scale=1">
<meta name="description" content="一、使用线程 🔗有三种使用线程的方法：
 实现 Runnable 接口； 实现 Callable接口； 继承 Tread 类；  实现 Runnable 接口 🔗需要实现接口中的 run() 方法。
public class MyRunnable implements Runnable {  @Override  public void run(){  // ...  } } 使用 Runnable 实例再创建一个 Thread 实例，然后调用 Thread 实例的 start() 方法来启动线程。
public static void main(String[] args){  MyRunnable instance = new MyRunnable();  Thread thread = new Thread(instance);  thread.start(); } 实现 Callable 接口 🔗与 Runnable 相比，Callable 可以有返回值，返回值通过 FutureTask 进行封装。">
<meta name="generator" content="Hugo 0.95.0" />


  <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">


<link rel="stylesheet" href="/css/style.css">



<link rel="shortcut icon" href="/images/favicon.ico" type="image/x-icon" />
<link href="https://cdn.bootcss.com/aplayer/1.10.1/APlayer.min.css" rel="stylesheet">
<script src="https://cdn.bootcss.com/aplayer/1.10.1/APlayer.min.js"></script>

 
    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'G-KDTTBGMLCQ', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>







  </head>

  <body>
    <nav class="navigation">
	
		<a href="/"> <span class="arrow">←</span>首页</a>
	
	
	
	

	
		<a href="/posts">博客</a>
	
		<a href="/tags">归档</a>
	
		<a href="/about">关于</a>
	

	
	  <a class="button" href="/index.xml">订阅</a>
	
</nav>


    <main class="main">
      



<section id="single">
    <h1 class="title">Java 并发</h1>

    <div class="tip">
        <time datetime="2021-01-09 10:50:16 &#43;0800 CST">2021年01月09日</time>
        <span class="split">
          ·
        </span>
        <span>
          523字
        </span>
        <span class="split">
          ·
        </span>
        <span>
          3分钟
        </span>
    </div>

    
    
    


    <div class="content">
      <h3 id="一使用线程">一、使用线程 <a href="#%e4%b8%80%e4%bd%bf%e7%94%a8%e7%ba%bf%e7%a8%8b" class="anchor">🔗</a></h3><p>有三种使用线程的方法：</p>
<ul>
<li>实现 Runnable 接口；</li>
<li>实现 Callable接口；</li>
<li>继承 Tread 类；</li>
</ul>
<h4 id="实现-runnable-接口">实现 Runnable 接口 <a href="#%e5%ae%9e%e7%8e%b0-runnable-%e6%8e%a5%e5%8f%a3" class="anchor">🔗</a></h4><p>需要实现接口中的 run() 方法。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>public class MyRunnable implements Runnable {
</span></span><span style="display:flex;"><span>    @Override
</span></span><span style="display:flex;"><span>    public void run(){
</span></span><span style="display:flex;"><span>        // ...
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>使用 Runnable 实例再创建一个 Thread 实例，然后调用 Thread 实例的 start() 方法来启动线程。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>public static void main(String[] args){
</span></span><span style="display:flex;"><span>    MyRunnable instance = new MyRunnable();
</span></span><span style="display:flex;"><span>    Thread thread = new Thread(instance);
</span></span><span style="display:flex;"><span>    thread.start();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="实现-callable-接口">实现 Callable 接口 <a href="#%e5%ae%9e%e7%8e%b0-callable-%e6%8e%a5%e5%8f%a3" class="anchor">🔗</a></h4><p>与 Runnable 相比，Callable 可以有返回值，返回值通过 FutureTask 进行封装。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>public class MyCallable implements Callable&lt;Integer&gt; {
</span></span><span style="display:flex;"><span>    public Integer call(){
</span></span><span style="display:flex;"><span>        return 123;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>public static void main(String[] args) throws ExecutionException,InterruptedException {
</span></span><span style="display:flex;"><span>    MyCallable mc = new MyCallble();
</span></span><span style="display:flex;"><span>    FutureTask&lt;Integer&gt; ft = new FutureTask&lt;&gt;(mc);
</span></span><span style="display:flex;"><span>    Thread thread = new Thread(ft);
</span></span><span style="display:flex;"><span>    thread.start();
</span></span><span style="display:flex;"><span>    System.out.println(ft.get());
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="继承-thread-类">继承 Thread 类 <a href="#%e7%bb%a7%e6%89%bf-thread-%e7%b1%bb" class="anchor">🔗</a></h3><p>同样也是需要实现 run() 方法，因为 Thread 类也实现了 Runnable 接口。</p>
<p>当调用 start() 方法启动一个线程时，虚拟机会将该线程放入就绪队列中等待被调度，当一个线程被调度时会执行该线程的 run() 方法。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>public class MyThread extends Thread {
</span></span><span style="display:flex;"><span>    public void run() {
</span></span><span style="display:flex;"><span>        // ...
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>public static void main(String[] args) {
</span></span><span style="display:flex;"><span>    MyThread mt = new MyThread();
</span></span><span style="display:flex;"><span>    mt.start();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="实现接口-vs-继承-thread">实现接口 VS 继承 Thread <a href="#%e5%ae%9e%e7%8e%b0%e6%8e%a5%e5%8f%a3-vs-%e7%bb%a7%e6%89%bf-thread" class="anchor">🔗</a></h3><p>实现接口会更好一些，因为：</p>
<ul>
<li>Java 不支持多重继承，可以实现多个接口。</li>
<li>继承整个 Thread 类开销过大。</li>
</ul>
<h3 id="四互斥同步">四、互斥同步 <a href="#%e5%9b%9b%e4%ba%92%e6%96%a5%e5%90%8c%e6%ad%a5" class="anchor">🔗</a></h3><p>Java 提供了两种锁机制来控制多个线程对共享资源的互斥访问，第一个是 JVM 实现的 synchronized，而另一个是 JDK 实现的 ReentrantLock。</p>
<h4 id="synchronized">synchronized <a href="#synchronized" class="anchor">🔗</a></h4><h5 id="1同步一个代码块">1.同步一个代码块 <a href="#1%e5%90%8c%e6%ad%a5%e4%b8%80%e4%b8%aa%e4%bb%a3%e7%a0%81%e5%9d%97" class="anchor">🔗</a></h5><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>public void func() {
</span></span><span style="display:flex;"><span>    synchronized (this) {
</span></span><span style="display:flex;"><span>        // ...
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>它只作用于同一个对象，如果调用两个对象上的同步代码块，就不会进行同步。</p>
<p>对于以下代码，使用 ExecutorService 执行了两个线程，由于调用的是同一个对象的同步代码块，因此这两个线程会进行同步，当一个线程进入同步语句块时，另一个线程就必须等待。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>public class SynchronizedExample {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    public void func1() {
</span></span><span style="display:flex;"><span>        synchronized (this) {
</span></span><span style="display:flex;"><span>            for (int i = 0; i &lt; 10; i++) {
</span></span><span style="display:flex;"><span>                System.out.print(i + &#34; &#34;);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>public static void main(String[] args) {
</span></span><span style="display:flex;"><span>    SynchronizedExample e1 = new SynchronizedExample();
</span></span><span style="display:flex;"><span>    ExecutorService executorService = Executors.newCachedThreadPool();
</span></span><span style="display:flex;"><span>    executorService.execute(() -&gt; e1.func1());
</span></span><span style="display:flex;"><span>    executorService.execute(() -&gt; e1.func1());
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9
</span></span></code></pre></div><p>对于以下代码，两个线程调用了不同对象的同步代码块，因此这两个线程就不需要同步。从输出结果可以看出，两个线程交叉执行。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>public static void main(String[] args) {
</span></span><span style="display:flex;"><span>    SynchronizedExample e1 = new SynchronizedExample();
</span></span><span style="display:flex;"><span>    SynchronizedExample e2 = new SynchronizedExample();
</span></span><span style="display:flex;"><span>    ExecutorService executorService = Executors.newCachedThreadPool();
</span></span><span style="display:flex;"><span>    executorService.execute(() -&gt; e1.func1());
</span></span><span style="display:flex;"><span>    executorService.execute(() -&gt; e2.func1());
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>0 0 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9
</span></span></code></pre></div><h5 id="2同步一个方法">2.同步一个方法 <a href="#2%e5%90%8c%e6%ad%a5%e4%b8%80%e4%b8%aa%e6%96%b9%e6%b3%95" class="anchor">🔗</a></h5><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>public synchronized void func() {
</span></span><span style="display:flex;"><span>    // ...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>它和同步代码块一样，作用于同一个对象</p>
<h5 id="3同步一个类">3.同步一个类 <a href="#3%e5%90%8c%e6%ad%a5%e4%b8%80%e4%b8%aa%e7%b1%bb" class="anchor">🔗</a></h5><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>public void func() {
</span></span><span style="display:flex;"><span>    synchronized (SynchronizedExample.class) {
</span></span><span style="display:flex;"><span>        // ...
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>作用于整个类，也就是说两个线程调用同一个类的不同对象上的这种同步语句块，也会进行同步。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>public class SynchronizedExample {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    public void func2() {
</span></span><span style="display:flex;"><span>        synchronized (SynchronizedExample.class) {
</span></span><span style="display:flex;"><span>            for (int i = 0; i &lt; 10; i++) {
</span></span><span style="display:flex;"><span>                System.out.print(i + &#34; &#34;);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>public static void main(String[] args) {
</span></span><span style="display:flex;"><span>    SynchronizedExample e1 = new SynchronizedExample();
</span></span><span style="display:flex;"><span>    SynchronizedExample e2 = new SynchronizedExample();
</span></span><span style="display:flex;"><span>    ExecutorService executorService = Executors.newCachedThreadPool();
</span></span><span style="display:flex;"><span>    executorService.execute(() -&gt; e1.func2());
</span></span><span style="display:flex;"><span>    executorService.execute(() -&gt; e2.func2());
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9
</span></span></code></pre></div><h5 id="4同步一个静态方法">4.同步一个静态方法 <a href="#4%e5%90%8c%e6%ad%a5%e4%b8%80%e4%b8%aa%e9%9d%99%e6%80%81%e6%96%b9%e6%b3%95" class="anchor">🔗</a></h5><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>public synchronized static void fun() {
</span></span><span style="display:flex;"><span>    // ...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>作用于整个类。</p>
<h4 id="reentrantlock">ReentrantLock <a href="#reentrantlock" class="anchor">🔗</a></h4><p>ReentrantLock 是 java.util.concurrent（J.U.C)包中的锁。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>public class LockExample {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    private Lock lock = new ReentrantLock();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    public void func() {
</span></span><span style="display:flex;"><span>        lock.lock();
</span></span><span style="display:flex;"><span>        try {
</span></span><span style="display:flex;"><span>            for (int i = 0; i &lt; 10; i++) {
</span></span><span style="display:flex;"><span>                System.out.print(i + &#34; &#34;);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        } finally {
</span></span><span style="display:flex;"><span>            lock.unlock(); // 确保释放锁，从而避免发生死锁。
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>public static void main(String[] args) {
</span></span><span style="display:flex;"><span>    LockExample lockExample = new LockExample();
</span></span><span style="display:flex;"><span>    ExecutorService executorService = Executors.newCachedThreadPool();
</span></span><span style="display:flex;"><span>    executorService.execute(() -&gt; lockExample.func());
</span></span><span style="display:flex;"><span>    executorService.execute(() -&gt; lockExample.func());
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9
</span></span></code></pre></div><h5 id="使用选择">使用选择 <a href="#%e4%bd%bf%e7%94%a8%e9%80%89%e6%8b%a9" class="anchor">🔗</a></h5><p>除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized。这是因为 synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。并且使用 synchronized 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放。</p>
<h3 id="六线程状态">六、线程状态 <a href="#%e5%85%ad%e7%ba%bf%e7%a8%8b%e7%8a%b6%e6%80%81" class="anchor">🔗</a></h3><h4 id="新建">新建 <a href="#%e6%96%b0%e5%bb%ba" class="anchor">🔗</a></h4><h4 id="可运行">可运行 <a href="#%e5%8f%af%e8%bf%90%e8%a1%8c" class="anchor">🔗</a></h4><h4 id="阻塞">阻塞 <a href="#%e9%98%bb%e5%a1%9e" class="anchor">🔗</a></h4><h4 id="无限期等待">无限期等待 <a href="#%e6%97%a0%e9%99%90%e6%9c%9f%e7%ad%89%e5%be%85" class="anchor">🔗</a></h4><h4 id="死亡">死亡 <a href="#%e6%ad%bb%e4%ba%a1" class="anchor">🔗</a></h4>
    </div>

    
        <div class="tags">
            
                <a href="/tags/java">Java</a>
            
        </div>
    
    
    


<script src="https://utteranc.es/client.js"
repo=""
issue-term=""
theme=""
crossorigin="anonymous"
async>
</script>





</section>


    </main>
    
    <footer id="footer">
    

    <div class="copyright">
    
       © Copyright 
       2022 
       <span class="split">
        <svg fill="#bbbbbb" width="15" height="15" version="1.1" id="heart-15" xmlns="http://www.w3.org/2000/svg" width="15px" height="15px" viewBox="0 0 15 15">
  <path d="M13.91,6.75c-1.17,2.25-4.3,5.31-6.07,6.94c-0.1903,0.1718-0.4797,0.1718-0.67,0C5.39,12.06,2.26,9,1.09,6.75&#xA;&#x9;C-1.48,1.8,5-1.5,7.5,3.45C10-1.5,16.48,1.8,13.91,6.75z"/>
</svg>
       </span>
       罗泽勋
    
    </div>

    
</footer>



  </body>
</html>
