<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    <title>从 Java 到 Qt/C&#43;&#43; 的一些经验总结 | Zexun Luo | 罗泽勋</title>

    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">    
<meta name="viewport" content="width=device-width,minimum-scale=1">
<meta name="description" content="C/C&#43;&#43; 代码编译成可执行程序的过程 🔗  预处理
 进行宏定义展开、头文件展开、条件编译，不检查语法。 gcc -E demo1.c -o demo1.i    编译
 检查语法，将预处理过的文件编译生成汇编文件 gcc -S demo2.c -o demo2.s    汇编
 将汇编文件生成目标文件（二进制代码文件，即.o 文件） gcc -c demo3.c -o demo3.o    链接
 找到依赖的库文件，将目标文件链接为可执行程序。 gcc demo4.c -o demo4 -L./ -llib1 通过gcc编译器让 demo4 链接自己制作的 lib1 动态库，并把 demo4 编译成可执行程序。    Java 代码编译和执行的过程 🔗 源文件由编译器编译成字节码 字节码由 Java 虚拟机解释运行。因为 Java 程序既要编译同时也要经过 JVM 的解释运行，所以 Java 也被称为半解释语言。  静态和动态 🔗 静态：在编译（编译 &#43; 链接）阶段 动态：在执行阶段  #include &lt;stdio.">
<meta name="generator" content="Hugo 0.95.0" />


  <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">


<link rel="stylesheet" href="/css/style.css">



<link rel="shortcut icon" href="/images/favicon.ico" type="image/x-icon" />
<link href="https://cdn.bootcss.com/aplayer/1.10.1/APlayer.min.css" rel="stylesheet">
<script src="https://cdn.bootcss.com/aplayer/1.10.1/APlayer.min.js"></script>

 
    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'G-KDTTBGMLCQ', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>







  </head>

  <body>
    <nav class="navigation">
	
		<a href="/"> <span class="arrow">←</span>首页</a>
	
	<a href="/posts">博客</a>
	<a href="/tags">归档</a>
	<a href="/about">关于</a>

	

	
	  <a class="button" href="/index.xml">订阅</a>
	
</nav>


    <main class="main">
      



<section id="single">
    <h1 class="title">从 Java 到 Qt/C&#43;&#43; 的一些经验总结</h1>

    <div class="tip">
        <time datetime="2022-03-07 12:22:40 &#43;0800 CST">2022年03月07日</time>
        <span class="split">
          ·
        </span>
        <span>
          979字
        </span>
        <span class="split">
          ·
        </span>
        <span>
          5分钟
        </span>
    </div>

    
    
    


    <div class="content">
      <h3 id="cc-代码编译成可执行程序的过程">C/C++ 代码编译成可执行程序的过程 <a href="#cc-%e4%bb%a3%e7%a0%81%e7%bc%96%e8%af%91%e6%88%90%e5%8f%af%e6%89%a7%e8%a1%8c%e7%a8%8b%e5%ba%8f%e7%9a%84%e8%bf%87%e7%a8%8b" class="anchor">🔗</a></h3><ul>
<li>
<p>预处理</p>
<ul>
<li>进行宏定义展开、头文件展开、条件编译，不检查语法。</li>
<li>gcc -E demo1.c -o demo1.i</li>
</ul>
</li>
<li>
<p>编译</p>
<ul>
<li>检查语法，将预处理过的文件编译生成汇编文件</li>
<li>gcc -S demo2.c  -o demo2.s</li>
</ul>
</li>
<li>
<p>汇编</p>
<ul>
<li>将汇编文件生成目标文件（二进制代码文件，即.o 文件）</li>
<li>gcc -c demo3.c  -o demo3.o</li>
</ul>
</li>
<li>
<p>链接</p>
<ul>
<li>找到依赖的库文件，将目标文件链接为可执行程序。</li>
<li>gcc demo4.c -o demo4 -L./ -llib1</li>
<li>通过gcc编译器让 demo4 链接自己制作的 lib1 动态库，并把 demo4 编译成可执行程序。</li>
</ul>
</li>
</ul>
<h3 id="java-代码编译和执行的过程">Java 代码编译和执行的过程 <a href="#java-%e4%bb%a3%e7%a0%81%e7%bc%96%e8%af%91%e5%92%8c%e6%89%a7%e8%a1%8c%e7%9a%84%e8%bf%87%e7%a8%8b" class="anchor">🔗</a></h3><ul>
<li>源文件由编译器编译成字节码</li>
<li>字节码由 Java 虚拟机解释运行。因为 Java 程序既要编译同时也要经过 JVM 的解释运行，所以 Java 也被称为半解释语言。</li>
</ul>
<h3 id="静态和动态">静态和动态 <a href="#%e9%9d%99%e6%80%81%e5%92%8c%e5%8a%a8%e6%80%81" class="anchor">🔗</a></h3><ul>
<li>静态：在编译（编译 + 链接）阶段</li>
<li>动态：在执行阶段</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>#include &lt;stdio.h&gt;
</span></span><span style="display:flex;"><span>#include &lt;stdlib.h&gt;
</span></span><span style="display:flex;"><span>int main() {
</span></span><span style="display:flex;"><span>  int m, n;
</span></span><span style="display:flex;"><span>  int *p, *q;
</span></span><span style="display:flex;"><span>  scanf(&#34;%d%d&#34;, &amp;m, &amp;n);
</span></span><span style="display:flex;"><span>  p = (int*)malloc(sizeof(int) * m);
</span></span><span style="display:flex;"><span>  q = (int*)malloc(sizeof(int) * n);
</span></span><span style="display:flex;"><span>  return 0;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p>m、n、p、q 静态分配内存。局部变量，要占多大空间、往哪里放，在编译时就已经确定。
malloc 函数动态分配内存，在堆区分配内存，把地址赋值给 p、q。</p>
</blockquote>
<p>进一步：静态和动态 + static 关键字</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>#include &lt;stdio.h&gt;
</span></span><span style="display:flex;"><span>#include &lt;stdlib.h&gt;
</span></span><span style="display:flex;"><span>void hehe() {
</span></span><span style="display:flex;"><span>  int k=0;
</span></span><span style="display:flex;"><span>  static int sum = 0;
</span></span><span style="display:flex;"><span>  k++;
</span></span><span style="display:flex;"><span>  sum++;
</span></span><span style="display:flex;"><span>  printf(&#34;%d %d\n&#34;, k, sum);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>int main() {
</span></span><span style="display:flex;"><span>  int *p;
</span></span><span style="display:flex;"><span>  p = (int*)malloc(sizeof(int));
</span></span><span style="display:flex;"><span>  hehe();
</span></span><span style="display:flex;"><span>  hehe();
</span></span><span style="display:flex;"><span>  return 0;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p>k、sum 静态分配内存。局部变量，它们要占多大空间、往哪里放，在编译时就已经确定。
static 和静态、动态分配内存没关系，static 指 sum 变量的创建和销毁不会随着 hehe() 函数的调用而一次次创建销毁。</p>
</blockquote>
<h3 id="c-语言的内存分区">C 语言的内存分区 <a href="#c-%e8%af%ad%e8%a8%80%e7%9a%84%e5%86%85%e5%ad%98%e5%88%86%e5%8c%ba" class="anchor">🔗</a></h3><ul>
<li>栈（Stack）</li>
<li>堆（Heap）</li>
<li>全局/静态 常量</li>
<li>文本（代码）Text(Code)</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>#include &lt;stdio.h&gt;
</span></span><span style="display:flex;"><span>#include &lt;stdlib.h&gt;
</span></span><span style="display:flex;"><span>int total = 0;//全局变量-&gt;全局/静态区
</span></span><span style="display:flex;"><span>void hehe() {
</span></span><span style="display:flex;"><span>  static int he = 0;//静态局部变量，只创建一次，静态区
</span></span><span style="display:flex;"><span>  he++;
</span></span><span style="display:flex;"><span>  total++;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>int main() {
</span></span><span style="display:flex;"><span>  int k = 3;//局部变量-&gt;栈， 3-&gt;文本区
</span></span><span style="display:flex;"><span>  char *str = &#34;Hello&#34;;//str-&gt;栈  &#34;Hello&#34;-&gt;常量区
</span></span><span style="display:flex;"><span>  int *p = (int*)malloc(sizeof(int));//p-&gt;栈  malloc分配控件-&gt;堆
</span></span><span style="display:flex;"><span>  hehe();//函数每次结束，栈空间都会释放，而静态区不会
</span></span><span style="display:flex;"><span>  free(p);
</span></span><span style="display:flex;"><span>  return 0;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//文本区-&gt;放这个文件编译后的二进制码
</span></span></code></pre></div><h3 id="动态库静态库">动态库、静态库 <a href="#%e5%8a%a8%e6%80%81%e5%ba%93%e9%9d%99%e6%80%81%e5%ba%93" class="anchor">🔗</a></h3><ul>
<li>
<p>库是写好的现有的，成熟的，可以复用的代码。</p>
</li>
<li>
<p>linux：</p>
<ul>
<li>静态库：.a</li>
<li>动态库：.so</li>
</ul>
</li>
<li>
<p>window：</p>
<ul>
<li>静态库：.lib</li>
<li>动态库：.dll</li>
</ul>
</li>
</ul>
<ul>
<li>静态库：是因为在链接阶段，会将汇编生成的目标文件.o与引用到的库一起链接打包到可执行文件中。因此对应的链接方式称为静态链接。</li>
<li>动态库：在程序编译时并不会被连接到目标代码中，而是在程序运行是才被载入。不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例。</li>
</ul>
<p>静态库的特点：</p>
<ul>
<li>1、使用静态库的时候，会将静态库的信息直接编译到可执行文件中（在编译时期完成的）</li>
<li>2、优点:当静态库被删除，对可执行文件没有影响</li>
<li>3、缺点:浪费内存空间。如果静态库被修改，可执行程序要重新编译</li>
</ul>
<p>动态库的特点：</p>
<ul>
<li>加载器在加载动态库时，操作系统会先检查动态库是否因为其它程序已经将这个动态库信息加载到了内存中。如果没有加载到内存中，操作系统会将动态库载入内存，并将它的引用计数设置为1;如果已经加载到内存，仅将动态库的引用计数加1。</li>
</ul>
<h3 id="动态库与模板">动态库与模板 <a href="#%e5%8a%a8%e6%80%81%e5%ba%93%e4%b8%8e%e6%a8%a1%e6%9d%bf" class="anchor">🔗</a></h3><ul>
<li>由于模板实例化是在编译时执行，如果在动态库中导出模板类(函数)，因为实际的调用代码是在外部exe中，不在动态库本身中，所以在编译生成动态库的时候是不会生成实例的，这样在编译外部exe的时候就会报链接错误。</li>
<li>只有将导出库里面的模板函数或者模板类实例化，才能将实例化后模板函数的地址信息和模板类实例化的地址信息保存在导出库中。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>//TemplateLib.h  使用动态库
</span></span><span style="display:flex;"><span>#ifdef	TEST_DLL_EXPORTS
</span></span><span style="display:flex;"><span>	#define	TEST_API	__declspec(dllexport)
</span></span><span style="display:flex;"><span>#else
</span></span><span style="display:flex;"><span>	#define TEST_API	__declspec(dllimport)
</span></span><span style="display:flex;"><span>#endif
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>// 导出模板函数
</span></span><span style="display:flex;"><span>template&lt;typename T1&gt;
</span></span><span style="display:flex;"><span>TEST_API	void	fun1(T1);
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>template&lt;typename T1,typename T2&gt;
</span></span><span style="display:flex;"><span>TEST_API	void	fun2(T1 , T2);
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>// 模板类
</span></span><span style="display:flex;"><span>template&lt;typename T,int size&gt;
</span></span><span style="display:flex;"><span>class TEST_API	CTest
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>public:
</span></span><span style="display:flex;"><span>	CTest()		{};
</span></span><span style="display:flex;"><span>	~CTest()	{};
</span></span><span style="display:flex;"><span>	T*	GetDataBuff()	{	return m_data;}
</span></span><span style="display:flex;"><span>private:
</span></span><span style="display:flex;"><span>	T	m_data[size];
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>// TemplateLib.cpp : 定义 DLL 应用程序的导出函数。
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>#include &#34;stdafx.h&#34;
</span></span><span style="display:flex;"><span>#include &#34;TemplateLib.h&#34;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>// 1.利用重载来实例化不同类型的模板，代码量大不说，基本上是重复的代码
</span></span><span style="display:flex;"><span>// 2.库的设计者不知道用户会传入什么类型，也就是说设计者不可能实例化每一种类型的模板。
</span></span><span style="display:flex;"><span>TEST_API	void fun1(int var1)		{}
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>TEST_API	void fun1(char var1)		{}
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>template&lt;typename T1,typename T2&gt;
</span></span><span style="display:flex;"><span>TEST_API	void fun2( T1 var1, T2 var2)	{}
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>// 这个名字空间不作为导出使用，唯一作用是用来例化函数模板和类模板.
</span></span><span style="display:flex;"><span>namespace implement_template_private
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>	void	implement_template()
</span></span><span style="display:flex;"><span>	{
</span></span><span style="display:flex;"><span>		int		idata = 10;
</span></span><span style="display:flex;"><span>		char	chr	= &#39;x&#39;;
</span></span><span style="display:flex;"><span>		float	fdata = 20.f;
</span></span><span style="display:flex;"><span>		UINT	undata= 9;
</span></span><span style="display:flex;"><span>		char*	str	=	&#34;hello&#34;;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>		// 这种方式的实例化，代码量比重载方式少许多，但需运行一次该模板函数
</span></span><span style="display:flex;"><span>		// 也许在某些时候凭空运行这个函数是不合理的。
</span></span><span style="display:flex;"><span>		fun2(idata,chr);				// int,char
</span></span><span style="display:flex;"><span>		fun2(undata,str);				// UINT,char*
</span></span><span style="display:flex;"><span>		fun2&lt;float,char*&gt;(fdata,str);		// float,char* 显示参数
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>		// 导出类的实例化。
</span></span><span style="display:flex;"><span>		// 1.除了要实例化提供给用户使用的公有成员函数外，这里面还隐含的实例化了构造函数和析构函数.
</span></span><span style="display:flex;"><span>		// 2.注意这里每一个模板的实例化都是唯一的。
</span></span><span style="display:flex;"><span>		// 3.假如客户如果在项目中使用了CTest&lt;char,30&gt; impl_obj; 将会连接错误， 模板的参数列表必须完全匹配。
</span></span><span style="display:flex;"><span>		// 4.假如该模板类非常大，功能非常多，那么实例化工作可以想象是不堪忍受的。
</span></span><span style="display:flex;"><span>		// 5.库的设计者不知道用户会传入什么类型，也就是说设计者不可能实例化每一种类型的模板。
</span></span><span style="display:flex;"><span>		CTest&lt;char,20&gt;	impl_obj;
</span></span><span style="display:flex;"><span>		impl_obj.GetDataBuff();
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>		CTest&lt;int,5&gt;	impl_obj2;
</span></span><span style="display:flex;"><span>		impl_obj.GetDataBuff();
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>总结：不建议在导出库中使用模板相关的技术，假如你能够确定用户在使用你设计的模板函数时，将传入哪些类型，设计者要将这些类型的模板一一实例化。</li>
<li>在动态库和静态库使用模板:https://blog.csdn.net/xiexievv/article/details/8500234</li>
</ul>
<h3 id="autoc-11">auto（C++ 11） <a href="#autoc-11" class="anchor">🔗</a></h3><p>其核心在于类型推导，也就是让编译器根据等号右边的表达式来决定auto实际代表的类型。C++的auto只涉及到编译期的行为而不是运行期。</p>
<ul>
<li>优点：
<ul>
<li>可以极大的缩短代码的长度。</li>
</ul>
</li>
<li>缺点：
<ul>
<li>可能会降低代码的可读性。</li>
<li>可能会引入额外的性能开销。</li>
</ul>
</li>
</ul>
<p>如：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span> MyBigDataType&amp; func();
</span></span><span style="display:flex;"><span> ...
</span></span><span style="display:flex;"><span> auto value = func();
</span></span></code></pre></div><p>因为 auto 会移除表达式类型的引用属性，那么此时以上最后一行的行为就是拷贝构造一MyBigData实例，相信这不是此函数的实现者希望的。</p>
<ul>
<li>注意：在引用类型、const 等类型上使用 auto 时要小心。</li>
</ul>
<h3 id="c-引用">C++ 引用 <a href="#c-%e5%bc%95%e7%94%a8" class="anchor">🔗</a></h3><p>参数传递：注意值传递和引用传递的区别。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>#include &lt;iostream&gt;
</span></span><span style="display:flex;"><span>using namespace std;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>void fun(int &amp;k) {
</span></span><span style="display:flex;"><span>  k = 2;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>int main() {
</span></span><span style="display:flex;"><span>  int a = 1;
</span></span><span style="display:flex;"><span>  fun(a);
</span></span><span style="display:flex;"><span>  cout &lt;&lt; a &lt;&lt; endl;
</span></span><span style="display:flex;"><span>  return 0;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="新的-for-循环c-11">新的 for 循环（C++ 11） <a href="#%e6%96%b0%e7%9a%84-for-%e5%be%aa%e7%8e%afc-11" class="anchor">🔗</a></h3><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>int arr[5] = {1, 2, 3, 4, 5};
</span></span><span style="display:flex;"><span>for (int x : arr) {
</span></span><span style="display:flex;"><span>  x += 100;
</span></span><span style="display:flex;"><span>  cout &lt;&lt; x &lt;&lt; &#39; &#39;;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>cout &lt;&lt; arr[0];
</span></span></code></pre></div><ul>
<li>arr 到 x 是值传递，可以用 int &amp;x，或者 auto &amp;</li>
</ul>
<h3 id="lambdac">lambda（C++） <a href="#lambdac" class="anchor">🔗</a></h3><p>定义一个匿名函数，还可以捕获外部一定范围内的变量。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>auto f1 = [](int a, int b) -&gt; int{return a + b; };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>auto f2 = [](auto a, auto b) -&gt; auto{return a + b; };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//编译器就根据 return 语句自动推导出返回值类型。
</span></span><span style="display:flex;"><span>auto f3 = [](auto a, auto b){return a + b; };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>int c = 9;
</span></span><span style="display:flex;"><span>//按值捕获 c 变量，同时不捕获其他变量。
</span></span><span style="display:flex;"><span>auto f4 = [c](auto a, auto b){return a + b + c; };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//捕获外部作用域中所有变量（按值捕获）
</span></span><span style="display:flex;"><span>auto f5 = [=](auto a, auto b){return a + b + c; };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>cout &lt;&lt; f1(1, 2) &lt;&lt; endl;
</span></span></code></pre></div><h3 id="类型转换c">类型转换（C++） <a href="#%e7%b1%bb%e5%9e%8b%e8%bd%ac%e6%8d%a2c" class="anchor">🔗</a></h3><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>  int k;
</span></span><span style="display:flex;"><span>  k = 3.14;//在 Java 中会报错，在 C/C++ 编译器中正常（k==3）。
</span></span></code></pre></div><ul>
<li>Java 对类型转换更严格。</li>
<li>C/C++ 编译器给了程序员太多自由：编译器认为，程序员可以这样写，程序员应该知道他在干什么，也应该为自己的行为负责。</li>
</ul>
<h3 id="指针引用java">指针？引用（Java） <a href="#%e6%8c%87%e9%92%88%e5%bc%95%e7%94%a8java" class="anchor">🔗</a></h3><p>Java：基本数据类型（int、long等）、引用数据类型（数组、类、接口）。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>Student zs = new Student();     //Java，引用
</span></span><span style="display:flex;"><span>Student *pzs = new Student();   //c++，指针
</span></span></code></pre></div><ul>
<li>实质是一样的。</li>
<li>要注意 Java 中的值传递和引用传递问题，实质上 Java 还是值传递的，只不过对于引用数据类型时，值的内容是它的引用（指针）。</li>
</ul>
<h3 id="for-循环java">for 循环（Java） <a href="#for-%e5%be%aa%e7%8e%afjava" class="anchor">🔗</a></h3><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>int[] arr = new int[10];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>for (int temp : arr) {
</span></span><span style="display:flex;"><span>    temp++;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>for (Student s : ss) {
</span></span><span style="display:flex;"><span>  s.changeSomething();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="lamdajava">lamda（Java） <a href="#lamdajava" class="anchor">🔗</a></h3><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>(parameters) -&gt; expression
</span></span><span style="display:flex;"><span>或
</span></span><span style="display:flex;"><span>(parameters) -&gt;{ statements; }
</span></span></code></pre></div><ul>
<li>Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>// 1. 不需要参数,返回值为 5  
</span></span><span style="display:flex;"><span>() -&gt; 5  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>// 2. 接收一个参数(数字类型),返回其2倍的值  
</span></span><span style="display:flex;"><span>x -&gt; 2 * x  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>// 3. 接受2个参数(数字),并返回他们的差值  
</span></span><span style="display:flex;"><span>(x, y) -&gt; x – y  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>// 4. 接收2个int型整数,返回他们的和  
</span></span><span style="display:flex;"><span>(int x, int y) -&gt; x + y  
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>// 5. 接受一个 string 对象,并在控制台打印,不返回任何值(看起来像是返回void)  
</span></span><span style="display:flex;"><span>(String s) -&gt; System.out.print(s)
</span></span></code></pre></div><h3 id="理解封装">理解封装 <a href="#%e7%90%86%e8%a7%a3%e5%b0%81%e8%a3%85" class="anchor">🔗</a></h3><ul>
<li>类：某一类东西</li>
<li>对象：某类东西的实例</li>
<li>“封”：数据 + 操作
<ul>
<li>成员：成员变量、成员函数</li>
<li>属性，方法（服务）</li>
</ul>
</li>
<li>“装”：访问控制
<ul>
<li>public/protected/private/&hellip;</li>
</ul>
</li>
</ul>
<h3 id="构造和析构c">构造和析构（C++） <a href="#%e6%9e%84%e9%80%a0%e5%92%8c%e6%9e%90%e6%9e%84c" class="anchor">🔗</a></h3><ul>
<li>构造函数、析构函数</li>
<li>初始化列表
<ul>
<li>在构造函数中用初始化列表的方式对成员变量进行初始化，效率会更高，因为只进行构造，少了一次赋值。</li>
<li>成员变量的初始化顺序与初始化列表中列出的变量的顺序无关，它只与成员变量在类中声明的顺序有关。</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>#include &lt;iostream&gt;
</span></span><span style="display:flex;"><span>using namespace std;
</span></span><span style="display:flex;"><span>class Note {
</span></span><span style="display:flex;"><span>public:
</span></span><span style="display:flex;"><span>  int nid;
</span></span><span style="display:flex;"><span>  Note(int id) :nid(id) {}
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>class Student {
</span></span><span style="display:flex;"><span>private:
</span></span><span style="display:flex;"><span>  int sid;
</span></span><span style="display:flex;"><span>  string name;
</span></span><span style="display:flex;"><span>  Note nt;
</span></span><span style="display:flex;"><span>public:
</span></span><span style="display:flex;"><span>  Student(int sid, string name, int id) : sid(sid), name(name), nt(id) {//初始化列表，进行初始化构造
</span></span><span style="display:flex;"><span>    //写在这里的只能是赋值
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="对象的复制c">对象的复制（C++） <a href="#%e5%af%b9%e8%b1%a1%e7%9a%84%e5%a4%8d%e5%88%b6c" class="anchor">🔗</a></h3><ul>
<li>注意浅拷贝、深拷贝。</li>
<li>默认生成的赋值函数、拷贝构造函数都是浅拷贝（值拷贝），成员变量中有指针变量时，需要自己重写（深拷贝）。</li>
</ul>
<h3 id="java-类-与c不同">Java 类-与C++不同 <a href="#java-%e7%b1%bb-%e4%b8%8ec%e4%b8%8d%e5%90%8c" class="anchor">🔗</a></h3><ul>
<li>没有析构</li>
<li>不支持默认参数</li>
<li>显示构造</li>
</ul>
<h3 id="对象的复制java">对象的复制（Java） <a href="#%e5%af%b9%e8%b1%a1%e7%9a%84%e5%a4%8d%e5%88%b6java" class="anchor">🔗</a></h3><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>Array a = new Array();
</span></span><span style="display:flex;"><span>Array b = a;
</span></span></code></pre></div><p>其实是引用的复制。</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>Array b = new Array(a);
</span></span></code></pre></div><p>对象的复制（返回新对象的引用）</p>
<h3 id="理解继承">理解“继承” <a href="#%e7%90%86%e8%a7%a3%e7%bb%a7%e6%89%bf" class="anchor">🔗</a></h3><ul>
<li>目的：代码复用</li>
<li>代码复用：
<ul>
<li>组合（has-a）：窗口、按钮、文本框</li>
<li>继承（is-a）：人（id、姓名、性别）、学生（id、姓名、性别、学号）、教师（id、姓名、性别、教师号）</li>
</ul>
</li>
</ul>
<h3 id="c-的继承和java-的继承区别">C++ 的继承和Java 的继承区别 <a href="#c-%e7%9a%84%e7%bb%a7%e6%89%bf%e5%92%8cjava-%e7%9a%84%e7%bb%a7%e6%89%bf%e5%8c%ba%e5%88%ab" class="anchor">🔗</a></h3><ul>
<li>C++ 可以多继承</li>
<li>Java 单继承</li>
</ul>
<h3 id="多态-需求是什么">多态-需求是什么 <a href="#%e5%a4%9a%e6%80%81-%e9%9c%80%e6%b1%82%e6%98%af%e4%bb%80%e4%b9%88" class="anchor">🔗</a></h3><p>多态：指为不同数据类型的实体提供统一的接口。</p>
<p>是否有需要使用基类指针（引用）指向（引向）派生类对象？</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>class People {
</span></span><span style="display:flex;"><span>public:
</span></span><span style="display:flex;"><span>  void say() {
</span></span><span style="display:flex;"><span>    cout &lt;&lt; &#34;I &#39;m a person!&#34; &lt;&lt; endl;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>class Student : public People {
</span></span><span style="display:flex;"><span>public:
</span></span><span style="display:flex;"><span>  void say() {
</span></span><span style="display:flex;"><span>    cout &lt;&lt; &#34;I&#39;m a student!&#34; &lt;&lt; endl;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>int main() {
</span></span><span style="display:flex;"><span>  People *zs = new Student();
</span></span><span style="display:flex;"><span>  zs-&gt;say();
</span></span><span style="display:flex;"><span>  return 0;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>这不是真需求，应该用 Student 指针，甚至是 Student 对象。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>class People {
</span></span><span style="display:flex;"><span>public:
</span></span><span style="display:flex;"><span>  void say() {}
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>class Student : public People {
</span></span><span style="display:flex;"><span>public:
</span></span><span style="display:flex;"><span>  void say() {}
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>class Teacher : public People {
</span></span><span style="display:flex;"><span>public:
</span></span><span style="display:flex;"><span>  void say() {}
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>void func(People *zs) { zs-&gt;say(); }
</span></span><span style="display:flex;"><span>int main() {
</span></span><span style="display:flex;"><span>  Student zs;
</span></span><span style="display:flex;"><span>  Teacher ls;
</span></span><span style="display:flex;"><span>  func(&amp;zs);
</span></span><span style="display:flex;"><span>  func(&amp;ls);
</span></span><span style="display:flex;"><span>  return 0;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>拿不同的派生类的对象干同一件事</li>
<li>func() 和具体的派生类型没关系。</li>
<li>用相同形式的东西（指针或引用），在具体调用的时候去执行不同对象或实体的行为</li>
<li>动态联编：编译时不确定，运行时才确定。</li>
</ul>
<h3 id="qt-隐式共享">Qt 隐式共享 <a href="#qt-%e9%9a%90%e5%bc%8f%e5%85%b1%e4%ba%ab" class="anchor">🔗</a></h3><ul>
<li>Qt 中的许多 C++ 类使用隐式数据共享来最大化资源使用并最小化复制。</li>
<li>当作为参数传递时，隐式共享类既安全又高效，因为只有一个指向数据的指针被传递，并且只有当函数写入数据时才会复制数据，即copy-on-write。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>QPixmap p1, p2;
</span></span><span style="display:flex;"><span>p1.load(&#34;image.bmp&#34;);
</span></span><span style="display:flex;"><span>p2 = p1;                        // p1 and p2 share data
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>QPainter paint;
</span></span><span style="display:flex;"><span>paint.begin(&amp;p2);               // cuts p2 loose from p1
</span></span><span style="display:flex;"><span>paint.drawText(0,50, &#34;Hi&#34;);
</span></span><span style="display:flex;"><span>paint.end();
</span></span></code></pre></div><ul>
<li>
<p>隐式共享对象的对象分配（使用 operator=()）是使用浅拷贝实现的。</p>
</li>
<li>
<p>隐式共享大多发生在幕后；程序员很少需要担心它。但是，Qt 的容器迭代器与 STL 的容器迭代器具有不同的行为。</p>
</li>
<li>
<p>Qt doc：https://doc.qt.io/qt-6/implicit-sharing.html</p>
</li>
</ul>
<h3 id="qlist">QList <a href="#qlist" class="anchor">🔗</a></h3><ul>
<li>
<p>QList 类是提供动态数组的模板类。该类中的所有函数都是可重入的(可以由多个线程同时调用)。另外两个常用的顺序容器 QStack 和 QQueue 继承自 Qlist。</p>
</li>
<li>
<p>对于大多数应用程序， QList 是最好使用的类型。 它提供了非常快速的追加。 如果你真的需要一个链表，使用 std::list。</p>
</li>
</ul>
<h3 id="qt-元对象系统">Qt 元对象系统 <a href="#qt-%e5%85%83%e5%af%b9%e8%b1%a1%e7%b3%bb%e7%bb%9f" class="anchor">🔗</a></h3><p>Qt 的元对象系统为对象间通信、运行时类型信息和动态属性系统提供了信号和槽机制。</p>
<ul>
<li>
<p>QObject 类为可以利用元对象系统的对象提供基类 。</p>
</li>
<li>
<p>Q_OBJECT 宏用于启用元对象功能，例如动态属性、信号和插槽。</p>
</li>
<li>
<p>元对象编译器(moc)为每个 QObject 子类提供实现元对象功能所需的代码。</p>
</li>
</ul>
<ul>
<li>这 moc工具读取 C++ 源文件。 类声明 Q_OBJECT ，它会生成另一个 C++ 源文件，其中包含每个这些类的元对象代码。 这个生成的源文件是 #include 到类的源文件中，或者更常见的是，编译并链接到类的实现中。</li>
</ul>
<ul>
<li>
<p>Qt 对象应该被视为身份，而不是值。 因此，QObject和所有子类都禁用了拷贝构造函数和赋值操作符。</p>
</li>
<li>
<p>为了方便内存管理，QObject 的构造函数中会传入一个 Parent 父对象指针，当父对象析构的时候，这个子对象列表中的所有对象都会被析构，当析构子对象的时候，会自动从父对象的子对象列表中删除。</p>
</li>
<li>
<p>这种机制在 GUI 程序开发过程中是相当实用的。有一个很明显的现象就是我们会在窗口中new很多控件，但是却没有delete，因为在父控件销毁时这些子控件以及布局管理器对象会一并销毁。</p>
</li>
<li>
<p>C++中规定了析构顺序应该按照其创建顺序的相反过程。</p>
</li>
<li>
<p>先创建父对象再创建子类对象，并且在创建子对象时就指定父对象；</p>
</li>
</ul>
<h3 id="qt-跨平台和-java-跨平台">Qt 跨平台和 Java 跨平台 <a href="#qt-%e8%b7%a8%e5%b9%b3%e5%8f%b0%e5%92%8c-java-%e8%b7%a8%e5%b9%b3%e5%8f%b0" class="anchor">🔗</a></h3><ul>
<li>
<p>Qt 允许我们编写独立于平台的代码，其中相同的代码库可以在不同平台上编译和部署，而无需任何更改（理想状态）。</p>
</li>
<li>
<p>Java 运行在虚拟机上。</p>
</li>
<li>
<p>Java：在虚拟机上 一次编译到处运行，但虚拟机是平台各异的，执行代码格式统一。</p>
</li>
<li>
<p>Qt 程序的运行是建立在 Qt 框架上的，一次编码到处编译，但框架是平台各异的，编程接口统一。</p>
</li>
<li>
<p>java也为此付出了运行效率的代价。因为一般程序直接通过操作系统由 CPU 执行，而 java 语言需要先通过 JVM 再映射到操作系统里，最后由 CPU 执行，执行过程多了一步。</p>
</li>
<li>
<p>Qt平台并没有使用类似 JVM 的明显抽象层（但是原理类似，它底层封装了针对不同平台的类库，API之类的，只是这些都被上层做了封装，对开发者来说操作各种平台的接口都是一样的），因此在框架开发过程中处理各种平台问题的复杂性要超过java。</p>
</li>
</ul>

    </div>

    
    
    


<script src="https://utteranc.es/client.js"
repo=""
issue-term=""
theme=""
crossorigin="anonymous"
async>
</script>





</section>


    </main>
    
    <footer id="footer">
    

    <div class="copyright">
    
       © Copyright 
       2022 
       <span class="split">
        <svg fill="#bbbbbb" width="15" height="15" version="1.1" id="heart-15" xmlns="http://www.w3.org/2000/svg" width="15px" height="15px" viewBox="0 0 15 15">
  <path d="M13.91,6.75c-1.17,2.25-4.3,5.31-6.07,6.94c-0.1903,0.1718-0.4797,0.1718-0.67,0C5.39,12.06,2.26,9,1.09,6.75&#xA;&#x9;C-1.48,1.8,5-1.5,7.5,3.45C10-1.5,16.48,1.8,13.91,6.75z"/>
</svg>
       </span>
       罗泽勋
    
    </div>

    
</footer>



  </body>
</html>
