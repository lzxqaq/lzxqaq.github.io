<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Zexun Luo | 罗泽勋</title>
    <link>/posts/</link>
    <description>Recent content on Zexun Luo | 罗泽勋</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Fri, 15 Apr 2022 14:05:59 +0800</lastBuildDate><atom:link href="/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Qt 实现数据持久化框架</title>
      <link>/posts/orm/</link>
      <pubDate>Fri, 15 Apr 2022 14:05:59 +0800</pubDate>
      
      <guid>/posts/orm/</guid>
      <description>项目大量使用数据库，如何简化数据库操作？直接上 ORM 可能会影响性能，而且也不够灵活，而且 Qt 的 ORM 框架也并不多。不过好消息是，由于 Qt 元对象系统提供的反射功能，我们可以轻松地封装一个数据持久化框架。
源码和使用可以查看我的Qt 开发脚手架。
该框架的实现思路参考 MyBatis，利用 Qt 的元对象系统（属性宏）将数据库字段与实体类字段映射，将 SQL 语句放到XML配置文件中，封装了常见的增删改查接口，并使用一个数据库连接池管理数据库的连接。并且，制作使用一个代码生成器，生成 SQL 文件、实体类、持久层、服务层文件。
于是，开发人员可以从常见的增删改查业务中解脱出来。</description>
    </item>
    
    <item>
      <title>Qt 实现 MVVM 框架</title>
      <link>/posts/mvvm/</link>
      <pubDate>Fri, 15 Apr 2022 13:44:37 +0800</pubDate>
      
      <guid>/posts/mvvm/</guid>
      <description>该 MVVM 框架主要用到了 Qt 元对象系统、信号槽连接管理、以及自己搭建的 Ioc 容器，核心源码及使用请看我的 Qt 开发脚手架中 MVVM 部分。
什么是 MVVM 🔗MVVM 即 Model-View-ViewModel，它本质上就是MVC 的改进版。MVVM 就是将其中的View 的状态和行为抽象化，让我们将视图 UI 和业务逻辑分开。当然这些事 ViewModel 已经帮我们做了，它可以取出 Model 的数据同时帮忙处理 View 中由于需要展示内容而涉及的业务逻辑。。
什么是 MVC 🔗 Model：数据模型，用来存储数据 View：视图界面，用来展示UI界面和响应用户交互 Controller：控制器(大管家角色)，监听模型数据的改变和控制视图行为、处理用户交互  为什么是 MVVM 🔗在 MVC 开发模式中，由于Controller主要用来处理各种逻辑和数据转化，复杂业务逻辑界面的Controller非常庞大，维护困难，所以有人想到把Controller的数据和逻辑处理部分从中抽离出来，用一个专门的对象去管理，这个对象就是ViewModel，是Model和View之间的一座桥梁。
优点 🔗1.逻辑清晰： ViewModel分离了大部分Controller代码，更加清晰和容易维护。 2.方便测试：开发中大部分Bug来至于逻辑处理，由于ViewModel分离了许多逻辑，可以对ViewModel构造单元测试。 3.开发解耦。 4.逻辑清晰。</description>
    </item>
    
    <item>
      <title>Qt 实现控制反转（IoC） </title>
      <link>/posts/ioc/</link>
      <pubDate>Fri, 15 Apr 2022 11:38:11 +0800</pubDate>
      
      <guid>/posts/ioc/</guid>
      <description>之前在 Github 中找到一个 Qt 的 IoC 库 QtDependencyResolver，原理是基于 Qt 的元对象系统，使用反射方法进行构造函数注入。
我在它的基础上进行了一些功能扩展。放到了我的 Qt 开发脚手架上。
什么是 IoC 🔗IoC全称Inversion of Control，直译为控制反转。IoC 又称为依赖注入（DI：Dependency Injection），它解决了一个最主要的问题：将组件的创建+配置与组件的使用相分离，并且，由IoC容器负责管理组件的生命周期。
为什么要 Ioc 🔗在传统应用程序中，如果一个系统有大量的组件，其生命周期和相互之间的依赖关系如果由组件自身来维护，不但大大增加了系统的复杂度，而且会导致组件之间极为紧密的耦合，继而给测试和维护带来了极大的困难。
核心问题是：
 谁负责创建组件？ 谁负责根据依赖关系组装组件？ 销毁时，如何按依赖顺序正确销毁？  解决这一问题的核心方案就是IoC。
在IoC模式下，控制权发生了反转，即从应用程序转移到了IoC容器，所有组件不再由应用程序自己创建和配置，而是由IoC容器负责，这样，应用程序只需要直接使用已经创建好并且配置好的组件。为了能让组件在IoC容器中被“装配”出来，需要某种“注入”机制。</description>
    </item>
    
    <item>
      <title>Qt 信号槽与观察者模式</title>
      <link>/posts/2022-4-14/</link>
      <pubDate>Thu, 14 Apr 2022 15:05:13 +0800</pubDate>
      
      <guid>/posts/2022-4-14/</guid>
      <description>介绍 🔗在 GUI 编程中，当我们更改一个小部件时，我们经常希望通知另一个小部件。 更一般地说，我们希望任何类型的对象都能够相互通信。 例如，如果用户单击 关闭 窗口的 close() 调用.
其他工具包使用回调实现这种通信。 回调是指向函数的指针，因此如果您希望处理函数通知您某个事件，您可以将指向另一个函数（回调）的指针传递给处理函数。 然后，处理函数会在适当的时候调用回调。 虽然确实存在使用此方法的成功框架，但回调可能不直观，并且可能在确保回调参数的类型正确性方面遇到问题。
信号和插槽 🔗在 Qt 中，我们有一个回调技术的替代方案：我们使用信号和槽。 当特定事件发生时会发出信号。 Qt 的小部件有许多预定义的信号，但我们总是可以子类化小部件以向它们添加我们自己的信号。 插槽是响应特定信号而调用的函数。 Qt 的小部件有许多预定义的插槽，但通常的做法是子类化小部件并添加自己的插槽，以便您可以处理您感兴趣的信号。
继承的所有类都 QObject 或其子类之一（例如 QWidget 可以包含信号和槽。 当对象以可能对其他对象感兴趣的方式改变其状态时，信号由对象发出。 这就是对象进行通信的全部内容。 它不知道也不关心是否有任何东西在接收它发出的信号。 这是真正的信息封装，并确保对象可以用作软件组件。
与回调相比，信号和槽的速度稍慢，因为它们提供了更高的灵活性，尽管对于实际应用程序的差异并不显着。 一般来说，发出一个连接到某些槽的信号，比直接调用接收器慢大约十倍，使用非虚拟函数调用。 这是定位连接对象、安全地迭代所有连接（即检查后续接收器在发射期间是否被破坏）以及以通用方式编组任何参数所需的开销。 虽然十个非虚拟函数调用听起来很多，但它的开销比任何一个都少得多 new或者 delete操作，例如。 只要您执行幕后需要的字符串、向量或列表操作 new或者 delete，信号和槽的开销只占整个函数调用成本的很小一部分。 每当您在插槽中进行系统调用时，都是如此。 或者间接调用十多个函数。 信号和槽机制的简单性和灵活性非常值得您的用户甚至不会注意到的开销。
观察者模式 🔗观察者模式定义了一对多的依赖关系，当一个对象改变时，它的所有依赖者都会收到通知并自动更新。类似很多人订阅了一个公众号，一旦公众号发送消息，订阅的人都会收到消息。
经典的观察者模式在讲解举例的时候通常会举报纸和订阅者的例子。有一个报纸Newspaper，有一个订阅者类Subscriber。Subscriber可以订阅Newspaper。这样，当Newspaper有了新的内容的时候，Subscriber可以立即得到通知。在这个例子中，观察者是Subscriber，被观察者是Newspaper。在经典的实现代码中，观察者会将自身注册到被观察者的一个容器中。被观察者发生了任何变化的时候，会主动遍历这个容器，依次通知各个观察者。</description>
    </item>
    
    <item>
      <title>PImpl 机制和 Qt 的实现 D-Pointer</title>
      <link>/posts/2022-4-14-dpoint/</link>
      <pubDate>Thu, 14 Apr 2022 12:26:14 +0800</pubDate>
      
      <guid>/posts/2022-4-14-dpoint/</guid>
      <description>一、什么是 PImpl 🔗PImpl是 Pointer to implementation的缩写， 是C++ 在构建导出库接口时特有的技术手段。 即是将类Class中所有私有变量以及私有方法，封装在一单独的实现类ClassImpl中。我们在Class中通过一指向ClassImpl的私有指针，访问这些私有数据。而ClassImpl类的具体定义和实现，我们放入cpp中。
二、什么是 D-Pointer 🔗如果你曾经看过 Qt 的源代码，你会看到很多 Q_D 和 Q_Q 宏。Q_D 和 Q_Q 宏定义是 d-pointer，它可以把一个类库的实施细节对使用的用户隐藏， 而且对实施的更改不会打破二进制兼容。Qt中的 D-Pointer 技术，便是 PImpl 机制的一种实现方式。
三、为什么会产生二进制兼容问题 🔗究其原因，通过添加了一个新的数据成员，我们最终改变了类对象的大小。为什么会这样？因为当你的C+编译器生成代码的时候，他会用偏移量来访问对象的数据。
四、不要改变导出的 C++ 类的大小 🔗总之，一旦你的类库发布了，永远不要改变 导出的 C++ 类的大小或者布局（不要移动成员）。C++ 编译器生成的代码会假定，一个类的大小和成员的顺序 编译后 就不会改变.
那么，如何在不改变对象的大小的同时添加新的功能呢？
五、d-pointer 🔗诀窍是通过保存唯一的一个指针而保持一个类库所有公共类的大小不变。这个指针指向一个包含所有数据的私有的（内部的）数据结构。内部结构的大小可以增大或者减小，而不会对应用程序带来副作用，因为指针只会被类库里面的代码访问，从应用程序的视角来看，对象的大小并没有改变 - 它永远是指针的大小。 这个指针被叫做 d-pointer 。
六、d-pointer 的其它好处 🔗这里不全都是和二进制兼容有关。d-pointer 还有其它的好处： 隐藏了实现细节 - 我们可以只发布带有头文件和二进制文件的 WidgetLib。源文件可以是闭源代码的。
头文件很干净，不包含实现细节，可以直接作为 API 参考。由于实施需要的包含的头文件从头文件里已到了实施（源文件）里面，编译速更快。（译：降低了编译依赖） 事实上，上边的好处是微乎其微的。Qt 使用 d-pointer 的真正原因是为了二进制兼容。
七、Qt 中的 d-pointers 🔗在 Qt 中，几乎所有的公有类都使用了 d-pointer。唯一不用的情况是如果事先知道某个类永远不会添加额外的成员变量。例如，像 QPoint, QRect 这些类，我们不期望有新的成员添加，因此它们的数据成员直接保存在类里而没用 d-pointer。</description>
    </item>
    
    <item>
      <title>C&#43;&#43; 动态库的二进制兼容性问题</title>
      <link>/posts/2022-4-13/</link>
      <pubDate>Wed, 13 Apr 2022 12:26:14 +0800</pubDate>
      
      <guid>/posts/2022-4-13/</guid>
      <description>一、定义 🔗  二进制兼容：在升级库文件的时候，不必重新编译使用此库的可执行文件或其他库文件，并且程序的功能不被破坏。
  源码兼容：在升级库文件的时候，不必修改使用此库的可执行文件或其他库文件的源代码，只需重新编译应用程序，即可使程序的功能不被破坏。
  二进制兼容性可以解决很多麻烦，它会使为特定平台分发软件时变得更容易。 如果不能确保发行版之间的二进制兼容性，人们将不得不提供静态链接的二进制文件。 静态二进制文件很糟糕，因为它们
 浪费资源（尤其是内存） 程序不能从库的bug修复或功能扩展中受益  二、ABI 和 API 🔗 应用二进制接口（application binary interface，缩写为 ABI）描述了应用程序（或者其他类型）和操作系统之间或其他应用程序的低级接口。ABI涵盖了各种细节，如：数据类型的大小、布局和对齐；调用约定等。
 在了解二进制兼容和源码兼容两个定义以后，我们再看与其类似且对应的两个概念：ABI和API。ABI不同于API（应用程序接口），API定义了源代码和库之间的接口，因此同样的代码可以在支持这个API的任何系统中编译，然而ABI允许编译好的目标代码在使用兼容ABI的系统中无需改动就能运行。
举个例子，在Qt和Java两种跨平台程序中，API像是Qt的接口，Qt有着通用接口，源代码只需要在支持Qt的环境下编译即可。ABI更像是Jvm，只要支持Jvm的系统上，都可以运行已有的Java程序。
三、C++ 的 ABI 🔗ABI更像是一个产品的使用说明书，同理C++的ABI就是如何使用C++生成可执行程序的一张说明书。编译器会根据这个说明书，生成二进制代码。C++的ABI在不同的编译器下会略有不同。
C++ABI的部分内容举例：
 函数参数传递的方式，比如 x86-64 用寄存器来传函数的前 4 个整数参数 虚函数的调用方式，通常是 vptr/vtbl 然后用 vtbl[offset] 来调用 struct 和 class 的内存布局，通过偏移量来访问数据成员  综上所述，如果可执行程序通过以上说明书访问动态链接库A，以及此库的升级版本A+，若按此说明书上的方法，可以无痛的使用A和A+，那么我们就称库A的这次升级是二进制兼容的。
四、破坏二进制兼容的常见方式 🔗 添加新的虚函数 取消导出或删除已导出的类。 以任何方式更改类层次结构（添加，删除或重新排序基类）。 改变虚函数声明时的顺序（偏移量改变，导致调用失败） 添加新的非静态成员变量（类的内存布局改变，偏移量也发生变化） 改变非静态成员变量的声明顺序 以任何方式更改模板参数（添加，删除或重新排序）。  五、不会破坏二进制兼容的几种常见方式 🔗 添加非虚函数（包括构造函数） 添加新的类 添加Qt中的信号、槽 添加新的枚举或者在已存在的枚举类型中添加一个枚举值 添加新的静态成员变量 修改成员变量名称（偏移量未改变） 添加Q_OBJECT,Q_PROPERTY, Q_ENUMS ,Q_FLAGS宏，添加这些宏都是修改了moc生成的文件，而不是类本身 重新实现在类层次结构中原始基类定义的虚函数，如果程序链接到先前版本的库，且该库调用了基类中的实现而不是派生类中的实现，是安全的。这很棘手，可能很危险。三思而后行。 移除私有非虚函数，如果它们没有被任何内联函数调用过（并且从未使用过）。 移除私有静态成员变量，如果它们没有被任何内联函数调用过（并且从未使用过）。 更改方法的默认参数。但是，它需要重新编译才能使用实际的新的默认参数值。 导出以前未导出的类。 在类中添加或删除友元声明。  六、库程序员的技巧（解决二进制兼容问题） 🔗编写库时最大的问题是，不能安全地添加数据成员，因为这会改变每个class类，struct结构，或者对象类型数组的大小和布局。</description>
    </item>
    
    <item>
      <title>C&#43;&#43; STL 排序</title>
      <link>/posts/2022-4-12-sort/</link>
      <pubDate>Tue, 12 Apr 2022 12:26:14 +0800</pubDate>
      
      <guid>/posts/2022-4-12-sort/</guid>
      <description>日常开发中经常会有排序需求，常见的方法有很多种：选择排序，冒泡排序，归并排序，快速排序等，那我们需要手写排序算法吗？大多数场景下用现成的库函数就够了。STL 的 std::sort 是用得最多的排序算法。
STL的std::sort函数是基于Musser在1996年提出的内省排序（Introspective sort）算法实现。这个算法是个缝合怪，它汲取了插入排序、堆排序以及快排的优点：
 针对大数据量，使用快排，时间复杂度是O(NlogN)； 若快排递归深度超过阈值__depth_limit ，改用堆排序，防止快排递归过深，同时保持时间复杂度仍是O(NlogN)； 当数据规模小于阈值_S_threshold时，改用插入排序。  在 Qt 6 之前，Qt 容器有专门的排序函数 qSort，在 Qt 6 中已经放弃了该函数，取而代之的是 std::sort，两者的用法是一致的。
示例：
bool caseInsensitiveLessThan(const QString &amp;amp;s1, const QString &amp;amp;s2) {  return s1.toLower() &amp;lt; s2.toLower(); //从小到大排序 }  int doSomething() {  QStringList list;  list &amp;lt;&amp;lt; &amp;#34;AlPha&amp;#34; &amp;lt;&amp;lt; &amp;#34;beTA&amp;#34; &amp;lt;&amp;lt; &amp;#34;gamma&amp;#34; &amp;lt;&amp;lt; &amp;#34;DELTA&amp;#34;;  qSort(list.begin(), list.end(), caseInsensitiveLessThan);  // list: [ &amp;#34;AlPha&amp;#34;, &amp;#34;beTA&amp;#34;, &amp;#34;DELTA&amp;#34;, &amp;#34;gamma&amp;#34; ] } </description>
    </item>
    
    <item>
      <title>落后就要挨打吗</title>
      <link>/posts/2022-4-2/</link>
      <pubDate>Sat, 02 Apr 2022 12:34:49 +0800</pubDate>
      
      <guid>/posts/2022-4-2/</guid>
      <description>今天下班回家的路上，我走在一条十字路口的斑马线上，一辆车从后方疾驰而来，在离我不到半米的地方刹停了。急促的喇叭声中，我看向了这辆想转弯到我左边的车，才意识到我又躲过一劫。司机透过车窗看着我，我们对视了一两秒。看着他淡然的眼神，我什么没说，随后他开车离开了。
类似的事情半年前也发生过一次，甚至更为严重。当时是在单位园区里的小道上，我正骑单车上班。当我快骑到一个 T 字形岔路时，我的正前方迎面而来有一辆小车。我发觉它几乎压中间那条线了，有要转弯到右边路口的意思，但我没有停。因为我已经到这个岔路口了，而它还有好一段距离，而且我是直行的，也没有让行的道理。结果，对方猛地加速了，直接压到我这边的车道逆行抢道转弯，我立马急刹，猛摆车头，就差那么一点，我就没了。我惊魂未定，吼了它一声：“怎么开车的”， 结果这车头也没回，直接就走了。那时我满腔怒火，脑海里就一个声音：“怎么能这样？！”因为我这血肉之躯敌不过钢铁锻造的汽车，所以我就理应退让吗？拳头大就是真理吗？
未成年人的力量比不过成年人，女性的力量比不过男性，个体的力量比不过集体，弱小的国家的力量比不过强大的国家，所以就要挨打了吗？是这样吗？
我想不明白。我知道中国是有法律条文规矩的，但我也清楚中国人最喜欢讲“通融”，讲“人情世故”。但什么是对？什么是错？落后就要挨打吗？按这样的逻辑，强大就可以打别人了？什么时候，真理也要讲国情，讲特色化了？
我知道现实便是如此，人只要自己开心活着就好嘛。但我还是想提醒一句，别吃太胖了哦，会被吃掉的。</description>
    </item>
    
    <item>
      <title>认知世界形势变化</title>
      <link>/posts/2022-3-20/</link>
      <pubDate>Sun, 20 Mar 2022 10:13:40 +0800</pubDate>
      
      <guid>/posts/2022-3-20/</guid>
      <description> 人类同胞们，
我来此召集你们，是要你们了解目前的形势。
每个人都应该意识到我们此时所遭受的危机，
我们彼此互相争斗，
为了共和历史的微小冲突而被分散。
现在，更大的危险正向我们靠近。
这股威胁将会毁灭我们的所有成就……
—— 阿克图拉斯一世
 现在，战争、疾病、贫穷、压迫等话题再次进入世界舆论中心。在纷争、嘈杂的社会环境中，我们如何认识世界，并在其中找到自己？
现代文明是集统治、科技、文化、宗教的复杂混合体，我们很难对每一方面都有足够的认知。但现代文明是人类的文明，我们可以从自身的角度出发，认识世界的全貌。审视自身，残忍、虚伪、傲慢、背叛和厌世等等人之恶无一不在，但我知道，我们绝不仅有这些，善良、追求美好也一直存在。同样，现在世界不乏纷争、歧视等阴暗，但同时也在追求和平、发展。人不是生来如此的，我们需要不断学习，世界也不是向来如此的。让人类从蛮荒中走向文明，我们现在赖以生存的基础，不是由一个神、一个党派、一个政府建立的，而是由一个又一个人的努力。
 历史的潮流在不断变化，要是想到达旅途的终点，我们必须不断适应，勇往直前。
  人类的天性就是不断地推动自己越过新的边界。我们考验自身的极限，我们直面自己的恐惧，我们奋起迎接挑战，最终成为远超我们自身的存在。
 </description>
    </item>
    
    <item>
      <title>在路的尽头，你会找到你自己</title>
      <link>/posts/2022-3-17/</link>
      <pubDate>Wed, 16 Mar 2022 23:38:01 +0800</pubDate>
      
      <guid>/posts/2022-3-17/</guid>
      <description>最近时常回忆起以前的事情，并且想用文字记下一些东西的念头越来越强烈。
回首往昔，能记起来的事却少之又少，其中多数藏在脑海深处久矣。二十多年的人生，好似极其漫长，又一览无余。现在，该和自己和解了，把一切收拾好，行动起来！</description>
    </item>
    
    <item>
      <title>Linux Socket 编程（不限 Linux）</title>
      <link>/posts/linuxsocket/</link>
      <pubDate>Mon, 07 Mar 2022 18:43:02 +0800</pubDate>
      
      <guid>/posts/linuxsocket/</guid>
      <description>作者：吴秦
出处：(http://www.cnblogs.com/skynet/)
1、网络中进程之间如何通信？ 🔗本地的进程间通信（IPC）有很多种方式，但可以总结为下面4类：
 消息传递（管道、FIFO、消息队列） 同步（互斥量、条件变量、读写锁、文件和写记录锁、信号量） 共享内存（匿名的和具名的） 远程过程调用（Solaris门和Sun RPC）  但这些都不是本文的主题！我们要讨论的是网络中进程之间如何通信？首要解决的问题是如何唯一标识一个进程，否则通信无从谈起！在本地可以通过进程PID来唯一标识一个进程，但是在网络中这是行不通的。其实TCP/IP协议族已经帮我们解决了这个问题，网络层的“ip地址”可以唯一标识网络中的主机，而传输层的“协议+端口”可以唯一标识主机中的应用程序（进程）。这样利用三元组（ip地址，协议，端口）就可以标识网络的进程了，网络中的进程通信就可以利用这个标志与其它进程进行交互。
使用TCP/IP协议的应用程序通常采用应用编程接口：UNIX BSD的套接字（socket）和UNIX System V的TLI（已经被淘汰），来实现网络进程之间的通信。就目前而言，几乎所有的应用程序都是采用socket，而现在又是网络时代，网络中进程通信是无处不在，这就是我为什么说“一切皆socket”。
2、什么是Socket？ 🔗上面我们已经知道网络中的进程是通过socket来通信的，那什么是socket呢？socket起源于Unix，而Unix/Linux基本哲学之一就是“一切皆文件”，都可以用“打开open –&amp;gt; 读写write/read –&amp;gt; 关闭close”模式来操作。我的理解就是Socket就是该模式的一个实现，socket即是一种特殊的文件，一些socket函数就是对其进行的操作（读/写IO、打开、关闭），这些函数我们在后面进行介绍。
 socket一词的起源 在组网领域的首次使用是在1970年2月12日发布的文献IETF RFC33中发现的，撰写者为Stephen Carr、Steve Crocker和Vint Cerf。根据美国计算机历史博物馆的记载，Croker写道：“命名空间的元素都可称为套接字接口。一个套接字接口构成一个连接的一端，而一个连接可完全由一对套接字接口规定。”计算机历史博物馆补充道：“这比BSD的套接字接口定义早了大约12年。”
 3、socket的基本操作 🔗既然socket是“open—write/read—close”模式的一种实现，那么socket就提供了这些操作对应的函数接口。下面以TCP为例，介绍几个基本的socket接口函数。
3.1、socket()函数 🔗int socket(int domain, int type, int protocol);
socket函数对应于普通文件的打开操作。普通文件的打开操作返回一个文件描述字，而socket()用于创建一个socket描述符（socket descriptor），它唯一标识一个socket。这个socket描述字跟文件描述字一样，后续的操作都有用到它，把它作为参数，通过它来进行一些读写操作。
正如可以给fopen的传入不同参数值，以打开不同的文件。创建socket的时候，也可以指定不同的参数创建不同的socket描述符，socket函数的三个参数分别为：
  domain：即协议域，又称为协议族（family）。常用的协议族有，AF_INET、AF_INET6、AF_LOCAL（或称AF_UNIX，Unix域socket）、AF_ROUTE等等。协议族决定了socket的地址类型，在通信中必须采用对应的地址，如AF_INET决定了要用ipv4地址（32位的）与端口号（16位的）的组合、AF_UNIX决定了要用一个绝对路径名作为地址。
  type：指定socket类型。常用的socket类型有，SOCK_STREAM、SOCK_DGRAM、SOCK_RAW、SOCK_PACKET、SOCK_SEQPACKET等等（socket的类型有哪些？）。
  protocol：故名思意，就是指定协议。常用的协议有，IPPROTO_TCP、IPPTOTO_UDP、IPPROTO_SCTP、IPPROTO_TIPC等，它们分别对应TCP传输协议、UDP传输协议、STCP传输协议、TIPC传输协议（这个协议我将会单独开篇讨论！）。
  注意：并不是上面的type和protocol可以随意组合的，如SOCK_STREAM不可以跟IPPROTO_UDP组合。当protocol为0时，会自动选择type类型对应的默认协议。
当我们调用socket创建一个socket时，返回的socket描述字它存在于协议族（address family，AF_XXX）空间中，但没有一个具体的地址。如果想要给它赋值一个地址，就必须调用bind()函数，否则就当调用connect()、listen()时系统会自动随机分配一个端口。
3.2、bind()函数 🔗正如上面所说bind()函数把一个地址族中的特定地址赋给socket。例如对应AF_INET、AF_INET6就是把一个ipv4或ipv6地址和端口号组合赋给socket。
int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen); 函数的三个参数分别为：
 sockfd：即socket描述字，它是通过socket()函数创建了，唯一标识一个socket。bind()函数就是将给这个描述字绑定一个名字。 addr：一个const struct sockaddr *指针，指向要绑定给sockfd的协议地址。这个地址结构根据地址创建socket时的地址协议族的不同而不同，如ipv4对应的是：  struct sockaddr_in {  sa_family_t sin_family; /* address family: AF_INET */  in_port_t sin_port; /* port in network byte order */  struct in_addr sin_addr; /* internet address */ };  /* Internet address.</description>
    </item>
    
    <item>
      <title>C&#43;&#43; 开发必备之网络编程</title>
      <link>/posts/networkpg/</link>
      <pubDate>Mon, 07 Mar 2022 18:38:17 +0800</pubDate>
      
      <guid>/posts/networkpg/</guid>
      <description>转载自https://github.com/huihut/interview
Socket 🔗 Linux Socket 编程（不限 Linux）
 Socket 中的 read()、write() 函数 🔗ssize_t read(int fd, void *buf, size_t count); ssize_t write(int fd, const void *buf, size_t count); read() 🔗 read 函数是负责从 fd 中读取内容。 当读成功时，read 返回实际所读的字节数。 如果返回的值是 0 表示已经读到文件的结束了，小于 0 表示出现了错误。 如果错误为 EINTR 说明读是由中断引起的；如果是 ECONNREST 表示网络连接出了问题。  write() 🔗 write 函数将 buf 中的 nbytes 字节内容写入文件描述符 fd。 成功时返回写的字节数。失败时返回 -1，并设置 errno 变量。 在网络程序中，当我们向套接字文件描述符写时有俩种可能。 （1）write 的返回值大于 0，表示写了部分或者是全部的数据。 （2）返回的值小于 0，此时出现了错误。 如果错误为 EINTR 表示在写的时候出现了中断错误；如果为 EPIPE 表示网络连接出现了问题（对方已经关闭了连接）。  Socket 中 TCP 的三次握手建立连接 🔗我们知道 TCP 建立连接要进行 “三次握手”，即交换三个分组。大致流程如下：</description>
    </item>
    
    <item>
      <title>从 Java 到 Qt/C&#43;&#43; 的一些经验总结</title>
      <link>/posts/java2c&#43;&#43;/</link>
      <pubDate>Mon, 07 Mar 2022 12:22:40 +0800</pubDate>
      
      <guid>/posts/java2c&#43;&#43;/</guid>
      <description>C/C++ 代码编译成可执行程序的过程 🔗  预处理
 进行宏定义展开、头文件展开、条件编译，不检查语法。 gcc -E demo1.c -o demo1.i    编译
 检查语法，将预处理过的文件编译生成汇编文件 gcc -S demo2.c -o demo2.s    汇编
 将汇编文件生成目标文件（二进制代码文件，即.o 文件） gcc -c demo3.c -o demo3.o    链接
 找到依赖的库文件，将目标文件链接为可执行程序。 gcc demo4.c -o demo4 -L./ -llib1 通过gcc编译器让 demo4 链接自己制作的 lib1 动态库，并把 demo4 编译成可执行程序。    Java 代码编译和执行的过程 🔗 源文件由编译器编译成字节码 字节码由 Java 虚拟机解释运行。因为 Java 程序既要编译同时也要经过 JVM 的解释运行，所以 Java 也被称为半解释语言。  静态和动态 🔗 静态：在编译（编译 + 链接）阶段 动态：在执行阶段  #include &amp;lt;stdio.</description>
    </item>
    
    <item>
      <title>Marp：使用 Markdown 创建漂亮的幻灯片</title>
      <link>/posts/2022-2-28-marp/</link>
      <pubDate>Mon, 28 Feb 2022 14:17:47 +0800</pubDate>
      
      <guid>/posts/2022-2-28-marp/</guid>
      <description>简介 🔗Marp（Markdown Presentation Ecosystem）为创建漂亮的幻灯片提供了直观的体验。 你只需要专注于在 Markdown 文档中写你的故事。
安装使用 🔗Marp 有两个集成应用，Marp for VS Code 和 Marp CLI。Marp for VS Code 是一个 VS Code 插件扩展，允许您在 VS Code 中编辑 Markdown 和预览幻灯片，Marp CLI 是一个命令行工具，允许您使用简单的 CLI 界面转换 Markdown。对普通用户而言，Marp for VS Code 已经足够了，本文只对其进行介绍。
安装：在 VS Code 左侧插件栏中搜索安装 Marp for VS Code 插件，同时你也可以选择再安装一个 Markdown All in One 插件，它有助于书写 Markdown。
使用：
方式1：新建或打开 md 格式文件，在开头写入：
--- marp: true --- 然后，在后面书写 Markdown 格式内容。
方式2：通过 VS Code 菜单：File -&amp;gt; New File&amp;hellip; -&amp;gt; Marp Markdown，生成新文件。</description>
    </item>
    
    <item>
      <title>《红发少女安妮——虔诚的承诺》</title>
      <link>/posts/2022-2-9/</link>
      <pubDate>Wed, 09 Feb 2022 19:45:15 +0800</pubDate>
      
      <guid>/posts/2022-2-9/</guid>
      <description>一 🔗 安妮：希望戴安娜会成为我的知心朋友，我一定会喜欢戴安娜的，而且我相信戴安娜她一定也会喜欢我的。因为今天晚上戴安娜家中的橙光，看起来是离我那么近。
 二 🔗 安妮：雨很快就会停了是不是，还是会一直下个不停呢？
  马修：你不用担心了，中午以前雨就会停了。
  安妮：马修，真的吗？
  玛莉娜：马修的天气预报蛮准的哟。
  安妮：谢谢老天爷。那我今天就可以去找戴安娜了。
  玛莉娜：是啊。不过必须过了下午茶时间，我们不能给人家添麻烦。
  安妮：嗯。
 三 🔗 玛莉娜：安妮，该出发了。
  玛莉娜：为什么换衣服？我们只是顺便去借做衣服的样版而已。
  安妮：可是……
  玛莉娜：快走吧，再拖下去天都黑了。
  玛莉娜：怎么回事啊？
  安妮：玛丽娜，我现在开始担心了。我担心万一，万一戴安娜她看到我，不喜欢我的话，那我该怎么办呢？那这将成为我这一辈子最大最大的失望。
  玛莉娜：用不着这么紧张。首先，我不希望你用这么一大串的形容词。小孩子用大人的口气说话，太奇怪了。你放心，戴安娜一定会很喜欢你的。不过重要的是她妈妈。如果她妈妈不喜欢你的话，就算戴安娜再喜欢你，那也没用的。如果她知道你对林德太太说粗话，还有你帽子的事，不知道对你有什么看法。你一定要有礼貌守规矩，别再发表你那惊人的言论了。你该不是在发抖吧……
  安妮：玛丽娜……如果你想要跟一个可能会成为你的好朋友的人见面，你一定也会很激动的。而且，她的妈妈要是不喜欢你的话，那该怎么办呢？
 四 🔗 贝瑞夫人：你好啊，玛丽娜，好久不见，快请进吧。我想那一位即是你领养的小女孩了。是不是呀。别站在那里，快点进来呀。
  玛莉娜：她是安妮·夏利。
  安妮：很高兴见到你，夫人。
  贝瑞夫人：你好啊。
  安妮：夫人，托您的福，我很好。虽然我现在的情绪有点紧张，贝瑞夫人。
  贝瑞夫人：快点进来吧。
  安妮：玛丽娜，我说的话不会夸张吧。</description>
    </item>
    
    <item>
      <title>我现在看清了我真正的敌人</title>
      <link>/posts/2022-2-5-5/</link>
      <pubDate>Sat, 05 Feb 2022 19:21:37 +0800</pubDate>
      
      <guid>/posts/2022-2-5-5/</guid>
      <description>前些天，我感觉我的世界崩塌了，可渐渐的，我的心平静了下来，那些一直一直困扰我的问题也随之解开。为了纪念自己进入“不惑”之年，我决定在此发表一段重要讲话：
 我现在看清了我真正的敌人。
他在虚空中等待着我，
拥有着我无法想象的力量……
为了对抗他，我放弃了所有的一切。
我的人性、
我的身份、
还有我爱的人。
但我不会独自去面对他的。
因为我即是 Artanis！
 来人，快把这个中二病拖走！
另外，最近疫情严重，不知各位看官身体是否安康？春节假期是否过得愉快？
话说不知道我这个网站有没有被 Github 沉进北极里，如果人类因疫情而遭受劫难，不知这些文字是否有重见天日的一天？想到这里，庆幸自己没有弄过于复杂的网页……</description>
    </item>
    
    <item>
      <title>水手</title>
      <link>/posts/2022-2-5-4/</link>
      <pubDate>Sat, 05 Feb 2022 19:21:20 +0800</pubDate>
      
      <guid>/posts/2022-2-5-4/</guid>
      <description>苦涩的沙 吹痛脸庞的感觉
  像父亲的责骂 母亲的哭泣 永远难忘记
  年少的我 喜欢一个人在海边
  卷起裤管 光着脚丫 踩在沙滩上
  总是幻想海洋的尽头有另一个世界
  总是以为勇敢的水手是真正的男儿
  总是一副弱不禁风孬种的样子
  在受人欺负的时候 总是听见水手说
  他说 风雨中 这点痛算什么
  擦干泪 不要怕
  至少我们还有梦
  他说 风雨中 这点痛算什么
  擦干泪 不要问 为什么
  长大以后 为了理想而努力
  渐渐的忽略了父亲母亲和故乡的消息
  如今的我 生活就像在演戏
  说着言不由衷的话 戴着伪善的面具
  总是拿着微不足道的成就来骗自己</description>
    </item>
    
    <item>
      <title>追梦赤子心</title>
      <link>/posts/2022-2-5-3/</link>
      <pubDate>Sat, 05 Feb 2022 19:21:18 +0800</pubDate>
      
      <guid>/posts/2022-2-5-3/</guid>
      <description>充满鲜花的世界到底在哪里
  如果它真的存在那么我一定会去
  我想在那里最高的山峰矗立
  不在乎它是不是悬崖峭壁
  用力活着用力爱哪怕肝脑涂地
  不求任何人满意只要对得起自己
  关于理想我从来没选择放弃
  即使在灰头土脸的日子里
  也许我没有天分
  但我有梦的天真
  我将会去证明用我的一生
  也许我手比较笨
  但我愿不停探寻
  付出所有的青春不留遗憾
  向前跑 迎着冷眼和嘲笑
  生命的广阔不历经磨难怎能感到
  命运它无法让我们跪地求饶
  就算鲜血洒满了怀抱
  继续跑 带着赤子的骄傲
  生命的闪耀不坚持到底怎能看到
  与其苟延残喘不如纵情燃烧吧
  有一天会再发芽
  未来迷人绚烂总在向我召唤</description>
    </item>
    
    <item>
      <title>とんぼ</title>
      <link>/posts/2022-2-5-2/</link>
      <pubDate>Sat, 05 Feb 2022 19:21:15 +0800</pubDate>
      
      <guid>/posts/2022-2-5-2/</guid>
      <description>コツコツとアスファルトに刻む
脚步声咯噔咯噔刻在沥青路上
足音を踏みしめるたびに
每踩一步时
俺は俺で在り続けたい そう願った
我都祈愿了 要永远保持住本真的自我
裏腹な心たちが見えて やりきれない夜を数え
看得见相反的不同内心 我数着难熬的夜晚
のがれられない闇の中で 今日も眠ったふりをする
在无法逃脱的黑暗之中 今天也假装睡着了
死にたいくらいに憧れた 花の都 大東京
曾令我憧憬得要死要活的 繁华都市大东京
薄っぺらのボストンバッグ 北へ北へ向かった
我提着瘪瘪的波士顿包 一路向北奔去
ざらついたにがい砂を噛むと
咀嚼了粗糙苦涩的砂砾后
ねじふせられた正直さが
被摁倒了的正直
今ごろになってやけに骨身にしみる
如今更加 铭心刻骨
  ああしあわせのとんぼよ どこへ
啊 幸福的蜻蜓啊 往哪里
お前はどこへ飛んで行く
你往哪里飞去
ああしあわせのとんぼが ほら
啊 幸福的蜻蜓 你瞧
舌を出して 笑ってらあ※
正伸出舌头在笑呢
  明日からまた冬の風が 横っつらを吹き抜けて行く
从明天起冬日的风 又将吹过我的侧脸而去
それでもおめおめと生きぬく 俺を恥らう
即便如此 仍令厚颜无耻赖活的我感到羞耻
裸足のまんまじゃ寒くて 凍りつくような夜を数え
我就这样冷赤着双脚 数着冰凉的夜晚
だけど俺はこの街を愛し そしてこの街を憎んだ
但我爱着这个城市 并又憎恨着这座城市
死にたいくらいに憧れた 東京のバカヤローが</description>
    </item>
    
    <item>
      <title>我什么也没说</title>
      <link>/posts/2022-2-5/</link>
      <pubDate>Sat, 05 Feb 2022 08:43:08 +0800</pubDate>
      
      <guid>/posts/2022-2-5/</guid>
      <description>很久之前，我见到过这样一个画面：一位年轻的母亲和她的孩子坐公交，她用手抱着小孩，小孩用手抱着手机。她在刷短视频，一遍又一遍。我就这么看着，什么也没说。
我什么都没说，因为大家都是这样做的；那位母亲什么错也没有，因为大家都是这样做的。但是那孩子，真的知道自己想要什么吗？
在这一点上，我很欣赏（ 喂！崇敬！注意你的用词! ）益辉的观念：我不是专职保姆，除非你的故事“催人泪下”（ 我瞎说的 )。我也很欣赏益辉因为不喜欢微信就拒绝回国的态度（还是瞎说的！）。然而，益辉的贡献是很多很多人无法比拟的，我并不是指他在 R 语言社区或者数据分析领域的贡献（ 因为我不懂～ ），我是觉得他在帮助人们关注阅读、关注写作上面做了很多努力（ 满大街都是抄他博客的人，当然也包括我，哈哈哈哈！ )。
今天又提益辉的名字，因为我现在就是在抄他的主题，甚至抄他的 blogdown（//▽//）。</description>
    </item>
    
    <item>
      <title>战斗吧！为了雅典娜！</title>
      <link>/posts/2022-2-4/</link>
      <pubDate>Fri, 04 Feb 2022 19:59:26 +0800</pubDate>
      
      <guid>/posts/2022-2-4/</guid>
      <description>如果说《世界名作系列》是想告诉世人什么是爱，那么《圣斗士星矢》则给我们展示了为爱而战斗的意志。爆发你的小宇宙吧！这样你才有力量去追求你爱的一切！
《圣斗士星矢》，80年代的动漫，感觉挺有意思。就是资源不太好找，不过还是强烈推荐日语中字的，TV版。千万别去看国语配音的……反正我是受不了(＠_＠;)。
“未必要有希望才能坚持”，今天从益辉博客里看来的。还有，我打算换一个网站主题了，虽然我很喜欢现在这个，但是毕竟这是益辉给自己定制的，我也想自己做一个。</description>
    </item>
    
    <item>
      <title>追 - 张国荣</title>
      <link>/posts/2022-2-3-3/</link>
      <pubDate>Thu, 03 Feb 2022 20:23:01 +0800</pubDate>
      
      <guid>/posts/2022-2-3-3/</guid>
      <description>这一生也在进取
  这分钟却挂念谁
  我会说是唯独你不可失去
  好风光似幻似虚
  谁明人生乐趣
  我会说为情为爱仍然是对
  谁比你重要
  成功了败了也完全无重要
  谁比你重要
  狂风与暴雨都因你燃烧
  一追再追
  只想追赶生命里一分一秒
  原来多么可笑
  你是真正目标
  一追再追
  追踪一些生活最基本需要
  原来早不缺少
  Oh
  有了你即使平凡却最重要
  好光阴纵没太多
  一分钟那又如何
  会与你共同渡过都不枉过
  疯恋多错误更多
  如能从新做过</description>
    </item>
    
    <item>
      <title>墮落 - 王菲</title>
      <link>/posts/2022-2-3-2/</link>
      <pubDate>Thu, 03 Feb 2022 20:00:09 +0800</pubDate>
      
      <guid>/posts/2022-2-3-2/</guid>
      <description>这世界看来很快乐
  看不出难过
  始终笑著沉默
  你不慌不忙
  自然坦荡
  脱下了伪装
  摘去了信仰
  你不愿多说话
  你想放纵一下
  没什么可怕
  没什么放心不下
  痛苦地享乐
  犹豫著堕落
  YI DA LI DA
  YI DA LI DA
  左右不了诱惑
  你才拒绝寂寞
  你没有错
  因为没有谁作对过
  心安理得
  于是你堕落
  YI DA LI DA</description>
    </item>
    
    <item>
      <title>昨天 今天 下雨天</title>
      <link>/posts/2022-2-3/</link>
      <pubDate>Thu, 03 Feb 2022 18:01:32 +0800</pubDate>
      
      <guid>/posts/2022-2-3/</guid>
      <description> 下雨天小雨点
那一天亲我面
我喜欢
街中披雨到处走
在那天七岁多
多开心很少挂念
雨那天起舞在前后
玩雨水追雨点
盼雨天一世现
但雨点
始终须要远走
问母亲怎会的
她温馨解释说着
每种东西有定时候
当飘到
不可以送走
若飘去
如何不舍都要放手
即使有泪流
亦学习承受
  下雨天的小雨点
有一天轻抚你面
你那天
开始牵我两手
十七岁那天
多开心很少挂念
说也许恋爱是时候
在雨中轻倚你肩
你说想天天见面
你说想
天边海角与我走
但那天的雨点
跟当天都不再现
我有哭当你别离后
当飘到
不可以送走
若飘去
如何不舍都要放手
即使有泪流
亦学习承受
  在这天飘飘雨点
再这般的亲我面
似不知 当天相隔已久
现我心懂多了点
知必须经考验
笑与哭
早注定是时候
在雨中仿佛见到
母亲的亲切面
也见到
当天的你与我走
亦见到许多昨天
许多东西使我念
我半泣的笑着怀旧
当飘到
不可以送走
若飘去
如何不舍都要放手
即使有泪流
亦学习承受
 </description>
    </item>
    
    <item>
      <title>《Thoughts on Death》</title>
      <link>/posts/thoughtsondeath/</link>
      <pubDate>Sun, 30 Jan 2022 22:58:34 +0800</pubDate>
      
      <guid>/posts/thoughtsondeath/</guid>
      <description>My third story is about death.
  我的第三个故事是关于死亡的。
  When I was 17, I read a quote that went something like: &amp;ldquo;If you live each day as if it was your last, someday you&amp;rsquo;ll most certainly be right.&amp;rdquo;
  17岁那年，我读到了一句话，它是这样说的：“如果你把每一天都当作生命中的最后一天去过，总有一天你会如愿以偿。”
  It made an impression on me, and since then, for the past 33 years, I have looked in the mirror every morning and asked myself:</description>
    </item>
    
    <item>
      <title>花咲く旅路</title>
      <link>/posts/2022-1-27-4/</link>
      <pubDate>Thu, 27 Jan 2022 07:50:56 +0800</pubDate>
      
      <guid>/posts/2022-1-27-4/</guid>
      <description>鈴なりの花を摘み
  摘下串串花儿
  吹く風に夏を知る
  微风吹拂夏日临
  おだやかに ああ おだやかに
  静静地，啊静静地
  今 ぼんやり遠くをながめてる
  凝望远方
  はるかなる空の果て
  在遥远天尽头
  想い出が駆けめぐる
  回忆的思绪萦绕着
  なだらかな この なだらかな
  缓缓的，这缓缓的
  名前さえしらない 坂だけど
  无名小路上
  咲く紫は 旅路を彩どる
  盛开的紫丁香将旅途装扮
  何処へと鳥は鳴き
  何处鸟儿歌婉转
  夢出ずる国をゆく
  伴我奔向梦之国</description>
    </item>
    
    <item>
      <title>月亮代表我的心</title>
      <link>/posts/2022-1-27-3/</link>
      <pubDate>Thu, 27 Jan 2022 07:43:09 +0800</pubDate>
      
      <guid>/posts/2022-1-27-3/</guid>
      <description>你问我爱你有多深
  我爱你有几分
  我的情也真
  我的爱也真
  月亮代表我的心
  你问我爱你有多深
  我爱你有几分
  我的情不移
  我的爱不变
  月亮代表我的心
  轻轻的一个吻
  已经打动我的心
  深深的一段情
  教我思念到如今
  你问我爱你有多深
  我爱你有几分
  你去想一想
  你去看一看
  月亮代表我的心
  轻轻的一个吻
  已经打动我的心
  深深的一段情
  教我思念到如今
  你问我爱你有多深</description>
    </item>
    
    <item>
      <title>左右手</title>
      <link>/posts/2022-1-27-2/</link>
      <pubDate>Thu, 27 Jan 2022 07:33:15 +0800</pubDate>
      
      <guid>/posts/2022-1-27-2/</guid>
      <description>不知道为何你会远走
  不知道何时才再有对手
  我的身心只适应你
  没气力回头
  不知道为何你会放手
  只知道习惯抱你抱了太久
  怕这双手一失去你
  令动作颤抖
  尚记得
  左手边一脸温柔
  来自你热暖在枕边消受
  同样记得
  当天一脸哀求
  摇着我右臂
  就这样而分手
  从那天起我不辨别前后
  从那天起我竟调乱左右
  惯都扭转了
  呼吸都张不开口
  你离开了
  却散落四周
  从那天起我恋上我左手
  从那天起我讨厌我右手
  为何没力气</description>
    </item>
    
    <item>
      <title>至少还有你</title>
      <link>/posts/2022-1-27/</link>
      <pubDate>Thu, 27 Jan 2022 07:24:25 +0800</pubDate>
      
      <guid>/posts/2022-1-27/</guid>
      <description>我怕来不及 我要抱着你
  直到感觉你的皱纹
  有了岁月的痕迹
  直到肯定你是真的
  直到失去力气
  为了你 我愿意
  动也不能动 也要抱着你
  直到感觉你的发线
  有了白雪的痕迹
  直到视线变得模糊
  直到不能呼吸
  让我们 形影不离
  如果 全世界我也可以放弃
  只因还有你 值得我去珍惜
  而你在这里 就是生命的奇迹
  也许 全世界我也可以放弃
  就是不愿意 失去你的消息
  你掌心的痣 我总记得在那里
  我怕来不及 我要抱着你
  直到感觉你的发线</description>
    </item>
    
    <item>
      <title>《Love and Loss》</title>
      <link>/posts/loveandloss/</link>
      <pubDate>Thu, 27 Jan 2022 00:19:44 +0800</pubDate>
      
      <guid>/posts/loveandloss/</guid>
      <description>—— Steve Jobs
  My second story is about love and loss.
  我的第二个故事是关于爱与得失的。
  I was lucky —— I found what I loved to do early in life.
  我很幸运，因为我在很早的时候就发现了自己钟爱的东西。
  Woz and I started Apple in my parents&amp;rsquo; garage when I was 20. We worked hard, and in ten years Apple had grown from just the two of us in a garage ito a $2 billion company with over 4,000 employess.</description>
    </item>
    
    <item>
      <title>《Connecting the dots》</title>
      <link>/posts/connectthedots/</link>
      <pubDate>Wed, 26 Jan 2022 22:13:11 +0800</pubDate>
      
      <guid>/posts/connectthedots/</guid>
      <description>—— Steve Jobs
  I am honored to be with you today for your commencement from one of the finest universities in the world.
  很荣幸与大家一道参加这次的毕业典礼，斯坦福大学是世界上最好的大学之一。
  Truth be told, I never graduated from college. And this is the closest I&amp;rsquo;ve ever gotten to a college graduation.
  说实话，我大学还没毕业，今天是我第一次离大学毕业典礼这么近。
  Today I want to tell you three stories from my life. That&amp;rsquo;s it. That&amp;rsquo;s it.</description>
    </item>
    
    <item>
      <title>爱自己</title>
      <link>/posts/2022-1-23/</link>
      <pubDate>Sun, 23 Jan 2022 22:06:42 +0800</pubDate>
      
      <guid>/posts/2022-1-23/</guid>
      <description></description>
    </item>
    
    <item>
      <title>C&#43;&#43; 开发必备之设计模式</title>
      <link>/posts/design-pattern/</link>
      <pubDate>Sat, 15 Jan 2022 08:14:07 +0800</pubDate>
      
      <guid>/posts/design-pattern/</guid>
      <description>转载自https://github.com/huihut/interview
 各大设计模式例子参考：CSDN专栏 . C++ 设计模式 系列博文
 设计模式工程目录
单例模式 🔗单例模式例子
抽象工厂模式 🔗抽象工厂模式例子
适配器模式 🔗适配器模式例子
桥接模式 🔗桥接模式例子
观察者模式 🔗观察者模式例子
设计模式的六大原则 🔗 单一职责原则（SRP，Single Responsibility Principle） 里氏替换原则（LSP，Liskov Substitution Principle） 依赖倒置原则（DIP，Dependence Inversion Principle） 接口隔离原则（ISP，Interface Segregation Principle） 迪米特法则（LoD，Law of Demeter） 开放封闭原则（OCP，Open Close Principle）  </description>
    </item>
    
    <item>
      <title>C&#43;&#43; 开发必备之链接装载库</title>
      <link>/posts/library/</link>
      <pubDate>Sat, 15 Jan 2022 08:10:50 +0800</pubDate>
      
      <guid>/posts/library/</guid>
      <description>转载自https://github.com/huihut/interview
 本节部分知识点来自《程序员的自我修养——链接装载库》
 内存、栈、堆 🔗一般应用程序内存空间有如下区域：
 栈：由操作系统自动分配释放，存放函数的参数值、局部变量等的值，用于维护函数调用的上下文 堆：一般由程序员分配释放，若程序员不释放，程序结束时可能由操作系统回收，用来容纳应用程序动态分配的内存区域 可执行文件映像：存储着可执行文件在内存中的映像，由装载器装载是将可执行文件的内存读取或映射到这里 保留区：保留区并不是一个单一的内存区域，而是对内存中受到保护而禁止访问的内存区域的总称，如通常 C 语言讲无效指针赋值为 0（NULL），因此 0 地址正常情况下不可能有效的访问数据  栈 🔗栈保存了一个函数调用所需要的维护信息，常被称为堆栈帧（Stack Frame）或活动记录（Activate Record），一般包含以下几方面：
 函数的返回地址和参数 临时变量：包括函数的非静态局部变量以及编译器自动生成的其他临时变量 保存上下文：包括函数调用前后需要保持不变的寄存器  堆 🔗堆分配算法：
 空闲链表（Free List） 位图（Bitmap） 对象池  “段错误（segment fault）” 或 “非法操作，该内存地址不能 read/write” 🔗典型的非法指针解引用造成的错误。当指针指向一个不允许读写的内存地址，而程序却试图利用指针来读或写该地址时，会出现这个错误。
普遍原因：
 将指针初始化为 NULL，之后没有给它一个合理的值就开始使用指针 没用初始化栈中的指针，指针的值一般会是随机数，之后就直接开始使用指针  编译链接 🔗各平台文件格式 🔗   平台 可执行文件 目标文件 动态库/共享对象 静态库     Windows exe obj dll lib   Unix/Linux ELF、out o so a   Mac Mach-O o dylib、tbd、framework a、framework    编译链接过程 🔗 预编译（预编译器处理如 #include、#define 等预编译指令，生成 .</description>
    </item>
    
    <item>
      <title>C&#43;&#43; 开发必备之数据库</title>
      <link>/posts/database/</link>
      <pubDate>Sat, 15 Jan 2022 08:08:34 +0800</pubDate>
      
      <guid>/posts/database/</guid>
      <description>转载自https://github.com/huihut/interview
 本节部分知识点来自《数据库系统概论（第 5 版）》
 基本概念 🔗 数据（data）：描述事物的符号记录称为数据。 数据库（DataBase，DB）：是长期存储在计算机内、有组织的、可共享的大量数据的集合，具有永久存储、有组织、可共享三个基本特点。 数据库管理系统（DataBase Management System，DBMS）：是位于用户与操作系统之间的一层数据管理软件。 数据库系统（DataBase System，DBS）：是有数据库、数据库管理系统（及其应用开发工具）、应用程序和数据库管理员（DataBase Administrator DBA）组成的存储、管理、处理和维护数据的系统。 实体（entity）：客观存在并可相互区别的事物称为实体。 属性（attribute）：实体所具有的某一特性称为属性。 码（key）：唯一标识实体的属性集称为码。 实体型（entity type）：用实体名及其属性名集合来抽象和刻画同类实体，称为实体型。 实体集（entity set）：同一实体型的集合称为实体集。 联系（relationship）：实体之间的联系通常是指不同实体集之间的联系。 模式（schema）：模式也称逻辑模式，是数据库全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。 外模式（external schema）：外模式也称子模式（subschema）或用户模式，它是数据库用户（包括应用程序员和最终用户）能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图，是与某一应用有关的数据的逻辑表示。 内模式（internal schema）：内模式也称为存储模式（storage schema），一个数据库只有一个内模式。他是数据物理结构和存储方式的描述，是数据库在数据库内部的组织方式。  常用数据模型 🔗 层次模型（hierarchical model） 网状模型（network model） 关系模型（relational model）  关系（relation）：一个关系对应通常说的一张表 元组（tuple）：表中的一行即为一个元组 属性（attribute）：表中的一列即为一个属性 码（key）：表中可以唯一确定一个元组的某个属性组 域（domain）：一组具有相同数据类型的值的集合 分量：元组中的一个属性值 关系模式：对关系的描述，一般表示为 关系名(属性1, 属性2, ..., 属性n)   面向对象数据模型（object oriented data model） 对象关系数据模型（object relational data model） 半结构化数据模型（semistructure data model）  常用 SQL 操作 🔗对象类型对象操作类型数据库模式模式CREATE SCHEMA基本表CREATE SCHEMA，ALTER TABLE视图CREATE VIEW索引CREATE INDEX数据基本表和视图SELECT，INSERT，UPDATE，DELETE，REFERENCES，ALL PRIVILEGES属性列SELECT，INSERT，UPDATE，REFERENCES，ALL PRIVILEGES SQL 语法教程：runoob .</description>
    </item>
    
    <item>
      <title>C&#43;&#43; 开发必备之计算机网络</title>
      <link>/posts/network/</link>
      <pubDate>Sat, 15 Jan 2022 08:06:35 +0800</pubDate>
      
      <guid>/posts/network/</guid>
      <description>转载自https://github.com/huihut/interview
 本节部分知识点来自《计算机网络（第 7 版）》
 计算机网络体系结构：
各层作用及协议 🔗   分层 作用 协议     物理层 通过媒介传输比特，确定机械及电气规范（比特 Bit） RJ45、CLOCK、IEEE802.3（中继器，集线器）   数据链路层 将比特组装成帧和点到点的传递（帧 Frame） PPP、FR、HDLC、VLAN、MAC（网桥，交换机）   网络层 负责数据包从源到宿的传递和网际互连（包 Packet） IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP（路由器）   运输层 提供端到端的可靠报文传递和错误恢复（ 段Segment） TCP、UDP、SPX   会话层 建立、管理和终止会话（会话协议数据单元 SPDU） NFS、SQL、NETBIOS、RPC   表示层 对数据进行翻译、加密和压缩（表示协议数据单元 PPDU） JPEG、MPEG、ASII   应用层 允许访问OSI环境的手段（应用协议数据单元 APDU） FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS    物理层 🔗 传输数据的单位：比特 数据传输系统：源系统（源点、发送器） &amp;ndash;&amp;gt; 传输系统 &amp;ndash;&amp;gt; 目的系统（接收器、终点）  通道：</description>
    </item>
    
    <item>
      <title>C&#43;&#43; 开发必备之操作系统</title>
      <link>/posts/os/</link>
      <pubDate>Fri, 14 Jan 2022 21:02:05 +0800</pubDate>
      
      <guid>/posts/os/</guid>
      <description>转载自https://github.com/huihut/interview
进程与线程 🔗对于有线程系统：
 进程是资源分配的独立单位 线程是资源调度的独立单位  对于无线程系统：
 进程是资源调度、分配的独立单位  进程之间的通信方式以及优缺点 🔗 管道（PIPE）  有名管道：一种半双工的通信方式，它允许无亲缘关系进程间的通信  优点：可以实现任意关系的进程间的通信 缺点：  长期存于系统中，使用不当容易出错 缓冲区有限     无名管道：一种半双工的通信方式，只能在具有亲缘关系的进程间使用（父子进程）  优点：简单方便 缺点：  局限于单向通信 只能创建在它的进程以及其有亲缘关系的进程之间 缓冲区有限       信号量（Semaphore）：一个计数器，可以用来控制多个线程对共享资源的访问  优点：可以同步进程 缺点：信号量有限   信号（Signal）：一种比较复杂的通信方式，用于通知接收进程某个事件已经发生 消息队列（Message Queue）：是消息的链表，存放在内核中并由消息队列标识符标识  优点：可以实现任意进程间的通信，并通过系统调用函数来实现消息发送和接收之间的同步，无需考虑同步问题，方便 缺点：信息的复制需要额外消耗 CPU 的时间，不适宜于信息量大或操作频繁的场合   共享内存（Shared Memory）：映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问  优点：无须复制，快捷，信息量大 缺点：  通信是通过将共享空间缓冲区直接附加到进程的虚拟地址空间中来实现的，因此进程间的读写操作的同步问题 利用内存缓冲区直接交换信息，内存的实体存在于计算机中，只能同一个计算机系统中的诸多进程共享，不方便网络通信     套接字（Socket）：可用于不同计算机间的进程通信  优点：  传输数据为字节级，传输数据可自定义，数据量小效率高 传输数据时间短，性能高 适合于客户端和服务器端之间信息实时交互 可以加密,数据安全性强   缺点：需对传输的数据进行解析，转化成应用级的数据。    线程之间的通信方式 🔗 锁机制：包括互斥锁/量（mutex）、读写锁（reader-writer lock）、自旋锁（spin lock）、条件变量（condition）  互斥锁/量（mutex）：提供了以排他方式防止数据结构被并发修改的方法。 读写锁（reader-writer lock）：允许多个线程同时读共享数据，而对写操作是互斥的。 自旋锁（spin lock）与互斥锁类似，都是为了保护共享资源。互斥锁是当资源被占用，申请者进入睡眠状态；而自旋锁则循环检测保持者是否已经释放锁。 条件变量（condition）：可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。   信号量机制(Semaphore)  无名线程信号量 命名线程信号量   信号机制(Signal)：类似进程间的信号处理 屏障（barrier）：屏障允许每个线程等待，直到所有的合作线程都达到某一点，然后从该点继续执行。  线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制</description>
    </item>
    
    <item>
      <title>C&#43;&#43; 开发必备之算法</title>
      <link>/posts/algorithm/</link>
      <pubDate>Fri, 14 Jan 2022 20:42:19 +0800</pubDate>
      
      <guid>/posts/algorithm/</guid>
      <description>转载自https://github.com/huihut/interview
排序 🔗   排序算法 平均时间复杂度 最差时间复杂度 空间复杂度 数据对象稳定性     冒泡排序 O(n2) O(n2) O(1) 稳定   选择排序 O(n2) O(n2) O(1) 数组不稳定、链表稳定   插入排序 O(n2) O(n2) O(1) 稳定   快速排序 O(n*log2n) O(n2) O(log2n) 不稳定   堆排序 O(n*log2n) O(n*log2n) O(1) 不稳定   归并排序 O(n*log2n) O(n*log2n) O(n) 稳定   希尔排序 O(n*log2n) O(n2) O(1) 不稳定   计数排序 O(n+m) O(n+m) O(n+m) 稳定   桶排序 O(n) O(n) O(m) 稳定   基数排序 O(k*n) O(n2)  稳定      均按从小到大排列 k：代表数值中的 “数位” 个数 n：代表数据规模 m：代表数据的最大值减最小值 来自：wikipedia .</description>
    </item>
    
    <item>
      <title>C&#43;&#43; 开发必备之数据结构</title>
      <link>/posts/data-structure/</link>
      <pubDate>Fri, 14 Jan 2022 20:28:54 +0800</pubDate>
      
      <guid>/posts/data-structure/</guid>
      <description>转载自https://github.com/huihut/interview
顺序结构 🔗顺序栈（Sequence Stack） 🔗SqStack.cpp
顺序栈数据结构和图片
typedef struct { 	ElemType *elem; 	int top; 	int size; 	int increment; } SqStack; 队列（Sequence Queue） 🔗队列数据结构
typedef struct { 	ElemType * elem; 	int front; 	int rear; 	int maxSize; }SqQueue; 非循环队列 🔗非循环队列图片
SqQueue.rear++
循环队列 🔗循环队列图片
SqQueue.rear = (SqQueue.rear + 1) % SqQueue.maxSize
顺序表（Sequence List） 🔗SqList.cpp
顺序表数据结构和图片
typedef struct { 	ElemType *elem; 	int length; 	int size; 	int increment; } SqList; 链式结构 🔗LinkList.</description>
    </item>
    
    <item>
      <title>C&#43;&#43; 开发必备之 STL</title>
      <link>/posts/c&#43;&#43;stl/</link>
      <pubDate>Fri, 14 Jan 2022 20:23:31 +0800</pubDate>
      
      <guid>/posts/c&#43;&#43;stl/</guid>
      <description>转载自https://github.com/huihut/interview
STL 索引 🔗STL 方法含义索引
STL 容器 🔗   容器 底层数据结构 时间复杂度 有无序 可不可重复 其他     array 数组 随机读改 O(1) 无序 可重复 支持随机访问   vector 数组 随机读改、尾部插入、尾部删除 O(1)头部插入、头部删除 O(n) 无序 可重复 支持随机访问   deque 双端队列 头尾插入、头尾删除 O(1) 无序 可重复 一个中央控制器 + 多个缓冲区，支持首尾快速增删，支持随机访问   forward_list 单向链表 插入、删除 O(1) 无序 可重复 不支持随机访问   list 双向链表 插入、删除 O(1) 无序 可重复 不支持随机访问   stack deque / list 顶部插入、顶部删除 O(1) 无序 可重复 deque 或 list 封闭头端开口，不用 vector 的原因应该是容量大小有限制，扩容耗时   queue deque / list 尾部插入、头部删除 O(1) 无序 可重复 deque 或 list 封闭头端开口，不用 vector 的原因应该是容量大小有限制，扩容耗时   priority_queue vector + max-heap 插入、删除 O(log2n) 有序 可重复 vector容器+heap处理规则   set 红黑树 插入、删除、查找 O(log2n) 有序 不可重复    multiset 红黑树 插入、删除、查找 O(log2n) 有序 可重复    map 红黑树 插入、删除、查找 O(log2n) 有序 不可重复    multimap 红黑树 插入、删除、查找 O(log2n) 有序 可重复    unordered_set 哈希表 插入、删除、查找 O(1) 最差 O(n) 无序 不可重复    unordered_multiset 哈希表 插入、删除、查找 O(1) 最差 O(n) 无序 可重复    unordered_map 哈希表 插入、删除、查找 O(1) 最差 O(n) 无序 不可重复    unordered_multimap 哈希表 插入、删除、查找 O(1) 最差 O(n) 无序 可重复     STL 算法 🔗   算法 底层算法 时间复杂度 可不可重复     find 顺序查找 O(n) 可重复   sort 内省排序 O(n*log2n) 可重复    </description>
    </item>
    
    <item>
      <title>C&#43;&#43; 开发必备之 Effective C&#43;&#43;</title>
      <link>/posts/effectivec&#43;&#43;/</link>
      <pubDate>Fri, 14 Jan 2022 20:16:02 +0800</pubDate>
      
      <guid>/posts/effectivec&#43;&#43;/</guid>
      <description>转载自https://github.com/huihut/interview
Effective C++ 🔗 视 C++ 为一个语言联邦（C、Object-Oriented C++、Template C++、STL） 宁可以编译器替换预处理器（尽量以 const、enum、inline 替换 #define） 尽可能使用 const 确定对象被使用前已先被初始化（构造时赋值（copy 构造函数）比 default 构造后赋值（copy assignment）效率高） 了解 C++ 默默编写并调用哪些函数（编译器暗自为 class 创建 default 构造函数、copy 构造函数、copy assignment 操作符、析构函数） 若不想使用编译器自动生成的函数，就应该明确拒绝（将不想使用的成员函数声明为 private，并且不予实现） 为多态基类声明 virtual 析构函数（如果 class 带有任何 virtual 函数，它就应该拥有一个 virtual 析构函数） 别让异常逃离析构函数（析构函数应该吞下不传播异常，或者结束程序，而不是吐出异常；如果要处理异常应该在非析构的普通函数处理） 绝不在构造和析构过程中调用 virtual 函数（因为这类调用从不下降至 derived class） 令 operator= 返回一个 reference to *this （用于连锁赋值） 在 operator= 中处理 “自我赋值” 赋值对象时应确保复制 “对象内的所有成员变量” 及 “所有 base class 成分”（调用基类复制构造函数） 以对象管理资源（资源在构造函数获得，在析构函数释放，建议使用智能指针，资源取得时机便是初始化时机（Resource Acquisition Is Initialization，RAII）） 在资源管理类中小心 copying 行为（普遍的 RAII class copying 行为是：抑制 copying、引用计数、深度拷贝、转移底部资源拥有权（类似 auto_ptr）） 在资源管理类中提供对原始资源（raw resources）的访问（对原始资源的访问可能经过显式转换或隐式转换，一般而言显示转换比较安全，隐式转换对客户比较方便） 成对使用 new 和 delete 时要采取相同形式（new 中使用 [] 则 delete []，new 中不使用 [] 则 delete） 以独立语句将 newed 对象存储于（置入）智能指针（如果不这样做，可能会因为编译器优化，导致难以察觉的资源泄漏） 让接口容易被正确使用，不易被误用（促进正常使用的办法：接口的一致性、内置类型的行为兼容；阻止误用的办法：建立新类型，限制类型上的操作，约束对象值、消除客户的资源管理责任） 设计 class 犹如设计 type，需要考虑对象创建、销毁、初始化、赋值、值传递、合法值、继承关系、转换、一般化等等。 宁以 pass-by-reference-to-const 替换 pass-by-value （前者通常更高效、避免切割问题（slicing problem），但不适用于内置类型、STL迭代器、函数对象） 必须返回对象时，别妄想返回其 reference（绝不返回 pointer 或 reference 指向一个 local stack 对象，或返回 reference 指向一个 heap-allocated 对象，或返回 pointer 或 reference 指向一个 local static 对象而有可能同时需要多个这样的对象。） 将成员变量声明为 private（为了封装、一致性、对其读写精确控制等） 宁以 non-member、non-friend 替换 member 函数（可增加封装性、包裹弹性（packaging flexibility）、机能扩充性） 若所有参数（包括被this指针所指的那个隐喻参数）皆须要类型转换，请为此采用 non-member 函数 考虑写一个不抛异常的 swap 函数 尽可能延后变量定义式的出现时间（可增加程序清晰度并改善程序效率） 尽量少做转型动作（旧式：(T)expression、T(expression)；新式：const_cast&amp;lt;T&amp;gt;(expression)、dynamic_cast&amp;lt;T&amp;gt;(expression)、reinterpret_cast&amp;lt;T&amp;gt;(expression)、static_cast&amp;lt;T&amp;gt;(expression)、；尽量避免转型、注重效率避免 dynamic_casts、尽量设计成无需转型、可把转型封装成函数、宁可用新式转型） 避免使用 handles（包括 引用、指针、迭代器）指向对象内部（以增加封装性、使 const 成员函数的行为更像 const、降低 “虚吊号码牌”（dangling handles，如悬空指针等）的可能性） 为 “异常安全” 而努力是值得的（异常安全函数（Exception-safe functions）即使发生异常也不会泄露资源或允许任何数据结构败坏，分为三种可能的保证：基本型、强列型、不抛异常型） 透彻了解 inlining 的里里外外（inlining 在大多数 C++ 程序中是编译期的行为；inline 函数是否真正 inline，取决于编译器；大部分编译器拒绝太过复杂（如带有循环或递归）的函数 inlining，而所有对 virtual 函数的调用（除非是最平淡无奇的）也都会使 inlining 落空；inline 造成的代码膨胀可能带来效率损失；inline 函数无法随着程序库的升级而升级） 将文件间的编译依存关系降至最低（如果使用 object references 或 object pointers 可以完成任务，就不要使用 objects；如果能够，尽量以 class 声明式替换 class 定义式；为声明式和定义式提供不同的头文件） 确定你的 public 继承塑模出 is-a（是一种）关系（适用于 base classes 身上的每一件事情一定适用于 derived classes 身上，因为每一个 derived class 对象也都是一个 base class 对象） 避免遮掩继承而来的名字（可使用 using 声明式或转交函数（forwarding functions）来让被遮掩的名字再见天日） 区分接口继承和实现继承（在 public 继承之下，derived classes 总是继承 base class 的接口；pure virtual 函数只具体指定接口继承；非纯 impure virtual 函数具体指定接口继承及缺省实现继承；non-virtual 函数具体指定接口继承以及强制性实现继承） 考虑 virtual 函数以外的其他选择（如 Template Method 设计模式的 non-virtual interface（NVI）手法，将 virtual 函数替换为 “函数指针成员变量”，以 tr1::function 成员变量替换 virtual 函数，将继承体系内的 virtual 函数替换为另一个继承体系内的 virtual 函数） 绝不重新定义继承而来的 non-virtual 函数 绝不重新定义继承而来的缺省参数值，因为缺省参数值是静态绑定（statically bound），而 virtual 函数却是动态绑定（dynamically bound） 通过复合塑模 has-a（有一个）或 “根据某物实现出”（在应用域（application domain），复合意味 has-a（有一个）；在实现域（implementation domain），复合意味着 is-implemented-in-terms-of（根据某物实现出）） 明智而审慎地使用 private 继承（private 继承意味着 is-implemented-in-terms-of（根据某物实现出），尽可能使用复合，当 derived class 需要访问 protected base class 的成员，或需要重新定义继承而来的时候 virtual 函数，或需要 empty base 最优化时，才使用 private 继承） 明智而审慎地使用多重继承（多继承比单一继承复杂，可能导致新的歧义性，以及对 virtual 继承的需要，但确有正当用途，如 “public 继承某个 interface class” 和 “private 继承某个协助实现的 class”；virtual 继承可解决多继承下菱形继承的二义性问题，但会增加大小、速度、初始化及赋值的复杂度等等成本） 了解隐式接口和编译期多态（class 和 templates 都支持接口（interfaces）和多态（polymorphism）；class 的接口是以签名为中心的显式的（explicit），多态则是通过 virtual 函数发生于运行期；template 的接口是奠基于有效表达式的隐式的（implicit），多态则是通过 template 具现化和函数重载解析（function overloading resolution）发生于编译期） 了解 typename 的双重意义（声明 template 类型参数是，前缀关键字 class 和 typename 的意义完全相同；请使用关键字 typename 标识嵌套从属类型名称，但不得在基类列（base class lists）或成员初值列（member initialization list）内以它作为 base class 修饰符） 学习处理模板化基类内的名称（可在 derived class templates 内通过 this-&amp;gt; 指涉 base class templates 内的成员名称，或藉由一个明白写出的 “base class 资格修饰符” 完成） 将与参数无关的代码抽离 templates（因类型模板参数（non-type template parameters）而造成代码膨胀往往可以通过函数参数或 class 成员变量替换 template 参数来消除；因类型参数（type parameters）而造成的代码膨胀往往可以通过让带有完全相同二进制表述（binary representations）的实现类型（instantiation types）共享实现码） 运用成员函数模板接受所有兼容类型（请使用成员函数模板（member function templates）生成 “可接受所有兼容类型” 的函数；声明 member templates 用于 “泛化 copy 构造” 或 “泛化 assignment 操作” 时还需要声明正常的 copy 构造函数和 copy assignment 操作符） 需要类型转换时请为模板定义非成员函数（当我们编写一个 class template，而它所提供之 “与此 template 相关的” 函数支持 “所有参数之隐式类型转换” 时，请将那些函数定义为 “class template 内部的 friend 函数”） 请使用 traits classes 表现类型信息（traits classes 通过 templates 和 “templates 特化” 使得 “类型相关信息” 在编译期可用，通过重载技术（overloading）实现在编译期对类型执行 if&amp;hellip;else 测试） 认识 template 元编程（模板元编程（TMP，template metaprogramming）可将工作由运行期移往编译期，因此得以实现早期错误侦测和更高的执行效率；TMP 可被用来生成 “给予政策选择组合”（based on combinations of policy choices）的客户定制代码，也可用来避免生成对某些特殊类型并不适合的代码） 了解 new-handler 的行为（set_new_handler 允许客户指定一个在内存分配无法获得满足时被调用的函数；nothrow new 是一个颇具局限的工具，因为它只适用于内存分配（operator new），后继的构造函数调用还是可能抛出异常） 了解 new 和 delete 的合理替换时机（为了检测运用错误、收集动态分配内存之使用统计信息、增加分配和归还速度、降低缺省内存管理器带来的空间额外开销、弥补缺省分配器中的非最佳齐位、将相关对象成簇集中、获得非传统的行为） 编写 new 和 delete 时需固守常规（operator new 应该内涵一个无穷循环，并在其中尝试分配内存，如果它无法满足内存需求，就应该调用 new-handler，它也应该有能力处理 0 bytes 申请，class 专属版本则还应该处理 “比正确大小更大的（错误）申请”；operator delete 应该在收到 null 指针时不做任何事，class 专属版本则还应该处理 “比正确大小更大的（错误）申请”） 写了 placement new 也要写 placement delete（当你写一个 placement operator new，请确定也写出了对应的 placement operator delete，否则可能会发生隐微而时断时续的内存泄漏；当你声明 placement new 和 placement delete，请确定不要无意识（非故意）地遮掩了它们地正常版本） 不要轻忽编译器的警告 让自己熟悉包括 TR1 在内的标准程序库（TR1，C++ Technical Report 1，C++11 标准的草稿文件） 让自己熟悉 Boost（准标准库）  More Effective c++ 🔗 仔细区别 pointers 和 references（当你知道你需要指向某个东西，而且绝不会改变指向其他东西，或是当你实现一个操作符而其语法需求无法由 pointers 达成，你就应该选择 references；任何其他时候，请采用 pointers） 最好使用 C++ 转型操作符（static_cast、const_cast、dynamic_cast、reinterpret_cast） 绝不要以多态（polymorphically）方式处理数组（多态（polymorphism）和指针算术不能混用；数组对象几乎总是会涉及指针的算术运算，所以数组和多态不要混用） 非必要不提供 default constructor（避免对象中的字段被无意义地初始化） 对定制的 “类型转换函数” 保持警觉（单自变量 constructors 可通过简易法（explicit 关键字）或代理类（proxy classes）来避免编译器误用；隐式类型转换操作符可改为显式的 member function 来避免非预期行为） 区别 increment/decrement 操作符的前置（prefix）和后置（postfix）形式（前置式累加后取出，返回一个 reference；后置式取出后累加，返回一个 const 对象；处理用户定制类型时，应该尽可能使用前置式 increment；后置式的实现应以其前置式兄弟为基础） 千万不要重载 &amp;amp;&amp;amp;，|| 和 , 操作符（&amp;amp;&amp;amp; 与 || 的重载会用 “函数调用语义” 取代 “骤死式语义”；, 的重载导致不能保证左侧表达式一定比右侧表达式更早被评估） 了解各种不同意义的 new 和 delete（new operator、operator new、placement new、operator new[]；delete operator、operator delete、destructor、operator delete[]） 利用 destructors 避免泄漏资源（在 destructors 释放资源可以避免异常时的资源泄漏） 在 constructors 内阻止资源泄漏（由于 C++ 只会析构已构造完成的对象，因此在构造函数可以使用 try&amp;hellip;catch 或者 auto_ptr（以及与之相似的 classes） 处理异常时资源泄露问题） 禁止异常流出 destructors 之外（原因：一、避免 terminate 函数在 exception 传播过程的栈展开（stack-unwinding）机制种被调用；二、协助确保 destructors 完成其应该完成的所有事情） 了解 “抛出一个 exception” 与 “传递一个参数” 或 “调用一个虚函数” 之间的差异（第一，exception objects 总是会被复制（by pointer 除外），如果以 by value 方式捕捉甚至被复制两次，而传递给函数参数的对象则不一定得复制；第二，“被抛出成为 exceptions” 的对象，其被允许的类型转换动作比 “被传递到函数去” 的对象少；第三，catch 子句以其 “出现于源代码的顺序” 被编译器检验对比，其中第一个匹配成功者便执行，而调用一个虚函数，被选中执行的是那个 “与对象类型最佳吻合” 的函数） 以 by reference 方式捕获 exceptions（可避免对象删除问题、exception objects 的切割问题，可保留捕捉标准 exceptions 的能力，可约束 exception object 需要复制的次数） 明智运用 exception specifications（exception specifications 对 “函数希望抛出什么样的 exceptions” 提供了卓越的说明；也有一些缺点，包括编译器只对它们做局部性检验而很容易不经意地违反，与可能会妨碍更上层的 exception 处理函数处理未预期的 exceptions） 了解异常处理的成本（粗略估计，如果使用 try 语句块，代码大约整体膨胀 5%-10%，执行速度亦大约下降这个数；因此请将你对 try 语句块和 exception specifications 的使用限制于非用不可的地点，并且在真正异常的情况下才抛出 exceptions） 谨记 80-20 法则（软件的整体性能几乎总是由其构成要素（代码）的一小部分决定的，可使用程序分析器（program profiler）识别出消耗资源的代码） 考虑使用 lazy evaluation（缓式评估）（可应用于：Reference Counting（引用计数）来避免非必要的对象复制、区分 operator[] 的读和写动作来做不同的事情、Lazy Fetching（缓式取出）来避免非必要的数据库读取动作、Lazy Expression Evaluation（表达式缓评估）来避免非必要的数值计算动作） 分期摊还预期的计算成本（当你必须支持某些运算而其结构几乎总是被需要，或其结果常常被多次需要的时候，over-eager evaluation（超急评估）可以改善程序效率）  Google C++ Style Guide 🔗 英文：Google C++ Style Guide 中文：C++ 风格指南  其他 🔗 Bjarne Stroustrup 的常见问题 Bjarne Stroustrup 的 C++ 风格和技巧常见问题  </description>
    </item>
    
    <item>
      <title>C&#43;&#43; 开发必备之 C/C&#43;&#43;基础</title>
      <link>/posts/cc&#43;&#43;base/</link>
      <pubDate>Tue, 11 Jan 2022 23:20:27 +0800</pubDate>
      
      <guid>/posts/cc&#43;&#43;base/</guid>
      <description>转载自https://github.com/huihut/interview
const 🔗作用 🔗 修饰变量，说明该变量不可以被改变； 修饰指针，分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer）； 修饰引用，指向常量的引用（reference to const），用于形参类型，即避免了拷贝，又避免了函数对值的修改； 修饰成员函数，说明该成员函数内不能修改成员变量。  const 的指针与引用 🔗 指针  指向常量的指针（pointer to const） 自身是常量的指针（常量指针，const pointer）   引用  指向常量的引用（reference to const） 没有 const reference，因为引用只是对象的别名，引用不是对象，不能用 const 修饰     （为了方便记忆可以想成）被 const 修饰（在 const 后面）的值不可改变，如下文使用例子中的 p2、p3
 使用 🔗const 使用
// 类 class A { private:  const int a; // 常对象成员，可以使用初始化列表或者类内初始化  public:  // 构造函数  A() : a(0) { };  A(int x) : a(x) { }; // 初始化列表   // const可用于对重载函数的区分  int getValue(); // 普通成员函数  int getValue() const; // 常成员函数，不得修改类中的任何数据成员的值 };  void function() {  // 对象  A b; // 普通对象，可以调用全部成员函数  const A a; // 常对象，只能调用常成员函数  const A *p = &amp;amp;a; // 指针变量，指向常对象  const A &amp;amp;q = a; // 指向常对象的引用   // 指针  char greeting[] = &amp;#34;Hello&amp;#34;;  char* p1 = greeting; // 指针变量，指向字符数组变量  const char* p2 = greeting; // 指针变量，指向字符数组常量（const 后面是 char，说明指向的字符（char）不可改变）  char* const p3 = greeting; // 自身是常量的指针，指向字符数组变量（const 后面是 p3，说明 p3 指针自身不可改变）  const char* const p4 = greeting; // 自身是常量的指针，指向字符数组常量 }  // 函数 void function1(const int Var); // 传递过来的参数在函数内不可变 void function2(const char* Var); // 参数指针所指内容为常量 void function3(char* const Var); // 参数指针为常量 void function4(const int&amp;amp; Var); // 引用参数在函数内为常量  // 函数返回值 const int function5(); // 返回一个常数 const int* function6(); // 返回一个指向常量的指针变量，使用：const int *p = function6(); int* const function7(); // 返回一个指向变量的常指针，使用：int* const p = function7(); 宏定义 #define 和 const 常量 🔗   宏定义 #define const 常量     宏定义，相当于字符替换 常量声明   预处理器处理 编译器处理   无类型安全检查 有类型安全检查   不分配内存 要分配内存   存储在代码段 存储在数据段   可通过 #undef 取消 不可取消    static 🔗作用 🔗 修饰普通变量，修改变量的存储区域和生命周期，使变量存储在静态区，在 main 函数运行前就分配了空间，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。 修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static。 修饰成员变量，修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员。 修饰成员函数，修饰成员函数使得不需要生成对象就可以访问该函数，但是在 static 函数内不能访问非静态成员。  this 指针 🔗 this 指针是一个隐含于每一个非静态成员函数中的特殊指针。它指向调用该成员函数的那个对象。 当对一个对象调用成员函数时，编译程序先将对象的地址赋给 this 指针，然后调用成员函数，每次成员函数存取数据成员时，都隐式使用 this 指针。 当一个成员函数被调用时，自动向它传递一个隐含的参数，该参数是一个指向这个成员函数所在的对象的指针。 this 指针被隐含地声明为: ClassName *const this，这意味着不能给 this 指针赋值；在 ClassName 类的 const 成员函数中，this 指针的类型为：const ClassName* const，这说明不能对 this 指针所指向的这种对象是不可修改的（即不能对这种对象的数据成员进行赋值操作）； this 并不是一个常规变量，而是个右值，所以不能取得 this 的地址（不能 &amp;amp;this）。 在以下场景中，经常需要显式引用 this 指针：  为实现对象的链式引用； 为避免对同一对象进行赋值操作； 在实现一些数据结构时，如 list。    inline 内联函数 🔗特征 🔗 相当于把内联函数里面的内容写在调用内联函数处； 相当于不用执行进入函数的步骤，直接执行函数体； 相当于宏，却比宏多了类型检查，真正具有函数特性； 编译器一般不内联包含循环、递归、switch 等复杂操作的内联函数； 在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数。  使用 🔗inline 使用</description>
    </item>
    
    <item>
      <title>《罗生门》</title>
      <link>/posts/rashomon/</link>
      <pubDate>Sun, 09 Jan 2022 22:41:53 +0800</pubDate>
      
      <guid>/posts/rashomon/</guid>
      <description>乞丐：（大笑）这倒像是是实话了。
  砍柴人：我可不撒谎，是我亲眼看见来的。
  乞丐：那也靠不住。
  砍柴人：是真的，我可不撒谎。
  乞丐：撒谎的人才不会说自己是说谎的呢。
  云游和尚：这真是可怕的事了。若是任何人都不能相信，那么这个世界就成了地狱。
  乞丐：没错，这世界就是个地狱。
  云游和尚：不，我相信人。我不想把世界看成地狱。
  乞丐：光说好听的话是不中用的。你倒想想看，刚才那三个人的话，又该相信谁的哪一句才好呢？
  砍柴人：不懂……简直就是不懂。
  乞丐：没有什么值得大惊小怪的。人做的事根本就是无法琢磨的。
  婴儿：（啼哭）
  砍柴人：你这是干什么？
  乞丐：你才干什么呢。
  砍柴人：你的心也太狠了。
  乞丐：心狠？这小衣服反正早晚都会叫人剥去的。我拿走又有什么不对呢？
  砍柴人：你是恶鬼么！
  乞丐：恶鬼？我要是恶鬼，这个崽子的爹娘又该是什么？自己任性地图个痛快，搞出来的崽子也不想养活？把孩子扔了的他们才是真的恶鬼。
  砍柴人：不对，这跟你说的不一样。你瞧，这小衣服上还缝着长命百岁的符咒呢。你替扔孩子的爹娘想想看吧，一定是有万不得已的苦衷啊。
  乞丐：什么事都替别人着想，那就没完没了。
  砍柴人：这也太自私自利……
  乞丐：自私自利为什么不行？这是个人不如狗的世界。谁要不自顾自就活不成啊。
  砍柴人：混蛋。是啊，谁都只是自私自利，只会给自己的自私自利行为辩护。那强盗！那女的！那男人！还有你也是！
  乞丐：难道你就不是吗？真可笑。纠察使署的官差们也许能被你糊弄过去，可我不会。我问你……那女人的短刀哪儿去了？多襄丸也说是镶螺钿的好家伙。那把短刀哪儿去了？难道落在草里就没了吗？不是你偷了，还有谁呀？看来被我说中了啊。贼喊捉贼的你，才叫自私自利。还有什么说的吗？没有的话，我先走了。（大笑）</description>
    </item>
    
    <item>
      <title>我终于变成了冬天的落汤鸡</title>
      <link>/posts/2022-1-5/</link>
      <pubDate>Wed, 05 Jan 2022 19:20:26 +0800</pubDate>
      
      <guid>/posts/2022-1-5/</guid>
      <description>Spring chicken，”春天里的小鸡“，这个词前一段时间总浮现在我脑海里，没想到，今天真成了冬天里的“落汤鸡”。
今天如同往常一样，在单位餐厅吃晚餐。正当吃完去放餐具时，在我旁边的一位女生，餐盘没拿稳，一大碗面汤撒在我身上……在事情发生前一刻，我还在想着别的什么事情；发生的那瞬间，我下意识伸手去扶；发生后的那一刻，我脑子还有点懵。恍惚之间，感觉我脑海里也幻想过这个场景。低头看下衣服，确认是真实发生的……因为放餐盘的时候需要把筷子什么的放到另一个盆里，必然有一刻是需要一只手拿筷子，一只手拿着餐盘，如果是吃面的话，碗里还有汤，会比较重，我以前还曾幻想过餐盘没拿稳撒到别人的场景，没想到今天真发生了！不过这角色互换了……这事很尴尬，肇事者不停道歉，我当时的想法是“今晚不用加班了……”，不过看到衣服上挂的面条还是没说出来，只能安慰她一下就溜回去了……</description>
    </item>
    
    <item>
      <title>《As I Began to Love Myself》</title>
      <link>/posts/asibegantolovemyself/</link>
      <pubDate>Mon, 03 Jan 2022 22:07:23 +0800</pubDate>
      
      <guid>/posts/asibegantolovemyself/</guid>
      <description>—— Charlie Chaplin
  As I began to love myself
I found that anguish and emotional suffering
are only warning signs
that I was living against my own truth.
Today, I know, this is “AUTHENTICITY”.
  当我真正开始爱自己
我才意识到，所有的痛苦和情感的折磨
仅仅是在提醒
我的生活背离了真正的自己
今日，我明白了，这叫做“真实“
  As I began to love myself
I understood how much it can offend somebody
if I try to force my desires on this person,</description>
    </item>
    
    <item>
      <title>你永远都不是独自一人</title>
      <link>/posts/2022-1-1/</link>
      <pubDate>Sat, 01 Jan 2022 22:44:04 +0800</pubDate>
      
      <guid>/posts/2022-1-1/</guid>
      <description>刚刚躺着的时候，我还在想着喵喵到哪去了。因为我在它的窝没看到，别的地方也没找到。还在想着，突然就听到它跳上床的声音……
今天给它伤口涂了些药，用酒精擦拭的时候它没有反抗，但后面它还是把伤口贴咬下来了。白天的时候，它就侧躺着在地上晒太阳，我看着它，它也在看着我。我玩手机的时候，它就跑到我怀里，枕着我的手。我能感受它呼吸，但，即使距离如此近，我仍不能理解它。因为人和动物无法交流，我不知道它是否在害怕，不知道它是否很痛苦。
人类也一样，也许无尽的未来中，人类也能实现“神圣的卡拉连接着我们每个人的思想“的梦想，但现在，每个人都是独立的，我们的大脑都在独立地思考。但是，目前是什么力量连接着我们呢？我想，答案，就在我们心中。</description>
    </item>
    
    <item>
      <title>相逢离别时</title>
      <link>/posts/2021-12-30/</link>
      <pubDate>Thu, 30 Dec 2021 22:21:26 +0800</pubDate>
      
      <guid>/posts/2021-12-30/</guid>
      <description>when the day meets the night, when the knife meets the fork, when you meet your soulmate.
—— Jessie
 在高中那会，我开始喜欢听电台音频。也不知道为了学英语，还是为了找到一个声音塞满思绪。这时，我遇到了 SoulmateEnglish 频道，刚听到 Jessie 的音频，我至今还记得那份感动。遗憾的是，SoulmateEnglish 频道很多年没更新了，我也以为再也不会遇见这个声音了。
然而缘总是很奇妙，在很久很久后的一天，我抓住了它的尾巴。在某个的平台里，我发现了活跃中的 SoulmateEnglish 频道，我当时感觉非常高兴，就在最新的作品下留言，Jessie 回复了。
我认为互联网最大的魅力便在于此，沿着历史的痕迹，你可以了解一个人的过往，了解当时他/她的喜怒哀乐，只要有两台设备，它就可以让两个人跨越时间、空间的界限，进行交流。</description>
    </item>
    
    <item>
      <title>C Primer 之 new, delete</title>
      <link>/posts/cprimer04/</link>
      <pubDate>Thu, 30 Dec 2021 07:13:11 +0800</pubDate>
      
      <guid>/posts/cprimer04/</guid>
      <description>转载自https://github.com/andycai/cprimer
new和delete运算符用于动态分配和撤销内存的运算符
(1) new用法 🔗 开辟单变量地址空间    new int; //开辟一个存放数组的存储空间,返回一个指向该存储空间的地址.int *a = new int 即为将一个int类型的地址赋值给整型指针a.
  int *a = new int(5) 作用同上,但是同时将整数赋值为5
   开辟数组空间
一维:
 int *a = new int[100]; // 开辟一个大小为100的整型数组空间 二维:
 int **a = new int[5][6] 三维及其以上:依此类推
  一般用法: new 类型 [初值]
(2) delete用法 🔗  int *a = new int;
 delete a; //释放单个int的空间   int *a = new int[5];</description>
    </item>
    
    <item>
      <title>C Primer 之 char*, char[], string</title>
      <link>/posts/cprimer03/</link>
      <pubDate>Thu, 30 Dec 2021 07:12:45 +0800</pubDate>
      
      <guid>/posts/cprimer03/</guid>
      <description>转载自https://github.com/andycai/cprimer
3.1 char*, char[], string 🔗在C中，并没有字符串这个数据类型，而是使用字符数组来保存字符串。C字符串实际上就是一个以null(&amp;rsquo;\0&amp;rsquo;)字符结尾的字符数组，null字符表示字符串的结束。需要注意的是：只有以null字符结尾的字符数组才是C字符串，否则只是一般的C字符数组。
C字符串定义时可以利用&amp;quot;=&amp;ldquo;号进行初始化，但是以后不能利用&amp;rdquo;=&amp;ldquo;对C字符串进行赋值。对C字符串的操作需要通过&amp;quot;string&amp;quot;文件中定义的字符串处理函数。例如：
//字符串的初始化char a[11] = &amp;quot;huanying&amp;quot;;//字符串的赋值strcpy(a,&amp;quot;nihao&amp;quot;)//获取字符串的长度，不包括&#39;\0&#39;在内strlen(a);printf(&amp;quot;%s&amp;quot;,a); 在C中也可以使用字符指针来访问一个字符串,通过字符指针指向存放字符串数组的首元素地址来进行访问. char *a = &amp;ldquo;nihao&amp;rdquo;; printf(&amp;quot;%s&amp;rdquo;,a);
在C++中则把字符串封装成了一种数据类型string,可以直接声明变量并进行赋值等字符串操作。以下是C字符串和C++中string的区别：
 C字符串 string对象所需的头文件名称 &amp;lt;string&amp;gt;或&amp;lt;string.h&amp;gt; &amp;lt;string&amp;gt;或&amp;lt;string.h&amp;gt;为什么需要头文件 为了使用字符串函数 为了使用string类如何声明 char name[20]; string name;如何初始化 char name[20]=&amp;quot;nihao&amp;quot;; string name = &amp;quot;nihao&amp;quot;;必须声明字符串长度么？	是 否使用一个null字符么？ 是 否怎样实现字符串赋值 strcpy(name,&amp;quot;John&amp;quot;); name = &amp;quot;John&amp;quot;;其他优点 更快 更易于使用，优选方案可以赋一个比现有字符更 不能 可以长的字符串么？  (1) C++常用字符串函数 🔗char s1[]=&amp;quot;I am a student&amp;quot;;char s2[20]=&amp;quot;teacher&amp;quot;;char s3[]=&amp;quot;student&amp;quot;;int result;char s4[20],*p;   串长度 int strlen(char *str)</description>
    </item>
    
    <item>
      <title>C Primer 之 指针和引用</title>
      <link>/posts/cprimer02/</link>
      <pubDate>Thu, 30 Dec 2021 07:12:43 +0800</pubDate>
      
      <guid>/posts/cprimer02/</guid>
      <description>转载自https://github.com/andycai/cprimer
2.1 refrence 引用 🔗引用是C++中的概念，初学者容易把引用和指针混淆一起。以下程序中，n 是 m 的一个引用（reference），m 是被引用物（referent）。
int m; int &amp;amp;n = m; n 相当于 m 的别名（绰号），对 n 的任何操作就是对m的操作。所以 n 既不是 m 的拷贝，也不是指向 m 的指针，其实 n 就是 m 它自己。
引用的规则：
 引用被创建的同时必须被初始化（指针则可以在任何时候被初始化）。 不能有NULL引用，引用必须与合法的存储单元关联（指针则可以是NULL）。 一旦引用被初始化，就不能改变引用的关系（指针则可以随时改变所指的对象）。  以下示例程序中，k 被初始化为 i 的引用。语句 k = j 并不能将 k 修改成为 j 的引用，只是把 k 的值改变成为6。由于 k 是 i 的引用，所以 i 的值也变成了6。
int i = 5; int j = 6; int &amp;amp;k = i; k = j; // k和i的值都变成了6;  引用的主要功能是传递函数的参数和返回值。</description>
    </item>
    
    <item>
      <title>C Primer 之 const, inline, static, this</title>
      <link>/posts/cprimer01/</link>
      <pubDate>Thu, 30 Dec 2021 07:12:38 +0800</pubDate>
      
      <guid>/posts/cprimer01/</guid>
      <description>转载自https://github.com/andycai/cprimer
1.1 const 🔗(1) const 基础 🔗如果const关键字不涉及到指针，我们很好理解，下面是涉及到指针的情况：
int b = 500;const int* a = &amp;amp;b; [1]int const *a = &amp;amp;b; [2]int* const a = &amp;amp;b; [3]const int* const a = &amp;amp;b; [4] 如果你能区分出上述四种情况，那么，恭喜你，你已经迈出了可喜的一步。不知道，也没关系，我们可以参考《Effective c++》Item21上的做法， 如果 const 位于星号的左侧，则 const 就是用来修饰指针所指向的变量，即指针指向为常量；如果 const 位于星号的右侧，const 就是修饰指针本身，即指针本身是常量。
因此，[1]和[2]的情况相同，都是指针所指向的内容为常量（const放在变量声明符的位置无关），这种情况下不允许对内容进行更改操作，如不能*a = 3；[3]为指针本身是常量，而指针所指向的内容不是常量，这种情况下不能对指针本身进行更改操作，如a++是错误的；[4]为指针本身和指向的内容均为常量。
(2) 作为参数 🔗void display(const double&amp;amp; r);void display(const double* r); 说明:
 在引用或者指针参数的时候使用 const 限制是有意义的，而对于值传递的参数使用 const 则没有意义 保证引用的变量的值不被改变 const 在 double 前或者后面意思相同，只是不同的人的写法不同  (3) const对象 🔗声明为 const 的对象只能访问类中声明为 const 的成员函数，不能调用其它成员函数。</description>
    </item>
    
    <item>
      <title>面向对象设计原则之开闭原则</title>
      <link>/posts/oop/</link>
      <pubDate>Tue, 28 Dec 2021 08:07:08 +0800</pubDate>
      
      <guid>/posts/oop/</guid>
      <description>转载自https://blog.csdn.net/lovelion/article/details/17517213
开闭原则是面向对象的可复用设计的第一块基石，它是最重要的面向对象设计原则。开闭原则由Bertrand Meyer于1988年提出，其定义如下：
 开闭原则(Open-Closed Principle, OCP)：一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。
 在开闭原则的定义中，软件实体可以指一个软件模块、一个由多个类组成的局部结构或一个独立的类。
任何软件都需要面临一个很重要的问题，即它们的需求会随时间的推移而发生变化。当软件系统需要面对新的需求时，我们应该尽量保证系统的设计框架是稳定的。如果一个软件设计符合开闭原则，那么可以非常方便地对系统进行扩展，而且在扩展时无须修改现有代码，使得软件系统在拥有适应性和灵活性的同时具备较好的稳定性和延续性。随着软件规模越来越大，软件寿命越来越长，软件维护成本越来越高，设计满足开闭原则的软件系统也变得越来越重要。
为了满足开闭原则，需要对系统进行抽象化设计，抽象化是开闭原则的关键。在Java、C#等编程语言中，可以为系统定义一个相对稳定的抽象层，而将不同的实现行为移至具体的实现层中完成。在很多面向对象编程语言中都提供了接口、抽象类等机制，可以通过它们定义系统的抽象层，再通过具体类来进行扩展。如果需要修改系统的行为，无须对抽象层进行任何改动，只需要增加新的具体类来实现新的业务功能即可，实现在不修改已有代码的基础上扩展系统的功能，达到开闭原则的要求。
 Sunny软件公司开发的CRM系统可以显示各种类型的图表，如饼状图和柱状图等，为了支持多种图表显示方式，原始设计方案如图1所示：
 图1 初始设计方案结构图
在ChartDisplay类的display()方法中存在如下代码片段：
...... if (type.equals(&amp;#34;pie&amp;#34;)) { PieChart chart = new PieChart(); chart.display(); } else if (type.equals(&amp;#34;bar&amp;#34;)) { BarChart chart = new BarChart(); chart.display(); } ...... 在该代码中，如果需要增加一个新的图表类，如折线图LineChart，则需要修改ChartDisplay类的display()方法的源代码，增加新的判断逻辑，违反了开闭原则。
现对该系统进行重构，使之符合开闭原则。
在本实例中，由于在ChartDisplay类的display()方法中针对每一个图表类编程，因此增加新的图表类不得不修改源代码。可以通过抽象化的方式对系统进行重构，使之增加新的图表类时无须修改源代码，满足开闭原则。具体做法如下：
(1) 增加一个抽象图表类AbstractChart，将各种具体图表类作为其子类；
(2) ChartDisplay类针对抽象图表类进行编程，由客户端来决定使用哪种具体图表。
重构后结构如图2所示：
图2 重构后的结构图
在图2中，我们引入了抽象图表类AbstractChart，且ChartDisplay针对抽象图表类进行编程，并通过setChart()方法由客户端来设置实例化的具体图表对象，在ChartDisplay的display()方法中调用chart对象的display()方法显示图表。如果需要增加一种新的图表，如折线图LineChart，只需要将LineChart也作为AbstractChart的子类，在客户端向ChartDisplay中注入一个LineChart对象即可，无须修改现有类库的源代码。
注意：因为xml和properties等格式的配置文件是纯文本文件，可以直接通过VI编辑器或记事本进行编辑，且无须编译，因此在软件开发中，一般不把对配置文件的修改认为是对系统源代码的修改。如果一个系统在扩展时只涉及到修改配置文件，而原有的Java代码或C#代码没有做任何修改，该系统即可认为是一个符合开闭原则的系统。</description>
    </item>
    
    <item>
      <title>面向对象设计原则之单一职责原则</title>
      <link>/posts/singleresponsibility/</link>
      <pubDate>Tue, 28 Dec 2021 07:40:16 +0800</pubDate>
      
      <guid>/posts/singleresponsibility/</guid>
      <description>转载自https://blog.csdn.net/lovelion/article/details/17517213
单一职责原则是最简单的面向对象设计原则，它用于控制类的粒度大小。单一职责原则定义如下：
单一职责原则(Single Responsibility Principle, SRP)：一个类只负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。
单一职责原则告诉我们：一个类不能太“累”！在软件系统中，一个类（大到模块，小到方法）承担的职责越多，它被复用的可能性就越小，而且一个类承担的职责过多，就相当于将这些职责耦合在一起，当其中一个职责变化时，可能会影响其他职责的运作，因此要将这些职责进行分离，将不同的职责封装在不同的类中，即将不同的变化原因封装在不同的类中，如果多个职责总是同时发生改变则可将它们封装在同一类中。
单一职责原则是实现高内聚、低耦合的指导方针，它是最简单但又最难运用的原则，需要设计人员发现类的不同职责并将其分离，而发现类的多重职责需要设计人员具有较强的分析设计能力和相关实践经验。
下面通过一个简单实例来进一步分析单一职责原则：
 Sunny软件公司开发人员针对某CRM（Customer Relationship Management，客户关系管理）系统中客户信息图形统计模块提出了如图1所示初始设计方案：
 图1 初始设计方案结构图
 在图1中，CustomerDataChart类中的方法说明如下：getConnection()方法用于连接数据库，findCustomers()用于查询所有的客户信息，createChart()用于创建图表，displayChart()用于显示图表。
 现使用单一职责原则对其进行重构。
在图1中，CustomerDataChart类承担了太多的职责，既包含与数据库相关的方法，又包含与图表生成和显示相关的方法。如果在其他类中也需要连接数据库或者使用findCustomers()方法查询客户信息，则难以实现代码的重用。无论是修改数据库连接方式还是修改图表显示方式都需要修改该类，它不止一个引起它变化的原因，违背了单一职责原则。因此需要对该类进行拆分，使其满足单一职责原则，类CustomerDataChart可拆分为如下三个类：
(1) DBUtil：负责连接数据库，包含数据库连接方法getConnection()；
(2) CustomerDAO：负责操作数据库中的Customer表，包含对Customer表的增删改查等方法，如findCustomers()；
(3) CustomerDataChart：负责图表的生成和显示，包含方法createChart()和displayChart()。
使用单一职责原则重构后的结构如图2所示：
图2 重构后的结构图</description>
    </item>
    
    <item>
      <title>面向对象设计原则概述</title>
      <link>/posts/oop/</link>
      <pubDate>Tue, 28 Dec 2021 06:59:01 +0800</pubDate>
      
      <guid>/posts/oop/</guid>
      <description>转载自https://blog.csdn.net/lovelion/article/details/17517213
对于面向对象软件系统的设计而言，在支持可维护性的同时，提高系统的可复用性是一个至关重要的问题，如何同时提高一个软件系统的可维护性和可复用性是面向对象设计需要解决的核心问题之一。在面向对象设计中，可维护性的复用是以设计原则为基础的。每一个原则都蕴含一些面向对象设计的思想，可以从不同的角度提升一个软件结构的设计水平。
面向对象设计原则为支持可维护性复用而诞生，这些原则蕴含在很多设计模式中，它们是从许多设计方案中总结出的指导性原则。面向对象设计原则也是我们用于评价一个设计模式的使用效果的重要指标之一，在设计模式的学习中，大家经常会看到诸如“XXX模式符合XXX原则”、“XXX模式违反了XXX原则”这样的语句。
最常见的7种面向对象设计原则如下表所示：</description>
    </item>
    
    <item>
      <title>简单工厂模式</title>
      <link>/posts/singlefactory/</link>
      <pubDate>Tue, 28 Dec 2021 06:50:56 +0800</pubDate>
      
      <guid>/posts/singlefactory/</guid>
      <description>转载自https://blog.csdn.net/lovelion/article/details/17517213
工厂模式是最常用的一类创建型设计模式，通常我们所说的工厂模式是指工厂方法模式，它也是使用频率最高的工厂模式。本章将要学习的简单工厂模式是工厂方法模式的“小弟”，它不属于GoF 23种设计模式，但在软件开发中应用也较为频繁，通常将它作为学习其他工厂模式的入门。此外，工厂方法模式还有一位“大哥”——抽象工厂模式。这三种工厂模式各具特色，难度也逐个加大，在软件开发中它们都得到了广泛的应用，成为面向对象软件中常用的创建对象的工具。
一、图表库的设计 🔗 Sunny软件公司欲基于Java语言开发一套图表库，该图表库可以为应用系统提供各种不同外观的图表，例如柱状图、饼状图、折线图等。Sunny软件公司图表库设计人员希望为应用系统开发人员提供一套灵活易用的图表库，而且可以较为方便地对图表库进行扩展，以便能够在将来增加一些新类型的图表。
 Sunny软件公司图表库设计人员提出了一个初始设计方案，将所有图表的实现代码封装在一个Chart类中，其框架代码如下所示：
class Chart { private String type; //图表类型  public Chart(Object[][] data, String type) { this.type = type; if (type.equalsIgnoreCase(&amp;#34;histogram&amp;#34;)) {  //初始化柱状图 } else if (type.equalsIgnoreCase(&amp;#34;pie&amp;#34;)) {  //初始化饼状图 } else if (type.equalsIgnoreCase(&amp;#34;line&amp;#34;)) {  //初始化折线图 } }  public void display() { if (this.type.equalsIgnoreCase(&amp;#34;histogram&amp;#34;)) {  //显示柱状图 } else if (this.type.equalsIgnoreCase(&amp;#34;pie&amp;#34;)) {  //显示饼状图 } else if (this.type.equalsIgnoreCase(&amp;#34;line&amp;#34;)) {  //显示折线图 }	} } 客户端代码通过调用Chart类的构造函数来创建图表对象，根据参数type的不同可以得到不同类型的图表，然后再调用display()方法来显示相应的图表。</description>
    </item>
    
    <item>
      <title>喵喵和狗子</title>
      <link>/posts/2021-12-27/</link>
      <pubDate>Mon, 27 Dec 2021 07:44:58 +0800</pubDate>
      
      <guid>/posts/2021-12-27/</guid>
      <description>这两张照片都是喵喵，狗子没有上镜。狗子就是前面有提到的罗小白，不过它现在已经不白了，而且因为它闯下的大祸，已经剥夺了它的取名资格……
狗子非常缠人，在它的世界里，恐怕只有玩和吃，折腾没有一刻停止过。每次有客人来都会缠着走。家里本来也不怎么喜欢狗，更何况它又烦人，又比较脏（狗子很抗拒洗澡，每次给它洗澡都很困难）。久而久之，没人搭理它，它就消停一些了。
直到喵喵的到来。喵喵刚来那会，狗子一直追着它闹。然后喵喵就到处找地方藏。第一张图片就是这个时候拍的，它刚好找到了我，正准备到我肩膀上来。
直到后来有一天，狗子又追着喵喵跑，喵喵到处躲。不幸的是，这时候喵喵被车压到了……我猜想它是想躲到车底下，但是它不知道开着的车并不像往常那么安全……不幸中的万幸是只压到了腿。
喵喵左后腿受伤严重，开始那会几乎没有食欲。狗子好像也自知闯了大祸，也同样精神萎靡。
第二张图片，喵喵伤口又不小心又被扯到了（左腿白色毛那里）。那天晚上天很冷，它窝在凳子上就睡着了。</description>
    </item>
    
    <item>
      <title>由 hpp 头文件引发 C&#43;&#43; 编译的思考</title>
      <link>/posts/hpp/</link>
      <pubDate>Sun, 26 Dec 2021 12:55:54 +0800</pubDate>
      
      <guid>/posts/hpp/</guid>
      <description>前一阵子，我注意到一位项目组新成员喜欢使用 hpp 头文件的方式来写，他解释说很多开源库都是以这样的方式实现，还问我 hpp 头文件和 h + cpp 方式的区别。这个问题很麻烦，解释起来可能需要理一遍 C++ 基础，对此，我劝告他：从本质来说 hpp 是将声明和实现放在一个文件，而 h + cpp 是将声明和实现分开在两个文件，采用 hpp 这种方式也是可以的，但是必须要清楚它的局限。我本来是希望他去学习 C++ 基础，但没想到从这里就埋下了一个坑，导致这篇文章的产生&amp;hellip;..
很快，遇到第一个问题，redefined identifier。我解释说，这是重复 include hpp 文件引入实现，会引发这个重定义的问题。使用 #ifndef 可以防止头文件被重复包含和引入。
过了一阵，又遇到新的问题。我过去一看，循环依赖。第一个坑出现了。A 依赖 B，B 又 依赖 A，如果用 hpp 实现的话，那A、B 都互相包含对方，无尽循环……所以这种情况只能老老实实用回 h + cpp 的方式了，A 依赖 B，就在 A 的头文件中前向声明 B，然后在源文件中 include B，B 也如此操作。
就这样过了很久很久，突然有一天，我发现有很多库都需要重新编译，奇怪的是这些库不应该有改动的。一看是依赖的一个底层动态库发生变化，再看，是这个库里的一个 hpp 文件发生变化。大坑，我最开始的时候提醒过的。 那个库本身就有别的坑，实际上它更应该是静态库，但因为客观原因，它暂时还是一个动态库。然后就这样，一个 hpp 文件被嵌入这个底层动态库对外开放的接口里面。它一改动，所有依赖这个库的库都需要重新编译，还真是“牵一发而动全身”啊。
补充 🔗一、#include 指令
#include &amp;#34;test.hpp&amp;#34; C++ 会使用一个预处理器，在进行主编译之前对源文件进行处理，它会在编译程序时自动运行。上面所示 #include &amp;ldquo;test.hpp&amp;rdquo;，该编译指令导致预处理器将 test.hpp 文件的内容添加到程序中。实际上，test.hpp 文件的内容将取代程序中的代码行 #include &amp;ldquo;test.hpp&amp;rdquo;。原始文件没有被修改，而是将源码和 test.hpp 文件组合成一个复合文件，编译的下一个阶段将使用该文件。</description>
    </item>
    
    <item>
      <title>设计模式概述</title>
      <link>/posts/design/</link>
      <pubDate>Sun, 26 Dec 2021 10:10:12 +0800</pubDate>
      
      <guid>/posts/design/</guid>
      <description>在软件开发生命周期的每一个阶段都存在着一些被认同的模式。
在软件模式中，设计模式是研究最为深入的分支，设计模式用于在特定的调剂爱你下为一些重复出现的软件设计问题提供合理的、有效的解决方案。
一般定义：设计模式（Design Pattern)是一套被反复使用、多数人知晓的、进过分类编目的代码设计经验的总结，使用设计模式是为了可重用代码、让代码更容易被他人理解并且保证代码可靠性。
狭义的设计模式是指 GoF 在《设计模式：可复用面向对象软件的基础》一书中所介绍的23种经典设计模式。不过设计模式并不仅仅只有这23种，越来越多的新模式不断诞生并得以应用。
23 种设计模式根据用途可分为创建型、结构型和行为型三种。其中创建型模式主要用于描述如何创建对象，结构型模式主要用于描述如何实现类或对象的组合，行为型模式主要用于描述类或对象怎样交互以及怎样分配职责。
值得注意的是，简单工厂模式没有在 23 种设计模式里面，但一般都会对它进行说明。</description>
    </item>
    
    <item>
      <title>栈和队列</title>
      <link>/posts/stackqueue/</link>
      <pubDate>Sun, 26 Dec 2021 09:14:03 +0800</pubDate>
      
      <guid>/posts/stackqueue/</guid>
      <description>从数据结构的角度看，栈和队列是操作受限的线性表，栈和队列的数据元素具有单一的前驱和后继的线性关系。
栈 🔗定义：栈是限定仅在表尾进行插入和删除操作的线性表，允许插入和删除的一端称为栈顶，另一端成为栈底。
栈中元素除了具有线性关系外，还具有后进先出的特性。
需要注意的是，栈只是对线性表的插入和删除操作的位置进行了限制，并没有限定插入和删除操作进行的时间，也就是说，出栈可以随时进行，只要某个元素位于栈顶就可以出栈。
栈的顺序存储结构——顺序栈 🔗顺序栈的本质是顺序表的简化，唯一需要确定的是用数组的哪一端表示栈底。通常把数组下标为0的一端称为栈底，同时附设指针 top 指示栈顶元素在数组中的位置。
设存储栈元素的数组长度为 StackSize,则栈空时栈顶指针 top=-1；栈满时栈顶指针 top=StackSize-1。入栈时，栈顶指针 top 加 1；出栈时，栈顶指针 top 减 1。
栈的链接存储结构——链栈 🔗通常链栈用单链表表示。因为只能在栈顶执行插入和删除操作，显然以单链表的头部作为栈顶是最方便的。
队列 🔗定义：队列是只允许在一端进行插入操作，在另一端进行删除操作的线性表，允许插入（也称入队、进队）的一端成为队尾，允许删除（也称出队）的一端成为队头。
队中元素除了具有线性关系外，还具有先进先出的特性。
队列的顺序存储结构——循环队列 🔗队列是特殊的线性表，从这个出发点来考虑队列的顺序存储问题。
将存储队列的数组看成头尾相接的循环结构，即允许队列直接从数组中下标最大的位置延续到下标最小的位置，这通过取模操作很容易实现。队列的这种头尾相接的顺序存储结构称为循环队列。
要注意的是，在循环队列中还有一个很重要的问题：队空和队满的判定问题。</description>
    </item>
    
    <item>
      <title>面向对象思想</title>
      <link>/posts/2021-12-22-oop/</link>
      <pubDate>Wed, 22 Dec 2021 23:41:54 +0800</pubDate>
      
      <guid>/posts/2021-12-22-oop/</guid>
      <description>面向对象思想 🔗 面向对象思想  一、三大特性  封装 继承 多态   二、类图  泛化关系 (Generalization) 实现关系 (Realization) 聚合关系 (Aggregation) 组合关系 (Composition) 关联关系 (Association) 依赖关系 (Dependency)   三、设计原则  S.O.L.I.D 其他常见原则   参考资料    一、三大特性 🔗封装 🔗利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体。数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外的接口使其与外部发生联系。用户无需关心对象内部的细节，但可以通过对象对外提供的接口来访问该对象。
优点：
 减少耦合：可以独立地开发、测试、优化、使用、理解和修改 减轻维护的负担：可以更容易被理解，并且在调试的时候可以不影响其他模块 有效地调节性能：可以通过剖析来确定哪些模块影响了系统的性能 提高软件的可重用性 降低了构建大型系统的风险：即使整个系统不可用，但是这些独立的模块却有可能是可用的  以下 Person 类封装 name、gender、age 等属性，外界只能通过 get() 方法获取一个 Person 对象的 name 属性和 gender 属性，而无法获取 age 属性，但是 age 属性可以供 work() 方法使用。
注意到 gender 属性使用 int 数据类型进行存储，封装使得用户注意不到这种实现细节。并且在需要修改 gender 属性使用的数据类型时，也可以在不影响客户端代码的情况下进行。</description>
    </item>
    
    <item>
      <title>缓存</title>
      <link>/posts/2021-12-22-cache/</link>
      <pubDate>Wed, 22 Dec 2021 23:37:55 +0800</pubDate>
      
      <guid>/posts/2021-12-22-cache/</guid>
      <description>缓存 🔗 缓存  一、缓存特征 二、缓存位置 三、CDN 四、缓存问题 五、数据分布 六、一致性哈希 七、LRU 参考资料    一、缓存特征 🔗命中率 🔗当某个请求能够通过访问缓存而得到响应时，称为缓存命中。
缓存命中率越高，缓存的利用率也就越高。
最大空间 🔗缓存通常位于内存中，内存的空间通常比磁盘空间小的多，因此缓存的最大空间不可能非常大。
当缓存存放的数据量超过最大空间时，就需要淘汰部分数据来存放新到达的数据。
淘汰策略 🔗  FIFO（First In First Out）：先进先出策略，在实时性的场景下，需要经常访问最新的数据，那么就可以使用 FIFO，使得最先进入的数据（最晚的数据）被淘汰。
  LRU（Least Recently Used）：最近最久未使用策略，优先淘汰最久未使用的数据，也就是上次被访问时间距离现在最久的数据。该策略可以保证内存中的数据都是热点数据，也就是经常被访问的数据，从而保证缓存命中率。
  LFU（Least Frequently Used）：最不经常使用策略，优先淘汰一段时间内使用次数最少的数据。
  二、缓存位置 🔗浏览器 🔗当 HTTP 响应允许进行缓存时，浏览器会将 HTML、CSS、JavaScript、图片等静态资源进行缓存。
ISP 🔗网络服务提供商（ISP）是网络访问的第一跳，通过将数据缓存在 ISP 中能够大大提高用户的访问速度。
反向代理 🔗反向代理位于服务器之前，请求与响应都需要经过反向代理。通过将数据缓存在反向代理，在用户请求反向代理时就可以直接使用缓存进行响应。
本地缓存 🔗使用 Guava Cache 将数据缓存在服务器本地内存中，服务器代码可以直接读取本地内存中的缓存，速度非常快。
分布式缓存 🔗使用 Redis、Memcache 等分布式缓存将数据缓存在分布式缓存系统中。
相对于本地缓存来说，分布式缓存单独部署，可以根据需求分配硬件资源。不仅如此，服务器集群都可以访问分布式缓存，而本地缓存需要在服务器集群之间进行同步，实现难度和性能开销上都非常大。
数据库缓存 🔗MySQL 等数据库管理系统具有自己的查询缓存机制来提高查询效率。
Java 内部的缓存 🔗Java 为了优化空间，提高字符串、基本数据类型包装类的创建效率，设计了字符串常量池及 Byte、Short、Character、Integer、Long、Boolean 这六种包装类缓冲池。</description>
    </item>
    
    <item>
      <title>Redis</title>
      <link>/posts/2021-12-22-redis/</link>
      <pubDate>Wed, 22 Dec 2021 23:34:10 +0800</pubDate>
      
      <guid>/posts/2021-12-22-redis/</guid>
      <description>Redis 🔗 Redis  一、概述 二、数据类型  STRING LIST SET HASH ZSET   三、数据结构  字典 跳跃表   四、使用场景  计数器 缓存 查找表 消息队列 会话缓存 分布式锁实现 其它   五、Redis 与 Memcached  数据类型 数据持久化 分布式 内存管理机制   六、键的过期时间 七、数据淘汰策略 八、持久化  RDB 持久化 AOF 持久化   九、事务 十、事件  文件事件 时间事件 事件的调度与执行   十一、复制  连接过程 主从链   十二、Sentinel 十三、分片 十四、一个简单的论坛系统分析  文章信息 点赞功能 对文章进行排序   参考资料    一、概述 🔗Redis 是速度非常快的非关系型（NoSQL）内存键值数据库，可以存储键和五种不同类型的值之间的映射。</description>
    </item>
    
    <item>
      <title>SQL 练习</title>
      <link>/posts/2021-12-22-sqldemo/</link>
      <pubDate>Wed, 22 Dec 2021 23:32:38 +0800</pubDate>
      
      <guid>/posts/2021-12-22-sqldemo/</guid>
      <description>SQL 练习 🔗 SQL 练习  595. Big Countries 627. Swap Salary 620. Not Boring Movies 596. Classes More Than 5 Students 182. Duplicate Emails 196. Delete Duplicate Emails 175. Combine Two Tables 181. Employees Earning More Than Their Managers 183. Customers Who Never Order 184. Department Highest Salary 176. Second Highest Salary 177. Nth Highest Salary 178. Rank Scores 180. Consecutive Numbers 626. Exchange Seats    595. Big Countries 🔗https://leetcode.</description>
    </item>
    
    <item>
      <title>Mysql</title>
      <link>/posts/2021-12-22-mysql/</link>
      <pubDate>Wed, 22 Dec 2021 23:30:39 +0800</pubDate>
      
      <guid>/posts/2021-12-22-mysql/</guid>
      <description>MySQL 🔗 MySQL  一、索引  B+ Tree 原理 MySQL 索引 索引优化 索引的优点 索引的使用条件   二、查询性能优化  使用 Explain 进行分析 优化数据访问 重构查询方式   三、存储引擎  InnoDB MyISAM 比较   四、数据类型  整型 浮点数 字符串 时间和日期   五、切分  水平切分 垂直切分 Sharding 策略 Sharding 存在的问题   六、复制  主从复制 读写分离   参考资料    一、索引 🔗B+ Tree 原理 🔗1. 数据结构 🔗B Tree 指的是 Balance Tree，也就是平衡树。平衡树是一颗查找树，并且所有叶子节点位于同一层。</description>
    </item>
    
    <item>
      <title>数据库系统原理</title>
      <link>/posts/2021-12-22-database/</link>
      <pubDate>Wed, 22 Dec 2021 23:28:00 +0800</pubDate>
      
      <guid>/posts/2021-12-22-database/</guid>
      <description>数据库系统原理 🔗 数据库系统原理  一、事务  概念 ACID AUTOCOMMIT   二、并发一致性问题  丢失修改 读脏数据 不可重复读 幻影读   三、封锁  封锁粒度 封锁类型 封锁协议 MySQL 隐式与显式锁定   四、隔离级别  未提交读（READ UNCOMMITTED） 提交读（READ COMMITTED） 可重复读（REPEATABLE READ） 可串行化（SERIALIZABLE）   五、多版本并发控制  基本思想 版本号 Undo 日志 ReadView 快照读与当前读   六、Next-Key Locks  Record Locks Gap Locks Next-Key Locks   七、关系数据库设计理论  函数依赖 异常 范式   八、ER 图  实体的三种联系 表示出现多次的关系 联系的多向性 表示子类   参考资料    一、事务 🔗概念 🔗事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。</description>
    </item>
    
    <item>
      <title>湖の決心</title>
      <link>/posts/2021-12-21-3/</link>
      <pubDate>Tue, 21 Dec 2021 23:21:29 +0800</pubDate>
      
      <guid>/posts/2021-12-21-3/</guid>
      <description> 運命を信じますか
【相信命运吗】
そしてそれに従いますか
【顺从于命运吗】
私は 私は
【我，我】
あなたに従います
【顺从于你】
白い鳥が仲良く
【白鸟友好地】
水をあびています
【戏水】
悪い人は訪ねて来ない
【没有坏人来访的】
名も知らぬ湖
【不知名的湖】
向こう岸をめがけて
【瞄准对岸】
石を投げたあなた
【扔石头的你】
波の渦が広がるように
【就像波浪的漩涡不断在扩张一样】
私の心も乱れます
【我也心乱如麻】
もしかしたらあなたに対して
【如果对你】
好意以上の気持を抱いてます
【有了好感以上的感情】
そしてそれはふたりにとっては
【那对我们两个人】
危険なことかも知れません
【可能是件危险的事情】
ひとつだけ教えて下さい
【只告诉我一件事】
倖せになれるでしょうか
【我能幸福吗】
赤い薔薇が一枝
【一枝红色的蔷薇】 水に浮いています
【浮在水面】
風の音もはばかるような
【风声更加猛烈的】
名も知らぬ湖
【不知名的湖】
ひとり何か悩んで
【一个人烦恼着】
ほほをぬらすあなた
【湿润了脸颊的你】
青い色に溶け込むように
【溶解在这片蓝色里】
私も一緒に泣いてます
【我也和你一起哭泣】
いつも私あなたのためなら
【我总是有为了你】
すべて投げ出す
【抛弃所有】
覚悟が出来てます
【的觉悟】
そしてそれでふたりの間が
【所以两个人之间】
終りを告げてもいいのです
【就算宣告结束也可以】
ひとつだけ教えて下さい
【只告诉我一件事】
倖せになれるでしょうか
【会幸福吗】
 </description>
    </item>
    
    <item>
      <title>裸足のフローネ</title>
      <link>/posts/2021-12-21-2/</link>
      <pubDate>Tue, 21 Dec 2021 23:09:27 +0800</pubDate>
      
      <guid>/posts/2021-12-21-2/</guid>
      <description> 潮風を頬にうけ
裸足で駆けてく
ふり向けば白い砂
わたしの足跡
ほら飲んでごらん
冷たい水を上げましょう
ほら空をごらん
カモメも飛ぶわよろしくネ
どんな淋しい時でも
わたしは負けないわ
潮風を頬にうけ
裸足で駆けてく
ふり向けば白い砂
わたしの足跡
ほら赤く燃える
焚火かこんで話すの
おいでわたしの膝に
あたたかい夢見るのよ
悲しい時こそ笑顔で
みんなを励ますわ
さざ波がうち寄せる
小さな珊瑚礁
見上げれば星空に
明日が広がる
どんな淋しい時でも
わたしは負けないわ
潮風を頬にうけ
裸足で駆けてく
ふり向けば白い砂
わたしの足跡
 </description>
    </item>
    
    <item>
      <title>山のごちそう</title>
      <link>/posts/2021-12-21-1/</link>
      <pubDate>Tue, 21 Dec 2021 23:09:24 +0800</pubDate>
      
      <guid>/posts/2021-12-21-1/</guid>
      <description>静かな山小屋の 朝ごはんは
木の葉のいいにおい さやさや風よ
ホルディア
ホルディヒヒヤ ホルディクク
ホルディヒヒヤ ホルディクク
ホルディヒヒヤ ホルディクク
ホルディヒヒヤ ホー
空にはちぎれ雲 スプーンでどうぞ
バナナものせましょう アイスクリーム
ホルディア
ホルディヒヒヤ ホルディクク
ホルディヒヒヤ ホルディクク
ホルディヒヒヤ ホルディクク
ホルディヒヒヤ ホー
はるかな山々は 真っ赤に染まる
谷間に白い霧 ミルクのようだ
ホルディア
ホルディヒヒヤ ホルディクク
ホルディヒヒヤ ホルディクク
ホルディヒヒヤ ホルディクク
ホルディヒヒヤ ホー
夜です山小屋の 一番のごちそう
パチパチ燃える火と みんなの歌よ
ホルディア
ホルディヒヒヤ ホルディクク
ホルディヒヒヤ ホルディクク
ホルディヒヒヤ ホルディクク
ホルディヒヒヤ ホー
  在寂静的山间小屋里 有树叶的芳香，有风儿的沙沙声 度假 度假 嘿嘿呀 度假 库库 度假 嘿嘿呀 度假 库库
度假 嘿嘿呀 度假 库库</description>
    </item>
    
    <item>
      <title>ドレミの歌</title>
      <link>/posts/2021-12-21/</link>
      <pubDate>Tue, 21 Dec 2021 22:36:52 +0800</pubDate>
      
      <guid>/posts/2021-12-21/</guid>
      <description>ドはドーナツのド
レはレモンのレ
ミはみんなのミ
ファはファイトのファ
ソは青い空
ラはラッパのラ
シは幸せよ
さあ歌いましょう
ランランラン
ドはドーナツのド
レはレモンのレ
ミはみんなのミ
ファはファイトのファ
ソは青い空 ラはラッパのラ
シは幸せよ
さあ歌いましょう
ドレミファソラシド
ドシラソファミレ
ドミミミソソ
レファファラシシ
ドミミミソソ
レファファラシシ……
ソドラファミドレ
ソドラシドレド
どんなときにも
列を組んで
みんな楽しく
ファイトを持って
空を仰いで
ランララララララー
幸せの歌
さあ歌いましょう ドレミファソラシドソド
  do是甜甜圈的do
le是柠檬的le
mi是大家的mi
fa是战斗的fa
so是蔚蓝的天空
la是喇叭的la
xi是幸福的xi
那么，大家一起来唱吧
啷啷啷
do是甜甜圈的do
le是柠檬的le
mi是大家的mi
fa是战斗的fa
so是蔚蓝的天空
la是喇叭的la
xi是幸福的xi
那么大家一起来唱吧
do re mi fa so la xi do
do xi la fa mi le
do mi mi mi so so</description>
    </item>
    
    <item>
      <title>心の友</title>
      <link>/posts/2021-12-20/</link>
      <pubDate>Mon, 20 Dec 2021 23:40:15 +0800</pubDate>
      
      <guid>/posts/2021-12-20/</guid>
      <description> あなたから苦しみを奪えたその時
私にも生きてゆく勇気が湧いてくる
あなたと出会うまでは孤独なさすらい人
その手のぬくもりを 感じさせて
愛はいつもララバイ
旅に疲れた時
ただ心の友と
私を呼んで
信じあう心さえどこかに忘れて
人は何故 過ぎた日の幸せ追いかける
静かにまぶた閉じて心のドアを開き
私をつかんだら 涙ふいて
愛はいつもララバイ
あなたが弱い時
ただ心の友と
私を呼んで
愛はいつもララバイ
旅に疲れた時
ただ心の友と
私を呼んで
  当你的痛苦消失不见时
我也满怀生存的勇气
在未遇见你之前一直都是孤单一人
让我感受双手的温馨
爱如同催眠曲
当旅途劳顿时
只有交心的朋友
对我呼喊着
相契的心已忘记身在何处
人们为何 总是缅怀旧日时光
静静地闭上眼睛打开心扉
我所能拥有的 只有泪水
爱如同催眠曲
当你虚弱无依时
只有交心的朋友
对我呼喊着
爱如同催眠曲
当旅途劳顿时
只有交心的朋友
对我呼喊着
 </description>
    </item>
    
    <item>
      <title>愛になりたい</title>
      <link>/posts/2021-12-20-2/</link>
      <pubDate>Mon, 20 Dec 2021 23:40:15 +0800</pubDate>
      
      <guid>/posts/2021-12-20-2/</guid>
      <description>Dream…
金色の星屑(ほし)を集め
君のイニシャル　落書き
Dream…
悲しみに負けちゃダメよ
銀の鏡に呪文をかけたの
夜空にまわしたオルゴール
夢の中まで
君を追いかけてあげる
その手で瞳を抱きしめて
私　いつだって
あなたの愛になりたい
Dream…
眠れないこんな夜は
月にしずくの　ベランダ
Dream…
君と　そう　はしゃいだ日は
パジャマの胸が　まだふるえてるの
夜空にボートを作るから
夢の波間で
も一度踊り出そうよ
心に魔法をかけて　今
私　いつだって
そばにいるのよ
夜空にまわしたオルゴール
夢の中まで
君を追いかけてあげる
その手で瞳を抱きしめて
私　いつだって
あなたの愛になりたい
  Dream&amp;hellip;
收集金色的繁星
胡乱写着你的姓名
Dream&amp;hellip;
不能输给悲伤哦
施展银镜的咒语
夜空中余音袅袅的八音盒
沁入梦乡
在不断地追寻着你
用那双手夺下你的视线
我总有一天 成为你的所爱
Dream&amp;hellip;
无眠之夜
阳台洒着点点月光&amp;hellip;
Dream&amp;hellip;
你过着多么幸福的日子
胸口的睡衣仍在颤抖着
制作一艘游于夜空的小船
在梦的低潮再一次舞动起来吧
如今在心中施展起魔法
我总有一天
会陪伴在你身旁
夜空中余音袅袅的八音盒
沁入梦乡
在不断追寻着你
用双手夺下你的视线
我总有一天</description>
    </item>
    
    <item>
      <title>2021 12 19 日记</title>
      <link>/posts/2021-12-19/</link>
      <pubDate>Sun, 19 Dec 2021 23:36:03 +0800</pubDate>
      
      <guid>/posts/2021-12-19/</guid>
      <description>今天很高兴，我认为这是值得纪念的一天，遂记于此。
首先今天是我二哥结婚，我哥是一个非常努力的人，现在和心爱之人开始相伴终生，我也很开心。这也意味着我们家添加了一位新成员，并且还将会诞生新的成员，我想这方面我爸妈是最高兴的，毕竟二十多年啦～今天还喝了很多酒（我不喜欢酒，但想喝，高兴的是喝了这些，我还感觉脑子很清醒）。今天交了新朋友，高兴～</description>
    </item>
    
    <item>
      <title>《失望和希望》</title>
      <link>/posts/2021-12-17-hope-lose/</link>
      <pubDate>Fri, 17 Dec 2021 22:07:23 +0800</pubDate>
      
      <guid>/posts/2021-12-17-hope-lose/</guid>
      <description> 从小时候就开始数了。
数到懂事、数到成熟,
还没有数清。
天上的星星为什么数不清呢？
像记忆和幻想，
永远背负着固执的谜……
  不要失望，
失望会使我们衰老，
趁我们还年轻，
抬起头来，让我们数星星；
也许，我们能数得清；
也许，我们能看到真相；
也许，我们能找到希望……
 </description>
    </item>
    
    <item>
      <title>线性表</title>
      <link>/posts/linearlist/</link>
      <pubDate>Thu, 16 Dec 2021 12:43:02 +0800</pubDate>
      
      <guid>/posts/linearlist/</guid>
      <description>线性表是一种最基本、最简单的数据结构，数据元素之间仅具有单一的前驱和后继关系。
一、线性表的逻辑结构 🔗定义：线性表简称表，是 n(n&amp;gt;=0) 个具有相同类型的数据元素的有限序列。
二、线性表的顺序存储结构——顺序表 🔗顺序表是用一段地址连续的存储单元依次存储线性表的元素。通常使用数组实现。
用数组存储顺序表，意味着要分配固定长度的数组空间，因此，必须确定数组的长度。
顺序表中数据元素的地址是其序号的线性函数，只要确定了存储顺序表的起始地址（即基地址），计算任意一个元素的存储地址的时间是相等的，具有这一特点的存储结构称为随机存储结构。
顺序表具有以下缺点：
 插入和删除操作需要移动大量元素。在顺序表上做插入和删除操作，等概率情况下，平均要移动表中一半的元素。 表的容量难以确定。由于数组的长度必须事先确定，因为此，当线性表的长度变化较大时，难以确定合适的存储规模。 造成存储空间的“碎片”。数组要求占用连续的存储空间，即使存储单元数超过所需的数目，如果不连续也不能使用，造成存储空间的“碎片”现象。  造成上述顺序表的缺点的根本原因是静态存储分配，为了克服顺序表的缺点，可以采用动态存储分配连存储线性表，也就是采用链接存储结构。
三、线性表的链接存储结构及实现 🔗单链表 🔗单链表是用一组任意的存储单元存放线性表的元素，这组存储单元可以连续也可以不连续，甚至可以零散分布在内存中的任意位置。每个存储单元在存储数据元素的同时，还必须存储其后继元素所在的地址信息，这个地址信息称为指针。这两部分组成数据元素的存储映射，称为节点。
单链表只有一个指针域（next）。
头节点：无论单链表是否为空，头指针始终指向头节点，因此空表和非空表的处理统一了。
循环链表 🔗在单链表中，如果将终端节点的指针域由空指针改为指向头节点，形成一个环，这种头尾相接的单链表称为循环链表。
从循环链表中任一节点出发，可以扫描到其他节点，增加了链表操作的灵活性。
但由于循环链表没有明显的尾端，要格外注意循环条件。通常判断用作循环变量的工作指针是否等于头一个制定指针（头指针或尾指针）。
双链表 🔗如果希望快速确定表中任一节点的前驱节点，可以在单链表的每个节点中再设置一个指向其前驱节点的指针域，这样就形成了双链表。
顺序表和链表的比较 🔗时间性能比较 🔗按位置随机访问某个元素，顺序表更快一些，时间性能为 O(1)；相比之下链表需要从头开始遍历扫描，所需要的平均时间为 O(n)。
在链表进行插入和删除操作不需要移动元素，在给出指向某个位置的指针后，进行插入和删除操作所需的时间仅为 O(1)；在顺序表中进行插入和删除操作需要移动表长一半的元素，平均时间为 O(n)。
一般规律，如果线性表需要频繁查找却很少进行插入和删除，或其操作和“数据元素在线性表中的位置密切相关时，宜采用顺序表作为存储结构；如果线性表需要频繁进行插入和删除操作，则宜采用链表作为存储结构。
空间性能比较 🔗作为一般规律，当线性表中元素个数变化较大或未知时，最好采用链表实现；如果事先知道线性表的大致长度，采用顺序表的空间效率会更高。</description>
    </item>
    
    <item>
      <title>C&#43;&#43; 基础总结</title>
      <link>/posts/cppbase/</link>
      <pubDate>Wed, 15 Dec 2021 12:35:27 +0800</pubDate>
      
      <guid>/posts/cppbase/</guid>
      <description>一、语法基础 🔗 指针和引用的概念 指针与内存关系 程序编译过程 static、const、#define的用法和区别 C和C++区别 内存模型 内存中的栈和堆分配  二、面对对象基础 🔗  面向对象理解
  析构函数
  构造函数
  拷贝构造
  多态
  纯虚函数和虚函数
  虚函数实现机制
  虚函数表
  访问限定符 public、private、protected
  继承原理、虚继承、菱形继承
  静态绑定和动态绑定
  new/delete和malloc/free
  重载、重写和隐藏
  三、语法进阶 🔗 智能指针 左值、右值引用和move语义 类型转换方式 常用的设计模式 线程安全的单例模式 内存溢出和内存泄漏 C++11新特性 静态链接库和动态链接库  四、STL 标准模板库 🔗 迭代器、空间配置器理解 常用容器特点、用法以及底层实现vector、list、deque、set、map、unorderedmap  </description>
    </item>
    
    <item>
      <title>Qt6 绘制基础</title>
      <link>/posts/paintsystem/</link>
      <pubDate>Mon, 13 Dec 2021 21:28:59 +0800</pubDate>
      
      <guid>/posts/paintsystem/</guid>
      <description>绘制系统 🔗Qt 的绘制系统可以使用相同的 API 在屏幕和打印设备上进行绘制，并且主要基于 QPainter 、 QPaintDevice 和 QPaintEngine 类。
QPainter 用于执行绘图操作， QPaintDevice 是二维空间的抽象，可以使用 进行绘制 QPainter ， QPaintEngine 提供了画家用来绘制不同类型设备的接口。 该 QPaintEngine 类是由在内部使用 了QPainter 和 的QPaintDevice ，除非他们创建自己的设备的种类从应用程序员隐藏。
这种方法的主要好处是所有绘制都遵循相同的绘制管道，从而可以轻松添加对新功能的支持并为不受支持的功能提供默认实现。
一、绘图示例 🔗通常在 QWidget, QPixmap, QPixture, QPrinter 上面绘图。
示例1 直接绘制： 🔗MainWindow::MainWindow(QWidget *parent)  : QMainWindow(parent) {  QLabel *label = new QLabel(this);  label-&amp;gt;resize(100, 100);   QPixmap pixmap(100, 100);  pixmap.fill(Qt::gray);   QPainter painter(&amp;amp;pixmap);  painter.drawRect(10, 10, 80, 80);  painter.drawText(20, 30, &amp;#34;Hello World&amp;#34;);   label-&amp;gt;setPixmap(pixmap);   QVBoxLayout *layout = new QVBoxLayout();  layout-&amp;gt;addWidget(label);  this-&amp;gt;setLayout(layout);  this-&amp;gt;resize(200, 200); } 运行结果：</description>
    </item>
    
    <item>
      <title>Qt6 对象模型</title>
      <link>/posts/object/</link>
      <pubDate>Mon, 13 Dec 2021 08:08:17 +0800</pubDate>
      
      <guid>/posts/object/</guid>
      <description>对象模型 🔗标准的 C++ 对象模型为对象范例提供了非常有效的运行时支持。 但是它的静态特性在某些问题领域是不灵活的。 图形用户界面编程是一个需要运行时效率和高度灵活性的领域。 Qt 通过将 C++ 的速度与 Qt 对象模型的灵活性相结合来提供这一点。
Qt 将这些特性添加到 C++ 中：
 一种非常强大的无缝对象通信机制，称为 信号和槽 可查询和可设计的 对象属性 强大的 事件和事件过滤器 上下文 用于国际化的 字符串翻译 复杂的间隔驱动 计时器 ，可以在事件驱动的 GUI 中优雅地集成许多任务 分层和可查询 对象树 以自然方式组织对象所有权的 受保护的指针 ( QPointer ) 在引用的对象被销毁时自动设置为 0，这与普通的 C++ 指针不同，后者在对象被销毁时变成悬空指针 动态转换 跨库边界 。 支持 自定义类型 创建。
 许多 Qt 功能是使用标准 C++ 技术实现的，基于 继承 QObject 的 。 其他的，比如对象通信机制和动态属性系统，需要 的 元对象系统 Qt自己的 提供 元对象编译器（moc） 。
元对象系统是一个 C++ 扩展，使该语言更适合真正的组件 GUI 编程。</description>
    </item>
    
    <item>
      <title>Qt 6 核心内部结构</title>
      <link>/posts/qt-core/</link>
      <pubDate>Mon, 13 Dec 2021 08:00:25 +0800</pubDate>
      
      <guid>/posts/qt-core/</guid>
      <description>Qt 包含一组丰富的基础使能器，主要来自 Qt Core 模块。 Qt 使用这些促成因素来提供更高级别的 UI 和应用程序开发组件。 以下主题解释了最重要的促成因素，并展示了如何使用它们来实现 Qt 尚未提供的专门功能。
对象、属性和事件 🔗该 QObject的 类构成Qt的对象模型的基础，是父类的许多Qt类的。 对象模型引入了许多机制，例如元对象系统，它允许运行时内省、操作和调用对象中的属性和方法。 它还作为 Qt 事件系统的基础，这是一种在 之间进行通信的低级方式 QObject 基于 的对象 。 Qt 的信号和槽机制提供了另一种高级通信形式。
另外， QObject 通过 提供了一个简单的计时机制 QObject::startTimer () 。 或者， QTimer 类为计时器提供高级接口。
 对象模型
元对象系统
物业系统
事件系统
信号和插槽
—— 基于字符串和基于函子的连接之间的差异
计时器
 容器类 🔗容器 是一种数据结构，其实例是其他对象的集合。 容器的一些示例是：动态数组、队列、链表和关联数组。 Qt 提供了一组通用的、基于模板的容器类，用于在内存中构造数据。
有关 请参阅 的完整列表 容器类 更多详细信息， 。
国际化 🔗Qt 使用 Unicode 来编码可显示的文本字符串。 Unicode 为世界上所有常用的书写系统提供支持，是跨平台开发的理想选择。 还可以使用 Qt 强大的国际化系统编写应用程序，以通过一个代码库支持任意数量的不同语言。
 Qt 中的 Unicode Qt 国际化</description>
    </item>
    
    <item>
      <title>Qt6 Qvariant 与自定义 Qt 类型</title>
      <link>/posts/qvariant/</link>
      <pubDate>Mon, 13 Dec 2021 07:29:55 +0800</pubDate>
      
      <guid>/posts/qvariant/</guid>
      <description>概述 🔗在本文档中，我们采用自定义类型并描述如何将其集成到 Qt 的对象模型中，以便可以像标准 Qt 类型一样存储它。 然后我们展示如何注册自定义类型以允许它在信号和插槽连接中使用。
创建自定义类型 🔗在开始之前，我们需要确保我们正在创建的自定义类型满足 QMetaType 强加的所有要求。换言之，它必须提供：
 公共默认构造函数 公共复制构造函数
公共析构函数
 下列 Message类定义包括以下成员：
class Message { public:  Message() = default;  ~Message() = default;  Message(const Message &amp;amp;) = default;  Message &amp;amp;operator=(const Message &amp;amp;) = default;   Message(const QString &amp;amp;body, const QStringList &amp;amp;headers);   QStringView body() const;  QStringList headers() const;  private:  QString m_body;  QStringList m_headers; }; 该类还提供了一个正常使用的构造函数和两个用于获取私有数据的公共成员函数。</description>
    </item>
    
    <item>
      <title>《圣斗士星矢——冥王哈迪斯十二宫篇》</title>
      <link>/posts/2021-12-12-saintseiya/</link>
      <pubDate>Sun, 12 Dec 2021 22:07:23 +0800</pubDate>
      
      <guid>/posts/2021-12-12-saintseiya/</guid>
      <description> 佛：沙加
佛：沙加啊
佛：有什么事让你如此悲伤
佛：只有六岁的你
佛：为什么每天都这么坐着
佛：有什么事情让你如此忧心忡忡
  沙加：今天
沙加：我又看到冈底斯河中浮着好几具尸体
沙加：在河岸上有好多来自印度各地的巡礼者在那里沐浴
沙加：看他们的样子
沙加：与其说是求生 还不如说是希望求死一样
沙加：我所降生的这个国家
沙加：为什么会这么贫穷呢
沙加：难道人们是为了受苦受难而来到这个世上的吗
  佛：沙加
佛：这就是你悲伤的原因吗
  沙加：当然了
沙加：谁会希望一个只有痛苦的人生呢
  佛：那是不对的
佛：因为有痛苦
佛：所以快乐也一定会相应存在
佛：反过来也是一样的
佛：美丽的花开了
佛：可它也总有一天会凋谢
佛：在这个世界上
佛：生命是一瞬也不会停止的
佛：它一直在动着 变着
佛：这就是无常
佛：人的一生也是这样的
  沙加：但是
沙加：最后还是只有一死……
沙加：这难道不可以说人生还是被悲伤所支配着吗
沙加：活着的时候
沙加：无论是克服痛苦 还是追求爱 追求喜悦
沙加：最后死亡还是把一切都化为虚无 沙加：那么人是为了什么而生的呢
沙加：人想要去和死亡这种永恒的东西对抗
沙加：根本就是不可能的啊
  佛：沙加
佛：你忘记了
  沙加：忘记了？
  佛：死并不是一切的终结
佛：死不过是万物变化的一种……
 </description>
    </item>
    
    <item>
      <title>《崔普一家物语》</title>
      <link>/posts/2021-12-12-trappfamily/</link>
      <pubDate>Sun, 12 Dec 2021 22:07:23 +0800</pubDate>
      
      <guid>/posts/2021-12-12-trappfamily/</guid>
      <description>一 🔗 耶拉：我觉得我好像做了不该做的事情耶
  玛莉亚：守规矩当然是很重要的事情
玛莉亚：但是为了交我这个举世无双的朋友
玛莉亚：而不守规矩的话
玛莉亚：是不会被上帝责骂的
  耶拉：为什么跟你交朋友必须爬到高塔上面才行呢……
  玛莉亚：来吧
  玛莉亚：啊，好棒哦
玛莉亚：耶拉
玛莉亚：你看过阿尔卑斯山的夕阳吗
  耶拉：我连阿尔卑斯山都没有去过呢
耶拉：因为我家里面很穷 所以都忙着帮忙家务
耶拉：我想只有有钱人……
  玛莉亚：才不呢 因为我父母双亡
玛莉亚：我是靠着奖学金到师范学校念书才刚刚毕业而已
玛莉亚：为了庆祝顺利毕业
玛莉亚：我和宿舍室友到阿尔卑斯山去露营
玛莉亚：就在那时候
玛莉亚：我突然决定要当修女
玛莉亚：所以就马上到这里来了
  “我到底能做什么呢 “
“要做什么才好呢 “
  玛莉亚：我心里的话 玛莉亚：你是第一个知道的喔
  耶拉：谢谢你 玛利亚
  桃乐丝修道长：你们两个赶快下来
  玛莉亚：啊
  桃乐丝修道长：玛莉亚
桃乐丝修道长：你非要我随时在你身旁管教你不可吗
  玛莉亚：对不起 修道长
 二 🔗 玛莉亚：早上好 修道长
  桃乐丝修道长：从现在到中午为止不准跟任何人说话</description>
    </item>
    
    <item>
      <title>It&#39;s a Small World - Disney Classics</title>
      <link>/posts/2021-12-11-9/</link>
      <pubDate>Sat, 11 Dec 2021 19:50:42 +0800</pubDate>
      
      <guid>/posts/2021-12-11-9/</guid>
      <description>It&amp;rsquo;s a world of laughter, a world of tears
It&amp;rsquo;s a world of hopes and a world of fears
There&amp;rsquo;s so much that we share
That it&amp;rsquo;s time we&amp;rsquo;re aware
It&amp;rsquo;s a small world after all
  It&amp;rsquo;s a small world after all
It&amp;rsquo;s a small world after all
It&amp;rsquo;s a small world after all
It&amp;rsquo;s a small, small world
  There is just one moon and one golden sun</description>
    </item>
    
    <item>
      <title>十分十二吋 - 林子祥</title>
      <link>/posts/2021-12-11-8/</link>
      <pubDate>Sat, 11 Dec 2021 19:50:40 +0800</pubDate>
      
      <guid>/posts/2021-12-11-8/</guid>
      <description></description>
    </item>
    
    <item>
      <title>And I Love You So - Don McLean</title>
      <link>/posts/2021-12-11-7/</link>
      <pubDate>Sat, 11 Dec 2021 15:45:11 +0800</pubDate>
      
      <guid>/posts/2021-12-11-7/</guid>
      <description>And I Love You So
The people ask me how
How I&amp;rsquo;ve lived &amp;rsquo;til now
I tell them &amp;ldquo;I don&amp;rsquo;t know&amp;rdquo;
  I guess they understand
How lonely life has been
But life began again
The day you took my hand
  And yes, I know how lonely life can be
The shadows follow me
And the night won&amp;rsquo;t set me free
But I don&amp;rsquo;t let the evening get me down</description>
    </item>
    
    <item>
      <title>春夏秋冬 - 张国荣</title>
      <link>/posts/2021-12-11-6/</link>
      <pubDate>Sat, 11 Dec 2021 15:18:33 +0800</pubDate>
      
      <guid>/posts/2021-12-11-6/</guid>
      <description> 秋天该很好
你若尚在场
秋风即使带凉 亦漂亮
深秋中的你填密我梦想
就像落叶飞
轻敲我窗
  冬天该很好
你若尚在场
天空多灰
我们亦放亮
一起坐坐谈谈来日动向
漠视外间低温
这样唱
能同途偶遇在这星球上
燃亮飘渺人生
我多么够运
无人如你逗留我思潮上
从没再疑问
这个世界好得很
  暑天该很好
你若尚在场
火一般的太阳在脸上
烧得肌肤如情
痕极又痒
滴着汗的一双
笑着唱
能同途偶遇在这星球上
燃亮飘渺人生
我多么够运
无人如你逗留我思潮上
从没再疑问
这个世界好得很
能同途偶遇在这星球上
是某种缘分
我多么庆幸
如离别你亦长处心灵上
宁愿有遗憾
亦愿和你远亦近
  春天该很好
你若尚在场
春风仿佛爱情在酝酿
初春中的你
撩动我幻想
就像嫩绿草使
春雨香
 </description>
    </item>
    
    <item>
      <title>且听风吟 - 朴树</title>
      <link>/posts/2021-12-11-5/</link>
      <pubDate>Sat, 11 Dec 2021 15:18:31 +0800</pubDate>
      
      <guid>/posts/2021-12-11-5/</guid>
      <description> 突然落下的夜晚
灯火已隔世般阑珊
昨天已经去得很远
我的窗前已模糊一片
大风声 像没发生 太多的记忆
又怎样放开我的手
怕你说 那些被风吹起的日子
在深夜收紧我的心
日子快消失了一半
那些梦又怎能做完
你还在拼命的追赶
这条路究竟是要去哪儿
大风声 像没发生 太多的记忆
又怎样放开我的手
怕你说 那些被风吹起的日子
在深夜收紧我的心
哎呀
时光真疯狂
我一路执迷与匆忙
依稀悲伤
来不及遗忘 只有待风将她埋葬
咿呀 咿呀
待风将她埋葬
咿呀 咿呀
待风将她埋葬
咿呀 咿呀
我们曾在路上
咿呀 咿呀
待风将她埋葬
 </description>
    </item>
    
    <item>
      <title>両手を広げて - 伊東惠里</title>
      <link>/posts/2021-12-11-4/</link>
      <pubDate>Sat, 11 Dec 2021 14:48:57 +0800</pubDate>
      
      <guid>/posts/2021-12-11-4/</guid>
      <description>丘に登って　深呼吸するの
つくり笑いは得意じゃない
臆病なのは誰だって同じ
明日の翼　信じたいね
風も山も　唄うメロディー
涙だって　幸せのレッスン
私らしく　両手を広げて
Sing my song
  傷つく事や　恋する気持ちを
恐れるよりも　見つめるのよ
大切な物　大切な人に
やさしくなれる それが愛ね
胸のチャイム　鳴らす予感
何があるの?　夢の向こう側に
待っていたい　両手を広げて
Sing my song
  涙だって　ときめきのレッスン
青い空に　両手を広げて
Sing my song
  登上山丘 做個深呼吸
不要再戴著 笑容假面具
畏懼膽小 是每個人都存在的
要相信 明天依然能夠去展翅飛翔
風與山 也在歌唱著
盡情流淚吧 必能引導走向幸福
像我一樣 張開你的雙手
Sing my song
  令人悲傷 失戀的感覺
不願去面對 感到很恐慌
他很重要 是無法能放下的</description>
    </item>
    
    <item>
      <title>Khayran Jalgan - 哈萨克民歌</title>
      <link>/posts/2021-12-11-3/</link>
      <pubDate>Sat, 11 Dec 2021 14:04:44 +0800</pubDate>
      
      <guid>/posts/2021-12-11-3/</guid>
      <description>Сонау алыс ауылда қалды-ау сұйген жар
Аттанарда қош десе алмай болдым- ау зар
Қайран жалған
  Кер даланың шөліндеи құлазыды
Кең деуші еді Бұл дұние недеген тар
Қайран жалған
  Таңдай татыр шетіңе жетемін бе　Құлагер ат аяңдайды тепеңімде
Қайран жалған
  Әзер тапқан алаштан дегдарім- ай
Ай жүзіңді бір көре алмай кетемін бе
Қайран жалған
  Көш асады қайқайып қарлы таудан
Егеи-егеи ел едік біз нарды сауған</description>
    </item>
    
    <item>
      <title>秋桜 - 山口百恵</title>
      <link>/posts/2021-12-11-2/</link>
      <pubDate>Sat, 11 Dec 2021 13:35:54 +0800</pubDate>
      
      <guid>/posts/2021-12-11-2/</guid>
      <description> 淡紅の秋桜が秋の日の
何気ない陽溜りに揺れている
此頃涙脆くなった母が
庭先でひとつ咳をする
縁側でアルバムを開いては
私の幼い日の思い出を
何度も同じ話くり返す
独言みたいに小さな声で
こんな小春日和の穏やかな日は
あなたの優しさが浸みて来る
明日嫁ぐ私に苦労はしても
笑い話に時が変えるよ
心配いらないと 笑った
あれこれと思い出をたどったら
いつの日もひとりではなかったと
今更乍ら我儘な私に
唇かんでいます
明日への荷造りに手を借りて
しばらくは楽し気にいたけれど
突然涙こぼし元気でと
何度も何度もくり返す母
ありがとうの言葉をかみしめながら
生きてみます私なりに
こんな小春日和の穏やかな日は
もう少しあなたの子供で
いさせてください
  淡红色的秋樱在秋日
平淡的阳光中摇曳
此刻 易哭的母亲
在花园中轻咳一声
露台上 相册被打开着
用同样的话语 一遍遍诉说我童年的话语
自言自语般轻轻道来
在这风和日丽的秋日
深深感受着您的温柔
微笑着 您对明天将披嫁衣的我说
无论多么辛劳
所以不要担心
沉浸在无尽的回忆中
发现无论如何我都不是一个人
如今才察觉我的任性
却只能咬住我的嘴唇
让您帮忙收拾明日的行李
母亲啊 您一遍又一遍
在霎那的快乐后
突然又溢出泪水 向我说到 多保重啊
含蓄地表达着谢意
我会努力走出我的人生之路
在这风和日丽的秋日
让我再多在您身边坐一会
您的女儿
 </description>
    </item>
    
    <item>
      <title>Forrest Gump Suite - Alan Silvestri</title>
      <link>/posts/2021-12-11/</link>
      <pubDate>Sat, 11 Dec 2021 01:02:32 +0800</pubDate>
      
      <guid>/posts/2021-12-11/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Qt6 顺序容器 QList</title>
      <link>/posts/qlist/</link>
      <pubDate>Thu, 02 Dec 2021 12:41:29 +0800</pubDate>
      
      <guid>/posts/qlist/</guid>
      <description>介绍 🔗QList 类是提供动态数组的模板类。该类中的所有函数都是可重入的。另外两个常用的顺序容器 QStack 和 QQueue 继承自 Qlist。
详细说明 🔗QList 是 Qt 的通用容器类之一。它将其项目存储在相邻的内存位置，并提供基于索引的快速访问。QVector  在 Qt 5 中曾经是一个不同的类，但现在是 QList 的一个简单别名。
QList 和QVarLengthArray  提供类似的 API 和功能。它们通常可以互换，但会产生性能后果。以下是用例的概述：
 QList 应该是您的默认首选。 QVarLengthArray提供了一个在堆栈上保留空间的数组，但如果需要，可以动态地增长到堆上。用于通常较小的短寿命容器是很好的。 如果您需要一个真正的链表，它保证在列表中间插入恒定时间并使用迭代器到项目而不是索引，请使用 std::list。  </description>
    </item>
    
    <item>
      <title>Qt6 隐式共享</title>
      <link>/posts/implicit-sharing/</link>
      <pubDate>Wed, 01 Dec 2021 22:48:45 +0800</pubDate>
      
      <guid>/posts/implicit-sharing/</guid>
      <description>Qt 中的许多 C++ 类使用隐式数据共享来最大化资源使用并最小化复制。当作为参数传递时，隐式共享类既安全又高效，因为只有一个指向数据的指针被传递，并且只有当函数写入数据时才会复制数据，即copy-on-write。
浅拷贝 🔗浅拷贝-引用类型。浅拷贝是指源对象与拷贝对象共用一份实体，仅仅是引用的变量不同（名称不同），对其中任何一个对象的改动都会影响另外一个对象。
深拷贝 🔗而深拷贝-值类型。深拷贝是指源对象与拷贝对象互相独立，其中任何一个对象的改动都不会对另外一个对象造成影响。
隐式共享： 🔗隐式共享又叫做回写复制。当两个对象共享同一份数据时（通过浅拷贝实现数据块的共享），如果数据不改变，不进行数据的复制。而当某个对象需要改变数据时则执行深拷贝。
采用隐式共享技术，将深拷贝和浅拷贝有机地结合起来。
概述 🔗共享类由指向共享数据块的指针组成，该共享数据块包含引用计数和数据。
创建共享对象时，它将引用计数设置为 1。只要新对象引用共享数据，引用计数就会增加，而当对象取消引用共享数据时，引用计数会减少。当引用计数变为零时，共享数据将被删除。
在处理共享对象时，有两种方法可以复制对象。我们通常谈论深拷贝和浅拷贝。深拷贝意味着复制一个对象。浅拷贝是引用拷贝，即只是指向共享数据块的指针。就内存和 CPU 而言，进行深度复制的成本可能很高。制作浅拷贝非常快，因为它只涉及设置一个指针和增加引用计数。
隐式共享对象的对象分配（使用 operator=()）是使用浅拷贝实现的。
共享的好处是程序不需要不必要地复制数据，从而减少内存使用和数据复制。对象可以很容易地被赋值，作为函数参数发送，并从函数中返回。
隐式共享大多发生在幕后；程序员很少需要担心它。但是，Qt 的容器迭代器与 STL 的容器迭代器具有不同的行为。阅读隐式共享迭代器问题。
在多线程应用程序中，会发生隐式共享，如线程和隐式共享类中所述。
在实现您自己的隐式共享类时，请使用QSharedData和QSharedDataPointer类。
详细的隐式共享 🔗如果对象即将更改并且引用计数大于 1，则隐式共享会自动将对象从共享块中分离。（这通常称为 copy-on-write 或者 value semantics。）
隐式共享类可以控制其内部数据。在任何修改其数据的成员函数中，它会在修改数据之前自动分离。但是，请注意容器迭代器的特殊情况；请参阅隐式共享迭代器问题。
 警告：在使用STL 样式的迭代器时，请小心复制隐式共享容器（QMap、QList等）。请参阅隐式共享迭代器问题。
 示例 🔗QPixmap p1, p2; p1.load(&amp;#34;image.bmp&amp;#34;); p2 = p1; // p1 and p2 share data  QPainter paint; paint.begin(&amp;amp;p2); // cuts p2 loose from p1 paint.drawText(0,50, &amp;#34;Hi&amp;#34;); paint.end(); 在这个例子中，p1 和 p2 共享数据，直到了 p2 被 QPainter::begin() 调用，因为画像素图将修改它。</description>
    </item>
    
    <item>
      <title>Qt6 容器类-概述</title>
      <link>/posts/qt-containers/</link>
      <pubDate>Wed, 01 Dec 2021 22:05:26 +0800</pubDate>
      
      <guid>/posts/qt-containers/</guid>
      <description>介绍 🔗Qt 库提供了一组通用的基于模板的容器类。这些类可用于存储制定类型的项。例如，您需要一个可调整大小的 QString 数组，请使用 QList。
这些容器类被设计为比 STL 容器更轻、更安全且更易于使用。如果您不熟悉 STL，或者更喜欢“Qt 方式”实现，您可以使用这些类而不是 STL 类。
容器类是 隐式共享的，它们是可重入的，并且它们针对速度、低内存消耗和最小的内联代码扩展进行了优化，从而产生更小的可执行文件。此外，在所有用于访问它们的线程将它们用作只读容器的情况下，它们是线程安全的。
容器提供了遍历的迭代器。STL 样式的迭代器是最有效的迭代器，可以与 Qt 和 STL 的通用算法一起使用。提供 Java 风格的迭代器是为了向后兼容。
容器类 🔗Qt 提供以下顺序容器：QList、QStack 和 QQueue。对于大多数应用程序，QList 是最好的类型。它提供了非常快速的追加。如果您确实需要链表，请使用 std::list。QStack 和 QQueue 是提供 LIFO 和 FIFO 语义的便利类。QList和QVector在 Qt 6 中被统一。两者都使用来自QVector的数据模型。QVector现在是QList的别名。
Qt 还提供了这些关联容器：QMap、QMultiMap、QHash、QMultiHash和QSet。“Multi”容器方便地支持与单个键关联的多个值。“散列”容器通过使用散列函数而不是对排序集的二分搜索来提供更快的查找。
作为特殊情况，QCache 和 QContiguousCache 类在有限的缓存存储中提供了有效的对象散列查找。
   类 简述     QList  这是迄今为止最常用的容器类。它存储可以通过索引访问的给定类型 (T) 的值列表。在内部，它在内存中的相邻位置存储一组给定类型的值。在列表的前面或中间插入可能会很慢，因为它可能导致大量项目必须在内存中移动一个位置。   QVarLengthArray &amp;lt;T, Prealloc &amp;gt; 这提供了一个低级的可变长度数组。在速度特别重要的地方，它可以代替QList使用。   QStack  这是QList 的一个便利子类，提供“后进先出”(LIFO) 语义。它向QList 中已有的函数添加了以下函数：push ()、pop () 和top ()。   QQueue  这是QList的便利子类，提供“先进先出”(FIFO) 语义。它将以下函数添加到QList 中已经存在的函数中：enqueue ()、dequeue () 和head ()。   QSet  这提供了具有快速查找功能的单值数学集。   QMap &amp;lt;Key, T&amp;gt; 这提供了一个字典（关联数组），将 Key 类型的键映射到 T 类型的值。通常每个键都与单个值相关联。QMap以 Key 顺序存储其数据；如果顺序无关紧要QHash是一个更快的选择。   QMultiMap &amp;lt;Key, T&amp;gt; 这是QMap 的一个方便的子类，它为多值映射提供了一个很好的接口，即一个键可以与多个值相关联的映射。   QHash &amp;lt;Key, T&amp;gt; 这与QMap具有几乎相同的 API ，但提供了明显更快的查找。QHash以任意顺序存储其数据。   QMultiHash &amp;lt;Key, T&amp;gt; 这是QHash 的一个便利子类，它为多值散列提供了一个很好的接口。    算法复杂性 🔗下表总结了顺序容器 QList 的算法复杂度。</description>
    </item>
    
    <item>
      <title>《星际争霸——虚空之遗》</title>
      <link>/posts/2021-11-30-starcraft4/</link>
      <pubDate>Tue, 30 Nov 2021 23:07:23 +0800</pubDate>
      
      <guid>/posts/2021-11-30-starcraft4/</guid>
      <description>（六） 🔗 阿塔尼斯：虫群摧毁了我们的家园。
阿塔尼斯：我高贵的族人们沦为难民。
阿塔尼斯：但是……
阿塔尼斯：虫群无法摧毁我们意志。
阿塔尼斯：因为神圣的卡拉连接着我们每个人的思想……
阿塔尼斯：让我们在绝望中团结一致。
  执政官：势不可挡。
  阿塔尼斯：今天我们将夺回我们的家园……
阿塔尼斯：夺回我们的遗产。
  阿塔尼斯：圣堂武士们，我们终于又站在了命运的十字路口。 阿塔尼斯：因为今天，我们将恢复属于星灵的荣耀。 阿塔尼斯：今天我们将重整旗鼓，夺回属于我们自己的家园。
  圣堂武士：为了艾尔！
  阿塔尼斯：愿卡拉之光指引我们。
  赛兰迪丝：舰队已经准备就绪。只等您的命令了，大主教。
  泽拉图：你们必须立即停止出征！
  阿塔尼斯：泽拉图……
  赛兰迪丝：圣堂武士，逮捕这个叛徒！
  阿塔尼斯：慢着！让他把话说完。
  泽拉图：最终之战已经来临。 泽拉图：黑暗者埃蒙，它回来了。
  赛兰迪丝：我们不能相信这个异端！
  泽拉图：出征艾尔会让我们忽略眼前真正的威胁。 泽拉图：埃蒙的怒火将会吞没整个星系。
  赛兰迪丝：别忘了，就是因为这个叛徒，艾尔才会沦陷。
  泽拉图：这份愧疚让我无法释怀……但是阿塔尼斯，我知道如何对抗即将来临的黑暗。
泽拉图：你必须相信我。
  阿塔尼斯：我们一起经历了许多，泽拉图。然而已经有太多族人为了此时此刻的到来，付出了生命。
阿塔尼斯：执行官，准备出战！
 （七） 🔗 阿塔尼斯：看来你一直警示的末日之战到来了。告诉我，老朋友，你到底发现了什么？
  泽拉图：我目睹了万物的毁灭……</description>
    </item>
    
    <item>
      <title>《星际争霸——虫群之心》</title>
      <link>/posts/2021-11-30-starcraft3/</link>
      <pubDate>Tue, 30 Nov 2021 22:07:23 +0800</pubDate>
      
      <guid>/posts/2021-11-30-starcraft3/</guid>
      <description>（四） 🔗 雷诺：莎拉？
雷诺：不……
  凯瑞甘：我要救你出去。
  雷诺：你都干了什么？
  凯瑞甘：我是……迫不得已。
  雷诺：这话去和芬尼科斯说，去和被你杀害的人说。
  凯瑞甘：你发誓说你会杀了刀锋女王。
凯瑞甘：你曾是唯一相信我的人。
凯瑞甘：你现在……还相信我吗？
  凯瑞甘：我爱你，吉姆。永远别忘记。
  雷诺：我们结束了。
 （五） 🔗 凯瑞甘：我现在看清了我真正的敌人。
凯瑞甘：他在虚空中等待着我，
凯瑞甘：拥有着我无法想象的力量……
凯瑞甘：为了对抗他，我放弃了所有的一切。
凯瑞甘：我的人性、
凯瑞甘：我的身份、
凯瑞甘：还有我爱的男人。 凯瑞甘：但我不会独自去面对他的。 凯瑞甘：我即是虫群。
 </description>
    </item>
    
    <item>
      <title>《星际争霸——自由之翼》</title>
      <link>/posts/2021-11-29-starcraft2/</link>
      <pubDate>Mon, 29 Nov 2021 22:30:23 +0800</pubDate>
      
      <guid>/posts/2021-11-29-starcraft2/</guid>
      <description>交易 🔗 阿克图尔斯：据说人在被剥夺了自由后……
阿克图尔斯：……才能真正了解自己
阿克图尔斯：我在想，你有多了解自己呢？
  副官：囚犯，向前走上平台。
  阿克图尔斯：626号囚犯……
阿克图尔斯：谋杀、掠夺、叛国 阿克图尔斯：今天……你出狱了。
阿克图尔斯：但你很快就会明白…… 阿克图尔斯：……自由也是有代价的。
  副官：战斗护甲焊接……并锁定完毕。
  阿克图尔斯：监狱将伴你同行，这身护甲就是你新的牢房。
阿克图尔斯：别误会——战争即将开始。
阿克图尔斯：它带来了功名荣耀……
阿克图尔斯：也带来了阴森恐怖。
阿克图尔斯：芬利先生——自由在召唤你。
  泰凯斯：来吧……好戏开场了。
 大预言 🔗 泽拉图：虫群的到来早有预言……
泽拉图：而星灵——神之长子，则奋起反抗。
泽拉图：如今我们的创世者萨尔纳加……回来了。
泽拉图：但回归是为了拯救……？
泽拉图：……还是毁灭？
  凯瑞甘：（笑声）
凯瑞甘：我就知道，最终你会来的。
  泽拉图：你的出现亵渎了这里，凯瑞甘。
  凯瑞甘：你能听到吗，泽拉图？群星间的低语。
凯瑞甘：星系会随他们的到来而燃烧。
  泽拉图：也许……
泽拉图：……但你看不到了！
  凯瑞甘：拜托，我们的恩怨微不足道。
凯瑞甘：一场势不可挡的风暴正在袭来。
凯瑞甘：这场湮灭，我们应该共同面对。
  泽拉图：休想！
  凯瑞甘：命运无法改变，
凯瑞甘：末日正在临近，
凯瑞甘：当它降临时，
凯瑞甘：我会欣然接受。
  泽拉图：预言尚未可知。
泽拉图：希望永不湮灭。
 火与怒 🔗 雷诺：你还能走啊，将军。</description>
    </item>
    
    <item>
      <title>《星际争霸——母巢之战》</title>
      <link>/posts/2021-11-29-starcraft1/</link>
      <pubDate>Mon, 29 Nov 2021 22:07:23 +0800</pubDate>
      
      <guid>/posts/2021-11-29-starcraft1/</guid>
      <description>人族帝国的皇帝—— 阿克图拉斯一世的加冕仪式 🔗 人类同胞们，
我来此召集你们，是要让你们了解目前的形势。
每个人都应该意识到我们此时所遭受到的危机，
我们彼此互相争斗，
为了共和历史的微小冲突而被分散。
现在，更大的危险正向我们靠近。
这股威胁将会毁灭我们的所有成就。
现在该是我们以国家或是个人的身份， 放下我们之间的仇恨，协同一致。
一场无法打赢的战争已经迫在眉睫，
而我们必须到更好的行星上找寻定居场所，
以免我们在转瞬之间就被战争所淹没。
联盟已经不存在了；
它曾经的团结和保护力量也成了一个幻影……一个回忆。
在我们还没打倒敌人之前，你们会向谁去寻求保护？
异形侵略者的破坏力量已经是显而易见。
我们看到了我们的家乡和村落在神族精准的攻击下毁灭。
我们看到了莫逆之交的朋友和挚爱之人在噩梦般的虫族手中丧生。
尽管它们是前所未有和无法想象的，但这就是我们此时的处境。
我的人类同胞们，该是集合起来创立一个新时代的时候了。
在团结中才会产生力量；许多反对组织已经加入了我们。
我们所有人将会凝聚成一股无法分割的力量，并且只服从于一个王座之下。
在这个王座之上，我将看着你们。
从这一天开始，再也不要让人类之间彼此交战，
再也没有任何组织来破坏这个新的开始。
并且再也不要让任何人试图利用异形的力量……
别让人类的敌人挡在我们的路上，
我们最后一定会胜利的，不计任何代价。
——阿克图尔斯·蒙斯克
 X-1 🔗 陆战队员1：谁是这个地方的主管？
陆战队员1：空中支援到哪里去了？
  陆战队员2指了指天上。
  阿列克斯：嗯，杰拉德，对于你把我从工作岗位上硬拉出来，
阿列克斯：我想你会给我一个好理由的。
  杰拉德：我的好阿列克斯，你的伏特加在等你。
杰拉德：站到我身边来，看看这些你就知道了。
  阿列克斯：杰拉德，我知道是有关虫族的事， 阿列克斯：我们看过带子几百遍了……
  杰拉德：你什么都没看到！
杰拉德：在实验室解剖死虫是一回事， 杰拉德：用我们的人去撕碎它们却是另一回事。 杰拉德：你必须把眼睛睁亮来对待这件事。 杰拉德：一旦开始之后，就再也没有退路了。 杰拉德：你准备好踏上这条路了吗，阿列克斯？
  阿列克斯：是……是的，我准备好了，我伟大的将军。
  杰拉德：好，好。我就知道我可以信任你。
  马士汀：将军。殖民基地在数分钟之内就会被攻下。我们要插手吗？
  杰拉德：带我们回到轨道上，马士汀。我们看够了。</description>
    </item>
    
    <item>
      <title>世界名作剧场系列推荐</title>
      <link>/posts/2021-11-27/</link>
      <pubDate>Sat, 27 Nov 2021 07:42:23 +0800</pubDate>
      
      <guid>/posts/2021-11-27/</guid>
      <description>《长腿叔叔》 🔗https://www.bilibili.com/bangumi/play/ep94176
《崔普一家物語》 🔗https://www.bilibili.com/video/BV1cb411P7N
《红发安妮》 🔗https://www.bilibili.com/video/BV12W411m7jJ
《阿尔卑斯山的少女》 🔗https://www.bilibili.com/bangumi/play/ep60826
《佩琳物语》 🔗https://www.bilibili.com/bangumi/play/ep81529</description>
    </item>
    
    <item>
      <title>在阳光下奔跑</title>
      <link>/posts/2021-11-21/</link>
      <pubDate>Sun, 21 Nov 2021 00:46:42 +0800</pubDate>
      
      <guid>/posts/2021-11-21/</guid>
      <description>前两天一位朋友向我分享了他的学生在校运会跑步的场景，选手们迎着终点跑去，赛道旁鼓气呐喊声连绵不绝。好怀念，在阳光下奔跑的时光。
跑步本身是没什么乐趣的，只会让身体负荷加重，还会带来肌肉酸痛等问题，但总有人乐此不疲。我曾经也热衷于长跑，也参加过不少比赛。但我并不喜欢这项运动。一步，两步，抬起，放下，腿像绑了沙袋一样沉重。一圈，两圈，十圈，二十圈，我真的不想跑，但是又不想停下来。因为，这是我清醒时让大脑放空的最好方式。当风吹在我脸上的时候，脑海里什么都没有。耳边一阵阵呐喊欢呼，我心里非常安静。
我曾听过一句最让我恐惧的话，“别大口呼吸，会死的”。是的，每个人都在害怕。害怕孤独，却只能感知自己，这算是人类最大的悲哀了吧？然而，无论如何置身于阳光下，黑暗，总会来临，掩盖世界，熄灭每一颗跳动的心。这是无法逃避的现实，越是逃避，便越沉浸在黑暗中。我们能做的只有接受黑暗，追求光明。因为黑暗是个体宿命，但，光明，却是世界。
回想那段时光，在黑夜里，阳光却如此相近。</description>
    </item>
    
    <item>
      <title>修改菜单栏和文章创作</title>
      <link>/posts/2021-11-18/</link>
      <pubDate>Thu, 18 Nov 2021 18:36:33 +0800</pubDate>
      
      <guid>/posts/2021-11-18/</guid>
      <description>前情提要 🔗完成前面的工作后，我们的网站是下图这样的，非常符合极简之美。不过空荡荡的网站不是我们想要的，接下来我们就开始最核心的部分：修改网站内容。
一、准备文本编辑工具 🔗（1）下载文本编辑工具。创作当然离不开文本的编辑，那么一款高效好用的文本编辑工具就非常重要了。这里我强烈推荐一个常用的工具 Visual Studio Code，它可以多文件管理。点击 https://code.visualstudio.com/Download 可以直达官网下载。接下来的讲述会使用到 VSCode，如果你选择其他文本编辑器，也无妨，找到对应的文件修改即可。
（2）用 VSCode 打开 blog 文件夹。打开 VSCode 后，点击左上角文件菜单，然后点击打开文件夹，选择 D:/hugo/site/blog 文件夹。
（3）我们需要关注 content 文件夹、public 文件夹和 config.yaml 文件即可。content 存放网站的所有内容，我们平时写文章会在里面创建；public 存放网站的源代码，我们使用 hugo 命令时它会自动生成，我们需要将它上传到 Github ；config.yaml 是网站的配置文件，我们网站的基本信息都会在里面配置。
二、网站预览 🔗用命令窗口进入网站 blog 根目录，执行 hugo server。打开浏览器，访问 localhost:1313。
三、创建菜单栏 🔗可以看到我们的网站现在有五个菜单，如果你前面在网站配置把菜单改成中文的话，那么将是[主页]、[关于]、[分类]、[标签]、[订阅]。[主页]不用多说了，[分类]、[标签]、[订阅]是自动管理的，如果不需要的话可以在网站目录的 config.yaml 里删掉，[关于]现在点击的话，是访问不了的，因为我们还没有创建对应的文件夹或文件。
（1）打开 themes/hugo-ivy/exampleSite 文件夹，这是 hugo-ivy 主题作者提供的示例网站。复制其中的 content 文件夹下的所有文件和文件夹，放到我们网站根目录下的 content文件夹下面。
（2）修改 config.yaml 文件，添加文章和记录两个菜单。对应的文件夹是 post 和 note。
（3）这样，再回到浏览器上看。因为我们把示例的文章也复制过来了，所以网站已经有文章显示了。而我们添加的[文章]和[记录]文章也完成了。如果你需要添加其他菜单，可以参考现有的：在 content 文件夹下新建文件夹，然后在 config.yaml 文件中添加修改。
四、新建文章 🔗我们可以复制 content/post 或者 content/note 下的文件，然后修改里面的标题、作者、日期、分类、标签等等，因为我们使用 hugo server 预览网站，所以可以在浏览器上 localhost:1313 实时查看修改后的效果。不过更常见的做法是通过命令的方式来创建，下面演示在[文章]菜单下创建一篇文章。</description>
    </item>
    
    <item>
      <title>搭建</title>
      <link>/posts/2021-11-17/</link>
      <pubDate>Wed, 17 Nov 2021 19:38:06 +0800</pubDate>
      
      <guid>/posts/2021-11-17/</guid>
      <description>一、在本地创建网站 🔗（1）使用 Hugo 建立网站。打开命令窗口，进入 D:\hugo\site 目录（便捷方法：在文件资源管理器中进入相应目录，单击地址栏右边空白地方，在最左边输入 cmd  加空格，回车。这样打开命令窗口的同时，进入了相应的目录），执行命令 hugo new site blog ，如出现 Congratulations! 提示则成功。（此时可在文件资源管理器中查看生成的文件，blog 是任意取的一个文件夹名字，但为了方便教程工作，请统一）
二、下载主题模板（以 hugo-ivy ）为例 🔗（1）接着回到刚刚的命令窗口，输入执行 cd blog\themes 进入 themes 目录。
（2）下载主题模板（ hugo-ivy ）。接上述步骤，在命令窗口中 执行 git clone https://github.com/yihui/hugo-ivy.git 来下载 hugo.386 主题。下载完成后，blog/themes 文件夹里面就可以看到下载好的主题了。
三、修改网站配置 🔗将 themes/hugo-ivy/exampleSite 文件夹中的 config.yaml 文件复制到文件夹 blog 下，并删除原有的 config.toml 。用记事本或者其他文本编辑工具，根据需要修改相应的内容。
四、网站本地预览 🔗用命令窗口进入 blog 目录，先执行 hugo 生成网页文件，再执行 hugo server 开启预览。打开浏览器，访问 localhost:1313 。（注意，这个命令窗口需要保持到你不需要预览网站的时候，届时可以用两次 Ctrl + c 停止，或者直接关闭窗口）
五、将网站推送到 Github 平台 🔗（2）打开命令窗口，进入 blog\public 目录，分别执行
git init git add .</description>
    </item>
    
    <item>
      <title>《天黑以后》</title>
      <link>/posts/2021-11-16-afterdark/</link>
      <pubDate>Tue, 16 Nov 2021 22:07:23 +0800</pubDate>
      
      <guid>/posts/2021-11-16-afterdark/</guid>
      <description>一 🔗 “为什么？”玛丽问。
  “你是问我，为什么忽然打算好好学习了？”
  “对。”
  高桥双手端着咖啡杯，眯起眼睛望着她的脸，就像从窗缝里窥视房间内部。“就是说，你是当真想听到回答才问的？”
  “当然。一般来说，人们都是想听到回答才提问的吧？”
  “按道理是。但也有不少人只是出于礼貌才提问的。”
  “那我就搞不懂了，我干嘛得出于礼貌向你提问呢？“
  “那倒是。”高桥略一沉吟，将咖啡杯放回小碟子里，发出一声清脆的响声，“我的说明有两个版本，一个长的一个短的，你想听哪一个？“
  ”中间的。“
  “知道啦。一个中等尺寸的回答。”
 二 🔗 “可是……”
  “可是?&amp;quot;
  “你好好想想。”玛丽说，“我问你‘是不是对爱丽深有兴趣？’你却回答‘我想是有兴趣’。漏掉了一个深字。我觉得好像有什么东西被你弃之不管了。”
  高桥感慨道：“你好细心啊。”
  玛丽无言地等待对方说下去。
  高桥不知道该如何作答，有些犹豫。”呃……是啊，跟你姐姐面对面长谈时，渐渐地，一种奇妙的感觉袭上心来。一开始我并没有注意到，可是随着时间过去，这种感觉越来越强烈。该怎么说呢？那是好像自己没被放在眼里的感觉。她明明近在眼前，可又好像远在几公里之外。“
  玛丽仍然一言不发。她轻咬嘴唇，等待下面的话。高桥花时间寻找合适的措辞。
  “简而言之，不管我说什么话，都不可能进入她的心里。在我和浅井爱丽之间，好像横着一道由透明海绵构筑的地层，我口中说出的话，在穿越那里的时候几乎被吸干了全部养分。在真正意义上，她根本没在听我说什么。说着说着，这种情形变得显而易见。这么一来，她说出的话也不能顺利地传递到我这边来。那实在是非常奇妙的感觉。”
 </description>
    </item>
    
    <item>
      <title>《你为生存做些什么，我不关心》</title>
      <link>/posts/2021-11-16-invitation/</link>
      <pubDate>Tue, 16 Nov 2021 20:07:23 +0800</pubDate>
      
      <guid>/posts/2021-11-16-invitation/</guid>
      <description>The Invitation by Oriah 🔗 ——〔加拿大〕 Oriah（译者：野竹林）
  It doesn&amp;rsquo;t interest me
what you do for a living.
I want to know
what you ache for
and if you dare to dream
of meeting your heart&amp;rsquo;s longing.
  你为生存做了些什么，我不关心；
我想知道，
你的追求，
你是否敢于梦想去触碰你那内心的渴望。
  It doesn&amp;rsquo;t interest me
how old you are.
I want to know
if you will risk
looking like a fool
for love
for your dream</description>
    </item>
    
    <item>
      <title>文非加粗描红不能读也？</title>
      <link>/posts/2021-11-16/</link>
      <pubDate>Tue, 16 Nov 2021 00:46:27 +0800</pubDate>
      
      <guid>/posts/2021-11-16/</guid>
      <description>刚刚一口气读完了一本小说《天黑以后》。我特别喜欢这样的阅读方式，从头读到尾，酣畅淋漓。然而每当我稍读到稍有蕴意或难懂的文字时，下方便被画了&amp;quot;重点&amp;quot;！这种感觉就像是品尝佳肴时一口吃到了苍蝇！想起了益辉的文非加粗描红不能读也？ 奈何,连纸质书也要沦陷了吗？</description>
    </item>
    
    <item>
      <title>准备工作</title>
      <link>/posts/2021-11-15/</link>
      <pubDate>Mon, 15 Nov 2021 12:26:45 +0800</pubDate>
      
      <guid>/posts/2021-11-15/</guid>
      <description>一、注册 Github 帐号 🔗（1）.前往 github.com 注册一个帐号。（注意：慎重考虑注册的用户名，如果你不购买别的域名，这个用户名将是你网站域名的一部分）
（2）在 Github 中创建一个名为 你的仓库名字.github.io 的仓库。
二、安装 Git 🔗（1）下载安装。前往 这里 ，点击下载 Git-**-64-bit.exe。然后安装，不懂的话一直 next 。
（2）配置。在 win10 搜索 cmd ，打开命令提示符，输入 git config --global user.email &amp;quot;你注册Github所用的邮箱&amp;quot; 回车执行，再输入 git config --global user.name &amp;quot;你的昵称&amp;quot; 回车执行。
注意：这种方式打开命令窗口会默认进入 C 盘的用户目录。如果需要切换到其他目录，比如我们后面所用的 D:/hugo/site/blog 目录，则需要先执行 D: 切换盘符，然后执行 cd hugo/site/blog，其中 cd 就是进入目录的命令，后面是需要进入的文件夹，有时候我们需要返回上一层目录，则可以执行 cd .. 来完成。后面会有相关操作。
三、安装 Hugo 🔗（1）首先在 D 盘创建一个新文件夹 hugo，然后在里面创建 bin 和 site 两个文件夹。bin 将用来放 Hugo 的可执行文件，site 将用来放你的网站的源代码。
（2）前往https://github.com/spf13/hugo/releases，找到并下载 hugo_Windows-64bit.zip。解压，如果是一个 hugo_windows_amd64.exe 文件，将它改名为 hugo.exe。
（3）将这个 hugo.</description>
    </item>
    
    <item>
      <title>基础概念</title>
      <link>/posts/2021-11-14-2/</link>
      <pubDate>Sun, 14 Nov 2021 20:57:13 +0800</pubDate>
      
      <guid>/posts/2021-11-14-2/</guid>
      <description>教程开始前，先来介绍一下最终的成果，以便确认是否符合你的需求。本篇教程以 Hugo 和 Github Pages 为基础，创建一个静态的网站。这个过程仅需要一台联网的电脑，不需要其他花费（注意：如果你想自定义域名，则需要自行购买域名，后面会有相关介绍）。下文提到的概念理论只需要有一个模糊的认识就足够了，不需要理解透彻，因为在后续文章中会具体介绍其用法，届时就会有更直观的认识了。
Hugo 和 Github Pages 稍后会介绍，我们先来了解什么是静态网站。静态网站是由静态网页文件（也就是HTML文件)组成，它不需要服务器运行，也不需要数据库。我们将组成网站的这些网页文件上传到服务器上，别人就可以在互联网上通过这台服务器的地址或域名（例如 www.lzxqaq.com)访问这些网页文件，这就是静态网站的大致原理。
不过，这里所说的服务器并非我们日常所用的电脑，因为我们日常所用的电脑都是在局域网里，是不能让整个互联网的人都能访问到的。所以一般都要用所谓的云服务器，例如阿里云服务器、华为云服务器等等。不过现在有一些平台提供了免费的站点服务，我们就不需要购买昂贵的服务器了。例如本教程中使用的 Github Pages 服务，我们可以将网站托管到 Github 平台上，让平台帮我们把网站跑起来并在互联网上可以访问。
这里提到的 Github 是一个代码托管平台，也是全世界最大的开源社区。在本教程中，我们只需要知道，它是帮我们帮网站跑起来的就行了。我们在自己的电脑上创建网站，然后将这些网页文件上传到 Github 平台，而 Github 会帮我们运行网站，这样网站就可以访问了。另外，我们还需要在 Github 下载网站主题（这会在后续介绍）。如何将我们的网站文件上传到 Github 或者从 Github 下载东西呢？这里我们会用到 Git 这个工具。
那么如何建立网站呢？需要去学习网页技术吗？答案是不需要，我们将使用静态网站生成器来完成这项繁琐的工作。在本教程里，我们会使用 Hugo 这款出色的静态网站生成器。我们只需要挑选别人制作好的博客模板，根据某种规则去生成网站就好了（这里说的规则可以简单理解成约定好的文本格式，我们在约定好的文本格式下写文字，网站生成器会将这些文字翻译成网页文件）。所以我们只需要关注网站的文本，也就是展示的文章那些。（理想状态下，就类似我们写微博、发说说，编辑好文本发送出去就可以了）
简单来说，我们的工作流程是：在自己的电脑上，用一个静态网站生成器工具生成网页文件，然后将网站文件上传到某个平台上，这样别人就可以访问我们的网站了。如果修改网站（比如添加文章），也是重复上述步骤：重新生成网页文件，重新上传。
后续文章我会细述搭建网站的具体步骤，尽可能考虑新手建站的情况。如果你在这过程中遇到问题，欢迎在评论中指出或着与我联系。</description>
    </item>
    
    <item>
      <title>开篇</title>
      <link>/posts/2021-11-14-3/</link>
      <pubDate>Sun, 14 Nov 2021 20:57:13 +0800</pubDate>
      
      <guid>/posts/2021-11-14-3/</guid>
      <description>回顾过去，我刚接触互联网时，还是 2G 时代，那时各类论坛博客和聊天室正蓬勃发展。这种跨越时空的交流方式让我感到非常新奇，看着屏幕吐出文字的时候，就感觉打开了一个新世界的大门。通过一根根网线，就可以将世界连起来，人们可以在其中感知世界并畅所欲言。有趣的是，当时还是小学生的我，已经在一款网页文字游戏中建立队伍，和几十位素不相识的伙伴一起在游戏江湖里打拼了……
不过随着QQ、微信和微博等便捷交流平台的发展，传统博客和论坛逐渐淡出人们的视线。然而人们在选择这些便捷的平台时，也被其束缚着。特别是在内容分发推荐和主流媒体导流的当下，人们获取信息的的渠道看似变多了，但是这过程已经从主动变成了被动，我不认为这是什么好事。
“I web, therefore I am a spiderman.”，这是 hugo-ivy 主题作者谢益辉在他 blogdown一书提到的个人网站的作用，我深以为然。在当下，个人网站用来交流分享、内容创造或者记录人生仍是一个非常棒的选择。
值得高兴的是，个人网站搭建技术从未停下发展的脚步，现在搭建一个个人网站已经是一件很容易的事了～如果你拥有了它，那么你便在这嘈杂的网络世界有了一方净土。这需要感谢开源，感谢前人的努力。因为他们的努力，让搭建网站这类技术活变得更简单，让这世界充满自由与奉献的星光。
但即便如此，为了更自由、更多元化的需求，搭建和管理网站仍需要足够的耐心，特别是对于不了解这方面的人。为了前人的付出让更多的人知晓，让自由的表达有更多选择，我在这里开启系列教程，将搭建个人网站的步骤一一讲述。虽然有很多人做过类似的工作，但我还是希望我能做得更详细、更简单，为有需要的朋友省下一番功夫。注意，本系列教程默认读者为零基础的读者，所以会涉及很多基础概念，有一定基础的读者建议去查找其他教程。同时，因为技术会不停地发展，本教程的一些信息可能已经过时，如果你发现任何问题或者有改进建议，请在评论（需要注册 Github 帐号）指出或者联系我，我会及时更新。在此，感谢支持。
 当你面对一个陌生领域的挑战时，最困难的往往是开始动手这个决定。
 </description>
    </item>
    
    <item>
      <title>年轻人要多做事啊</title>
      <link>/posts/2021-11-14/</link>
      <pubDate>Sun, 14 Nov 2021 20:50:29 +0800</pubDate>
      
      <guid>/posts/2021-11-14/</guid>
      <description>还在想什么呢？不创造价值，谈什么需求？果然还是要马上行动起来！</description>
    </item>
    
    <item>
      <title>Qt单元测试基础笔记</title>
      <link>/posts/2021-10-13-1/</link>
      <pubDate>Wed, 13 Oct 2021 07:01:19 +0800</pubDate>
      
      <guid>/posts/2021-10-13-1/</guid>
      <description>一、构建 🔗构建时添加 QT += testlib 。
二、测试类 🔗测试类必须从 QObject 继承，头文件 include &amp;lt;QTest&amp;gt; ，并将测试函数声明 private slot
三、QVERIFY(condition) 宏 🔗检查 condition（条件）是否为真。如果为真，则继续执行。如果没有，则测试日志中会记录失败，并且不会进一步执行测试。
如果需要在测试失败报告中加入附加信息，可以使用 QVERIFY2(condition, message)。
如果需要测试日志有更详细的输出，可以使用 QCOMPARE(actual, expected)。
四、QCOMPARE(actual, expected)宏 🔗使用相等运算符将 actual （实际值）与 expected （预期值）进行比较。如果实际和预期匹配，则继续执行。如果不是，则在测试日志中记录失败，并且测试函数返回而不尝试任何后续检查。
如果比较失败，QCOMPARE() 会尝试输出值的内容，因此可以从测试日志中看到比较失败的原因。
对于你自己的类，你可以使用 QTest::toString () 来格式化输出到测试日志中的值。具体可参考 Qt 文档;
五、可执行文件 🔗如果需要将测试用例成为独立的可执行文件，需要添加以下两行：
QTEST_MAIN(YourClassName) #include &amp;#34;yourfilename.moc&amp;#34; </description>
    </item>
    
    <item>
      <title>Qt测试最佳实践</title>
      <link>/posts/2021-10-13-2/</link>
      <pubDate>Wed, 13 Oct 2021 07:01:19 +0800</pubDate>
      
      <guid>/posts/2021-10-13-2/</guid>
      <description>Qt 测试最佳实践 🔗我们建议您为错误修复和新功能添加 Qt 测试。在您尝试修复错误之前，添加一个回归测试（理想情况下是自动的），该测试在修复之前失败，表现出错误，并在修复之后通过。在开发新功能时，添加测试以验证它们是否按预期工作。
符合一组编码标准将使 Qt 自动测试更有可能在所有环境中可靠地工作。例如，有些测试需要从磁盘读取数据。如果没有为如何完成设置标准，则某些测试将无法移植。例如，假设其测试数据文件位于当前工作目录中的测试仅适用于源代码构建。在影子构建中（在源目录之外），测试将无法找到其数据。
以下章节包含了编写Qt测试的指南。
 一般原则 编写可靠的测试 改进测试输出 编写可测试的代码 设置测试机  一般原则 🔗下面的章节提供了编写单元测试的一般指南。
 验证测试 赋予测试函数描述性的名称 编写自带的测试函数 测试全栈 让测试快速完成 使用数据驱动的测试 使用覆盖工具 选择适当的机制来排除测试 避免Q_ASSERT  验证测试 🔗编写并提交你的测试以及你的修复或新功能到一个新的分支上。一旦你完成了,你可以检查出你的工作所基于的分支,然后把你的新测试的测试文件检查到这个分支。这可以让你验证测试是否在前一个分支上失败了,因此确实抓住了一个错误或测试了一个新功能。
例如，如果使用Git版本控制系统，则修复 QDateTime 类中的错误的工作流程可能如下所示：
 1.为您的修订和测试创建一个分支： git checkout -b fix-branch 5.14
2.编写一个测试并修复错误。
3.用修复版和新的测试版进行构建和测试,以验证新的测试版是否能通过修复版。
4.将修复程序和测试添加到您的分支： git add tests/auto/corelib/time/qdatetime/tst_qdatetime.cpp src/corelib/time/qdatetime.cpp
5.提交修复程序并测试您的分支机构： git commit -m &amp;lsquo;Fix bug in QDateTime&amp;rsquo;
6.要验证测试是否确实捕获了需要您修复的内容，请检出您自己的分支所基于的分支： git checkout 5.14
7.仅将测试文件检出到5.14分支： git checkout fix-branch &amp;ndash; tests/auto/corelib/time/qdatetime/tst_qdatetime.cpp
现在只有测试在fix-branch上。其余的源代码树仍在5.14上。
8.构建并运行测试,以验证它在5.14上失败,因此确实抓住了一个错误。
9.您现在可以返回到fix分支： git checkout fix-branch</description>
    </item>
    
    <item>
      <title>火车驶向云外，梦安魂于九霄</title>
      <link>/posts/2021-9-28/</link>
      <pubDate>Tue, 28 Sep 2021 12:56:24 +0800</pubDate>
      
      <guid>/posts/2021-9-28/</guid>
      <description>  ——趙子健
    我那些残梦 灵异九霄
徒忙漫奋斗 满目沧桑
在滑翔之后 完美坠落
在四维宇宙 炫目遨游
    我那些烂曲 流窜九州
云游魂飞奏 音愤符吼
在宿命身后 不停挥手
视死如归仇 毫无保留
    黑色的不是夜晚
是漫长的孤单
看脚下一片黑暗
望头顶星光璀璨
叹世万物皆可盼
唯真爱最短暂
失去的永不复返
世守恒而今倍还
    摇旗呐喊的热情
携光阴渐远去
人世间悲喜烂剧
昼夜轮播不停
纷飞的滥情男女
情仇爱恨别离
一代人终将老去
但总有人正年轻
  </description>
    </item>
    
    <item>
      <title>你吃了吗</title>
      <link>/posts/2021-9-23/</link>
      <pubDate>Thu, 23 Sep 2021 18:30:58 +0800</pubDate>
      
      <guid>/posts/2021-9-23/</guid>
      <description>前些天中秋假期，我和几个朋友出去玩。泡温泉的时候，一位久未见面的朋友一针见血地指出我胖了好多！
是啊，以前我还是挺瘦的，从去年疫情在家开始，体重就压抑不住狂涨了，一直心念的减肥计划也没怎么实施。
即便如此，我还是要说，其实我对吃并无多大兴趣。可能我真得了厌食症。我曾和一位朋友讨论过，饥饿是一种怎样的感觉，因为那时我单知道饿了，肚子会咕咕叫，但别的反应却是没有。后来我才知道，肚子饿了，会全身乏力，还会明显感觉到胃在“造反”。
无论如何，这终究是不对的。我们不能只盯着自己的盘子，我们得关心粮食和蔬菜，关心别人的胃口。“客从远方来，遗我双鲤鱼，中有尺素书，长跪读素书，书中意如何？上言加餐饭，下言长相思。”
在这方面我算是糟透了吧，很多时候我都在思考和朋友的关系。我QQ空间还留着一个留言，那时初中我同桌对我说，我一个朋友也没有，因为我总欺负她。〒▽〒
其实我也有一肚子“愿君勉强多饭之”，但是话到嘴边，无处说，无法说。这就是生活的无奈吧。
努力加餐，勿念之！</description>
    </item>
    
    <item>
      <title>神的旨意</title>
      <link>/posts/2021-8-9/</link>
      <pubDate>Mon, 09 Aug 2021 13:16:30 +0800</pubDate>
      
      <guid>/posts/2021-8-9/</guid>
      <description> 神啊
全知全能的神啊
请你告诉我
哪里需要我
我要到哪里去
怎样才能给他人带来快乐？
 </description>
    </item>
    
    <item>
      <title>文字vs动画</title>
      <link>/posts/2021-7-29/</link>
      <pubDate>Thu, 29 Jul 2021 06:09:09 +0800</pubDate>
      
      <guid>/posts/2021-7-29/</guid>
      <description>在我看来，在小说故事的表现能力上看，动画是优于文字的，而影视则是最末。为什么是这样？我举个例子。这个例子关于小说《绿山墙的安妮》和动画《红发少女安妮》。（没看过的朋友一定要去看哦）
在我看完动画之后，深受触动，想找原小说继续看。因为原著作者是加拿大作家，语言不通，我只好找来翻译版本。但是看了一段，感觉和自己预期落差很大。举个典型的例子，故事中的安妮给那个苹果树大道取名，在小说翻译版本中，有译为”白色的欢乐之路”的、也有译为“喜悦雪路”、“愉悦之路”等等，贝瑞家的池塘，有译为“阳光水湖”、“闪光小湖”等等。这样的文字，不但让人难以理解、更不能让人产生“内心颤动”的感觉。而在动画中，它们被译为“喜悦的银白色长廊”、“波光粼粼之湖”。“喜悦的银白色长廊”、“波光粼粼之湖”显然更具备画面感，也更容易让人理解安妮的形象。那为什么会产生这样的差距呢？是那些小说里翻译家的水平比不上动画里的汉译组吗？
我认为不是，问题出于文字和动画表现能力的差异上。文字描述更难让人发挥想象力，那些小说的翻译家，他们难以想象那个画面，自然就更难表达出来。而动画里不同，简单勾勒的线条、鲜明的色彩，朦胧的画面和丰富的想象力在人的脑海里迸发，所以“喜悦的银白色长廊”和“波光粼粼之湖”的出现也不足为奇了。
当然了，如何要考虑细枝末节的话，先前的结论就存在争议了。比如说恰当的文字描述和糟糕的动画效果。恰倒好处的文字的表现力并不见得比动画弱，而现在那些精美程度可以和影视剧相较高下的动画，也不见得给人多大的想象空间，影视剧就不提了，我认为它们扼杀了人类的想象力。</description>
    </item>
    
    <item>
      <title>开发指南-未完待续</title>
      <link>/posts/2021-7-16/</link>
      <pubDate>Fri, 16 Jul 2021 14:24:34 +0800</pubDate>
      
      <guid>/posts/2021-7-16/</guid>
      <description>提高质量和生产率是软件工程要解决的核心问题。
软件开发：正确性、健壮性、可靠性、效率、易用性、可读性（可理解性）、可扩展性、可复用性、兼容性、可移植性等。
只记录实际目前为止比较困惑的。
头文件的结构 🔗1.为了防止头文件被重复引用，应当用 ifndef/define/endif 结构产生预处理块。
2.用 #include&amp;lt;filename.h&amp;gt;格式来引用非标准库的头文件（编译器将会从标准库目录开始搜索；用 #include&amp;lt;Îy &amp;ldquo;filename.h&amp;rdquo; 格式来引用非标准库的头文件（编译器将从用户的工作目录开始搜索）。（注：一般将 &amp;lt;&amp;gt; 格式的放在前， &amp;ldquo;&amp;ldquo;格式的放在后，为了统一风格）
3.头文件只存放“声明”而不存放“定义”。（C++中，类的成员函数可以在声明的同时被定义，并且自动成为内联函数。但这样做会造成风格不一致，弊大于利！
4.不提倡使用全局变量，尽量不要在头文件中出现 extern int value 这类声明。
头文件作用： 🔗  （1）通过头文件来调用库功能。在很多场合，源代码不便（或不准）向用户公布，只要向用户提供头文件和二进制的库即可。用户只需要按照头文件中的借口声明来调用库的功能，而不必关心接口怎么实现的。编译器会从库中提取相应的代码。
  （2）头文件能加强类型安全检查。如果某个接口被实现或被使用时，其方式与头文件中的声明不一致，编译器就会指出错误，这一简单的规则能大大减轻程序员调试、改错的负担。
  目录结构 🔗如果一个软件的头文件数目比较多（如超过十个），通常应将头文件和定义文件分别保存于不同的目录，以便于维护。
例如可将头文件保存于 include 目录，将定义文件保存于 source 目录（可以是多级目录）。
如果某些头文件是私有的，它不会被用户的程序直接饮用，则没有必要公开其“声明”，可以把这些私有的头文件和定义文件存放于同一个目录。
空行 🔗1.类声明之后、函数定义结束之后要加空行。
2.在一个函数体内，逻辑上密切相关的语句之间不加空行，其他地方应加空行分割。
代码行 🔗1.一行代码只做一件事情，如只定义一个变量，或只写一条语句。
2.if、for、while、do 等语句自占一行，执行语句不得紧跟其后。不论执行语句有多少都要加{}。这样可以防止书写失误。（注：也为了统一风格）
3.尽可能在定义变量的同时初始化该变量（就近原则）。（注：这样可以减少被野指针折磨的痛苦，强烈建议）
代码行内的空格 🔗1.关键字之后要留一个空格。像 if、for、while 等关键字之后应留一个空格再跟左括号 &amp;lsquo;(&amp;rsquo;，以突出关键字。
2.函数名之后不要留空格，紧跟左括号&amp;rsquo;(&amp;rsquo;，以与关键字区别。
3.&amp;rsquo;(&amp;lsquo;向后紧跟，&amp;rsquo;)&amp;rsquo;、‘，’、‘；’向前紧跟，紧跟处不留空格。
4.&amp;rsquo;,&amp;lsquo;之后要留空格，如果&amp;rsquo;;&amp;lsquo;不是一行的结束符号，其后要留空格，如for(initialization; condition; update)。
5.【建议】对于表达式比较长的 for 语句和 if 语句，为了紧凑起见可以适当地去掉一些空格。（注：如果真的长到影响阅读，可以考虑）
对齐 🔗1.‘{{’h和‘}}’应独占一行并且位于同一列，同时与引用它们的语句左对齐。
长行拆分 🔗1.代码行最大长度应控制在 70 至 80 个字符以内。
2.【强烈】长表达式要在低优先级操作符处拆分成新行，操作符放在新行之首。</description>
    </item>
    
    <item>
      <title>《球场快乐指南》</title>
      <link>/posts/2021-7-10-2/</link>
      <pubDate>Sat, 10 Jul 2021 21:27:45 +0800</pubDate>
      
      <guid>/posts/2021-7-10-2/</guid>
      <description>前段时间，我又有了新的伙伴——小橙！
它还转过去了。别看它背面黑不溜秋的，头顶却长着一撮橙色的头发。而且它可是有着不少巧妙的设计，顶部有开口可以放羽毛球拍，夹层刚好可以放我 13 寸的 matebook。身材不大不小刚刚好。
这张图片是我今天打球去早了，等人的时候给它拍的。也有一段时间没和我的高中伙伴打球了，时间改变了许多事，唯独没变的是，他还记着提醒我不要忘记场地和时间！是的，以前我是一个“咕咕咕”，还是那种“你觉得我会鸽，然后我还真的鸽了……”。
回到今天的主题，羽毛球是一项老少咸宜的运动，不仅能强身健体，还可以和朋友放松交流，而且还能减肥～接下来就聊聊我和羽毛球的一些有趣过往。
我从高一开始接触羽毛球，那时候，学校羽毛球场特别多，但玩的人也特别多。所以每当放学铃声响起的时候，都要“biu”的一声，冲出教室，去到球场上占着。当时，教学楼外就有几个球场，那就是我们的主战场，我们从教室的窗户上可以轻易地看到下面球场的情况。虽然是室外的场地，有时候也会受到风的影响，不过我们也没那么多讲究，一伙人打着玩。那会，我算是球场熟面孔了。去到那里不管有没有认识的，能加队就一起玩了。我还记得一个初中部的小伙子。时常找我搭伙加双打。虽然那会技术上没什么长进，但就很快乐。后来分班了，我发现新同学里有两位（开头所说高中伙伴便是其一）打羽毛球很厉害，我觉得很酷，就经常和他们打球，边打边学，很有意思。
羽毛球让我结识了许多朋友，在他们身上，在羽毛球这项运动上，我也学到许多东西。特别记得，我的第一位羽毛球老师，他在第一节课里，言行身教地教我们羽毛球必须遵守的原则和羽毛球必胜诀窍。前者是：尊重你的对手、尊重这项运动，后者是找到并针对对手的弱点。
这是一个数十年球场经验的前辈总结出来的道理，开始我以为这很简单，慢慢的，我很庆幸曾受过他的教导。为了让前辈的球场哲学让更多的人知晓，我在前辈的基础上编写了《球场快乐指南》，望与诸君共勉。
《球场快乐指南》 🔗 （强制）尊重你的对手 （强制）尊重该运动 （建议）对手亦好友，且行且珍惜。  </description>
    </item>
    
    <item>
      <title>莓莓酸奶冰</title>
      <link>/posts/2021-7-10/</link>
      <pubDate>Sat, 10 Jul 2021 20:10:36 +0800</pubDate>
      
      <guid>/posts/2021-7-10/</guid>
      <description>前段时间，我决定自制一些饮品，为这沉闷而又炽热的夏日增添一些色彩。说做就做，先看成品。
1.莓莓酸奶冰(不可描述的食物) 🔗材料：草莓、蓝莓、金桔柠檬、鲜牛奶
灵感源自《明日之后》的草莓酸奶冰（草莓、蜂蜜、牛奶、冰块），我用鲜牛奶替代了酸奶， 加了蓝莓，没有蜂蜜，最黑暗的是，为了添加酸的味道，我加了金桔柠檬……好家伙，酸中带苦。还有，原本刚做好的时候还是挺好看的，结果我拿去冰冻之后， 成了这个样子……
2.草莓奶昔 🔗材料：草莓、鲜牛奶
有了上面的教训，这次终于正常点了。美中不足的是草莓籽太多了，而且甜度不够，还感觉有些稠（可能因为没加水）。
3.火龙果奶昔
材料：火龙果、鲜牛奶
这个也是拿去冷冻之后的样子，喝起来味道有些古怪，这个搭配要再斟酌斟酌……</description>
    </item>
    
    <item>
      <title>vim 操作备忘</title>
      <link>/posts/2021-7-10-3/</link>
      <pubDate>Sat, 10 Jul 2021 10:35:46 +0800</pubDate>
      
      <guid>/posts/2021-7-10-3/</guid>
      <description>一、存活 🔗   操作 含义     i Insert 模式，按 ESC 回到 Normal 模式。   x 删除当前光标所在的一个字符。   :wq 保存退出   dd 删除当前行，并存到剪切板   p 粘贴剪切板   hjkl 左下上右   :help  显示相关命令的帮助    二、感觉良好 🔗1.各种插入模式
   操作 含义     a 在光标后插入   o 在当前行后插入一个新行   O 在当前行前插入一个新行   cw 替换从光标所在位置到一个单词结尾的字符    2.</description>
    </item>
    
    <item>
      <title>瞎嚷嚷</title>
      <link>/posts/2021-7-7/</link>
      <pubDate>Wed, 07 Jul 2021 01:10:46 +0800</pubDate>
      
      <guid>/posts/2021-7-7/</guid>
      <description>最近到处都可以看到中国共产党建党100周年的口号标语，本来这些和我一个吃瓜群众毫无关系，但是今天在单位被拉去凑人头参加活动。完了憋不住，想来这里嚷嚷两句。
参加的活动是玩得很开心，领导的讲话也很振奋人心。但我总觉得哪里不对。噢，原来是没听到习大大的“不忘初心，牢记使命”。不对啊，现在不兴喊这个了吗？我赶紧翻了翻《中国共产党宣言》，不看不知道，一看吓一跳。上面怎么写着马云、马化腾的名字，是因为他们去中南海议政了吗？啊，怎么还有我的名字！我只是一个工地搬砖的，可不敢写在上面污人眼睛啊。赶紧擦了擦。噢，原来是看错了，上面写的是“资本家”和“无产阶级”……哎，眼睛蒙得太厉害了。
另外，说一个最近的倒霉事。因为我发现最近 Github Pages 经常打不开（本网站就挂在上面），考虑到最近的政治趋势，国内封杀国外资源是迟早的事，所以趁着华为云 618 活动，我买了一年云对象存储服务。但是，用它之后访问资源的速度居然比不过免费的 Github + jsDriver ！除非我再来一个 CDN 加速服务，但是这个高昂的价格劝退了我。还好，我的服务器还有两年优惠期，还能撑一撑。
 “华为牛掰！支持华为！华为万岁！支持国产！”
“你买华为什么东西了，用脚支持吗？这样喊两句，华为的东西能便宜点吗？没有你瞎嚷嚷啥呢！”
 PS:我目前使用的所有云产品都是“中华有为”的，仅仅是因为性价比的缘故，亦如大多国企、事业单位使用“美帝良心想”一样。</description>
    </item>
    
    <item>
      <title>罗小黑和罗小白</title>
      <link>/posts/2021-7-3/</link>
      <pubDate>Sat, 03 Jul 2021 08:38:33 +0800</pubDate>
      
      <guid>/posts/2021-7-3/</guid>
      <description>小黑是我的雨伞。前段时间，小黑同学不见了。当我意识到这点的时候，它已经从我的世界上消失了，我怎么也找不到它。在它不见的那段时间里，我很伤心，然后就有了——大黑。直到两个星期之后，它就那么突然地出现在我的面前。原来，它在我背包里……很好，我的战友，又回来了。
小白是我家的新成员——一只白色的宠物狗。第一次和它见面时，它就往我身上扑。我看它身上脏兮兮的，而我穿着白衣服，但犹豫了一下，还是没有躲开。它很聪明，非常爱玩。不过我爸妈不怎么喜欢它，因为它经常会在房间里大小便（这可能是因为没人管它）。在多数时间里，它总趴在地上发呆，而且它的姿势有些奇特，要么是两手前伸搭在门沿，头枕在手上，要么像乌龟那样，四肢伸开，头侧在一边。每当有客人来的时候，它就很兴奋，到处瞎跑，往人身上扑。没人搭理它的时候，它就自个趴着发呆。不过它不喜欢自己待着，每次我回家的时候，它总会来我房间。我看电脑的时候，它在旁边趴着；我睡觉的时候，它也在旁边趴着。哎，也不知道你的家人是否尚在，是否挂念着你。
说说近况，这周回家，我妈说我胖了好多。这句话很少见，但确实我也感觉到最近胖了不少。究其原因，一是饮食问题，二是缺少运动，二者关系密切。变胖原因一：自从上次我哥过来看我，给我带来了一个小冰箱、一个电磁炉和一些厨具，我自以为可以在厨房里大展拳脚了，结果真是一言难尽。从买菜、下厨到清洁收拾，花费的时间比较多，更关键的是，做出来的味道效果不太理想，这就很打击。而且因为买菜（特别是肉类）不好买太少，所以经常是：好不容易做出来的，含着泪也要吃完（肥胖++）……变胖原因二：晚上忙完厨房的时候，已经身心疲惫了。这个时候，运动的事情只能妥协了。
近期计划：
  尽量减少厨房事务，认清事实，以后闲下来的时候再好好学厨艺吧！
  坚持运动，每天至少半小时。
  茶艺计划。是的，厨艺不行转投茶艺～计划学着做一些果汁、柠檬茶、奶茶之类的。结果估计在下一篇文章见晓。期待^_^
  时间管理。保证每天足够的代码实践啊（着急：），以后还要加上阅读的时间。我没有时间了！
  </description>
    </item>
    
    <item>
      <title>做咩啊</title>
      <link>/posts/2021-6-12/</link>
      <pubDate>Sat, 12 Jun 2021 00:38:48 +0800</pubDate>
      
      <guid>/posts/2021-6-12/</guid>
      <description>“嗰個人嘅樣好怪啊”
“我都見到，好似隻狗咁哦”
 刚刚做了个噩梦，梦到火烧到了脚，但是眼睛却怎么也挣不开，慌张之时我在心头默念：“我一定要醒来”，两下之后，眼睛猛地睁开了。只见墙上映着一道微弱的光，忽闪忽闪。
字数有点少了不好看，那就拿来凑个数吧，《人生啊，就是这么无常……》</description>
    </item>
    
    <item>
      <title>网站搭建一二事</title>
      <link>/posts/2021-6-10/</link>
      <pubDate>Thu, 10 Jun 2021 13:39:39 +0800</pubDate>
      
      <guid>/posts/2021-6-10/</guid>
      <description> “30°C，依旧是骑着 BWM 上班的一天，虽然它是山寨的，虽然兜里只有十块钱，但听着周杰伦的《超人不会飞》，就感觉自己也超屌的~”
 前两天在哔哩哔哩投了两个视频，其中一个是关于网站搭建的。这个视频从计划到完成耗时两周（其实实际动手只花了两天），再次验证了计划在脑海里没有行动，就永远是空想。
其实今年一月初我也做过这样的视频，当时主要是自己搭建网站的操作演示，因为用的环境是 Linux ，可能不适合大众。那个视频的播放量也是挺少，远没有我当时另一个介绍 Manjaro 的视频高（估计大多数人是冲着视频配图来的，后来我把视频删了）。
为什么我对这件事这么热衷呢？其实我做完第一期视频之后，就不打算再续作了，但前段时间我意外发现本站一个读者，看到我那些个教程，也跟着搭网站，甚至把我的网站源码也复制过去了（其实我最初也是这么干的）。不过因为我把原主题改得乱七八糟了，可能会对他搭建网站造成一定的影响，所以我把自己网站整理之后给他发了一个邮件致歉，同时也给出了修改后的示例网站。也正是这个读者激发了我创作第二期教程的动力，不过现在看来效果依旧不好啊。
实际上，我不仅写了文章，投了视频，还向身边的一些朋友推荐过，但是可惜的是并没有人感兴趣。可能也是自己太急功近利了些。是的，我做这些是有目的的。它来源于我脑海里的一个想法，不过目前尚没有实现的条件，就不说出来惊扰大家了。（读者还没有几个，你瞎操啥心）。
是吧，现在自己最大的问题就是太沉不住气了，还是要脚踏实地做事啊。唉，自己的话影响力不高，那就借用益辉他老人家的话结尾吧：“我不和没有个人主页的人说话”。
 益辉：“我没有说过，别瞎说，别赖我！”
我：“我说你有你就有！”
 </description>
    </item>
    
    <item>
      <title>从零开始搭建个人网站——小白篇</title>
      <link>/posts/2021-6-1/</link>
      <pubDate>Tue, 01 Jun 2021 06:16:32 +0800</pubDate>
      
      <guid>/posts/2021-6-1/</guid>
      <description>前言 🔗小白篇和前面正经篇的区别是，懒人篇专门针对基础更浅（或者更懒的）朋友而设计，在这里不会新建一个网站，而是下载我预先准备好的示例网站，在这个示例上面做扩展。这样也是为了避免新手成功创建网站时，面对空荡荡的网站不知所措的尴尬。
准备工作（与前篇一致） 🔗1.注册 Github 帐号。前往 github.com 注册一个 Github 帐号。（友情提示：认真考虑注册时的用户名，它将是你网站网址的一部分）
补充：Github 是一个代码托管平台（远程仓库），你可以将网站的源代码放在上面，Github Pages 是一个免费的静态网站服务，你将网站的源文件放在上面，它会提供一个链接，使互联网上的人都能访问你的网站。
2.准备Git。
（1）下载安装。前往 这里 ，点击下载 Git-**-64-bit.exe。然后安装，不懂的话一直 next 。
（2）配置。在 win10 搜索 cmd ，打开命令提示符，输入 git config --global user.email &amp;quot;你注册Github所用的邮箱&amp;quot; 回车执行，再输入 git config --global user.name &amp;quot;你的昵称&amp;quot; 回车执行。
3.安装 Hugo。（官方教程可看这里)
（1）首先在 D 盘创建一个新文件夹 Hugo，然后在里面创建 bin 和 sites两个文件夹。bin 将用来放 Hugo 的可执行文件，sites 将用来放你的网站的源代码。
（2）前往这里，找到并下载 hugo_Windows-64bit.zip。解压，如果是一个 hugo_windows_amd64.exe 文件，将它改名为 hugo.exe。
（3）将这个 hugo.exe 文件移动到刚刚创建的 bin 文件夹里。
（4）配置环境变量。方法1:在 win10 搜索 cmd，右键以管理员身份打开命令提示符，将 setx &amp;quot;Path&amp;quot; &amp;quot;%PATH%;D:\Hugo\bin&amp;quot; /m 复制粘贴上去，回车（输入命令后需回车执行，后文不再赘述）。 方法2：在 win10 搜索环境变量，进去找到系统变量中的 Path，-&amp;gt;编辑-&amp;gt;新建，然后将 D:\Hugo\bin 复制进去，确定。</description>
    </item>
    
    <item>
      <title>【规约】 C&#43;&#43; 编程篇</title>
      <link>/posts/2021-05-28-c&#43;&#43;codingguidelines/</link>
      <pubDate>Fri, 28 May 2021 11:46:44 +0800</pubDate>
      
      <guid>/posts/2021-05-28-c&#43;&#43;codingguidelines/</guid>
      <description>前言 🔗“码出高效，码出质量”。本文整理了比较常见的 C++ 编程规范，主要来源于华为《软件编程规范总则》。
（一）排版 🔗1.程序块要采用缩进风格编写，缩进的空格数位 4 个。对齐只用空格键，不适用tab键。
2.相对独立的程序块之间、变量说明之后必须加空行。
3.较长的语句（&amp;gt;80 字符）要分成多行书写，长表达式要在低优先级操作符划分新行，操作符放在新行之首。
4.if、for、do、while、case、switch、default 等语句自占一行，且执行语句部分无论多少都要加括号 {}。
（二）注释 🔗1.一般情况下，源程序有效注释量必须在 20% 以上。
2.说明性文件（如头文件 .h 文件、.inc 文件、.def 文件等）头部应进行注释，注释必须列出：版权说明、版本号、生成日期、作者、内容、功能、与其他头文件关系、修改日志等，头文件注释中还应有函数功能简要说明。
3.源文件头部应进行注释，列出：版权说明、版本号、生成日期、作者、模块目的/功能、主要函数及其功能、修改日志等。
4.函数头部应进行注释，列出：函数的目的/功能、输入参数、输出参数、返回值、调用关系（函数、表）等。
5.边写代码边注释，修改代码同时修改响应的注释。不再有用的注释 要删除。
6.注释格式尽量统一，建议使用“/…………/”。
7.注释应考虑程序易读性，建议使用中文。
（三）标识符命名 🔗1.命名规范必须与所使用的系统风格保持一致，并在同一项目中统一，比如采用 UNIX 的全小写加下划线风格或大小写混排的方式，不要将两种方式混合使用。用作特殊标识如标识成员变量或全局变量的 m_ 和 g_，其后加上大小写混排的方式是允许的。
示例：Add_User 不允许，add_user、AddUser、m_AddUser允许。
2.用正确的反义词组命名具有互斥意义的变量或相反动作的函数等。
说明：以下是一些在软件中常用的反义词组。
add / remove begin / end create / destroy
insert /delete first / last get / release
increment / decrement put / get
add /delete lock unlock open /close
min / max old /new stat / stop</description>
    </item>
    
    <item>
      <title>【规约】 Java 编程篇</title>
      <link>/posts/2021-05-28-javacodingguidelines/</link>
      <pubDate>Fri, 28 May 2021 10:36:40 +0800</pubDate>
      
      <guid>/posts/2021-05-28-javacodingguidelines/</guid>
      <description>前言 🔗“码出高效，码出质量”。本文整理了比较常见的 Java 编程规范，主要来源于《阿里巴巴 Java 开发手册》。
（一）命名风格 🔗1.【强制】类名使用 UpperCamelCase风格，但以下情形例外：DO / BO / DTO / VO / AO / PO / UID等。 正例：MarcoPolo / UserDO / XmlService / TcpUdpDeal /TaPromotion
2.【强制】方法名、参数名、成员变量、局部变量都统一使用 lowerCamelCase 风格，必须遵从驼峰形式。
正例：localValue / getHttpMessage() / inputUserId
3.【强制】常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。
正例：MAX_STOCK_COUNT
4.【强制】抽象类命名使用 Abstract 或 Base 开头；异常类命名使用 Exception 结尾；测试类命名以它要测试的类的名称开始，以 Test 结尾。
5.【强制】类型与中括号紧挨起来表示数组。
正例：int[] arrayDemo;
6.【强制】POJO 类中布尔类型的变量，都不要加 is 前缀。
7.【强制】包名统一使用小写，点分隔符之间有且只有一个自然语义的英语单词。包名统一使用单数形式，但是类名如果有复数含义，类名可以使用复数形式。
正例：应用工具类包名为 com.alibaba.ai.util、类名为 MessageUtils。
8.【强制】杜绝完全不规范的缩写，任何自定义编程元素在命名时，使用尽量完整的单词组合来表达其意。
9.【推荐】如果模块、接口、类、方法使用了设计模式，在命名时需体系那具体模式。
10.【推荐】接口类的方法和属性不要加任何修饰符号（public 也不要加），保持代码整洁，并加上有效的 Javadoc 注释。
11.【强制】对于 Service 和 DAO 类，基于 SOA 的理念，暴露出来的一定时接口，内部的实现类用 Impl 的后缀与接口区别。</description>
    </item>
    
    <item>
      <title>【规约】 MySQL 数据库篇</title>
      <link>/posts/2021-05-28-databaseguidelines/</link>
      <pubDate>Fri, 28 May 2021 09:03:51 +0800</pubDate>
      
      <guid>/posts/2021-05-28-databaseguidelines/</guid>
      <description>前言 🔗“码出高效，码出质量”。本文整理了比较常见的 MySQL 数据库编程规范，主要来源于《阿里巴巴 Java 开发手册》。
(一)建表规约 🔗1.【强制】表达是与否概念的字段，必须使用 is_xxx 的方式命名，数据类型是 unsigned tinying(1 表示是，0 表示否)。
说明：任何字段如果为非负数，必须是 unsigned。
注意：POJO 类中任何布尔类型的变量，都不要加 is 前缀，所以，需要在  设置从 is_xxx 到 Xxx 的映射关系。数据库表示是与否的值，使用 tinyint 类型，坚持 is_xxx 的命名方式是为了明确其取值含义与范围。
正例：表达逻辑删除的字段名 is_deleted，1 表示删除，0 表示未删除。
2.【强制】表名、字段名必须使用小写字母或数字，禁止出现数字开头，禁止两个下划线中间只出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。
说明:MySQL 在 Windows 下不区分大小写，但在 Linux 下默认是区分大小写。因此，数据库名、表名、字段名，都不允许出现任何大小写字母，避免节外生枝。
正例：aliyun_admin, rdc_config, level3_name 反例：AliyunAdmin, rdcConfig, level_3_name
3.【强制】表明不使用复数名词。 说明：表名应该仅仅表示表里面的实体内容，不应该表示实体数量，对应于 DO 类名也是单数形式，符合表达习惯。
4.【强制】主键索引名为 pk_字段名；唯一索引名为 uk_字段名；普通索引名则为 idx_字段名。
说明：pk_ 即 primary key；uk_ 即 unique key；idx_ 即 index 的简称。
5.【小数类型】为 decimal，禁止使用 float 和 double。</description>
    </item>
    
    <item>
      <title>只爱陌生人</title>
      <link>/posts/2021-5-25/</link>
      <pubDate>Tue, 25 May 2021 23:32:47 +0800</pubDate>
      
      <guid>/posts/2021-5-25/</guid>
      <description>我的天空 为何挂满 湿的泪
我的天空 为何总 灰的脸
《天空》
 今天看到王菲的一张专辑，名叫《只爱陌生人》，感觉很有意思。
时间总是悄悄溜走，写上篇文章的情形还历历在目，恍惚昨日。
先说一下我的近况吧。也许是这些日里都没有好好睡午觉，今天中午趴在桌子睡了一阵，起来瞬间感觉头似千斤重，整个下午都昏昏沉沉，脑袋隐隐作痛。所以一下班我就早早走了，也不知道领导有没有记到小本本上。
回到住处，煮些东西，吃完就听着音乐躺下睡了。然而终究思绪万千，难梦难醒。约莫一个小时，还是觉得头痛难忍，于是就决定去附近的篮球场打会球。最近我每天都会去那里打球，好像哪天不去，这一天都过得不真实。不过今天确实有些晚了，平时在那儿玩闹的小孩都不见了踪影。于是我只能压低声音投球，免得扰人清梦。
最后说一下近期的计划吧。首先就是好好上班了（生活所迫啊），然后多交一些朋友（长期目标），最后，把我手头上做的事情做完。最近我有个想法，把大学几年里做过的、尚有意义的东西，整理出来。说来也是惭愧啊，从大一的第一个控制台程序，到最后的毕业设计项目，都不尽如意。</description>
    </item>
    
    <item>
      <title>[做点有趣的]C&#43;&#43;做一个哈夫曼压缩软件</title>
      <link>/posts/2021-05-25-zxhan/</link>
      <pubDate>Tue, 25 May 2021 07:12:32 +0800</pubDate>
      
      <guid>/posts/2021-05-25-zxhan/</guid>
      <description>前言 🔗这是以前的一个实训周作业，核心是哈夫曼编码和解码，软件界面由 QT 实现。代码量很小，比较简单。
源代码： https://gitee.com/lzxqaq/zxhan.git
介绍：https://lzxqaq.com/post/zxhan/
算法参考：Huffman压缩真正的C++实现
运行环境：Linux 系统（Windows系统下运行尚有 bug ),开发环境为 QT Creator。
运行截图：
核心实现 🔗void create_node_array();//构造包含字符及其频率的数组 void create_pq();//构造优先级队列 void create_huffman_tree();//构造哈夫曼树 void create_map_table(Node* node,bool);//根据哈夫曼树建立哈夫曼映射表 bool calculate_huffman_codes();//计算哈夫曼编码 bool do_compress();//开始压缩 bool rebuid_huffman_tree();//从哈夫曼编码文件中重构哈夫曼树 void decode_huffman();//根据重构的哈夫曼树解码文件 后续 🔗该项目仍有许多不足之处，如果你对该项目有任何意见或建议，欢迎联系我。如有任何问题，亦可与我一同探讨。</description>
    </item>
    
    <item>
      <title>《一小时人生》</title>
      <link>/posts/2021-5-9-2/</link>
      <pubDate>Sun, 09 May 2021 10:34:35 +0800</pubDate>
      
      <guid>/posts/2021-5-9-2/</guid>
      <description>一小时，体验人生百态。
最近在玩一款名叫《一小时人生》的游戏，国内手机移植版名为&amp;quot;希望之村&amp;quot;，有兴趣可以查查这游戏的来历，很有意思。作为一个游戏老玩家，我玩过很多游戏，但说让我印象深刻的还是要提到它。
首先介绍一下游戏基本的设定。《一小时人生》，游戏开始，玩家将会以“夏娃”（成年女性，开创者）或者“婴儿”（幼年期无生存能力，必须由他人抚养）的身份诞生在一个原始世界，成年女性会在某个不确定的时间诞生“婴儿”，在老年的时候就会失去生育能力。在游戏里，玩家每分钟会成长一岁，最高寿命为60岁，期间可能会因为饥饿、野兽袭击或疾病等原因致死而结束游戏。
既然说人生百态，目标不同，那这人生的玩法就很多了，具体怎么玩我就不多说了，有兴趣可以自行体验。下面分享一些我在游戏中遇到的趣事。（注：下列故事出现的人物称呼均为游戏中玩家关系）。
一 🔗这张图片的背景是：我作为夏娃的儿子诞生，能下地走路独自进食后，我便开始忙于生计，制造各种农具，种植果树。但因为环境恶劣，也或许是能力不足的缘故，随着人口的增多，我的兄弟姐妹在接下来的几次饥荒中丧生，母亲也化为了白骨。时间流逝，我渐渐意识到，这个世界仅剩我一人，在我死后这个世界便再也没有人记得曾有过这样一个家族，我的工作也便没有了价值。于是我放弃了工作，靠着附近的野果度日。最后，白发苍苍的我，忍受了漫长的孤寂，站在母亲的白骨前，等待死亡（我连埋葬都不会）……
二 🔗为了免受饥饿的困扰，我刻意到人少的地方作为夏娃诞生，苦练种植技术。当积累了足够经验后，因饥荒而导致种族灭绝的情况已经得到改善。然而环境探索和资源采集的过程中，自己或亲人时常被野兽袭击，因为缺乏医疗手段，鲜活的生命转瞬便消失在眼前。于是，我决定奋起反抗，用武器与热血对抗冰冷的大自然。同时也考虑到整个家族的生存大计，我选择在农业发展到一定阶段，自己也不能为家族创造更多价值的时候，拿起早已准备好的武器，向大自然最凶恶的野兽-巨熊，发起挑战！但即使是青壮年面对野兽，也需要足够多的勇气与体魄，更何况垂垂老矣的我，结局不言而喻……
三 🔗这是一个情节复杂，值得思考的故事，光看图片可能不能理解，且听我细细讲来。
这一世我作为夏娃的女儿诞生，但当我睁开眼之后，便吓出一身冷汗！原来我诞生在一个香蕉地，附近有一地的香蕉皮，在旁边还有一位刚能走动的姐姐（她也是一位传奇人物，后面会讲述她的故事）。
显然，这位母亲是一位流浪者，俗称香蕉人，即到处流浪，靠食野果为生。她的生平经历，我无从得知，她的所思所感，我亦无暇顾及。只知道她在我诞生后便放弃了自己的生命，是姐姐靠采摘附近的香蕉把我养大。但是资源终究会消耗完，这样的生活注定不能长久，我们不能让后代延续这样的悲剧。于是，我和姐姐同时做了一个决定，离开这里！我们相约到一个合适的地方共建家园，但是，显然幸运女神没有怜顾我们，我们迷路分离了。这也是流浪者后代的悲剧，在野外恶劣环境下，没有路引，迷失是注定的命运。
令我宽慰的是，在分开不远处我便找到一个环境不错的地方，同时找到了一些珍稀的果树——覆盘子，这也算是不幸中的万幸。于是我就地开展工作，开启了农耕时代。忙碌一生之后，我凭借附近的丰富资源，建立了一片果园，可以维持后代一定人口的生计。
然而，这看似美好的结局，其中的经历却骇人听闻。
看回第一张照片，我的三位儿子全部饿死，而其中一位，更是我亲手杀死。是的，我是那刽子手，但假如重来一次，我可能还是会作出同样的选择。在那时，我正全身心投入果园的建设之中，然而果园尚无产出，附近的野果资源却已经消耗殆尽了，饥荒迫在眉睫。这时，他诞生了。当然，我可以带着他离开这里，和我的母亲一样，去当一段时间的流浪者、香蕉人。但是，饥荒不会与你讲述人间的伦理道德，它会在到来的一瞬间夺取整个家族的命脉，让整个家族从此分崩离析，尸横遍野。于是，我把他放在了野外，加紧投身果园的工作中……
这仅仅只是一次饥荒的缩影，在我的众多儿女，只有一位能颐养天年，长寿而死（图二死于年老者，她也肩起繁衍大任，延续了家族的命脉），其余大都死于饥荒的侵袭。在这些死于饥荒的人中，有一位令我心中有愧，不得不提。他诞生之时，同样面临着饥饿的局面。在我准备再当一次刽子手时，我在他眼中看到了生命的执着。于是，我对他说，“以后要努力工作”，他被留下了。后来，他造农具，搜集资源，忙活一生，最后年迈时饥饿而死，而死前的遗言是：“娘养了我，已经报答完了……”。
我终究还是免不了归于尘土，是非对错对我来说已无半毫关系，只留在历史长河中成为后人评判的谈资。但令我感动的是，在我故去之后，我那位女儿在晚年时，仍纪念着我，拜托她的子孙帮我立碑……
历史人物终究受限于时代背景，从而带上了一些悲剧色彩，我那位传奇的姐姐也不外如是。在那些年里，我一直放不下寻找姐姐的执念。到了晚年的时候，子孙已经可以肩负大任，果园也已经健康运作，我交代完工作后，便开始在四周扩散寻找。一天，儿子突然跟我说，“带上吃的，快跟我来”。我跟着他，穿过一片没有食物资源的“生命禁区”，来到了他口中所说的“遗迹”。那里是一个荒废的营地，种植着稀少衰败的果树，四周散落着破旧的农具，以及大量的狩猎工具。地上还有一具白骨，儿子很高兴，他说可以狩猎了。而我却顿时眼中泛泪，说：“这是我姐姐建造的家，地上的是你表哥“。是的，凭借对血脉的感应，我认出了那一具白骨是姐姐的儿子，这荒废的营地就是姐姐建造的家园。虽然我没有亲眼所见，但这里发生的一幕，我却感到无比熟悉……回顾姐姐的一生，为了延续生命，她乐观、执着、坚强，面对恶劣的生存环境，她走向了一条不一样的道路——狩猎。她也许比我更具智慧与勇气，但命运没有眷顾她……
未完待续 🔗</description>
    </item>
    
    <item>
      <title>打脸</title>
      <link>/posts/2021-5-9/</link>
      <pubDate>Sun, 09 May 2021 00:53:14 +0800</pubDate>
      
      <guid>/posts/2021-5-9/</guid>
      <description>现在是 5 月 9 日 12 时 55 分。刚刚十一点左右回到住处，躺了一会，发现肚子不太舒服。不知道是刚吃的香辣鸡肉卷的锅，还是奶茶太冰的原因，或者是今天坐七八个小时公交影响。不过不管是哪个原因，经过慎重考虑（？），本人郑重立 flag：
 奶茶少冰 拒绝某汉堡店 不再吃辣  想到这里，不由地想起前面写的一篇文章，《追》。哈哈哈，开篇的信誓旦旦，现在竟成了赤裸裸的打脸现场。难搞。
人生就是不断打脸的过程，下一秒的我，可长点记性吧。</description>
    </item>
    
    <item>
      <title>[做点有趣的]Java开发泡泡堂游戏（MVC架构）</title>
      <link>/posts/2021-05-08-paopaotang/</link>
      <pubDate>Sat, 08 May 2021 11:09:51 +0800</pubDate>
      
      <guid>/posts/2021-05-08-paopaotang/</guid>
      <description>介绍 🔗本项目是一个很久以前的实训周项目，由我和我的组员 ljr 共同实现。整个项目思路清晰，整体难度不大，但是很多细节需要花功夫。本项目仍存在一些不足的地方，后续可能会进行优化，现在我将项目源代码和一些实现思路开源公布。
源代码：https://gitee.com/lzxqaq/CrazyArcade
文章介绍：https://lzxqaq.com/post/java/paopaotang/
程序运行： 在终端下进入执行程序所在目录，执行 java -jar CrazyArcade.jar 或者双击 CrazyArcade.jar，或者在开发环境中打开源代码，运行 GameStart.java的 main 方法。
运行环境：Linux、Windows均可。开发环境：IDEA。
演示视频：
运行截图：
功能 🔗本项目实现的功能如下：
 绘制游戏启动界面、结束界面、地图、主角、道具 实现泡泡爆炸 实现双主角PK（积分制） 实现道具掉落和相应属性加成 实现游戏音效和背景音乐  其中我们对游戏玩法做了调整，大致如下:
我们把游戏设计为双人pk积分赛模式，在这个模式里面，玩家只要率先达到一定分数既可以赢得比赛。玩家可以通过炸箱子可以得到少量的分数，也可以通过炸掉对手然后戳破包围对手的水泡得到大量分数。而玩家如果被泡泡爆炸击中，会被泡泡包裹一段时间，在这段时间内不可以移动和放泡泡，需要等时间过去或者被对手戳破水泡才能获得自由。但如果玩家被自己放的泡泡炸中，会扣一定的分数。
思路和架构 🔗整个项目采用 MVC 架构，将项目整体分为数据模型层（M）、视图层（V）、控制层（C）。M层负责元素的创建、存储、管理，V层负责所有元素的显示（24帧/秒），C层负责交互（监听用户的操作），同时负责控制游戏的进程。
选择MVC架构最主要的原因是让这个游戏项目具有良好的可扩展性和更新功能，当然了，一个好的游戏也需要良好的交互功能，漂亮的UI设计。
架构设计图：
包结构 🔗未完待续……
核心实现 🔗未完待续……
后续 🔗该项目仍有许多不足之处，如果你对该项目有任何意见或建议，欢迎联系我。如有任何问题，亦可与我一同探讨。</description>
    </item>
    
    <item>
      <title>失眠</title>
      <link>/posts/2021-5-5/</link>
      <pubDate>Wed, 05 May 2021 23:53:33 +0800</pubDate>
      
      <guid>/posts/2021-5-5/</guid>
      <description>从明天开始，做一个幸福的人
喂马、劈柴，周游世界
从明天开始，关心粮食和蔬菜
《面朝大海，春暖花开》
 我刚刚躺在床上胡思乱想的时候，脑海里冒出一些东西。
我终于意识到为何对这房子墙壁的粉刷配色感到熟悉了。是它，《Dark Season》。这个电影多次出现用小孩做残忍实验的片段，所用密闭房间就和我的房间很像。有点慌，怎么办，窗户那边一直传来莫名响动。我要不要睁开眼看一看？</description>
    </item>
    
    <item>
      <title>新生活</title>
      <link>/posts/2021-5-4/</link>
      <pubDate>Tue, 04 May 2021 23:08:53 +0800</pubDate>
      
      <guid>/posts/2021-5-4/</guid>
      <description>很长一段时间没来更新了，这期间并非无事可写，而是诸多事宜终究只能留于心底，随时光消散。
值得一提的是，前段时间突然发现我 Github 帐号多了一个粉丝，这可是一件稀奇事。查探一番后，惊讶的发现，他也在使用 hugo-ivy 这个主题搭建博客。原来，他应该是看到我那篇完成了一半的博客搭建教程（现在补充完整了）……真是尴尬，我当时只写了个大概，然后就直接鸽了……不得不说，虽然有些意外，但是还是有些开心。
回到当下，今天要开始独自租房生活了，值得纪念。同时，这也注定了今晚是一个难眠夜啊。从今天开始，就要独自居住在一个陌生的地方生活。过去不再有，前途飘忽不定。这样的画面，换作很多年前的我，想必是开心的吧。多年期盼终成真，然而人却不再是。任何事都会有代价，选择了，就要去承担。
不管怎么样，当我写到这里，新的一天已经到来。而明天，是未知，也是希望。
 “好好完成工作，好好度过每一天。蒙德的生活不就是如此吗？”
 </description>
    </item>
    
    <item>
      <title>晚</title>
      <link>/posts/2021-2-18-3/</link>
      <pubDate>Thu, 18 Feb 2021 23:33:16 +0800</pubDate>
      
      <guid>/posts/2021-2-18-3/</guid>
      <description>去年, 不曾有过什么事，
前年, 不曾有过什么事，
大前年, 也不曾有过什么事。
《斜阳》
 今天手机又坏了，这足以让我心情胸沉闷到整晚睡不着。:)
忽然想起很多年前的一个朋友，她有时会在晚修的时候跟我开玩笑说，“白天我是女神，晚上呢，是女神经”。我开始不是很懂，但感觉她很聪明，所以也很佩服她。
人是多么奇怪的生物啊，其实我对人一点也不懂。我不知道别人脑海真正的想法是什么。我在想，应该怎么样才能和另一颗心交流呢？</description>
    </item>
    
    <item>
      <title>从零开始搭建个人网站（win10,Github,Hugo）</title>
      <link>/posts/2021-2-18-2/</link>
      <pubDate>Thu, 18 Feb 2021 09:03:38 +0800</pubDate>
      
      <guid>/posts/2021-2-18-2/</guid>
      <description>准备工作 🔗1.注册 Github 帐号。前往 github.com 注册一个 Github 帐号。（友情提示：认真考虑注册时的用户名，它将是网址的一部分）
补充：Github 是一个代码托管平台（远程仓库），你可以将网站的源代码放在上面，Github Pages 是一个免费的静态网站服务，你将网站的源文件放在上面，它会提供一个链接，使互联网上的人都能访问你的网站。
2.准备Git。
（1）下载安装。前往 这里 ，点击下载 Git-**-64-bit.exe。然后安装，不懂的话一直 next 。
（2）配置。在 win10 搜索 cmd ，打开命令提示符，输入 git config --global user.email &amp;quot;你注册Github所用的邮箱&amp;quot; 回车执行，再输入 git config --global user.name &amp;quot;你的昵称&amp;quot; 回车执行。
3.安装 Hugo。（官方教程可看这里)
（1）首先在 D 盘创建一个新文件夹 Hugo，然后在里面创建 bin 和 sites两个文件夹。bin 将用来放 Hugo 的可执行文件，sites 将用来放你的网站的源代码。
（2）前往这里，找到并下载 hugo_Windows-64bit.zip。解压，如果是一个 hugo_windows_amd64.exe 文件，将它改名为 hugo.exe。
（3）将这个 hugo.exe 文件移动到刚刚创建的 bin 文件夹里。
（4）配置环境变量。方法1:在 win10 搜索 cmd，右键以管理员身份打开命令提示符，将 setx &amp;quot;Path&amp;quot; &amp;quot;%PATH%;D:\Hugo\bin&amp;quot; /m 复制粘贴上去，回车（输入命令后需回车执行，后文不再赘述）。 方法2：在 win10 搜索环境变量，进去找到系统变量中的 Path，-&amp;gt;编辑-&amp;gt;新建，然后将 D:\Hugo\bin 复制进去，确定。</description>
    </item>
    
    <item>
      <title>万恶之源——“瘟痘死”</title>
      <link>/posts/2021-2-18/</link>
      <pubDate>Thu, 18 Feb 2021 00:33:32 +0800</pubDate>
      
      <guid>/posts/2021-2-18/</guid>
      <description>最近我打算在 Windows 上录些视频，考虑过后决定重新装一下 Windows 10。
距离上次决心完全抛弃 Windows 已经过去大半年了，除了开始时遇到很多问题，之后的心情一直欢乐无比。然而这两天重装 Windows 的经历却再次让我抓狂。
本以为有着丰富的安装操作系统经验（惨痛经历）的我，装个 Windows 还不是小菜一碟～但，事实上我又被狠狠打脸了。从一个非 Windows 环境装 Windows 系统遭遇的问题之多，让我没办法淡定了……
整个过程遇到问题很多，最恶心也是最常见的就是装 Windows 的时候，会破坏原有其他操作系统的引导。我想流氓软件里 Windows 也算老大了吧。另外还有差点让我气笑了，微软官网检测到我当前用的不是 Windows 系统，居然不让我下载装 Windows 需要的工具安装包，美名其曰：“怕我下载错了”。这是玩霸道总裁还是别有用心？绝了！
这次之后，奇怪的知识增加了，而且装系统用的U盘也倍增了，以后应该不会再有类似这样的窘境了。
 “好像，你上次也是这样说的？”
 </description>
    </item>
    
    <item>
      <title>Java I/O</title>
      <link>/posts/2021-01-12-io/</link>
      <pubDate>Tue, 12 Jan 2021 08:46:08 +0800</pubDate>
      
      <guid>/posts/2021-01-12-io/</guid>
      <description>一、概览 🔗Java 的 I/O 大概可以分成以下几类：
 磁盘操作：File 字节操作：InputStream 和 OutputStream 对象操作：Serializable 网络操作：Socket 新的输入/输出：NIO  二、磁盘操作 🔗File 类可以用于表示文件和目录的信息，但是它不表示文件的内容。 递归地列出一个目录的所有文件：
public static void listAllFiles(File dir){  if(dir == null || !dir.exists()){  return ;  }  if(dir.isFile()) {  System.out.println(dir.getName());  return ;  }  for (File:file : dir.listFiles()) {  listAllFiles(file);  } } 从 Java 7 开始，可以使用 Paths 和 Files 代替 File。
三、字节操作 🔗实现文件复制 🔗public static void copuFile(String src, String dist) throws IOException {  FileInputStream in = new FileInputStream(src);  FileOutputStream out = new FileOutStream(dist);   byte[] buffer = new byte[20 * 1024];  int cnt;  // read() 最多读 buffer.</description>
    </item>
    
    <item>
      <title>Java 并发</title>
      <link>/posts/2021-01-09-concurrent/</link>
      <pubDate>Sat, 09 Jan 2021 10:50:16 +0800</pubDate>
      
      <guid>/posts/2021-01-09-concurrent/</guid>
      <description>一、使用线程 🔗有三种使用线程的方法：
 实现 Runnable 接口； 实现 Callable接口； 继承 Tread 类；  实现 Runnable 接口 🔗需要实现接口中的 run() 方法。
public class MyRunnable implements Runnable {  @Override  public void run(){  // ...  } } 使用 Runnable 实例再创建一个 Thread 实例，然后调用 Thread 实例的 start() 方法来启动线程。
public static void main(String[] args){  MyRunnable instance = new MyRunnable();  Thread thread = new Thread(instance);  thread.start(); } 实现 Callable 接口 🔗与 Runnable 相比，Callable 可以有返回值，返回值通过 FutureTask 进行封装。</description>
    </item>
    
    <item>
      <title>奈落之底</title>
      <link>/posts/2021-1-7/</link>
      <pubDate>Thu, 07 Jan 2021 08:57:26 +0800</pubDate>
      
      <guid>/posts/2021-1-7/</guid>
      <description>“一切的答案，都在奈落之底。” 《来自深渊》
 人类从未停止对未知事物的探寻。对内，不断剖析人的身体构造、思想信仰；对外，不断探索宇宙的边际，寻找那遥远处的未知。人从哪里来，往哪里去。如果不能解答这些问题，就不能认识到自身的存在意义。</description>
    </item>
    
    <item>
      <title>飞蛾扑火——命运</title>
      <link>/posts/2021-1-3/</link>
      <pubDate>Sun, 03 Jan 2021 19:19:51 +0800</pubDate>
      
      <guid>/posts/2021-1-3/</guid>
      <description> 从前 现在 过去了 再不来
红红落叶 长埋 尘土内 开始 终结 总是 没变改
天边的你 漂泊 白云外
《一生所爱》
 </description>
    </item>
    
    <item>
      <title>事“故”</title>
      <link>/posts/2021-1-2-2/</link>
      <pubDate>Sat, 02 Jan 2021 02:37:19 +0800</pubDate>
      
      <guid>/posts/2021-1-2-2/</guid>
      <description>现在是凌晨两点半。
在刚刚写好上一篇文章的时候，突然恶心呕吐……应该是今天吃的东西的锅。今天蒸了网购的腊肠，吃完就感觉隐隐不舒服，只是没想到后来越来越严重。
万一我挂了，这要归咎于朴朴上那些黑心的商家，望后来者哀之而鉴之……</description>
    </item>
    
    <item>
      <title>2021 年的开始</title>
      <link>/posts/2021-1-1/</link>
      <pubDate>Fri, 01 Jan 2021 00:38:48 +0800</pubDate>
      
      <guid>/posts/2021-1-1/</guid>
      <description>现在，2020 年已成为过去。在这里我不想总结过去，也不想展望未来，而是记录此刻的想法。
我的记忆力和我的听力一样不靠谱，这个问题由来已久。有得就有失，选择性遗忘有时候是保护自己的一种方式，但也有着它的代价。因此，这也是我一直以来想用文字来记录的原因。人生无常且短暂，无论是积极的、愉悦的，还是负面的、痛苦的事物、想法，都应该被记录下来。
昨天是在单位实习的最后一天。在这期间我遇到不少很棒的人，有许多很照顾我的朋友。是啊，刚出来社会都会有许多困惑。对我来说可能最困扰的应该是：人为什么而活？这个问题由来已久，对我来说可以追溯到……好吧，具体时间已经忘记了，但是我还记得当时的情形：我坐在一个石板上，时不时抬头望天空（小时候对神秘的宇宙真的很感兴趣）。显然当时的我不可能得出答案，不过却引起了一个子问题的思考:死亡是什么？当时我得出了一个结论，这个结论到现在我也认同：死亡会令你失去感知能力和思考能力。没办法感知这世界，感知身边的喜怒哀乐，没办法去思考。这是多可惜、多令人害怕的事情。
现在，我期望家人朋友都平安快乐地生活。同时人生不容易，我总得在世界上留下自己的声音。</description>
    </item>
    
    <item>
      <title>SQL 语法</title>
      <link>/posts/2020-12-31-sql/</link>
      <pubDate>Thu, 31 Dec 2020 10:12:40 +0800</pubDate>
      
      <guid>/posts/2020-12-31-sql/</guid>
      <description>一、基础 二、创建表 三、修改表 四、插入 五、更新 六、删除 七、查询  DISTINCT LIMIT   八、排序 九、过滤 十、通配符 十一、计算字段 十二、函数  汇总 文本处理 日期和时间处理 数值处理   十三、分组 十四、子查询 十五、连接  内连接 自连接 自然连接 外连接   十六、组合查询 十七、视图 十八、存储过程 十九、游标 二十、触发器 二十一、事务管理 二十二、字符集 二十三、权限管理  一、基础 🔗模式定义了数据如何存储、存储怎么样的数据以及数据如何分解等信息，数据库和表都有模式。
主键的值不允许修改，也不允许复用（不能将已经删除的主键值赋给新数据行的主键）。
SQL，（Structred Query Language)，标准 SQL 由 ANSI 标准委员会管理，从而被称为 ANSI SQL。各个 DBMS 都有自己的实现，如 PL/SQL、Transact-SQL 等。
SQL 语句不区分大小写，但是数据库表名、列名和值是否区分依赖于具体的 DBMS 以及配置。
SQL 支持以下三种注释：
### 注释 SELECT * FROM mytable; -- 注释 /* 注释1  注释2 */ 数据库创建与使用：</description>
    </item>
    
    <item>
      <title>Linux 不同发行版的选择</title>
      <link>/posts/2020-12-26/</link>
      <pubDate>Sat, 26 Dec 2020 22:33:13 +0800</pubDate>
      
      <guid>/posts/2020-12-26/</guid>
      <description>如果你对 Linux 感兴趣但还不了解，想知道 Linux 的不同发行版之间的区别，我的这些经历应该对你有帮助。
我最初使用的是 Ubuntu，它以前经常被推荐为 Linux 入门选择。用了很长一段时间，它给我最大的感受是不稳定和笨重。会经常收到系统内部崩溃的通知，而且另一个问题是装其他显卡驱动时很艰难（做深度学习、玩游戏等等会用到），令我几度崩溃 T_T 。所以，我认为 Ubuntu 对新手非常不友好；
后来我开始尝试 Deepin 系统，这是一款由国内深之度公司推出的发行版，预装软件最符合国人习惯，而且上手简单，系统不需要怎么配置就能拥有漂亮的界面。但是很快我就不能忍受它的软件源的落后。软件获取、维护便捷本该是 Linux 系统的一大优点，它可以为很多工作带来便利。
接着我来到 Arch 的世界。遗憾的是 Arch Linux 我在尝试的中途便放弃了。它确实很棒，从零开始定制操作系统很诱人，但是因为时间关系，我需要的是能快速上手，成为主力的操作系统。
最后，我接触到了很多人推荐的 Manjaro，它是为了让用户更方便使用的 Arch 衍生版。安装之后确实让我很惊喜，它完美符合我对操作系统的需求：上手简单、使用高效、美。而且尝试过后我才知道 Arch 系的软件仓库 AUR 有多强大。AUR 是一个社区维护的软件包仓库，有了它，你可以轻易获取到很多想要的软件。因此我很推荐使用 Manjaro。
（顺便提一下最稳定发行版之一的 CentOS。当我想在服务器上尝试它时，它就被官宣抛弃了……）</description>
    </item>
    
    <item>
      <title>Java 虚拟机</title>
      <link>/posts/2020-12-25jvm/</link>
      <pubDate>Fri, 25 Dec 2020 15:06:19 +0800</pubDate>
      
      <guid>/posts/2020-12-25jvm/</guid>
      <description>参考自 CyC2018/CS-Notes
 一、运行时数据区域  程序计数器 Java 虚拟机栈 本地方法栈 堆 方法区 运行时常量池 直接内存   二、垃圾收集  判断一个对象是否可被回收 引用类型 垃圾收集算法 垃圾收集器   三、内存分配和回收策略  Minor Gc 和 Full Gc 内存分配策略 Full GC 的触发条件   四、类加载机制  类的生命周期 类加载过程 类初始化时机 类与类加载器 类加载器分类 双亲委派模型 自定义类加载器实现    一、运行时数据区域  🔗程序计数器  🔗记录正在执行的虚拟机字节码指令的地址（如果正在执行的是本地方法则为空）。
Java 虚拟机栈  🔗每个 Java方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。
可以通过 -Xss 这个虚拟机参数来指定每个线程的 Java 虚拟机栈内存大小，在 JDK 1.4 中默认为 256K，而在 JDK1.5+ 默认为 1M：</description>
    </item>
    
    <item>
      <title>大恐怖</title>
      <link>/posts/2020-12-25/</link>
      <pubDate>Fri, 25 Dec 2020 08:56:19 +0800</pubDate>
      
      <guid>/posts/2020-12-25/</guid>
      <description>是夜，黑暗逐渐笼罩大地，劳累了一天的人们也逐渐睡去。然而，在一个狭窄凌乱的房间里，还泛着些许微光。他坐在书桌前，浑然不觉窗外传来的阵阵寒意，只因思绪沉浸在先前发生的一幕……
时间回到傍晚时分，他从单位回到了住处。那是一个旧小区，狭窄昏暗的楼梯，忽闪忽闪的楼道灯光，仿佛在陈述着它久远的历史。与往常一样，他翻了翻手机未读信息，便倒睡在床上。枕着按摩枕，戴上热敷眼罩，再给耳朵塞上耳机，最后躺在床上，仿佛在仙境一般舒适，全然忘记了白天的劳累。渐渐地，伴着歌声的旋律，逐渐进入了一种半梦半醒的状态……梦中不知时间流逝，恍惚之间，他从这种状态中醒来。下床，然后走到浴室。忽然，他觉察到某个地方不对劲。猛地低头，发现鞋子有了异样……
显然，这并非他的鞋子。问题是，它从什么时候出现在他的脚下，或者说什么时候出现在他的床边……未知的诡异感让他一下子清醒，多年的侦探思维派上用场。压下心头思绪，他将它放回室友的鞋架位置，仿佛当做无事发生，而实则开始暗自思索。“刚回来时便穿错了？不对，根据平时放鞋的习惯位置和鞋子的明显差异，可能很小。”“那它从一开始就在那里了？还是，在他睡觉的时候……”
不寻常的事物从不单独出现，他开始联想最近发生的不平常的事件。“最近深夜无人的客厅常常传来响动、室友某天早起出门后便再没回来……”细细琢磨，平日里安静的环境里隐藏着许多未知的事物。到底发生了什么，又是因何而起，这一切是道德的沦丧还是人性的泯灭……等等！啊，他明白了，猛地转身。原来，这诡异的根源，这诡异的根源，就在他的背后……
 “什么，精神损失费？放心，我会在夜深的时候去送给你的……”
 </description>
    </item>
    
    <item>
      <title>Java 容器</title>
      <link>/posts/2020-12-24-collection/</link>
      <pubDate>Thu, 24 Dec 2020 16:47:24 +0800</pubDate>
      
      <guid>/posts/2020-12-24-collection/</guid>
      <description>参考自 CyC2018/CS-Notes
 一、概览  Collection Map    一、概览  🔗容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map存储着键值对（两个对象）的映射表。
Collection  🔗1.Set
 TreeSet: 基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet, HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。 HashSet: 基于哈希表的实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。 LinkedHashSet: 具有 HashSet 的查找效率，并且内部使用双向链表维护元素的插入顺序。  2.List
 ArrayList： 基于动态数组实现，支持随机访问。 Vector： 和 ArrayList 类似，但它是线程安全的。 LinkedList： 基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用做栈、队列和双向队列。  3.Queue
 LinkedList：可以用它来实现双向队列。 PriorityQueue：基于堆结构实现，可以用它来实现优先队列。  Map  🔗 TreeMap：基于红黑树实现 HashMap：基于哈希表实现 hashTable：和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程同时写入 HashTable 不会导致数据不一致。它是遗留类，不应该去使用它，而是使用 ConcurrentHashMap 来支持线程安全，ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。 LinkedHashMap：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。  </description>
    </item>
    
    <item>
      <title>开心</title>
      <link>/posts/2020-12-17/</link>
      <pubDate>Thu, 17 Dec 2020 08:14:26 +0800</pubDate>
      
      <guid>/posts/2020-12-17/</guid>
      <description>晚上不开心，就会睡不好，睡不好早上就会早早起床，早起本身和它带来的结果（如吃上热腾腾的早餐）又会让人开心。
晚上很开心，就会睡得香，睡得香早上就不愿意起床，赖床本身和它带来的结果（如迟到）又会让人不开心。
所以，在晚上的时候要开心好，还是不开心好？
 “唉，我看你是想找不开心！”
 </description>
    </item>
    
    <item>
      <title>卖火柴的小女孩</title>
      <link>/posts/2020-12-16/</link>
      <pubDate>Wed, 16 Dec 2020 00:24:46 +0800</pubDate>
      
      <guid>/posts/2020-12-16/</guid>
      <description>今年的冬天也是格外的冷。
有时候讨厌冬天，因为自身仿佛不会发热，所以总感觉冷。有时候喜欢冬天，寒冷时刻刺激着大脑，提醒着要清醒。
今天晚上吃了两根玉米，本以为清水一煮，简单了事。结果，还是吃着还是生的，但是已经不想再动手煮了。
此情此景，我想起了那个卖火柴的小女孩。在那时候，想必她也没那么容易睡着吧，她会想些什么呢？是在想她爱的人还是爱她的人呢？</description>
    </item>
    
    <item>
      <title>String 类真的不可以改变吗？</title>
      <link>/posts/2020-12-15-2/</link>
      <pubDate>Tue, 15 Dec 2020 15:05:27 +0800</pubDate>
      
      <guid>/posts/2020-12-15-2/</guid>
      <description>对于 java.lang.String 类，我相信很多人印象里都是它不能被改变。通过查看源码，可以知道 String 有一个 final char 数组的变量，这个变量初始化之后便不能重新赋值。虽然这个变量引用的 char 数组的值虽然可以改变，但是String 类中并没有主动修改 这个 char 数组的方法。这就是通常所说 String 类不可变的依据。
然而在学习反射的时候，我产生了一个疑问：我们不可以通过反射修改 String 内部的 char 数组的值吗？答案是可以的，了解 Java 反射的人很容易就做到这点。那为什么还说 String 不可变呢？在思考过后，我得出一个答案：String 的不可变说的是一种约束规范。换句话说，String 的不可变是有好处的。在实际工作中，代码是自己写来用的，没有人会费劲给自己找麻烦，而没有任何益处。
事情到这里就完了？不，最近我再去了解 String 、String Pool（字符串常量池）的时候，又有了一些疑惑，于是亲手操刀给String 来了一次手术。最后也是加深了对 String 的理解，也验证了上面的观点。先上代码（如果你对任一实验结果感到疑惑，没关系，请带着疑惑来看后面的对照实验）：
 //实验1  String s1 = &amp;#34;1&amp;#34;;  Field valueField = String.class.getDeclaredField(&amp;#34;value&amp;#34;);  valueField.setAccessible(true);  char[] value = (char[]) valueField.get(s1);  value[0] = &amp;#39;2&amp;#39;;  System.out.println(s1); //2  System.out.println((s1 == &amp;#34;1&amp;#34;)); //true 上述实验 1 做的事情就是：用 s1 = &amp;quot;1&amp;quot;  的方式创建字符串，用反射修改它的值为 &amp;quot;2&amp;quot;,最后用它与 &amp;quot;1&amp;quot; 比较，结果是 true 。琢磨琢磨，再看下一段代码：</description>
    </item>
    
    <item>
      <title>Java 基础</title>
      <link>/posts/2020-12-15-base/</link>
      <pubDate>Tue, 15 Dec 2020 08:32:26 +0800</pubDate>
      
      <guid>/posts/2020-12-15-base/</guid>
      <description>参考自 CyC2018/CS-Notes
 一、数据类型  基本类型 包装类型 缓存池   二、String  概述 不可变的好处 String,StringBuffer and StringBuilder StringPoll new String(&amp;ldquo;abc&amp;rdquo;)   三、运算  参数传递 float与double 隐式类型转换 switch   四、关键字  final static   五、Object通用方法  概览 equals() hashCode() toString() clone()   六、继承  访问权限 抽象类和接口 super 重载和重写   七、反射 八、异常 九、泛型 十、注解 十一、特性  一、数据类型  🔗基本类型  🔗 byte/8 char/16 short/16 int/32 float/32 long/64 double/64 boolean/~  boolean 只有两个值：true、flase,可以使用 1 bit 来存储，但是具体大小没有明确规定。JVM 会在编译时期将 boolean 类型的数据转换为 int，使用 1 来表示 true， 0 表示 false。JVM 支持 boolean 数组，但是是通过读写 byte 数组来实现的。</description>
    </item>
    
    <item>
      <title>追</title>
      <link>/posts/2020-12-15/</link>
      <pubDate>Tue, 15 Dec 2020 00:27:32 +0800</pubDate>
      
      <guid>/posts/2020-12-15/</guid>
      <description>这一生也在进取
这分钟却挂念谁
我会说是唯独你不可失去
《追》
 今天没签单位的就业协议。我在想什么呢？到底什么是我想要的呢？
 你为生存做些什么，我不关心  🔗——〔加拿大〕 Oriah（译者：野竹林）
  你为生存做了些什么，我不关心；
我想知道，
你的追求，
你是否敢于梦想去触碰你那内心的渴望。
  你的年龄多大，我不关心；
我想知道，
你是否愿意像傻瓜一样不顾风险，
为了爱，梦想还有活着就该有的冒险。
  我不关心，是什么行星牵引着你的月亮，
我想知道，
你是否已触及自己悲伤的中心，
是否因生活的种种背叛而心胸开阔，
抑或因为害怕更大的痛苦而消沉封闭！
  我想知道，
你是否能面对痛苦——我的或者你自己的，
而不必去隐藏、涂抹或修饰。
  我想知道，
你是否能享受快乐——我的或者你自己的，
你是否能充满野性地舞蹈，让你从指端到足尖都被狂喜所充满，
而不会告诫我们要小心、要现实、要记住做人的禁忌。
  我并不关心你告诉我的故事是否真实，
我想知道，
你是否能为了真实地对待自己而不怕别人失望，
你是否能承受背叛的指责而不出卖自己的灵魂。
我想知道，你是否能抛弃曾经的信念，而因此值得信赖。
  我想知道，
你是否能发现美，即使它每天都不漂亮，
你是否能从它的存在中追寻你自己生命的源头。
  我想知道，
你是否能与失败相伴——你的和我的，
却依然可以站立在湖边对着银色的满月放生大喊
“是的，就是这样！”
  我不关心你在哪里生活或者你拥有多少金钱，
我想知道，
在一个悲伤、绝望、厌世和痛彻骨髓的夜晚之后，
你是否能起床，为养育孩子做那些需要的事情。
  我不关心你是谁，你是如何来到这里，
我想知道，你是否愿同我一起站在烈焰的中心，毫不退缩。</description>
    </item>
    
    <item>
      <title>飞蛾扑火——缘起</title>
      <link>/posts/2020-12-14/</link>
      <pubDate>Mon, 14 Dec 2020 01:07:07 +0800</pubDate>
      
      <guid>/posts/2020-12-14/</guid>
      <description> 明明知道烈焰焚身的痛苦，
明明知道短暂的光芒过后，
仍是无尽的黑暗，
为何你还是，
一心向前？
  是火焰的温暖给予你力量，
还是黑夜的漫长令你恐慌？
  我想知道，
当灰烬落地，
你是否找到心中的答案？
我想知道，
当火花再次摇晃，
你是否还会煽动翅膀？
 </description>
    </item>
    
    <item>
      <title>过去与未来</title>
      <link>/posts/2020-12-10/</link>
      <pubDate>Thu, 10 Dec 2020 23:14:51 +0800</pubDate>
      
      <guid>/posts/2020-12-10/</guid>
      <description> 我 回头再望某年，
象失色照片 乍现眼前。
—— 《风再起时》
 刚看完《寻找失去的未来》。啊，我是谁，我在哪,我昨天都做了什么？
在未来的一天，过去的所有都被遗忘，欢乐和痛苦终化为岁月的尘埃。只是，那时的我，又会变成什么样呢？现在的我，又是什么呢，现在的我，又在追求什么呢？
“没有未来的未来，不是我想要的未来~”可惜我不是那神原秋人，未来也不知道有没有“未来”。既然未来不可言，那我便讲述一下过去吧。
相较于“网瘾少年”，我更愿意把小时候的我称为“网上冲浪者”。那时候，最喜欢做的事情就是自个在某个地方，用一部能上网的手机，进入各种游戏聊天室、论坛。在那里，可以接触五湖四海的人们，跟不同的人交流，了解别人。当然，与之而来的苦恼就是每个月的流量费用。
说起网瘾少年，另一个词也不得不提，那就是“中二病”。和很多患者一样，以前的我总认为自己拥有一种超能力，它就像《冰海战记》里的阿谢拉特那样，看一眼就能“知其人”的能力。
 “嗯？你不是一直都是近视眼吗？”
  “因为看淡了世间事，所以模糊了双眼。&amp;quot;
  “喂，120 吗，这里有个病人需要抢救一下。”
 </description>
    </item>
    
  </channel>
</rss>
