<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    <title>PImpl 机制和 Qt 的实现 D-Pointer | Zexun Luo | 罗泽勋</title>

    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">    
<meta name="viewport" content="width=device-width,minimum-scale=1">
<meta name="description" content="一、什么是 PImpl 🔗PImpl是 Pointer to implementation的缩写， 是C&#43;&#43; 在构建导出库接口时特有的技术手段。 即是将类Class中所有私有变量以及私有方法，封装在一单独的实现类ClassImpl中。我们在Class中通过一指向ClassImpl的私有指针，访问这些私有数据。而ClassImpl类的具体定义和实现，我们放入cpp中。
二、什么是 D-Pointer 🔗如果你曾经看过 Qt 的源代码，你会看到很多 Q_D 和 Q_Q 宏。Q_D 和 Q_Q 宏定义是 d-pointer，它可以把一个类库的实施细节对使用的用户隐藏， 而且对实施的更改不会打破二进制兼容。Qt中的 D-Pointer 技术，便是 PImpl 机制的一种实现方式。
三、为什么会产生二进制兼容问题 🔗究其原因，通过添加了一个新的数据成员，我们最终改变了类对象的大小。为什么会这样？因为当你的C&#43;编译器生成代码的时候，他会用偏移量来访问对象的数据。
四、不要改变导出的 C&#43;&#43; 类的大小 🔗总之，一旦你的类库发布了，永远不要改变 导出的 C&#43;&#43; 类的大小或者布局（不要移动成员）。C&#43;&#43; 编译器生成的代码会假定，一个类的大小和成员的顺序 编译后 就不会改变.
那么，如何在不改变对象的大小的同时添加新的功能呢？
五、d-pointer 🔗诀窍是通过保存唯一的一个指针而保持一个类库所有公共类的大小不变。这个指针指向一个包含所有数据的私有的（内部的）数据结构。内部结构的大小可以增大或者减小，而不会对应用程序带来副作用，因为指针只会被类库里面的代码访问，从应用程序的视角来看，对象的大小并没有改变 - 它永远是指针的大小。 这个指针被叫做 d-pointer 。
六、d-pointer 的其它好处 🔗这里不全都是和二进制兼容有关。d-pointer 还有其它的好处： 隐藏了实现细节 - 我们可以只发布带有头文件和二进制文件的 WidgetLib。源文件可以是闭源代码的。
头文件很干净，不包含实现细节，可以直接作为 API 参考。由于实施需要的包含的头文件从头文件里已到了实施（源文件）里面，编译速更快。（译：降低了编译依赖）事实上，上边的好处是微乎其微的。Qt 使用 d-pointer 的真正原因是为了二进制兼容。
七、Qt 中的 d-pointers 🔗在 Qt 中，几乎所有的公有类都使用了 d-pointer。唯一不用的情况是如果事先知道某个类永远不会添加额外的成员变量。例如，像 QPoint, QRect 这些类，我们不期望有新的成员添加，因此它们的数据成员直接保存在类里而没用 d-pointer。">
<meta name="generator" content="Hugo 0.100.1" />


  <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">


<link rel="stylesheet" href="/css/style.css">



<link rel="shortcut icon" href="/images/favicon.ico" type="image/x-icon" />
<link href="https://cdn.bootcss.com/aplayer/1.10.1/APlayer.min.css" rel="stylesheet">
<script src="https://cdn.bootcss.com/aplayer/1.10.1/APlayer.min.js"></script>

 
    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'G-KDTTBGMLCQ', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>







  </head>

  <body>
    <nav class="navigation">
	
		<a href="/"> <span class="arrow">←</span>首页</a>
	
	
	
	

	
		<a href="/posts">博客</a>
	
		<a href="/tags">归档</a>
	
		<a href="/todos">事项</a>
	
		<a href="/recipe">菜谱</a>
	
		<a href="/about">关于</a>
	

	
	  <a class="button" href="/index.xml">订阅</a>
	
</nav>


    <main class="main">
      



<section id="single">
    <h1 class="title">PImpl 机制和 Qt 的实现 D-Pointer</h1>

    <div class="tip">
        <time datetime="2022-04-14 12:26:14 &#43;0800 CST">2022年04月14日</time>
        <span class="split">
          ·
        </span>
        <span>
          248字
        </span>
        <span class="split">
          ·
        </span>
        <span>
          2分钟
        </span>
    </div>

    
    
    


    <div class="content">
      <h3 id="一什么是-pimpl">一、什么是 PImpl <a href="#%e4%b8%80%e4%bb%80%e4%b9%88%e6%98%af-pimpl" class="anchor">🔗</a></h3><p>PImpl是 Pointer to implementation的缩写， 是C++ 在构建导出库接口时特有的技术手段。 即是将类Class中所有私有变量以及私有方法，封装在一单独的实现类ClassImpl中。我们在Class中通过一指向ClassImpl的私有指针，访问这些私有数据。而ClassImpl类的具体定义和实现，我们放入cpp中。</p>
<h3 id="二什么是-d-pointer">二、什么是 D-Pointer <a href="#%e4%ba%8c%e4%bb%80%e4%b9%88%e6%98%af-d-pointer" class="anchor">🔗</a></h3><p>如果你曾经看过 Qt 的源代码，你会看到很多 Q_D 和 Q_Q 宏。Q_D 和 Q_Q 宏定义是 d-pointer，它可以把一个类库的实施细节对使用的用户隐藏， 而且对实施的更改不会打破二进制兼容。Qt中的 D-Pointer 技术，便是 PImpl 机制的一种实现方式。</p>
<h3 id="三为什么会产生二进制兼容问题">三、为什么会产生二进制兼容问题 <a href="#%e4%b8%89%e4%b8%ba%e4%bb%80%e4%b9%88%e4%bc%9a%e4%ba%a7%e7%94%9f%e4%ba%8c%e8%bf%9b%e5%88%b6%e5%85%bc%e5%ae%b9%e9%97%ae%e9%a2%98" class="anchor">🔗</a></h3><p>究其原因，通过添加了一个新的数据成员，我们最终改变了类对象的大小。为什么会这样？因为当你的C+编译器生成代码的时候，他会用<code>偏移量</code>来访问对象的数据。</p>
<h3 id="四不要改变导出的-c-类的大小">四、不要改变导出的 C++ 类的大小 <a href="#%e5%9b%9b%e4%b8%8d%e8%a6%81%e6%94%b9%e5%8f%98%e5%af%bc%e5%87%ba%e7%9a%84-c-%e7%b1%bb%e7%9a%84%e5%a4%a7%e5%b0%8f" class="anchor">🔗</a></h3><p>总之，一旦你的类库发布了，永远不要改变 导出的 C++ 类的大小或者布局（不要移动成员）。C++ 编译器生成的代码会假定，一个类的大小和成员的顺序 编译后 就不会改变.</p>
<p>那么，如何在不改变对象的大小的同时添加新的功能呢？</p>
<h3 id="五d-pointer">五、d-pointer <a href="#%e4%ba%94d-pointer" class="anchor">🔗</a></h3><p>诀窍是通过保存唯一的一个指针而保持一个类库所有公共类的大小不变。这个指针指向一个包含所有数据的私有的（内部的）数据结构。内部结构的大小可以增大或者减小，而不会对应用程序带来副作用，因为指针只会被类库里面的代码访问，从应用程序的视角来看，对象的大小并没有改变 - 它永远是指针的大小。 这个指针被叫做 d-pointer 。</p>
<h3 id="六d-pointer-的其它好处">六、d-pointer 的其它好处 <a href="#%e5%85%add-pointer-%e7%9a%84%e5%85%b6%e5%ae%83%e5%a5%bd%e5%a4%84" class="anchor">🔗</a></h3><p>这里不全都是和二进制兼容有关。d-pointer 还有其它的好处： 隐藏了实现细节 - 我们可以只发布带有头文件和二进制文件的 WidgetLib。源文件可以是闭源代码的。</p>
<pre><code>头文件很干净，不包含实现细节，可以直接作为 API 参考。
由于实施需要的包含的头文件从头文件里已到了实施（源文件）里面，编译速更快。（译：降低了编译依赖）
</code></pre>
<p>事实上，上边的好处是微乎其微的。Qt 使用 d-pointer 的真正原因是为了二进制兼容。</p>
<h3 id="七qt-中的-d-pointers">七、Qt 中的 d-pointers <a href="#%e4%b8%83qt-%e4%b8%ad%e7%9a%84-d-pointers" class="anchor">🔗</a></h3><p>在 Qt 中，几乎所有的公有类都使用了 d-pointer。唯一不用的情况是如果事先知道某个类永远不会添加额外的成员变量。例如，像 QPoint, QRect 这些类，我们不期望有新的成员添加，因此它们的数据成员直接保存在类里而没用 d-pointer。</p>
<ul>
<li>在Qt中，所有私有对象的基类是 QObjectPrivate</li>
<li>Q_D和Q_Q 宏提供了上边讨论的 QPTR 和 DPTR 的功能.</li>
<li>Qt 的公有类有一个 Q_DECLARE_PRIVATE 的宏。</li>
</ul>
<h3 id="八qt-源码示例">八、Qt 源码示例 <a href="#%e5%85%abqt-%e6%ba%90%e7%a0%81%e7%a4%ba%e4%be%8b" class="anchor">🔗</a></h3><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>// 在基类QObject中将d_ptr变为protected类型，
</span></span><span style="display:flex;"><span>// 并在基类中添加一protected类型的构造函数，供子类使用
</span></span><span style="display:flex;"><span>class QObject
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>protected：
</span></span><span style="display:flex;"><span>    QObject(QObjectPrivate &amp;dd, QObject *parent = 0); 
</span></span><span style="display:flex;"><span>    QScopedPointer&lt;QObjectData&gt; d_ptr;
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>//所有的私有类均继承于QObjectPrivate，
</span></span><span style="display:flex;"><span>class QWidgetPrivate : public QObjectPrivate
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    Q_OBJECT
</span></span><span style="display:flex;"><span>    Q_DECLARE_PUBLIC(QWidget)
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>//QWidget 构造函数
</span></span><span style="display:flex;"><span>QWidget::QWidget(QWidget *parent, Qt::WindowFlags f)     
</span></span><span style="display:flex;"><span>        : QObject(*new QWidgetPrivate, 0), QPaintDevice()  
</span></span><span style="display:flex;"><span>{ 
</span></span><span style="display:flex;"><span>    ... 
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>//QObject 构造函数
</span></span><span style="display:flex;"><span>QObject::QObject(QObject *parent)
</span></span><span style="display:flex;"><span>    : d_ptr(new QObjectPrivate)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    Q_D(QObject);
</span></span><span style="display:flex;"><span>    d_ptr-&gt;q_ptr = this;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>QObject::QObject(QObjectPrivate &amp;dd, QObject *parent)
</span></span><span style="display:flex;"><span>    : d_ptr(&amp;dd)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    Q_D(QObject);
</span></span><span style="display:flex;"><span>    d_ptr-&gt;q_ptr = this;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>QWidget中并没有出现d_ptr指针，原来是从Qbject继承而来。QObject中我们新添加的那个protected构造函数传入一个QWidgetPrivate，用此给QObject中的d_ptr赋值，而这便是我们唯一的d_ptr。d_func()中那些类型转换的作用，就是保证我们可以拿到当前正确类型的private指针。</p>
<h3 id="九d-pointer的实现-demo">九、D-Pointer的实现 Demo <a href="#%e4%b9%9dd-pointer%e7%9a%84%e5%ae%9e%e7%8e%b0-demo" class="anchor">🔗</a></h3><ul>
<li>Person.h</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>class PersonPrivate;
</span></span><span style="display:flex;"><span>class Person
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    Q_DECLARE_PRIVATE(Person)
</span></span><span style="display:flex;"><span>public:
</span></span><span style="display:flex;"><span>    Person();
</span></span><span style="display:flex;"><span>    ~Person();
</span></span><span style="display:flex;"><span>    QString name() const;
</span></span><span style="display:flex;"><span>    void setName(const QString &amp;name);
</span></span><span style="display:flex;"><span>signals:
</span></span><span style="display:flex;"><span>    void calcRequested();
</span></span><span style="display:flex;"><span>private:
</span></span><span style="display:flex;"><span>    QScopedPointer&lt;PersonPrivate&gt; d_ptr;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>Person_p.h</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>#include &#34;Person.h&#34;
</span></span><span style="display:flex;"><span>class PersonPrivate
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    Q_DECLARE_PUBLIC(Person)
</span></span><span style="display:flex;"><span>public:
</span></span><span style="display:flex;"><span>    PersonPrivate(Person *parent);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    void calc();
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    QString name;
</span></span><span style="display:flex;"><span>private:
</span></span><span style="display:flex;"><span>    Person * const q_ptr;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>Person.cpp</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>#include &#34;Person_p.h&#34;
</span></span><span style="display:flex;"><span>Person::Person() : d_ptr(new PersonPrivate(this))
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>~Person() {}
</span></span><span style="display:flex;"><span>QString Person::name() const
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    Q_D(const Person);
</span></span><span style="display:flex;"><span>    return d-&gt;name;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>void Person::setName(const QString &amp;name)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    Q_D(const Person);
</span></span><span style="display:flex;"><span>    d-&gt;name = name;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>PersonPrivate::PersonPrivate(Person *parent) : q_ptr(parent)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>void PersonPrivate::calc()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    Q_Q(Person);
</span></span><span style="display:flex;"><span>    emit q-&gt;calcRequested();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
    </div>

    
        <div class="tags">
            
                <a href="/tags/c/c&#43;&#43;">C/C&#43;&#43;</a>
            
                <a href="/tags/qt">Qt</a>
            
        </div>
    
    
    


<script src="https://utteranc.es/client.js"
repo=""
issue-term=""
theme=""
crossorigin="anonymous"
async>
</script>





</section>


    </main>
    
    <footer id="footer">
    

    <div class="copyright">
    
       © Copyright 
       2022 
       <span class="split">
        <svg fill="#bbbbbb" width="15" height="15" version="1.1" id="heart-15" xmlns="http://www.w3.org/2000/svg" width="15px" height="15px" viewBox="0 0 15 15">
  <path d="M13.91,6.75c-1.17,2.25-4.3,5.31-6.07,6.94c-0.1903,0.1718-0.4797,0.1718-0.67,0C5.39,12.06,2.26,9,1.09,6.75&#xA;&#x9;C-1.48,1.8,5-1.5,7.5,3.45C10-1.5,16.48,1.8,13.91,6.75z"/>
</svg>
       </span>
       罗泽勋
    
    </div>

    
</footer>



  </body>
</html>
