<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    <title>线性表 | Zexun Luo | 罗泽勋</title>

    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">    
<meta name="viewport" content="width=device-width,minimum-scale=1">
<meta name="description" content="线性表是一种最基本、最简单的数据结构，数据元素之间仅具有单一的前驱和后继关系。
一、线性表的逻辑结构 🔗定义：线性表简称表，是 n(n&gt;=0) 个具有相同类型的数据元素的有限序列。
二、线性表的顺序存储结构——顺序表 🔗顺序表是用一段地址连续的存储单元依次存储线性表的元素。通常使用数组实现。
用数组存储顺序表，意味着要分配固定长度的数组空间，因此，必须确定数组的长度。
顺序表中数据元素的地址是其序号的线性函数，只要确定了存储顺序表的起始地址（即基地址），计算任意一个元素的存储地址的时间是相等的，具有这一特点的存储结构称为随机存储结构。
顺序表具有以下缺点：
插入和删除操作需要移动大量元素。在顺序表上做插入和删除操作，等概率情况下，平均要移动表中一半的元素。 表的容量难以确定。由于数组的长度必须事先确定，因为此，当线性表的长度变化较大时，难以确定合适的存储规模。 造成存储空间的“碎片”。数组要求占用连续的存储空间，即使存储单元数超过所需的数目，如果不连续也不能使用，造成存储空间的“碎片”现象。 造成上述顺序表的缺点的根本原因是静态存储分配，为了克服顺序表的缺点，可以采用动态存储分配连存储线性表，也就是采用链接存储结构。
三、线性表的链接存储结构及实现 🔗单链表 🔗单链表是用一组任意的存储单元存放线性表的元素，这组存储单元可以连续也可以不连续，甚至可以零散分布在内存中的任意位置。每个存储单元在存储数据元素的同时，还必须存储其后继元素所在的地址信息，这个地址信息称为指针。这两部分组成数据元素的存储映射，称为节点。
单链表只有一个指针域（next）。
头节点：无论单链表是否为空，头指针始终指向头节点，因此空表和非空表的处理统一了。
循环链表 🔗在单链表中，如果将终端节点的指针域由空指针改为指向头节点，形成一个环，这种头尾相接的单链表称为循环链表。
从循环链表中任一节点出发，可以扫描到其他节点，增加了链表操作的灵活性。
但由于循环链表没有明显的尾端，要格外注意循环条件。通常判断用作循环变量的工作指针是否等于头一个制定指针（头指针或尾指针）。
双链表 🔗如果希望快速确定表中任一节点的前驱节点，可以在单链表的每个节点中再设置一个指向其前驱节点的指针域，这样就形成了双链表。
顺序表和链表的比较 🔗时间性能比较 🔗按位置随机访问某个元素，顺序表更快一些，时间性能为 O(1)；相比之下链表需要从头开始遍历扫描，所需要的平均时间为 O(n)。
在链表进行插入和删除操作不需要移动元素，在给出指向某个位置的指针后，进行插入和删除操作所需的时间仅为 O(1)；在顺序表中进行插入和删除操作需要移动表长一半的元素，平均时间为 O(n)。
一般规律，如果线性表需要频繁查找却很少进行插入和删除，或其操作和“数据元素在线性表中的位置密切相关时，宜采用顺序表作为存储结构；如果线性表需要频繁进行插入和删除操作，则宜采用链表作为存储结构。
空间性能比较 🔗作为一般规律，当线性表中元素个数变化较大或未知时，最好采用链表实现；如果事先知道线性表的大致长度，采用顺序表的空间效率会更高。">
<meta name="generator" content="Hugo 0.100.1" />


  <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">


<link rel="stylesheet" href="/css/style.css">



<link rel="shortcut icon" href="/images/favicon.ico" type="image/x-icon" />
<link href="https://cdn.bootcss.com/aplayer/1.10.1/APlayer.min.css" rel="stylesheet">
<script src="https://cdn.bootcss.com/aplayer/1.10.1/APlayer.min.js"></script>

 
    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'G-KDTTBGMLCQ', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>







  </head>

  <body>
    <nav class="navigation">
	
		<a href="/"> <span class="arrow">←</span>首页</a>
	
	
	
	

	
		<a href="/posts">博客</a>
	
		<a href="/todos">事项</a>
	
		<a href="/recipe">菜谱</a>
	
		<a href="/about">关于</a>
	

	
</nav>


    <main class="main">
      



<section id="single">
    <h1 class="title">线性表</h1>

    <div class="tip">
        <time datetime="2021-12-16 12:43:02 &#43;0800 CST">2021年12月16日</time>
        <span class="split">
          ·
        </span>
        <span>
          36字
        </span>
        <span class="split">
          ·
        </span>
        <span>
          1分钟
        </span>
    </div>

    
    
    


    <div class="content">
      <p>线性表是一种最基本、最简单的数据结构，数据元素之间仅具有单一的前驱和后继关系。</p>
<h3 id="一线性表的逻辑结构">一、线性表的逻辑结构 <a href="#%e4%b8%80%e7%ba%bf%e6%80%a7%e8%a1%a8%e7%9a%84%e9%80%bb%e8%be%91%e7%bb%93%e6%9e%84" class="anchor">🔗</a></h3><p>定义：线性表简称表，是 n(n&gt;=0) 个具有<strong>相同类型</strong>的数据元素的<strong>有限序列</strong>。</p>
<h3 id="二线性表的顺序存储结构顺序表">二、线性表的顺序存储结构——顺序表 <a href="#%e4%ba%8c%e7%ba%bf%e6%80%a7%e8%a1%a8%e7%9a%84%e9%a1%ba%e5%ba%8f%e5%ad%98%e5%82%a8%e7%bb%93%e6%9e%84%e9%a1%ba%e5%ba%8f%e8%a1%a8" class="anchor">🔗</a></h3><p>顺序表是用一段<strong>地址连续</strong>的存储单元依次存储线性表的元素。通常使用数组实现。</p>
<p>用数组存储顺序表，意味着要分配固定长度的数组空间，因此，必须确定数组的长度。</p>
<p>顺序表中数据元素的地址是其序号的线性函数，只要确定了存储顺序表的起始地址（即基地址），计算任意一个元素的存储地址的时间是相等的，具有这一特点的存储结构称为<strong>随机存储结构</strong>。</p>
<p>顺序表具有以下缺点：</p>
<ul>
<li>插入和删除操作需要移动大量元素。在顺序表上做插入和删除操作，等概率情况下，平均要移动表中一半的元素。</li>
<li>表的容量难以确定。由于数组的长度必须事先确定，因为此，当线性表的长度变化较大时，难以确定合适的存储规模。</li>
<li>造成存储空间的“碎片”。数组要求占用连续的存储空间，即使存储单元数超过所需的数目，如果不连续也不能使用，造成存储空间的“碎片”现象。</li>
</ul>
<p>造成上述顺序表的缺点的根本原因是静态存储分配，为了克服顺序表的缺点，可以采用动态存储分配连存储线性表，也就是采用链接存储结构。</p>
<h3 id="三线性表的链接存储结构及实现">三、线性表的链接存储结构及实现 <a href="#%e4%b8%89%e7%ba%bf%e6%80%a7%e8%a1%a8%e7%9a%84%e9%93%be%e6%8e%a5%e5%ad%98%e5%82%a8%e7%bb%93%e6%9e%84%e5%8f%8a%e5%ae%9e%e7%8e%b0" class="anchor">🔗</a></h3><h4 id="单链表">单链表 <a href="#%e5%8d%95%e9%93%be%e8%a1%a8" class="anchor">🔗</a></h4><p>单链表是用一组任意的存储单元存放线性表的元素，这组存储单元可以连续也可以不连续，甚至可以零散分布在内存中的任意位置。每个存储单元在存储数据元素的同时，还必须存储其后继元素所在的地址信息，这个地址信息称为指针。这两部分组成数据元素的存储映射，称为节点。</p>
<p>单链表只有一个指针域（next）。</p>
<p>头节点：无论单链表是否为空，头指针始终指向头节点，因此空表和非空表的处理统一了。</p>
<h4 id="循环链表">循环链表 <a href="#%e5%be%aa%e7%8e%af%e9%93%be%e8%a1%a8" class="anchor">🔗</a></h4><p>在单链表中，如果将终端节点的指针域由空指针改为指向头节点，形成一个环，这种头尾相接的单链表称为循环链表。</p>
<p>从循环链表中任一节点出发，可以扫描到其他节点，增加了链表操作的灵活性。</p>
<p>但由于循环链表没有明显的尾端，要格外注意循环条件。通常判断用作循环变量的工作指针是否等于头一个制定指针（头指针或尾指针）。</p>
<h4 id="双链表">双链表 <a href="#%e5%8f%8c%e9%93%be%e8%a1%a8" class="anchor">🔗</a></h4><p>如果希望快速确定表中任一节点的前驱节点，可以在单链表的每个节点中再设置一个指向其前驱节点的指针域，这样就形成了双链表。</p>
<h3 id="顺序表和链表的比较">顺序表和链表的比较 <a href="#%e9%a1%ba%e5%ba%8f%e8%a1%a8%e5%92%8c%e9%93%be%e8%a1%a8%e7%9a%84%e6%af%94%e8%be%83" class="anchor">🔗</a></h3><h4 id="时间性能比较">时间性能比较 <a href="#%e6%97%b6%e9%97%b4%e6%80%a7%e8%83%bd%e6%af%94%e8%be%83" class="anchor">🔗</a></h4><p>按位置随机访问某个元素，顺序表更快一些，时间性能为 O(1)；相比之下链表需要从头开始遍历扫描，所需要的平均时间为 O(n)。</p>
<p>在链表进行插入和删除操作不需要移动元素，在给出指向某个位置的指针后，进行插入和删除操作所需的时间仅为 O(1)；在顺序表中进行插入和删除操作需要移动表长一半的元素，平均时间为 O(n)。</p>
<p>一般规律，如果线性表需要频繁查找却很少进行插入和删除，或其操作和“数据元素在线性表中的位置密切相关时，宜采用顺序表作为存储结构；如果线性表需要频繁进行插入和删除操作，则宜采用链表作为存储结构。</p>
<h4 id="空间性能比较">空间性能比较 <a href="#%e7%a9%ba%e9%97%b4%e6%80%a7%e8%83%bd%e6%af%94%e8%be%83" class="anchor">🔗</a></h4><p>作为一般规律，当线性表中元素个数变化较大或未知时，最好采用链表实现；如果事先知道线性表的大致长度，采用顺序表的空间效率会更高。</p>

    </div>

    
        <div class="tags">
            
                <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">数据结构</a>
            
        </div>
    
    
    


<script src="https://utteranc.es/client.js"
repo=""
issue-term=""
theme=""
crossorigin="anonymous"
async>
</script>





</section>


    </main>
    
    <footer id="footer">
    

    <div class="copyright">
    
       © Copyright 
       2022 
       <span class="split">
        <svg fill="#bbbbbb" width="15" height="15" version="1.1" id="heart-15" xmlns="http://www.w3.org/2000/svg" width="15px" height="15px" viewBox="0 0 15 15">
  <path d="M13.91,6.75c-1.17,2.25-4.3,5.31-6.07,6.94c-0.1903,0.1718-0.4797,0.1718-0.67,0C5.39,12.06,2.26,9,1.09,6.75&#xA;&#x9;C-1.48,1.8,5-1.5,7.5,3.45C10-1.5,16.48,1.8,13.91,6.75z"/>
</svg>
       </span>
       罗泽勋
    
    </div>

    
</footer>



  </body>
</html>
