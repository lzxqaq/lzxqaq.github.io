<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    <title>形式验证基础理论 | Zexun Luo | 罗泽勋</title>

    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">    
<meta name="viewport" content="width=device-width,minimum-scale=1">
<meta name="description" content="1. 形式验证 Formal Verification 🔗所谓形式验证，是指从数学上完备地证明或验证电路的实现方案是否确实实现了电路设计所描述的功能。
形式验证主要验证数字IC设计流程中的各个阶段的代码功能是否一致，包括综合前RTL代码和综合后网表的验证。
形式验证方法分为等价性验证（Equivalence Checking）、模型检验（Model Checking）和定理证明（Theorem Proving）等。
下图为形式验证技术
2. 模型检查 Model Checking 🔗模型检查，也称为属性检查，是一种基于状态的形式验证方法。
模型检查主要是检查RTL代码是否满足规范中规定的一些特性。在规定这些特性时一般使用特性规范语言，一般也使用基于断言的验证语言。由于这种方法可以在不需要仿真的前提下检查设计中所有可能出现的情况是否满足规定的特性，所以使用这种方法不会遗漏任何的边界情况。
优点和缺点：一旦将系统模型和属性规范提供给模型检查器，验证过程就将是完全自动的。但是，从模型检查器要处理的状态数来看，模型检查适用于小型系统。
下图为模型检查的程序
3. 定理证明 Theorem Proving 🔗定理证明是使用数学推理方法验证所实现的系统是否满足设计要求（或规范）的过程。它是一种基于证据的形式验证方法。
优点和缺点:定理证明的最大优点是它可以处理非常复杂的系统。但是，定理证明不是完全自动的，需要人工干预才能完成，这需要时间以及操作人员的专业知识。而且，在证明失败的情况下，不会生成Equivalence
下图为定理证明的程序
4. 等价性检查 Equivalence Checking（EC） 🔗等价性检查是验证两个设计在功能上是否相同的过程。
等价性检查主要是检查两个门级网表之间是否一致，保证网表处理后不会改变电路的功能，或者保证网表能正确地实现RTL代码所描述的功能，或者保证两种RTL描述逻辑一致。等价性检查通过对比两个描述来检测它们的等价性。
等价性检查工具将两个设计读入内存，用形式化数据算法分析彼此的数据结构来进行比较。只要两个设计的所有输出管脚与每一个寄存器或锁存器的功能是一样的，那么就认为两个设计的功能等效。它主要是用来寻找实现中的缺陷，而不是设计中的缺陷，与检验C语言到汇编语言的转换的检测类似。因此这种方法很难发现同时存在于两种要比较的描述中的固有缺陷。
等价性检查有逻辑等价性检查（LEC）和顺序等价性检查（SEC）。
下图为等价性检查在 IC 流程的使用场景
5. 逻辑等价性检查 LEC(CEC) 🔗逻辑等价性检查（Logical Equivalence Checking，LEC），也称为组合等价性检查（Combinational Equivalence Checking，CEC）。
它是验证两个设计在寄存器之间具有相同组合逻辑的过程。两个被比较的设计也应具有相同数量的寄存器。该技术用于验证不同抽象级别的两个设计在功能上是否相同；例如，门级网表在功能上与布局网表是否相同。
对组合逻辑来说，不存在状态寄存器，其输出值Z[t]不依赖于前面的输入值Xt-i。这时只要对每个输入向量证明其输出向量相同。
下图为逻辑等价检查示意图
6. 时序等价性检查 SEC 🔗时序等价性检查（Sequential EquivalencevChecking），验证两个设计在功能上是否相同的过程，并且在提供相同输入时验证是否有相同的输出。它用于比较两种设计的顺序逻辑，而这两种设计可能有不同的实现。
对一个时序电路而言，可以把它看成一个有限状态机(FSM，finite-state machine)。电路功能的等价可以用有限状态机的等价来判断。假定有两个状态机A和B，要对它们进行比较。直观的说，当A和B有相同的接口，而且从相同的初始状态出发，两者对有效输入值序列产生相同的输出值序列，则可以说A和B等价。
下图为时序等价性检查示意图">
<meta name="generator" content="Hugo 0.99.1" />


  <META NAME="ROBOTS" CONTENT="NOINDEX, NOFOLLOW">


<link rel="stylesheet" href="/css/style.css">



<link rel="shortcut icon" href="/images/favicon.ico" type="image/x-icon" />
<link href="https://cdn.bootcss.com/aplayer/1.10.1/APlayer.min.css" rel="stylesheet">
<script src="https://cdn.bootcss.com/aplayer/1.10.1/APlayer.min.js"></script>

 
    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'G-KDTTBGMLCQ', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>







  </head>

  <body>
    <nav class="navigation">
	
		<a href="/"> <span class="arrow">←</span>首页</a>
	
	
	
	

	
		<a href="/posts">博客</a>
	
		<a href="/tags">归档</a>
	
		<a href="/about">关于</a>
	

	
	  <a class="button" href="/index.xml">订阅</a>
	
</nav>


    <main class="main">
      



<section id="single">
    <h1 class="title">形式验证基础理论</h1>

    <div class="tip">
        <time datetime="2022-06-12 22:35:54 &#43;0800 CST">2022年06月12日</time>
        <span class="split">
          ·
        </span>
        <span>
          56字
        </span>
        <span class="split">
          ·
        </span>
        <span>
          1分钟
        </span>
    </div>

    
    
    
        
  


    


    <div class="content">
      <h1 id="1-形式验证-formal-verification">1. 形式验证 Formal Verification <a href="#1-%e5%bd%a2%e5%bc%8f%e9%aa%8c%e8%af%81-formal-verification" class="anchor">🔗</a></h1><p>所谓形式验证，是指从数学上<strong>完备地</strong>证明或验证电路的实现方案是否确实实现了电路设计所描述的功能。</p>
<p>形式验证主要验证数字IC设计流程中的各个阶段的代码功能是否一致，包括综合前RTL代码和综合后网表的验证。</p>
<p>形式验证方法分为等价性验证（Equivalence Checking）、模型检验（Model Checking）和定理证明（Theorem Proving）等。</p>
<p>下图为形式验证技术</p>
<p><p class="markdown-image">
  <img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2022-6-12/formal_verification.png" alt="Formal Verification"  />
</p></p>
<h1 id="2-模型检查-model-checking">2. 模型检查 Model Checking <a href="#2-%e6%a8%a1%e5%9e%8b%e6%a3%80%e6%9f%a5-model-checking" class="anchor">🔗</a></h1><p>模型检查，也称为属性检查，是一种基于状态的形式验证方法。</p>
<p>模型检查主要是检查RTL代码是否满足规范中规定的一些特性。在规定这些特性时一般使用特性规范语言，一般也使用基于断言的验证语言。由于这种方法可以在不需要仿真的前提下检查设计中所有可能出现的情况是否满足规定的特性，所以使用这种方法不会遗漏任何的边界情况。</p>
<p>优点和缺点：一旦将系统模型和属性规范提供给模型检查器，验证过程就将是完全自动的。但是，从模型检查器要处理的状态数来看，模型检查适用于小型系统。</p>
<p>下图为模型检查的程序</p>
<p><p class="markdown-image">
  <img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2022-6-12/model_checking.png" alt="Model Checking"  />
</p></p>
<h1 id="3-定理证明-theorem-proving">3. 定理证明 Theorem Proving <a href="#3-%e5%ae%9a%e7%90%86%e8%af%81%e6%98%8e-theorem-proving" class="anchor">🔗</a></h1><p>定理证明是使用数学推理方法验证所实现的系统是否满足设计要求（或规范）的过程。它是一种基于证据的形式验证方法。</p>
<p>优点和缺点:定理证明的最大优点是它可以处理非常复杂的系统。但是，定理证明不是完全自动的，需要人工干预才能完成，这需要时间以及操作人员的专业知识。而且，在证明失败的情况下，不会生成Equivalence</p>
<p>下图为定理证明的程序</p>
<p><p class="markdown-image">
  <img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2022-6-12/theorem_proving.png" alt="Theorem Proving"  />
</p></p>
<h1 id="4-等价性检查-equivalence-checkingec">4. 等价性检查 Equivalence Checking（EC） <a href="#4-%e7%ad%89%e4%bb%b7%e6%80%a7%e6%a3%80%e6%9f%a5-equivalence-checkingec" class="anchor">🔗</a></h1><p>等价性检查是验证两个设计在功能上是否相同的过程。</p>
<p>等价性检查主要是检查两个门级网表之间是否一致，保证网表处理后不会改变电路的功能，或者保证网表能正确地实现RTL代码所描述的功能，或者保证两种RTL描述逻辑一致。等价性检查通过对比两个描述来检测它们的等价性。</p>
<p>等价性检查工具将两个设计读入内存，用形式化数据算法分析彼此的数据结构来进行比较。只要两个设计的所有输出管脚与每一个寄存器或锁存器的功能是一样的，那么就认为两个设计的功能等效。它主要是用来寻找实现中的缺陷，而不是设计中的缺陷，与检验C语言到汇编语言的转换的检测类似。因此这种方法很难发现同时存在于两种要比较的描述中的固有缺陷。</p>
<p>等价性检查有逻辑等价性检查（LEC）和顺序等价性检查（SEC）。</p>
<p>下图为等价性检查在 IC 流程的使用场景</p>
<p><p class="markdown-image">
  <img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2022-6-12/ec.jpg" alt="EC"  />
</p></p>
<h1 id="5-逻辑等价性检查-leccec">5. 逻辑等价性检查 LEC(CEC) <a href="#5-%e9%80%bb%e8%be%91%e7%ad%89%e4%bb%b7%e6%80%a7%e6%a3%80%e6%9f%a5-leccec" class="anchor">🔗</a></h1><p>逻辑等价性检查（Logical Equivalence Checking，LEC），也称为组合等价性检查（Combinational Equivalence Checking，CEC）。</p>
<p>它是验证两个设计在寄存器之间具有相同组合逻辑的过程。两个被比较的设计也应具有相同数量的寄存器。该技术用于验证不同抽象级别的两个设计在功能上是否相同；例如，门级网表在功能上与布局网表是否相同。</p>
<p>对组合逻辑来说，不存在状态寄存器，其输出值Z[t]不依赖于前面的输入值X<a href="1%e2%89%a4i%e2%89%a4t">t-i</a>。这时只要对每个输入向量证明其输出向量相同。</p>
<p>下图为逻辑等价检查示意图</p>
<p><p class="markdown-image">
  <img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2022-6-12/lec.png" alt="LEC"  />
</p></p>
<p><p class="markdown-image">
  <img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2022-6-12/lec2.jpg" alt="LEC"  />
</p></p>
<h1 id="6-时序等价性检查-sec">6. 时序等价性检查 SEC <a href="#6-%e6%97%b6%e5%ba%8f%e7%ad%89%e4%bb%b7%e6%80%a7%e6%a3%80%e6%9f%a5-sec" class="anchor">🔗</a></h1><p>时序等价性检查（Sequential EquivalencevChecking），验证两个设计在功能上是否相同的过程，并且在提供相同输入时验证是否有相同的输出。它用于比较两种设计的顺序逻辑，而这两种设计可能有不同的实现。</p>
<p>对一个时序电路而言，可以把它看成一个有限状态机(FSM，finite-state machine)。电路功能的等价可以用有限状态机的等价来判断。假定有两个状态机A和B，要对它们进行比较。直观的说，当A和B有相同的接口，而且从相同的初始状态出发，两者对有效输入值序列产生相同的输出值序列，则可以说A和B等价。</p>
<p>下图为时序等价性检查示意图</p>
<p><p class="markdown-image">
  <img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2022-6-12/sec.png" alt="SEC"  />
</p></p>
<p><p class="markdown-image">
  <img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2022-6-12/sec2.png" alt="SEC"  />
</p></p>

    </div>

    
        <div class="tags">
            
                <a href="/tags/eda">eda</a>
            
        </div>
    
    
    


<script src="https://utteranc.es/client.js"
repo=""
issue-term=""
theme=""
crossorigin="anonymous"
async>
</script>





</section>


    </main>
    
    <footer id="footer">
    

    <div class="copyright">
    
       © Copyright 
       2022 
       <span class="split">
        <svg fill="#bbbbbb" width="15" height="15" version="1.1" id="heart-15" xmlns="http://www.w3.org/2000/svg" width="15px" height="15px" viewBox="0 0 15 15">
  <path d="M13.91,6.75c-1.17,2.25-4.3,5.31-6.07,6.94c-0.1903,0.1718-0.4797,0.1718-0.67,0C5.39,12.06,2.26,9,1.09,6.75&#xA;&#x9;C-1.48,1.8,5-1.5,7.5,3.45C10-1.5,16.48,1.8,13.91,6.75z"/>
</svg>
       </span>
       罗泽勋
    
    </div>

    
</footer>



  </body>
</html>
