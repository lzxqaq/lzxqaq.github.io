<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>设计模式 on Zexun Luo | 罗泽勋</title>
    <link>/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link>
    <description>Recent content in 设计模式 on Zexun Luo | 罗泽勋</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sat, 15 Jan 2022 08:14:07 +0800</lastBuildDate><atom:link href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>C&#43;&#43; 开发必备之设计模式</title>
      <link>/posts/design-pattern/</link>
      <pubDate>Sat, 15 Jan 2022 08:14:07 +0800</pubDate>
      
      <guid>/posts/design-pattern/</guid>
      <description>转载自https://github.com/huihut/interview
 各大设计模式例子参考：CSDN专栏 . C++ 设计模式 系列博文
 设计模式工程目录
单例模式 🔗单例模式例子
抽象工厂模式 🔗抽象工厂模式例子
适配器模式 🔗适配器模式例子
桥接模式 🔗桥接模式例子
观察者模式 🔗观察者模式例子
设计模式的六大原则 🔗 单一职责原则（SRP，Single Responsibility Principle） 里氏替换原则（LSP，Liskov Substitution Principle） 依赖倒置原则（DIP，Dependence Inversion Principle） 接口隔离原则（ISP，Interface Segregation Principle） 迪米特法则（LoD，Law of Demeter） 开放封闭原则（OCP，Open Close Principle）  </description>
    </item>
    
    <item>
      <title>面向对象设计原则之开闭原则</title>
      <link>/posts/oop/</link>
      <pubDate>Tue, 28 Dec 2021 08:07:08 +0800</pubDate>
      
      <guid>/posts/oop/</guid>
      <description>转载自https://blog.csdn.net/lovelion/article/details/17517213
开闭原则是面向对象的可复用设计的第一块基石，它是最重要的面向对象设计原则。开闭原则由Bertrand Meyer于1988年提出，其定义如下：
 开闭原则(Open-Closed Principle, OCP)：一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。
 在开闭原则的定义中，软件实体可以指一个软件模块、一个由多个类组成的局部结构或一个独立的类。
任何软件都需要面临一个很重要的问题，即它们的需求会随时间的推移而发生变化。当软件系统需要面对新的需求时，我们应该尽量保证系统的设计框架是稳定的。如果一个软件设计符合开闭原则，那么可以非常方便地对系统进行扩展，而且在扩展时无须修改现有代码，使得软件系统在拥有适应性和灵活性的同时具备较好的稳定性和延续性。随着软件规模越来越大，软件寿命越来越长，软件维护成本越来越高，设计满足开闭原则的软件系统也变得越来越重要。
为了满足开闭原则，需要对系统进行抽象化设计，抽象化是开闭原则的关键。在Java、C#等编程语言中，可以为系统定义一个相对稳定的抽象层，而将不同的实现行为移至具体的实现层中完成。在很多面向对象编程语言中都提供了接口、抽象类等机制，可以通过它们定义系统的抽象层，再通过具体类来进行扩展。如果需要修改系统的行为，无须对抽象层进行任何改动，只需要增加新的具体类来实现新的业务功能即可，实现在不修改已有代码的基础上扩展系统的功能，达到开闭原则的要求。
 Sunny软件公司开发的CRM系统可以显示各种类型的图表，如饼状图和柱状图等，为了支持多种图表显示方式，原始设计方案如图1所示：
 图1 初始设计方案结构图
在ChartDisplay类的display()方法中存在如下代码片段：
...... if (type.equals(&amp;#34;pie&amp;#34;)) { PieChart chart = new PieChart(); chart.display(); } else if (type.equals(&amp;#34;bar&amp;#34;)) { BarChart chart = new BarChart(); chart.display(); } ...... 在该代码中，如果需要增加一个新的图表类，如折线图LineChart，则需要修改ChartDisplay类的display()方法的源代码，增加新的判断逻辑，违反了开闭原则。
现对该系统进行重构，使之符合开闭原则。
在本实例中，由于在ChartDisplay类的display()方法中针对每一个图表类编程，因此增加新的图表类不得不修改源代码。可以通过抽象化的方式对系统进行重构，使之增加新的图表类时无须修改源代码，满足开闭原则。具体做法如下：
(1) 增加一个抽象图表类AbstractChart，将各种具体图表类作为其子类；
(2) ChartDisplay类针对抽象图表类进行编程，由客户端来决定使用哪种具体图表。
重构后结构如图2所示：
图2 重构后的结构图
在图2中，我们引入了抽象图表类AbstractChart，且ChartDisplay针对抽象图表类进行编程，并通过setChart()方法由客户端来设置实例化的具体图表对象，在ChartDisplay的display()方法中调用chart对象的display()方法显示图表。如果需要增加一种新的图表，如折线图LineChart，只需要将LineChart也作为AbstractChart的子类，在客户端向ChartDisplay中注入一个LineChart对象即可，无须修改现有类库的源代码。
注意：因为xml和properties等格式的配置文件是纯文本文件，可以直接通过VI编辑器或记事本进行编辑，且无须编译，因此在软件开发中，一般不把对配置文件的修改认为是对系统源代码的修改。如果一个系统在扩展时只涉及到修改配置文件，而原有的Java代码或C#代码没有做任何修改，该系统即可认为是一个符合开闭原则的系统。</description>
    </item>
    
    <item>
      <title>面向对象设计原则之单一职责原则</title>
      <link>/posts/singleresponsibility/</link>
      <pubDate>Tue, 28 Dec 2021 07:40:16 +0800</pubDate>
      
      <guid>/posts/singleresponsibility/</guid>
      <description>转载自https://blog.csdn.net/lovelion/article/details/17517213
单一职责原则是最简单的面向对象设计原则，它用于控制类的粒度大小。单一职责原则定义如下：
单一职责原则(Single Responsibility Principle, SRP)：一个类只负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。
单一职责原则告诉我们：一个类不能太“累”！在软件系统中，一个类（大到模块，小到方法）承担的职责越多，它被复用的可能性就越小，而且一个类承担的职责过多，就相当于将这些职责耦合在一起，当其中一个职责变化时，可能会影响其他职责的运作，因此要将这些职责进行分离，将不同的职责封装在不同的类中，即将不同的变化原因封装在不同的类中，如果多个职责总是同时发生改变则可将它们封装在同一类中。
单一职责原则是实现高内聚、低耦合的指导方针，它是最简单但又最难运用的原则，需要设计人员发现类的不同职责并将其分离，而发现类的多重职责需要设计人员具有较强的分析设计能力和相关实践经验。
下面通过一个简单实例来进一步分析单一职责原则：
 Sunny软件公司开发人员针对某CRM（Customer Relationship Management，客户关系管理）系统中客户信息图形统计模块提出了如图1所示初始设计方案：
 图1 初始设计方案结构图
 在图1中，CustomerDataChart类中的方法说明如下：getConnection()方法用于连接数据库，findCustomers()用于查询所有的客户信息，createChart()用于创建图表，displayChart()用于显示图表。
 现使用单一职责原则对其进行重构。
在图1中，CustomerDataChart类承担了太多的职责，既包含与数据库相关的方法，又包含与图表生成和显示相关的方法。如果在其他类中也需要连接数据库或者使用findCustomers()方法查询客户信息，则难以实现代码的重用。无论是修改数据库连接方式还是修改图表显示方式都需要修改该类，它不止一个引起它变化的原因，违背了单一职责原则。因此需要对该类进行拆分，使其满足单一职责原则，类CustomerDataChart可拆分为如下三个类：
(1) DBUtil：负责连接数据库，包含数据库连接方法getConnection()；
(2) CustomerDAO：负责操作数据库中的Customer表，包含对Customer表的增删改查等方法，如findCustomers()；
(3) CustomerDataChart：负责图表的生成和显示，包含方法createChart()和displayChart()。
使用单一职责原则重构后的结构如图2所示：
图2 重构后的结构图</description>
    </item>
    
    <item>
      <title>面向对象设计原则概述</title>
      <link>/posts/oop/</link>
      <pubDate>Tue, 28 Dec 2021 06:59:01 +0800</pubDate>
      
      <guid>/posts/oop/</guid>
      <description>转载自https://blog.csdn.net/lovelion/article/details/17517213
对于面向对象软件系统的设计而言，在支持可维护性的同时，提高系统的可复用性是一个至关重要的问题，如何同时提高一个软件系统的可维护性和可复用性是面向对象设计需要解决的核心问题之一。在面向对象设计中，可维护性的复用是以设计原则为基础的。每一个原则都蕴含一些面向对象设计的思想，可以从不同的角度提升一个软件结构的设计水平。
面向对象设计原则为支持可维护性复用而诞生，这些原则蕴含在很多设计模式中，它们是从许多设计方案中总结出的指导性原则。面向对象设计原则也是我们用于评价一个设计模式的使用效果的重要指标之一，在设计模式的学习中，大家经常会看到诸如“XXX模式符合XXX原则”、“XXX模式违反了XXX原则”这样的语句。
最常见的7种面向对象设计原则如下表所示：</description>
    </item>
    
    <item>
      <title>简单工厂模式</title>
      <link>/posts/singlefactory/</link>
      <pubDate>Tue, 28 Dec 2021 06:50:56 +0800</pubDate>
      
      <guid>/posts/singlefactory/</guid>
      <description>转载自https://blog.csdn.net/lovelion/article/details/17517213
工厂模式是最常用的一类创建型设计模式，通常我们所说的工厂模式是指工厂方法模式，它也是使用频率最高的工厂模式。本章将要学习的简单工厂模式是工厂方法模式的“小弟”，它不属于GoF 23种设计模式，但在软件开发中应用也较为频繁，通常将它作为学习其他工厂模式的入门。此外，工厂方法模式还有一位“大哥”——抽象工厂模式。这三种工厂模式各具特色，难度也逐个加大，在软件开发中它们都得到了广泛的应用，成为面向对象软件中常用的创建对象的工具。
一、图表库的设计 🔗 Sunny软件公司欲基于Java语言开发一套图表库，该图表库可以为应用系统提供各种不同外观的图表，例如柱状图、饼状图、折线图等。Sunny软件公司图表库设计人员希望为应用系统开发人员提供一套灵活易用的图表库，而且可以较为方便地对图表库进行扩展，以便能够在将来增加一些新类型的图表。
 Sunny软件公司图表库设计人员提出了一个初始设计方案，将所有图表的实现代码封装在一个Chart类中，其框架代码如下所示：
class Chart { private String type; //图表类型 public Chart(Object[][] data, String type) { this.type = type; if (type.equalsIgnoreCase(&amp;#34;histogram&amp;#34;)) { //初始化柱状图 } else if (type.equalsIgnoreCase(&amp;#34;pie&amp;#34;)) { //初始化饼状图 } else if (type.equalsIgnoreCase(&amp;#34;line&amp;#34;)) { //初始化折线图 } } public void display() { if (this.type.equalsIgnoreCase(&amp;#34;histogram&amp;#34;)) { //显示柱状图 } else if (this.type.equalsIgnoreCase(&amp;#34;pie&amp;#34;)) { //显示饼状图 } else if (this.type.equalsIgnoreCase(&amp;#34;line&amp;#34;)) { //显示折线图 }	} } 客户端代码通过调用Chart类的构造函数来创建图表对象，根据参数type的不同可以得到不同类型的图表，然后再调用display()方法来显示相应的图表。
不难看出，Chart类是一个“巨大的”类，在该类的设计中存在如下几个问题：
(1) 在Chart类中包含很多“if…else…”代码块，整个类的代码相当冗长，代码越长，阅读难度、维护难度和测试难度也越大；而且大量条件语句的存在还将影响系统的性能，程序在执行过程中需要做大量的条件判断。
(2) Chart类的职责过重，它负责初始化和显示所有的图表对象，将各种图表对象的初始化代码和显示代码集中在一个类中实现，违反了“单一职责原则”，不利于类的重用和维护；而且将大量的对象初始化代码都写在构造函数中将导致构造函数非常庞大，对象在创建时需要进行条件判断，降低了对象创建的效率。</description>
    </item>
    
    <item>
      <title>设计模式概述</title>
      <link>/posts/design/</link>
      <pubDate>Sun, 26 Dec 2021 10:10:12 +0800</pubDate>
      
      <guid>/posts/design/</guid>
      <description>在软件开发生命周期的每一个阶段都存在着一些被认同的模式。
在软件模式中，设计模式是研究最为深入的分支，设计模式用于在特定的调剂爱你下为一些重复出现的软件设计问题提供合理的、有效的解决方案。
一般定义：设计模式（Design Pattern)是一套被反复使用、多数人知晓的、进过分类编目的代码设计经验的总结，使用设计模式是为了可重用代码、让代码更容易被他人理解并且保证代码可靠性。
狭义的设计模式是指 GoF 在《设计模式：可复用面向对象软件的基础》一书中所介绍的23种经典设计模式。不过设计模式并不仅仅只有这23种，越来越多的新模式不断诞生并得以应用。
23 种设计模式根据用途可分为创建型、结构型和行为型三种。其中创建型模式主要用于描述如何创建对象，结构型模式主要用于描述如何实现类或对象的组合，行为型模式主要用于描述类或对象怎样交互以及怎样分配职责。
值得注意的是，简单工厂模式没有在 23 种设计模式里面，但一般都会对它进行说明。</description>
    </item>
    
  </channel>
</rss>
