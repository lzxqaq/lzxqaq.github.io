<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Qt on Zexun Luo | 罗泽勋</title>
    <link>/tags/qt/</link>
    <description>Recent content in Qt on Zexun Luo | 罗泽勋</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 14 Apr 2022 15:05:13 +0800</lastBuildDate><atom:link href="/tags/qt/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Qt 信号槽与观察者模式</title>
      <link>/posts/2022-4-14/</link>
      <pubDate>Thu, 14 Apr 2022 15:05:13 +0800</pubDate>
      
      <guid>/posts/2022-4-14/</guid>
      <description>介绍 🔗在 GUI 编程中，当我们更改一个小部件时，我们经常希望通知另一个小部件。 更一般地说，我们希望任何类型的对象都能够相互通信。 例如，如果用户单击 关闭 窗口的 close() 调用.
其他工具包使用回调实现这种通信。 回调是指向函数的指针，因此如果您希望处理函数通知您某个事件，您可以将指向另一个函数（回调）的指针传递给处理函数。 然后，处理函数会在适当的时候调用回调。 虽然确实存在使用此方法的成功框架，但回调可能不直观，并且可能在确保回调参数的类型正确性方面遇到问题。
信号和插槽 🔗在 Qt 中，我们有一个回调技术的替代方案：我们使用信号和槽。 当特定事件发生时会发出信号。 Qt 的小部件有许多预定义的信号，但我们总是可以子类化小部件以向它们添加我们自己的信号。 插槽是响应特定信号而调用的函数。 Qt 的小部件有许多预定义的插槽，但通常的做法是子类化小部件并添加自己的插槽，以便您可以处理您感兴趣的信号。
继承的所有类都 QObject 或其子类之一（例如 QWidget 可以包含信号和槽。 当对象以可能对其他对象感兴趣的方式改变其状态时，信号由对象发出。 这就是对象进行通信的全部内容。 它不知道也不关心是否有任何东西在接收它发出的信号。 这是真正的信息封装，并确保对象可以用作软件组件。
与回调相比，信号和槽的速度稍慢，因为它们提供了更高的灵活性，尽管对于实际应用程序的差异并不显着。 一般来说，发出一个连接到某些槽的信号，比直接调用接收器慢大约十倍，使用非虚拟函数调用。 这是定位连接对象、安全地迭代所有连接（即检查后续接收器在发射期间是否被破坏）以及以通用方式编组任何参数所需的开销。 虽然十个非虚拟函数调用听起来很多，但它的开销比任何一个都少得多 new或者 delete操作，例如。 只要您执行幕后需要的字符串、向量或列表操作 new或者 delete，信号和槽的开销只占整个函数调用成本的很小一部分。 每当您在插槽中进行系统调用时，都是如此。 或者间接调用十多个函数。 信号和槽机制的简单性和灵活性非常值得您的用户甚至不会注意到的开销。
观察者模式 🔗观察者模式定义了一对多的依赖关系，当一个对象改变时，它的所有依赖者都会收到通知并自动更新。类似很多人订阅了一个公众号，一旦公众号发送消息，订阅的人都会收到消息。
经典的观察者模式在讲解举例的时候通常会举报纸和订阅者的例子。有一个报纸Newspaper，有一个订阅者类Subscriber。Subscriber可以订阅Newspaper。这样，当Newspaper有了新的内容的时候，Subscriber可以立即得到通知。在这个例子中，观察者是Subscriber，被观察者是Newspaper。在经典的实现代码中，观察者会将自身注册到被观察者的一个容器中。被观察者发生了任何变化的时候，会主动遍历这个容器，依次通知各个观察者。</description>
    </item>
    
    <item>
      <title>PImpl 机制和 Qt 的实现 D-Pointer</title>
      <link>/posts/2022-4-14-dpoint/</link>
      <pubDate>Thu, 14 Apr 2022 12:26:14 +0800</pubDate>
      
      <guid>/posts/2022-4-14-dpoint/</guid>
      <description>一、什么是 PImpl 🔗PImpl是 Pointer to implementation的缩写， 是C++ 在构建导出库接口时特有的技术手段。 即是将类Class中所有私有变量以及私有方法，封装在一单独的实现类ClassImpl中。我们在Class中通过一指向ClassImpl的私有指针，访问这些私有数据。而ClassImpl类的具体定义和实现，我们放入cpp中。
二、什么是 D-Pointer 🔗如果你曾经看过 Qt 的源代码，你会看到很多 Q_D 和 Q_Q 宏。Q_D 和 Q_Q 宏定义是 d-pointer，它可以把一个类库的实施细节对使用的用户隐藏， 而且对实施的更改不会打破二进制兼容。Qt中的 D-Pointer 技术，便是 PImpl 机制的一种实现方式。
三、为什么会产生二进制兼容问题 🔗究其原因，通过添加了一个新的数据成员，我们最终改变了类对象的大小。为什么会这样？因为当你的C+编译器生成代码的时候，他会用偏移量来访问对象的数据。
四、不要改变导出的 C++ 类的大小 🔗总之，一旦你的类库发布了，永远不要改变 导出的 C++ 类的大小或者布局（不要移动成员）。C++ 编译器生成的代码会假定，一个类的大小和成员的顺序 编译后 就不会改变.
那么，如何在不改变对象的大小的同时添加新的功能呢？
五、d-pointer 🔗诀窍是通过保存唯一的一个指针而保持一个类库所有公共类的大小不变。这个指针指向一个包含所有数据的私有的（内部的）数据结构。内部结构的大小可以增大或者减小，而不会对应用程序带来副作用，因为指针只会被类库里面的代码访问，从应用程序的视角来看，对象的大小并没有改变 - 它永远是指针的大小。 这个指针被叫做 d-pointer 。
六、d-pointer 的其它好处 🔗这里不全都是和二进制兼容有关。d-pointer 还有其它的好处： 隐藏了实现细节 - 我们可以只发布带有头文件和二进制文件的 WidgetLib。源文件可以是闭源代码的。
头文件很干净，不包含实现细节，可以直接作为 API 参考。 由于实施需要的包含的头文件从头文件里已到了实施（源文件）里面，编译速更快。（译：降低了编译依赖） 事实上，上边的好处是微乎其微的。Qt 使用 d-pointer 的真正原因是为了二进制兼容。
七、Qt 中的 d-pointers 🔗在 Qt 中，几乎所有的公有类都使用了 d-pointer。唯一不用的情况是如果事先知道某个类永远不会添加额外的成员变量。例如，像 QPoint, QRect 这些类，我们不期望有新的成员添加，因此它们的数据成员直接保存在类里而没用 d-pointer。</description>
    </item>
    
  </channel>
</rss>
