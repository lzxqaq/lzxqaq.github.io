<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <title>【转载】C&#43;&#43; 面试之链接装载库 - Zexun Luo | 罗泽勋</title>
    <meta property="og:title" content="【转载】C&#43;&#43; 面试之链接装载库 - Zexun Luo | 罗泽勋">
    
    <meta name="twitter:card" content="summary">

    
      
    

    
      
      <meta property="description" content="转载自https://github.com/huihut/interview
[&amp;hellip;] 本节部分知识点来自《程序员的自我修养——链接装载库》
[&amp;hellip;] 一般应用程序内存空间有如下区域：
[&amp;hellip;] 栈保存了一个函数调用所需要的维护信息，常被称为堆栈帧（Stack Frame）或活动记录（Activate Record），一般包含以下几方面：
[&amp;hellip;]  &amp;hellip;">
      <meta property="og:description" content="转载自https://github.com/huihut/interview
[&amp;hellip;] 本节部分知识点来自《程序员的自我修养——链接装载库》
[&amp;hellip;] 一般应用程序内存空间有如下区域：
[&amp;hellip;] 栈保存了一个函数调用所需要的维护信息，常被称为堆栈帧（Stack Frame）或活动记录（Activate Record），一般包含以下几方面：
[&amp;hellip;]  &amp;hellip;">
      
    

    
    
    <meta name="twitter:image" content="https://gitee.com/huihut/interview/raw/master/images/WindowsLoadLibrary.png">
    
    

    

    
    
    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/fonts.css" />
    <script async src="/js/load-typekit.js"></script>
<link rel="stylesheet" href="/css/custom.css" />
<link href="https://cdn.bootcss.com/aplayer/1.10.1/APlayer.min.css" rel="stylesheet">
<script src="https://cdn.bootcss.com/aplayer/1.10.1/APlayer.min.js"></script>

  </head>

  
  <body class="post">
    <header class="masthead">
      

<h1><a href="/"><img src="/images/logo.png" alt="Zexun Luo" /></a></h1>



      <nav class="menu">
  <ul>
  
  
  <li><a href="/">主页</a></li>
  
  <li><a href="/about/">关于</a></li>
  
  <li><a href="/blog/">日志</a></li>
  
  <li><a href="/post/">编程</a></li>
  
  <li><a href="/series/">标签</a></li>
  
  <li><a href="/categories/">分类</a></li>
  
  <li><a href="/cv/">简历</a></li>
  
  <li><a href="/note/">抄录</a></li>
  
  </ul>
</nav>

    </header>

    <article class="main">
      <header class="title">
      
<h1>【转载】C&#43;&#43; 面试之链接装载库</h1>


<h3>罗泽勋 / 
2022-01-15</h3>

<hr>


      </header>


 <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#内存栈堆">内存、栈、堆</a></li>
        <li><a href="#编译链接">编译链接</a></li>
        <li><a href="#linux-的共享库shared-library">Linux 的共享库（Shared Library）</a></li>
        <li><a href="#windows-应用程序入口函数">Windows 应用程序入口函数</a></li>
        <li><a href="#windows-的动态链接库dynamic-link-library">Windows 的动态链接库（Dynamic-Link Library）</a></li>
        <li><a href="#运行库runtime-library">运行库（Runtime Library）</a></li>
      </ul>
    </li>
  </ul>
</nav> 


<p>转载自<a href="https://github.com/huihut/interview">https://github.com/huihut/interview</a></p>
<blockquote>
<p>本节部分知识点来自《程序员的自我修养——链接装载库》</p>
</blockquote>
<h3 id="内存栈堆">内存、栈、堆</h3>
<p>一般应用程序内存空间有如下区域：</p>
<ul>
<li>栈：由操作系统自动分配释放，存放函数的参数值、局部变量等的值，用于维护函数调用的上下文</li>
<li>堆：一般由程序员分配释放，若程序员不释放，程序结束时可能由操作系统回收，用来容纳应用程序动态分配的内存区域</li>
<li>可执行文件映像：存储着可执行文件在内存中的映像，由装载器装载是将可执行文件的内存读取或映射到这里</li>
<li>保留区：保留区并不是一个单一的内存区域，而是对内存中受到保护而禁止访问的内存区域的总称，如通常 C 语言讲无效指针赋值为 0（NULL），因此 0 地址正常情况下不可能有效的访问数据</li>
</ul>
<h4 id="栈">栈</h4>
<p>栈保存了一个函数调用所需要的维护信息，常被称为堆栈帧（Stack Frame）或活动记录（Activate Record），一般包含以下几方面：</p>
<ul>
<li>函数的返回地址和参数</li>
<li>临时变量：包括函数的非静态局部变量以及编译器自动生成的其他临时变量</li>
<li>保存上下文：包括函数调用前后需要保持不变的寄存器</li>
</ul>
<h4 id="堆">堆</h4>
<p>堆分配算法：</p>
<ul>
<li>空闲链表（Free List）</li>
<li>位图（Bitmap）</li>
<li>对象池</li>
</ul>
<h4 id="段错误segment-fault-或-非法操作该内存地址不能-readwrite">“段错误（segment fault）” 或 “非法操作，该内存地址不能 read/write”</h4>
<p>典型的非法指针解引用造成的错误。当指针指向一个不允许读写的内存地址，而程序却试图利用指针来读或写该地址时，会出现这个错误。</p>
<p>普遍原因：</p>
<ul>
<li>将指针初始化为 NULL，之后没有给它一个合理的值就开始使用指针</li>
<li>没用初始化栈中的指针，指针的值一般会是随机数，之后就直接开始使用指针</li>
</ul>
<h3 id="编译链接">编译链接</h3>
<h4 id="各平台文件格式">各平台文件格式</h4>
<table>
<thead>
<tr>
<th>平台</th>
<th>可执行文件</th>
<th>目标文件</th>
<th>动态库/共享对象</th>
<th>静态库</th>
</tr>
</thead>
<tbody>
<tr>
<td>Windows</td>
<td>exe</td>
<td>obj</td>
<td>dll</td>
<td>lib</td>
</tr>
<tr>
<td>Unix/Linux</td>
<td>ELF、out</td>
<td>o</td>
<td>so</td>
<td>a</td>
</tr>
<tr>
<td>Mac</td>
<td>Mach-O</td>
<td>o</td>
<td>dylib、tbd、framework</td>
<td>a、framework</td>
</tr>
</tbody>
</table>
<h4 id="编译链接过程">编译链接过程</h4>
<ol>
<li>预编译（预编译器处理如 <code>#include</code>、<code>#define</code> 等预编译指令，生成 <code>.i</code> 或 <code>.ii</code> 文件）</li>
<li>编译（编译器进行词法分析、语法分析、语义分析、中间代码生成、目标代码生成、优化，生成 <code>.s</code> 文件）</li>
<li>汇编（汇编器把汇编码翻译成机器码，生成 <code>.o</code> 文件）</li>
<li>链接（连接器进行地址和空间分配、符号决议、重定位，生成 <code>.out</code> 文件）</li>
</ol>
<blockquote>
<p>现在版本 GCC 把预编译和编译合成一步，预编译编译程序 cc1、汇编器 as、连接器 ld</p>
</blockquote>
<blockquote>
<p>MSVC 编译环境，编译器 cl、连接器 link、可执行文件查看器 dumpbin</p>
</blockquote>
<h4 id="目标文件">目标文件</h4>
<p>编译器编译源代码后生成的文件叫做目标文件。目标文件从结构上讲，它是已经编译后的可执行文件格式，只是还没有经过链接的过程，其中可能有些符号或有些地址还没有被调整。</p>
<blockquote>
<p>可执行文件（Windows 的 <code>.exe</code> 和 Linux 的 <code>ELF</code>）、动态链接库（Windows 的 <code>.dll</code> 和 Linux 的 <code>.so</code>）、静态链接库（Windows 的 <code>.lib</code> 和 Linux 的 <code>.a</code>）都是按照可执行文件格式存储（Windows 按照 PE-COFF，Linux 按照 ELF）</p>
</blockquote>
<h5 id="目标文件格式">目标文件格式</h5>
<ul>
<li>Windows 的 PE（Portable Executable），或称为 PE-COFF，<code>.obj</code> 格式</li>
<li>Linux 的 ELF（Executable Linkable Format），<code>.o</code> 格式</li>
<li>Intel/Microsoft 的 OMF（Object Module Format）</li>
<li>Unix 的 <code>a.out</code> 格式</li>
<li>MS-DOS 的 <code>.COM</code> 格式</li>
</ul>
<blockquote>
<p>PE 和 ELF 都是 COFF（Common File Format）的变种</p>
</blockquote>
<h5 id="目标文件存储结构">目标文件存储结构</h5>
<table>
<thead>
<tr>
<th>段</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>File Header</td>
<td>文件头，描述整个文件的文件属性（包括文件是否可执行、是静态链接或动态连接及入口地址、目标硬件、目标操作系统等）</td>
</tr>
<tr>
<td>.text section</td>
<td>代码段，执行语句编译成的机器代码</td>
</tr>
<tr>
<td>.data section</td>
<td>数据段，已初始化的全局变量和局部静态变量</td>
</tr>
<tr>
<td>.bss section</td>
<td>BSS 段（Block Started by Symbol），未初始化的全局变量和局部静态变量（因为默认值为 0，所以只是在此预留位置，不占空间）</td>
</tr>
<tr>
<td>.rodata section</td>
<td>只读数据段，存放只读数据，一般是程序里面的只读变量（如 const 修饰的变量）和字符串常量</td>
</tr>
<tr>
<td>.comment section</td>
<td>注释信息段，存放编译器版本信息</td>
</tr>
<tr>
<td>.note.GNU-stack section</td>
<td>堆栈提示段</td>
</tr>
</tbody>
</table>
<blockquote>
<p>其他段略</p>
</blockquote>
<h4 id="链接的接口符号">链接的接口————符号</h4>
<p>在链接中，目标文件之间相互拼合实际上是目标文件之间对地址的引用，即对函数和变量的地址的引用。我们将函数和变量统称为符号（Symbol），函数名或变量名就是符号名（Symbol Name）。</p>
<p>如下符号表（Symbol Table）：</p>
<table>
<thead>
<tr>
<th>Symbol（符号名）</th>
<th>Symbol Value （地址）</th>
</tr>
</thead>
<tbody>
<tr>
<td>main</td>
<td>0x100</td>
</tr>
<tr>
<td>Add</td>
<td>0x123</td>
</tr>
<tr>
<td>&hellip;</td>
<td>&hellip;</td>
</tr>
</tbody>
</table>
<h3 id="linux-的共享库shared-library">Linux 的共享库（Shared Library）</h3>
<p>Linux 下的共享库就是普通的 ELF 共享对象。</p>
<p>共享库版本更新应该保证二进制接口 ABI（Application Binary Interface）的兼容</p>
<h4 id="命名">命名</h4>
<p><code>libname.so.x.y.z</code></p>
<ul>
<li>x：主版本号，不同主版本号的库之间不兼容，需要重新编译</li>
<li>y：次版本号，高版本号向后兼容低版本号</li>
<li>z：发布版本号，不对接口进行更改，完全兼容</li>
</ul>
<h4 id="路径">路径</h4>
<p>大部分包括 Linux 在内的开源系统遵循 FHS（File Hierarchy Standard）的标准，这标准规定了系统文件如何存放，包括各个目录结构、组织和作用。</p>
<ul>
<li><code>/lib</code>：存放系统最关键和最基础的共享库，如动态链接器、C 语言运行库、数学库等</li>
<li><code>/usr/lib</code>：存放非系统运行时所需要的关键性的库，主要是开发库</li>
<li><code>/usr/local/lib</code>：存放跟操作系统本身并不十分相关的库，主要是一些第三方应用程序的库</li>
</ul>
<blockquote>
<p>动态链接器会在 <code>/lib</code>、<code>/usr/lib</code> 和由 <code>/etc/ld.so.conf</code> 配置文件指定的，目录中查找共享库</p>
</blockquote>
<h4 id="环境变量">环境变量</h4>
<ul>
<li><code>LD_LIBRARY_PATH</code>：临时改变某个应用程序的共享库查找路径，而不会影响其他应用程序</li>
<li><code>LD_PRELOAD</code>：指定预先装载的一些共享库甚至是目标文件</li>
<li><code>LD_DEBUG</code>：打开动态链接器的调试功能</li>
</ul>
<h4 id="so-共享库的编写">so 共享库的编写</h4>
<p>使用 CLion 编写共享库</p>
<p>创建一个名为 MySharedLib 的共享库</p>
<p>CMakeLists.txt</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cmake" data-lang="cmake">cmake_minimum_required(<span style="color:#e6db74">VERSION</span> <span style="color:#e6db74">3.10</span>)<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>project(<span style="color:#e6db74">MySharedLib</span>)<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>set(<span style="color:#e6db74">CMAKE_CXX_STANDARD</span> <span style="color:#e6db74">11</span>)<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>add_library(<span style="color:#e6db74">MySharedLib</span> <span style="color:#e6db74">SHARED</span> <span style="color:#e6db74">library.cpp</span> <span style="color:#e6db74">library.h</span>)<span style="color:#960050;background-color:#1e0010">
</span></code></pre></div><p>library.h</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#ifndef MYSHAREDLIB_LIBRARY_H
</span><span style="color:#75715e">#define MYSHAREDLIB_LIBRARY_H
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// 打印 Hello World!
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">hello</span>();

<span style="color:#75715e">// 使用可变模版参数求和
</span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
T sum(T t)
{
    <span style="color:#66d9ef">return</span> t;
}
<span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T, <span style="color:#66d9ef">typename</span> ...Types<span style="color:#f92672">&gt;</span>
T sum(T first, Types ... rest)
{
    <span style="color:#66d9ef">return</span> first <span style="color:#f92672">+</span> sum<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>(rest...);
}

<span style="color:#75715e">#endif
</span></code></pre></div><p>library.cpp</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;library.h&#34;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">hello</span>() {
    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Hello, World!&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
}
</code></pre></div><h4 id="so-共享库的使用被可执行项目调用">so 共享库的使用（被可执行项目调用）</h4>
<p>使用 CLion 调用共享库</p>
<p>创建一个名为 TestSharedLib 的可执行项目</p>
<p>CMakeLists.txt</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cmake" data-lang="cmake">cmake_minimum_required(<span style="color:#e6db74">VERSION</span> <span style="color:#e6db74">3.10</span>)<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>project(<span style="color:#e6db74">TestSharedLib</span>)<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#75715e"># C++11 编译
</span><span style="color:#75715e"></span>set(<span style="color:#e6db74">CMAKE_CXX_STANDARD</span> <span style="color:#e6db74">11</span>)<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#75715e"># 头文件路径
</span><span style="color:#75715e"></span>set(<span style="color:#e6db74">INC_DIR</span> <span style="color:#e6db74">/home/xx/code/clion/MySharedLib</span>)<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#75715e"># 库文件路径
</span><span style="color:#75715e"></span>set(<span style="color:#e6db74">LIB_DIR</span> <span style="color:#e6db74">/home/xx/code/clion/MySharedLib/cmake-build-debug</span>)<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>include_directories(<span style="color:#f92672">${</span>INC_DIR<span style="color:#f92672">}</span>)<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>link_directories(<span style="color:#f92672">${</span>LIB_DIR<span style="color:#f92672">}</span>)<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>link_libraries(<span style="color:#e6db74">MySharedLib</span>)<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span>add_executable(<span style="color:#e6db74">TestSharedLib</span> <span style="color:#e6db74">main.cpp</span>)<span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010">
</span><span style="color:#960050;background-color:#1e0010"></span><span style="color:#75715e"># 链接 MySharedLib 库
</span><span style="color:#75715e"></span>target_link_libraries(<span style="color:#e6db74">TestSharedLib</span> <span style="color:#e6db74">MySharedLib</span>)<span style="color:#960050;background-color:#1e0010">
</span></code></pre></div><p>main.cpp</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;library.h&#34;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> std<span style="color:#f92672">::</span>cout;
<span style="color:#66d9ef">using</span> std<span style="color:#f92672">::</span>endl;

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {

    hello();
    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;1 + 2 = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> sum(<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>) <span style="color:#f92672">&lt;&lt;</span> endl;
    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;1 + 2 + 3 = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> sum(<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>) <span style="color:#f92672">&lt;&lt;</span> endl;

    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>执行结果</p>
<pre tabindex="0"><code>Hello, World!
1 + 2 = 3
1 + 2 + 3 = 6
</code></pre><h3 id="windows-应用程序入口函数">Windows 应用程序入口函数</h3>
<ul>
<li>GUI（Graphical User Interface）应用，链接器选项：<code>/SUBSYSTEM:WINDOWS</code></li>
<li>CUI（Console User Interface）应用，链接器选项：<code>/SUBSYSTEM:CONSOLE</code></li>
</ul>
<p>_tWinMain 与 _tmain 函数声明</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">Int WINAPI <span style="color:#a6e22e">_tWinMain</span>(
    HINSTANCE hInstanceExe,
    HINSTANCE,
    PTSTR pszCmdLine,
    <span style="color:#66d9ef">int</span> nCmdShow);

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">_tmain</span>(
    <span style="color:#66d9ef">int</span> argc,
    TCHAR <span style="color:#f92672">*</span>argv[],
    TCHAR <span style="color:#f92672">*</span>envp[]);
</code></pre></div><table>
<thead>
<tr>
<th>应用程序类型</th>
<th>入口点函数</th>
<th>嵌入可执行文件的启动函数</th>
</tr>
</thead>
<tbody>
<tr>
<td>处理ANSI字符（串）的GUI应用程序</td>
<td>_tWinMain(WinMain)</td>
<td>WinMainCRTSartup</td>
</tr>
<tr>
<td>处理Unicode字符（串）的GUI应用程序</td>
<td>_tWinMain(wWinMain)</td>
<td>wWinMainCRTSartup</td>
</tr>
<tr>
<td>处理ANSI字符（串）的CUI应用程序</td>
<td>_tmain(Main)</td>
<td>mainCRTSartup</td>
</tr>
<tr>
<td>处理Unicode字符（串）的CUI应用程序</td>
<td>_tmain(wMain)</td>
<td>wmainCRTSartup</td>
</tr>
<tr>
<td>动态链接库（Dynamic-Link Library）</td>
<td>DllMain</td>
<td>_DllMainCRTStartup</td>
</tr>
</tbody>
</table>
<h3 id="windows-的动态链接库dynamic-link-library">Windows 的动态链接库（Dynamic-Link Library）</h3>
<blockquote>
<p>部分知识点来自《Windows 核心编程（第五版）》</p>
</blockquote>
<h4 id="用处">用处</h4>
<ul>
<li>扩展了应用程序的特性</li>
<li>简化了项目管理</li>
<li>有助于节省内存</li>
<li>促进了资源的共享</li>
<li>促进了本地化</li>
<li>有助于解决平台间的差异</li>
<li>可以用于特殊目的</li>
</ul>
<h4 id="注意">注意</h4>
<ul>
<li>创建 DLL，事实上是在创建可供一个可执行模块调用的函数</li>
<li>当一个模块提供一个内存分配函数（malloc、new）的时候，它必须同时提供另一个内存释放函数（free、delete）</li>
<li>在使用 C 和 C++ 混编的时候，要使用 extern &ldquo;C&rdquo; 修饰符</li>
<li>一个 DLL 可以导出函数、变量（避免导出）、C++ 类（导出导入需要同编译器，否则避免导出）</li>
<li>DLL 模块：cpp 文件中的 __declspec(dllexport) 写在 include 头文件之前</li>
<li>调用 DLL 的可执行模块：cpp 文件的 __declspec(dllimport) 之前不应该定义 MYLIBAPI</li>
</ul>
<h4 id="加载-windows-程序的搜索顺序">加载 Windows 程序的搜索顺序</h4>
<ol>
<li>包含可执行文件的目录</li>
<li>Windows 的系统目录，可以通过 GetSystemDirectory 得到</li>
<li>16 位的系统目录，即 Windows 目录中的 System 子目录</li>
<li>Windows 目录，可以通过 GetWindowsDirectory 得到</li>
<li>进程的当前目录</li>
<li>PATH 环境变量中所列出的目录</li>
</ol>
<h4 id="dll-入口函数">DLL 入口函数</h4>
<p>DllMain 函数</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">BOOL WINAPI <span style="color:#a6e22e">DllMain</span>(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
{
    <span style="color:#66d9ef">switch</span>(fdwReason)
    {
    <span style="color:#66d9ef">case</span> DLL_PROCESS_ATTACH:
        <span style="color:#75715e">// 第一次将一个DLL映射到进程地址空间时调用
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// The DLL is being mapped into the process&#39; address space.
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">break</span>;
    <span style="color:#66d9ef">case</span> DLL_THREAD_ATTACH:
        <span style="color:#75715e">// 当进程创建一个线程的时候，用于告诉DLL执行与线程相关的初始化（非主线程执行）
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// A thread is bing created.
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">break</span>;
    <span style="color:#66d9ef">case</span> DLL_THREAD_DETACH:
        <span style="color:#75715e">// 系统调用 ExitThread 线程退出前，即将终止的线程通过告诉DLL执行与线程相关的清理
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// A thread is exiting cleanly.
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">break</span>;
    <span style="color:#66d9ef">case</span> DLL_PROCESS_DETACH:
        <span style="color:#75715e">// 将一个DLL从进程的地址空间时调用
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// The DLL is being unmapped from the process&#39; address space.
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">break</span>;
    }
    <span style="color:#66d9ef">return</span> (TRUE); <span style="color:#75715e">// Used only for DLL_PROCESS_ATTACH
</span><span style="color:#75715e"></span>}
</code></pre></div><h4 id="载入卸载库">载入卸载库</h4>
<p>LoadLibrary、LoadLibraryExA、LoadPackagedLibrary、FreeLibrary、FreeLibraryAndExitThread 函数声明</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// 载入库
</span><span style="color:#75715e"></span>HMODULE WINAPI <span style="color:#a6e22e">LoadLibrary</span>(
  _In_ LPCTSTR lpFileName
);
HMODULE <span style="color:#a6e22e">LoadLibraryExA</span>(
  LPCSTR lpLibFileName,
  HANDLE hFile,
  DWORD  dwFlags
);
<span style="color:#75715e">// 若要在通用 Windows 平台（UWP）应用中加载 Win32 DLL，需要调用 LoadPackagedLibrary，而不是 LoadLibrary 或 LoadLibraryEx
</span><span style="color:#75715e"></span>HMODULE <span style="color:#a6e22e">LoadPackagedLibrary</span>(
  LPCWSTR lpwLibFileName,
  DWORD   Reserved
);

<span style="color:#75715e">// 卸载库
</span><span style="color:#75715e"></span>BOOL WINAPI <span style="color:#a6e22e">FreeLibrary</span>(
  _In_ HMODULE hModule
);
<span style="color:#75715e">// 卸载库和退出线程
</span><span style="color:#75715e"></span>VOID WINAPI <span style="color:#a6e22e">FreeLibraryAndExitThread</span>(
  _In_ HMODULE hModule,
  _In_ DWORD   dwExitCode
);
</code></pre></div><h4 id="显示地链接到导出符号">显示地链接到导出符号</h4>
<p>GetProcAddress 函数声明</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">FARPROC <span style="color:#a6e22e">GetProcAddress</span>(
  HMODULE hInstDll,
  PCSTR pszSymbolName  <span style="color:#75715e">// 只能接受 ANSI 字符串，不能是 Unicode
</span><span style="color:#75715e"></span>);
</code></pre></div><h4 id="dumpbinexe-查看-dll-信息">DumpBin.exe 查看 DLL 信息</h4>
<p>在 <code>VS 的开发人员命令提示符</code> 使用 <code>DumpBin.exe</code> 可查看 DLL 库的导出段（导出的变量、函数、类名的符号）、相对虚拟地址（RVA，relative virtual address）。如：</p>
<pre tabindex="0"><code>DUMPBIN -exports D:\mydll.dll
</code></pre><h4 id="loadlibrary-与-freelibrary-流程图">LoadLibrary 与 FreeLibrary 流程图</h4>
<p>LoadLibrary 与 FreeLibrary 流程图</p>
<h5 id="loadlibrary">LoadLibrary</h5>
<p><img src="https://gitee.com/huihut/interview/raw/master/images/WindowsLoadLibrary.png" alt="WindowsLoadLibrary"></p>
<h5 id="freelibrary">FreeLibrary</h5>
<p><img src="https://gitee.com/huihut/interview/raw/master/images/WindowsFreeLibrary.png" alt="WindowsFreeLibrary"></p>
<h4 id="dll-库的编写导出一个-dll-模块">DLL 库的编写（导出一个 DLL 模块）</h4>
<p>DLL 库的编写（导出一个 DLL 模块）
DLL 头文件</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// MyLib.h
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#ifdef MYLIBAPI
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// MYLIBAPI 应该在全部 DLL 源文件的 include &#34;Mylib.h&#34; 之前被定义
</span><span style="color:#75715e">// 全部函数/变量正在被导出
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#else
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// 这个头文件被一个exe源代码模块包含，意味着全部函数/变量被导入
</span><span style="color:#75715e"></span><span style="color:#75715e">#define MYLIBAPI extern &#34;C&#34; __declspec(dllimport)
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#endif
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// 这里定义任何的数据结构和符号
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// 定义导出的变量（避免导出变量）
</span><span style="color:#75715e"></span>MYLIBAPI <span style="color:#66d9ef">int</span> g_nResult;

<span style="color:#75715e">// 定义导出函数原型
</span><span style="color:#75715e"></span>MYLIBAPI <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">Add</span>(<span style="color:#66d9ef">int</span> nLeft, <span style="color:#66d9ef">int</span> nRight);
</code></pre></div><p>DLL 源文件</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// MyLibFile1.cpp
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// 包含标准Windows和C运行时头文件
</span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;windows.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// DLL源码文件导出的函数和变量
</span><span style="color:#75715e"></span><span style="color:#75715e">#define MYLIBAPI extern &#34;C&#34; __declspec(dllexport)
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// 包含导出的数据结构、符号、函数、变量
</span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;MyLib.h&#34;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// 将此DLL源代码文件的代码放在此处
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> g_nResult;

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">Add</span>(<span style="color:#66d9ef">int</span> nLeft, <span style="color:#66d9ef">int</span> nRight)
{
    g_nResult <span style="color:#f92672">=</span> nLeft <span style="color:#f92672">+</span> nRight;
    <span style="color:#66d9ef">return</span> g_nResult;
}
</code></pre></div><h4 id="dll-库的使用运行时动态链接-dll">DLL 库的使用（运行时动态链接 DLL）</h4>
<p>DLL 库的使用（运行时动态链接 DLL）</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// A simple program that uses LoadLibrary and 
</span><span style="color:#75715e">// GetProcAddress to access myPuts from Myputs.dll. 
</span><span style="color:#75715e"></span> 
<span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;windows.h&gt; </span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdio.h&gt; </span><span style="color:#75715e">
</span><span style="color:#75715e"></span> 
<span style="color:#66d9ef">typedef</span> <span style="color:#a6e22e">int</span> (<span style="color:#66d9ef">__cdecl</span> <span style="color:#f92672">*</span>MYPROC)(LPWSTR); 
 
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>( <span style="color:#66d9ef">void</span> ) 
{ 
    HINSTANCE hinstLib; 
    MYPROC ProcAdd; 
    BOOL fFreeResult, fRunTimeLinkSuccess <span style="color:#f92672">=</span> FALSE; 
 
    <span style="color:#75715e">// Get a handle to the DLL module.
</span><span style="color:#75715e"></span> 
    hinstLib <span style="color:#f92672">=</span> LoadLibrary(TEXT(<span style="color:#e6db74">&#34;MyPuts.dll&#34;</span>)); 
 
    <span style="color:#75715e">// If the handle is valid, try to get the function address.
</span><span style="color:#75715e"></span> 
    <span style="color:#66d9ef">if</span> (hinstLib <span style="color:#f92672">!=</span> NULL) 
    { 
        ProcAdd <span style="color:#f92672">=</span> (MYPROC) GetProcAddress(hinstLib, <span style="color:#e6db74">&#34;myPuts&#34;</span>); 
 
        <span style="color:#75715e">// If the function address is valid, call the function.
</span><span style="color:#75715e"></span> 
        <span style="color:#66d9ef">if</span> (NULL <span style="color:#f92672">!=</span> ProcAdd) 
        {
            fRunTimeLinkSuccess <span style="color:#f92672">=</span> TRUE;
            (ProcAdd) (<span style="color:#e6db74">L</span><span style="color:#e6db74">&#34;Message sent to the DLL function</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>); 
        }
        <span style="color:#75715e">// Free the DLL module.
</span><span style="color:#75715e"></span> 
        fFreeResult <span style="color:#f92672">=</span> FreeLibrary(hinstLib); 
    } 

    <span style="color:#75715e">// If unable to call the DLL function, use an alternative.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span> fRunTimeLinkSuccess) 
        printf(<span style="color:#e6db74">&#34;Message printed from executable</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>); 

    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="运行库runtime-library">运行库（Runtime Library）</h3>
<h4 id="典型程序运行步骤">典型程序运行步骤</h4>
<ol>
<li>操作系统创建进程，把控制权交给程序的入口（往往是运行库中的某个入口函数）</li>
<li>入口函数对运行库和程序运行环境进行初始化（包括堆、I/O、线程、全局变量构造等等）。</li>
<li>入口函数初始化后，调用 main 函数，正式开始执行程序主体部分。</li>
<li>main 函数执行完毕后，返回到入口函数进行清理工作（包括全局变量析构、堆销毁、关闭I/O等），然后进行系统调用结束进程。</li>
</ol>
<blockquote>
<p>一个程序的 I/O 指代程序与外界的交互，包括文件、管程、网络、命令行、信号等。更广义地讲，I/O 指代操作系统理解为 “文件” 的事物。</p>
</blockquote>
<h4 id="glibc-入口">glibc 入口</h4>
<p><code>_start -&gt; __libc_start_main -&gt; exit -&gt; _exit</code></p>
<p>其中 <code>main(argc, argv, __environ)</code> 函数在 <code>__libc_start_main</code> 里执行。</p>
<h4 id="msvc-crt-入口">MSVC CRT 入口</h4>
<p><code>int mainCRTStartup(void)</code></p>
<p>执行如下操作：</p>
<ol>
<li>初始化和 OS 版本有关的全局变量。</li>
<li>初始化堆。</li>
<li>初始化 I/O。</li>
<li>获取命令行参数和环境变量。</li>
<li>初始化 C 库的一些数据。</li>
<li>调用 main 并记录返回值。</li>
<li>检查错误并将 main 的返回值返回。</li>
</ol>
<h4 id="c-语言运行库crt">C 语言运行库（CRT）</h4>
<p>大致包含如下功能：</p>
<ul>
<li>启动与退出：包括入口函数及入口函数所依赖的其他函数等。</li>
<li>标准函数：有 C 语言标准规定的C语言标准库所拥有的函数实现。</li>
<li>I/O：I/O 功能的封装和实现。</li>
<li>堆：堆的封装和实现。</li>
<li>语言实现：语言中一些特殊功能的实现。</li>
<li>调试：实现调试功能的代码。</li>
</ul>
<h4 id="c语言标准库ansi-c">C语言标准库（ANSI C）</h4>
<p>包含：</p>
<ul>
<li>标准输入输出（stdio.h）</li>
<li>文件操作（stdio.h）</li>
<li>字符操作（ctype.h）</li>
<li>字符串操作（string.h）</li>
<li>数学函数（math.h）</li>
<li>资源管理（stdlib.h）</li>
<li>格式转换（stdlib.h）</li>
<li>时间/日期（time.h）</li>
<li>断言（assert.h）</li>
<li>各种类型上的常数（limits.h &amp; float.h）</li>
<li>变长参数（stdarg.h）</li>
<li>非局部跳转（setjmp.h）</li>
</ul>



  <footer>
  
<nav class="post-nav">
  <span class="nav-prev">&larr; <a href="/post/2022/01/15/database/">【转载】C&#43;&#43; 面试之数据库</a></span>
  <span class="nav-next"><a href="/post/2022/01/15/design-pattern/">【转载】C&#43;&#43; 面试之设计模式</a> &rarr;</span>
</nav>

<script type="text/javascript">
document.addEventListener('keyup', function(e) {
  if (e.target.nodeName.toUpperCase() != 'BODY') return;
  var url = false;
  if (e.which == 37) {  
    
    url = '\/post\/2022\/01\/15\/database\/';
    
  } else if (e.which == 39) {  
    
    url = '\/post\/2022\/01\/15\/design-pattern\/';
    
  }
  if (url) window.location = url;
});
</script>






<script src="https://utteranc.es/client.js"
repo="lzxqaq/site-comment"
issue-term="title"
theme="github-light"
crossorigin="anonymous"
async>
</script>








<script async src="/js/fix-toc.js"></script>

<script async src="/js/center-img.js"></script>

<script async src="/js/right-quote.js"></script>

<script async src="/js/fix-footnote.js"></script>

<script async src="/js/math-code.js"></script>

<script async src="/js/external-link.js"></script>

<script async src="/js/alt-title.js"></script>

<script async src="/js/header-link.js"></script>



  
  
  <hr>
  <div class="copyright">© <a href="/">Zexun Luo</a> 2020 - 2022</div>
  
  </footer>
  </article>
  
<script async src="https://www.googletagmanager.com/gtag/js?id=G-KDTTBGMLCQ"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-KDTTBGMLCQ', { 'anonymize_ip': false });
}
</script>

  </body>
</html>

