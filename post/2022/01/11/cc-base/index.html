<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <title>C/C&#43;&#43;基础 - Zexun Luo | 罗泽勋</title>
    <meta property="og:title" content="C/C&#43;&#43;基础 - Zexun Luo | 罗泽勋">
    
    <meta name="twitter:card" content="summary">

    
      
    

    
      
      <meta property="description" content="// 类 class A { private: const int a; // 常对象成员，只能在初始化列表赋值  public: // 构造函数  A() { }; A(int x) : a(x) { }; // 初始化列表  // const可用于对重载函数的区分  int getValue(); // 普通成员函数  int getValue() const; // 常成员函数，不得修改类中 &amp;hellip;">
      <meta property="og:description" content="// 类 class A { private: const int a; // 常对象成员，只能在初始化列表赋值  public: // 构造函数  A() { }; A(int x) : a(x) { }; // 初始化列表  // const可用于对重载函数的区分  int getValue(); // 普通成员函数  int getValue() const; // 常成员函数，不得修改类中 &amp;hellip;">
      
    

    
    

    

    
    
    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/fonts.css" />
    <script async src="/js/load-typekit.js"></script>
<link rel="stylesheet" href="/css/custom.css" />
<link href="https://cdn.bootcss.com/aplayer/1.10.1/APlayer.min.css" rel="stylesheet">
<script src="https://cdn.bootcss.com/aplayer/1.10.1/APlayer.min.js"></script>

  </head>

  
  <body class="post">
    <header class="masthead">
      

<h1><a href="/"><img src="/images/logo.png" alt="Zexun Luo" /></a></h1>



      <nav class="menu">
  <ul>
  
  
  <li><a href="/">主页</a></li>
  
  <li><a href="/about/">关于</a></li>
  
  <li><a href="/blog/">日志</a></li>
  
  <li><a href="/post/">编程</a></li>
  
  <li><a href="/series/">标签</a></li>
  
  <li><a href="/categories/">分类</a></li>
  
  <li><a href="/cv/">简历</a></li>
  
  <li><a href="/note/">抄录</a></li>
  
  </ul>
</nav>

    </header>

    <article class="main">
      <header class="title">
      
<h1>C/C&#43;&#43;基础</h1>


<h3>罗泽勋 / 
2022-01-11</h3>

<hr>


      </header>





<h3 id="一const">一、const</h3>
<h4 id="作用">作用：</h4>
<ul>
<li>修饰变量，说明该变量不可变;</li>
<li>修饰指针，分为指向常量的指针和指针常量；</li>
<li>常量引用，用于行参类型，即避免了拷贝，又避免了函数对值的修改；</li>
<li>修饰成员函数，说明该成员函数不能修改成员变量。</li>
</ul>
<h4 id="使用">使用</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++">
<span style="color:#75715e">// 类
</span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span>
{
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> a;                <span style="color:#75715e">// 常对象成员，只能在初始化列表赋值
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#75715e">// 构造函数
</span><span style="color:#75715e"></span>    A() { };
    A(<span style="color:#66d9ef">int</span> x) <span style="color:#f92672">:</span> a(x) { };        <span style="color:#75715e">// 初始化列表
</span><span style="color:#75715e"></span>
    <span style="color:#75715e">// const可用于对重载函数的区分
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">getValue</span>();             <span style="color:#75715e">// 普通成员函数
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">getValue</span>() <span style="color:#66d9ef">const</span>;       <span style="color:#75715e">// 常成员函数，不得修改类中的任何数据成员的值
</span><span style="color:#75715e"></span>};

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">function</span>()
{
    <span style="color:#75715e">// 对象
</span><span style="color:#75715e"></span>    A b;                        <span style="color:#75715e">// 普通对象，可以调用全部成员函数
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">const</span> A a;                  <span style="color:#75715e">// 常对象，只能调用常成员函数、更新常成员变量
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">const</span> A <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>a;            <span style="color:#75715e">// 常指针
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">const</span> A <span style="color:#f92672">&amp;</span>q <span style="color:#f92672">=</span> a;             <span style="color:#75715e">// 常引用
</span><span style="color:#75715e"></span>
    <span style="color:#75715e">// 指针
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">char</span> greeting[] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Hello&#34;</span>;
    <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> p1 <span style="color:#f92672">=</span> greeting;                <span style="color:#75715e">// 指针变量，指向字符数组变量
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> p2 <span style="color:#f92672">=</span> greeting;          <span style="color:#75715e">// 指针变量，指向字符数组常量
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> <span style="color:#66d9ef">const</span> p3 <span style="color:#f92672">=</span> greeting;          <span style="color:#75715e">// 常指针，指向字符数组变量
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> <span style="color:#66d9ef">const</span> p4 <span style="color:#f92672">=</span> greeting;    <span style="color:#75715e">// 常指针，指向字符数组常量
</span><span style="color:#75715e"></span>}

<span style="color:#75715e">// 函数
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">function1</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> Var);           <span style="color:#75715e">// 传递过来的参数在函数内不可变
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">function2</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> Var);         <span style="color:#75715e">// 参数指针所指内容为常量
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">function3</span>(<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> <span style="color:#66d9ef">const</span> Var);         <span style="color:#75715e">// 参数指针为常指针
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">function4</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">&amp;</span> Var);          <span style="color:#75715e">// 引用参数在函数内为常量
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// 函数返回值
</span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">function5</span>();      <span style="color:#75715e">// 返回一个常数
</span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> <span style="color:#a6e22e">function6</span>();     <span style="color:#75715e">// 返回一个指向常量的指针变量，使用：const int *p = function6();
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">function7</span>();     <span style="color:#75715e">// 返回一个指向变量的常指针，使用：int* const p = function7();
</span><span style="color:#75715e"></span>
</code></pre></div><h3 id="static">static</h3>
<h4 id="作用-1">作用</h4>
<ul>
<li>修饰普通变量，修改变量的存储区域和生命周期，使变量存储在静态区，在 main 函数运行前就分配了空间，如果有初始值就用初始值初始化它，如果没有初始值，系统用默认值初始化它。</li>
<li>修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命名函数重名，可以将函数定为 static。</li>
<li>修饰成员变量，修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员。</li>
<li>修饰成员函数，使得成员函数不需要生成对象就可以访问该函数，但是在 static 函数内不能访问非静态成员。</li>
</ul>
<h3 id="this-指针">this 指针</h3>
<ul>
<li>this 指针是一个隐含于每一个非静态成员函数中的特殊指针。它指向正在被该成员函数操作的那个对象。</li>
<li>当对一个对象调用成员函数时，编译程序先将对象的地址赋给 this 指针，然后调用成员函数，每次成员函数存取数据成员时，由隐含使用 this 指针。</li>
<li>当一个成员函数被调用时，自动向它传递一个隐含的参数，该参数是一个指向这个成员函数所在的对象的指针。</li>
<li>this 指针被隐含地声明为: ClassName const this<code>，这意味着不能给 </code>this<code>指针赋值；在</code>ClassName<code>类的</code>const<code> 成员函数中，</code>this<code> 指针的类型为：</code>const ClassName const，这说明不能对 this 指针所指向的这种对象是不可修改的（即不能对这种对象的数据成员进行赋值操作）；</li>
<li>this 并不是一个常规变量，而是个右值，所以不能取得 this 的地址（不能 &amp;this）。</li>
<li>在以下场景中，经常需要显式引用 this 指针：
<ul>
<li>
<p>为实现对象的链式引用；</p>
</li>
<li>
<p>为避免对同一对象进行赋值操作；</p>
</li>
<li>
<p>在实现一些数据结构时，如 <code>list</code>。</p>
</li>
</ul>
</li>
</ul>
<h3 id="inline-内联函数">inline 内联函数</h3>
<h4 id="特征">特征</h4>
<ul>
<li>
<p>相当于把内联函数里面的内容写在调用内联函数处；</p>
</li>
<li>
<p>相当于不用执行进入函数的步骤，直接执行函数体；</p>
</li>
<li>
<p>相当于宏，却比宏多了类型检查，真正具有函数特性；</p>
</li>
<li>
<p>不能包含循环、递归、switch 等复杂操作；</p>
</li>
<li>
<p>在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数。</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++">
<span style="color:#75715e">// 声明1（加 inline，建议使用）
</span><span style="color:#75715e"></span><span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">functionName</span>(<span style="color:#66d9ef">int</span> first, <span style="color:#66d9ef">int</span> secend,...);

<span style="color:#75715e">// 声明2（不加 inline）
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">functionName</span>(<span style="color:#66d9ef">int</span> first, <span style="color:#66d9ef">int</span> secend,...);

<span style="color:#75715e">// 定义
</span><span style="color:#75715e"></span><span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">functionName</span>(<span style="color:#66d9ef">int</span> first, <span style="color:#66d9ef">int</span> secend,...) {<span style="color:#75715e">/****/</span>};

<span style="color:#75715e">// 类内定义，隐式内联
</span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span> {
    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">doA</span>() { <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>; }         <span style="color:#75715e">// 隐式内联
</span><span style="color:#75715e"></span>}

<span style="color:#75715e">// 类外定义，需要显式内联
</span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span> {
    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">doA</span>();
}
<span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">int</span> A<span style="color:#f92672">::</span>doA() { <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>; }   <span style="color:#75715e">// 需要显式内联
</span><span style="color:#75715e"></span>
</code></pre></div><h4 id="编译器对-inline-函数的处理步骤">编译器对 inline 函数的处理步骤</h4>
<ul>
<li>
<p>将 inline 函数体复制到 inline 函数调用点处；</p>
</li>
<li>
<p>为所用 inline 函数中的局部变量分配内存空间；</p>
</li>
<li>
<p>将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中；</p>
</li>
<li>
<p>如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 GOTO）。</p>
</li>
</ul>
<h4 id="优缺点">优缺点</h4>
<p>优点</p>
<ul>
<li>
<p>内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。</p>
</li>
<li>
<p>内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会。</p>
</li>
<li>
<p>在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能。</p>
</li>
<li>
<p>内联函数在运行时可调试，而宏定义不可以。</p>
</li>
</ul>
<h4 id="缺点">缺点</h4>
<ul>
<li>
<p>代码膨胀。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。</p>
</li>
<li>
<p>inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接。</p>
</li>
<li>
<p>是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。</p>
</li>
</ul>
<h4 id="虚函数virtual可以是内联函数inline吗">虚函数（virtual）可以是内联函数（inline）吗？</h4>
<blockquote>
<p>Are &ldquo;inline virtual&rdquo; member functions ever actually &ldquo;inlined&rdquo;?<br>
答案：http://www.cs.technion.ac.il/users/yechiel/c++-faq/inline-virtuals.html</p>
</blockquote>
<ul>
<li>
<p>虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。</p>
</li>
<li>
<p>内联是在编译器建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。</p>
</li>
<li>
<p>inline virtual 唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 Base::who()），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。</p>
</li>
</ul>
<h4 id="虚函数内联使用">虚函数内联使用</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;  </span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Base</span>
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> who()
    {
        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;I am Base</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
    }
    <span style="color:#66d9ef">virtual</span> <span style="color:#f92672">~</span>Base() {}
};
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Derived</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Base
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">void</span> who()  <span style="color:#75715e">// 不写inline时隐式内联
</span><span style="color:#75715e"></span>    {
        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;I am Derived</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
    }
};

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
    <span style="color:#75715e">// 此处的虚函数 who()，是通过类（Base）的具体对象（b）来调用的，编译期间就能确定了，所以它可以是内联的，但最终是否内联取决于编译器。 
</span><span style="color:#75715e"></span>    Base b;
    b.who();

    <span style="color:#75715e">// 此处的虚函数是通过指针调用的，呈现多态性，需要在运行时期间才能确定，所以不能为内联。  
</span><span style="color:#75715e"></span>    Base <span style="color:#f92672">*</span>ptr <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Derived();
    ptr<span style="color:#f92672">-&gt;</span>who();

    <span style="color:#75715e">// 因为Base有虚析构函数（virtual ~Base() {}），所以 delete 时，会先调用派生类（Derived）析构函数，再调用基类（Base）析构函数，防止内存泄漏。
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">delete</span> ptr;
    ptr <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;

    system(<span style="color:#e6db74">&#34;pause&#34;</span>);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
} 
</code></pre></div><h3 id="assert">assert()</h3>
<p>断言，是宏，而非函数。assert 宏的原型定义在 &lt;assert.h&gt;（C）、<cassert>（C++）中，其作用是如果它的条件返回错误，则终止程序执行。可以通过定义 NDEBUG 来关闭 assert，但是需要在源代码的开头，include &lt;assert.h&gt; 之前。</p>
<h4 id="使用-1">使用</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#75715e">#define NDEBUG          </span><span style="color:#75715e">// 加上这行，则 assert 不可用
</span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;assert.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
assert( p <span style="color:#f92672">!=</span> NULL );    <span style="color:#75715e">// assert 不可用
</span></code></pre></div><h3 id="sizeof">sizeof()</h3>
<ul>
<li>
<p>sizeof 对数组，得到整个数组所占空间大小。</p>
</li>
<li>
<p>sizeof 对指针，得到指针本身所占空间大小。</p>
</li>
</ul>
<h3 id="pragma-packn">pragma pack(n)</h3>
<p>设定结构体、联合以及类成员变量以 n 字节方式对齐</p>
<h4 id="使用-2">使用</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#75715e">#pragma pack(push)  </span><span style="color:#75715e">// 保存对齐状态
</span><span style="color:#75715e"></span><span style="color:#75715e">#pragma pack(4)     </span><span style="color:#75715e">// 设定为 4 字节对齐
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">test</span>
{
    <span style="color:#66d9ef">char</span> m1;
    <span style="color:#66d9ef">double</span> m4;
    <span style="color:#66d9ef">int</span> m3;
};

<span style="color:#75715e">#pragma pack(pop)   </span><span style="color:#75715e">// 恢复对齐状态
</span></code></pre></div><h3 id="位域">位域</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++">Bit mode: <span style="color:#ae81ff">2</span>;    <span style="color:#75715e">// mode 占 2 位
</span></code></pre></div><p>类可以将其（非静态）数据成员定义为位域（bit-field），在一个位域中含有一定数量的二进制位。当一个程序需要向其他程序或硬件设备传递二进制数据时，通常会用到位域。</p>
<ul>
<li>
<p>位域在内存中的布局是与机器有关的</p>
</li>
<li>
<p>位域的类型必须是整型或枚举类型，带符号类型中的位域的行为将因具体实现而定</p>
</li>
<li>
<p>取地址运算符（&amp;）不能作用于位域，任何指针都无法指向类的位域</p>
</li>
</ul>
<h3 id="volatile">volatile</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#66d9ef">volatile</span> <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>; 
</code></pre></div><ul>
<li>
<p>volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以使用 volatile 告诉编译器不应对这样的对象进行优化。</p>
</li>
<li>
<p>volatile 关键字声明的变量，每次访问时都必须从内存中取出值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值）</p>
</li>
<li>
<p>const 可以是 volatile （如只读的状态寄存器）</p>
</li>
<li>
<p>指针可以是 volatile</p>
</li>
</ul>
<h3 id="extern-c">extern &ldquo;C&rdquo;</h3>
<ul>
<li>
<p>被 extern 限定的函数或变量是 extern 类型的</p>
</li>
<li>
<p>被 extern &ldquo;C&rdquo; 修饰的变量和函数是按照 C 语言方式编译和连接的</p>
</li>
</ul>
<p>extern &ldquo;C&rdquo; 的作用是让 C++ 编译器将 extern &ldquo;C&rdquo; 声明的代码当作 C 语言代码处理，可以避免 C++ 因符号修饰导致代码不能和C语言库中的符号进行链接的问题。</p>
<h4 id="c-使用">&ldquo;C&rdquo; 使用</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#75715e">#ifdef __cplusplus
</span><span style="color:#75715e"></span><span style="color:#66d9ef">extern</span> <span style="color:#e6db74">&#34;C&#34;</span> {
<span style="color:#75715e">#endif
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">memset</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>, <span style="color:#66d9ef">int</span>, size_t);

<span style="color:#75715e">#ifdef __cplusplus
</span><span style="color:#75715e"></span>}
<span style="color:#75715e">#endif
</span></code></pre></div><h3 id="struct-和-typedef-struct">struct 和 typedef struct</h3>
<h4 id="c-中">C 中</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#75715e">//C
</span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> Student {
    <span style="color:#66d9ef">int</span> age; 
} S;
</code></pre></div><p>等价于</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C" data-lang="C"><span style="color:#75715e">//C
</span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> Student { 
    <span style="color:#66d9ef">int</span> age; 
};

<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> Student S;
</code></pre></div><p>此时 S 等价于 struct Student，但两个标识符名称空间不相同。</p>
<p>另外还可以定义与 struct Student 不冲突的 void Student() {}。</p>
<h4 id="c-中-1">C++ 中</h4>
<p>由于编译器定位符号的规则（搜索规则）改变，导致不同于C语言。</p>
<p>一、如果在类标识符空间定义了 struct Student {&hellip;};，使用 Student me; 时，编译器将搜索全局标识符表，Student 未找到，则在类标识符内搜索。</p>
<p>即表现为可以使用 Student 也可以使用 struct Student，如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#75715e">// cpp
</span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Student</span> { 
    <span style="color:#66d9ef">int</span> age; 
};

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">f</span>( Student me );       <span style="color:#75715e">// 正确，&#34;struct&#34; 关键字可省略
</span></code></pre></div><p>二、若定义了与 Student 同名函数之后，则 Student 只代表函数，不代表结构体，如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Student</span> { 
    <span style="color:#66d9ef">int</span> age; 
} S;

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Student</span>() {}           <span style="color:#75715e">// 正确，定义后 &#34;Student&#34; 只代表此函数
</span><span style="color:#75715e"></span>
<span style="color:#75715e">//void S() {}               // 错误，符号 &#34;S&#34; 已经被定义为一个 &#34;struct Student&#34; 的别名
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    Student(); 
    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Student</span> me;      <span style="color:#75715e">// 或者 &#34;S me&#34;;
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}

</code></pre></div><h3 id="c-中-struct-和-class">C++ 中 struct 和 class</h3>
<p>总的来说，struct 更适合看成是一个数据结构的实现体，class 更适合看成是一个对象的实现体。</p>
<p>区别</p>
<ul>
<li>
<p>最本质的一个区别就是默认的访问控制</p>
<p>1.默认的继承访问权限。struct 是 public 的，class 是 private 的。</p>
<p>2.struct 作为数据结构的实现体，它默认的数据访问控制是 public 的，而 class 作为对象的实现体，它默认的成员变量访问控制是 private 的。</p>
</li>
</ul>
<h3 id="union-联合">union 联合</h3>
<p>联合（union）是一种节省空间的特殊的类，一个 union 可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值。当某个成员被赋值后其他成员变为未定义状态。联合有如下特点：</p>
<ul>
<li>
<p>默认访问控制符为 public</p>
</li>
<li>
<p>可以含有构造函数、析构函数</p>
</li>
<li>
<p>不能含有引用类型的成员</p>
</li>
<li>
<p>不能继承自其他类，不能作为基类</p>
</li>
<li>
<p>不能含有虚函数</p>
</li>
<li>
<p>匿名 union 在定义所在作用域可直接访问 union 成员</p>
</li>
<li>
<p>匿名 union 不能包含 protected 成员或 private 成员</p>
</li>
</ul>
<p>-全局匿名联合必须是静态（static）的</p>
<h4 id="使用-3">使用</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">union</span> <span style="color:#a6e22e">UnionTest</span> {
    UnionTest() <span style="color:#f92672">:</span> i(<span style="color:#ae81ff">10</span>) {};
    <span style="color:#66d9ef">int</span> i;
    <span style="color:#66d9ef">double</span> d;
};

<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">union</span> {
    <span style="color:#66d9ef">int</span> i;
    <span style="color:#66d9ef">double</span> d;
};

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    UnionTest u;

    <span style="color:#66d9ef">union</span> {
        <span style="color:#66d9ef">int</span> i;
        <span style="color:#66d9ef">double</span> d;
    };

    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> u.i <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;  <span style="color:#75715e">// 输出 UnionTest 联合的 10
</span><span style="color:#75715e"></span>
    <span style="color:#f92672">::</span>i <span style="color:#f92672">=</span> <span style="color:#ae81ff">20</span>;
    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">::</span>i <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;  <span style="color:#75715e">// 输出全局静态匿名联合的 20
</span><span style="color:#75715e"></span>
    i <span style="color:#f92672">=</span> <span style="color:#ae81ff">30</span>;
    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> i <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;    <span style="color:#75715e">// 输出局部匿名联合的 30
</span><span style="color:#75715e"></span>
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="explicit显式构造函数">explicit（显式）构造函数</h3>
<p>explicit 修饰的构造函数可用来防止隐式转换</p>
<h4 id="explicit-使用">explicit 使用</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Test1</span>
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    Test1(<span style="color:#66d9ef">int</span> n)            <span style="color:#75715e">// 普通构造函数
</span><span style="color:#75715e"></span>    {
        num<span style="color:#f92672">=</span>n;
    }
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">int</span> num;
};

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Test2</span>
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">explicit</span> Test2(<span style="color:#66d9ef">int</span> n)   <span style="color:#75715e">// explicit（显式）构造函数
</span><span style="color:#75715e"></span>    {
        num<span style="color:#f92672">=</span>n;
    }
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">int</span> num;
};

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
    Test1 t1<span style="color:#f92672">=</span><span style="color:#ae81ff">12</span>;            <span style="color:#75715e">// 隐式调用其构造函数，成功
</span><span style="color:#75715e"></span>    Test2 t2<span style="color:#f92672">=</span><span style="color:#ae81ff">12</span>;            <span style="color:#75715e">// 编译错误，不能隐式调用其构造函数
</span><span style="color:#75715e"></span>    Test2 t2(<span style="color:#ae81ff">12</span>);           <span style="color:#75715e">// 显式调用成功
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="friend-友元类和友元函数">friend 友元类和友元函数</h3>
<ul>
<li>
<p>能访问私有成员</p>
</li>
<li>
<p>破坏封装性</p>
</li>
<li>
<p>友元关系不可传递</p>
</li>
<li>
<p>友元关系的单向性</p>
</li>
<li>
<p>友元声明的形式及数量不受限制</p>
</li>
</ul>
<h3 id="using">using</h3>
<h4 id="using-声明">using 声明</h4>
<p>一条 using 声明 语句一次只引入命名空间的一个成员。它使得我们可以清楚知道程序中所引用的到底是哪个名字。如：</p>
<pre tabindex="0"><code>using namespace_name::name;
</code></pre><h4 id="构造函数的-using-声明c11">构造函数的 using 声明【C++11】</h4>
<p>在 C++11 中，派生类能够重用其直接基类定义的构造函数。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Derived</span> <span style="color:#f92672">:</span> Base {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">using</span> Base<span style="color:#f92672">::</span>Base;
    <span style="color:#75715e">/* ... */</span>
};
</code></pre></div><p>如上 using 声明，对于基类的每个构造函数，编译器都生成一个与之对应（形参列表完全相同）的派生类构造函数。生成如下类型构造函数：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++">derived(parms) <span style="color:#f92672">:</span> base(args) { }
</code></pre></div><h4 id="using-指示">using 指示</h4>
<p>using 指示 使得某个特定命名空间中所有名字都可见，这样我们就无需再为它们添加任何前缀限定符了。如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#66d9ef">using</span> namespace_name name;
</code></pre></div><h4 id="尽量少使用-using-指示-污染命名空间">尽量少使用 <code>using 指示</code> 污染命名空间</h4>
<blockquote>
<p>一般说来，使用 using 命令比使用 using 编译命令更安全，这是由于它只导入了制定的名称。如果该名称与局部名称发生冲突，编译器将发出指示。using编译命令导入所有的名称，包括可能并不需要的名称。如果与局部名称发生冲突，则局部名称将覆盖名称空间版本，而编译器并不会发出警告。另外，名称空间的开放性意味着名称空间的名称可能分散在多个地方，这使得难以准确知道添加了哪些名称。</p>
</blockquote>
<h3 id="using-使用">using 使用</h3>
<p>尽量少使用 using 指示</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</code></pre></div><p>应该多使用 using 声明</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#66d9ef">int</span> x;
std<span style="color:#f92672">::</span>cin <span style="color:#f92672">&gt;&gt;</span> x ;
std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> x <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</code></pre></div><p>或者</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#66d9ef">using</span> std<span style="color:#f92672">::</span>cin;
<span style="color:#66d9ef">using</span> std<span style="color:#f92672">::</span>cout;
<span style="color:#66d9ef">using</span> std<span style="color:#f92672">::</span>endl;
<span style="color:#66d9ef">int</span> x;
cin <span style="color:#f92672">&gt;&gt;</span> x;
cout <span style="color:#f92672">&lt;&lt;</span> x <span style="color:#f92672">&lt;&lt;</span> endl;
</code></pre></div><h3 id="-范围解析运算符">:: 范围解析运算符</h3>



  <footer>
  
<nav class="post-nav">
  <span class="nav-prev">&larr; <a href="/post/2021/12/30/cprimer04/">【转载】C Primer 之 new, delete</a></span>
  <span class="nav-next"></span>
</nav>

<script type="text/javascript">
document.addEventListener('keyup', function(e) {
  if (e.target.nodeName.toUpperCase() != 'BODY') return;
  var url = false;
  if (e.which == 37) {  
    
    url = '\/post\/2021\/12\/30\/cprimer04\/';
    
  } else if (e.which == 39) {  
    
  }
  if (url) window.location = url;
});
</script>






<script src="https://utteranc.es/client.js"
repo="lzxqaq/site-comment"
issue-term="title"
theme="github-light"
crossorigin="anonymous"
async>
</script>








<script async src="/js/fix-toc.js"></script>

<script async src="/js/center-img.js"></script>

<script async src="/js/right-quote.js"></script>

<script async src="/js/fix-footnote.js"></script>

<script async src="/js/math-code.js"></script>

<script async src="/js/external-link.js"></script>

<script async src="/js/alt-title.js"></script>

<script async src="/js/header-link.js"></script>



  
  
  <hr>
  <div class="copyright">© <a href="/">Zexun Luo</a> 2020 - 2022</div>
  
  </footer>
  </article>
  
<script async src="https://www.googletagmanager.com/gtag/js?id=G-KDTTBGMLCQ"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-KDTTBGMLCQ', { 'anonymize_ip': false });
}
</script>

  </body>
</html>

