<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <title>【转载】C&#43;&#43;面试之 C/C&#43;&#43;基础 - Zexun Luo | 罗泽勋</title>
    <meta property="og:title" content="【转载】C&#43;&#43;面试之 C/C&#43;&#43;基础 - Zexun Luo | 罗泽勋">
    
    <meta name="twitter:card" content="summary">

    
      
    

    
      
      <meta property="description" content="转载自https://github.com/huihut/interview
[&amp;hellip;] （为了方便记忆可以想成）被 const 修饰（在 const 后面）的值不可改变，如下文使用例子中的 p2、p3
[&amp;hellip;] const 使用
[&amp;hellip;] // 类 class A { private: const int a; // 常对象成员， &amp;hellip;">
      <meta property="og:description" content="转载自https://github.com/huihut/interview
[&amp;hellip;] （为了方便记忆可以想成）被 const 修饰（在 const 后面）的值不可改变，如下文使用例子中的 p2、p3
[&amp;hellip;] const 使用
[&amp;hellip;] // 类 class A { private: const int a; // 常对象成员， &amp;hellip;">
      
    

    
    
    <meta name="twitter:image" content="https://gitee.com/huihut/interview/raw/master/images/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81.png">
    
    

    
    
    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/fonts.css" />
    <link href="https://cdn.bootcss.com/aplayer/1.10.1/APlayer.min.css" rel="stylesheet">
<script src="https://cdn.bootcss.com/aplayer/1.10.1/APlayer.min.js"></script>

  </head>

  
  <body>
    <header class="masthead">
      

<h1><a href="/"><img src="/images/logo.png" alt="Zexun Luo" /></a></h1>



      <nav class="menu">
  <ul>
  
  
  <li><a href="/">主页</a></li>
  
  <li><a href="/about/">关于</a></li>
  
  <li><a href="/blog/">日志</a></li>
  
  <li><a href="/post/">编程</a></li>
  
  <li><a href="/series/">标签</a></li>
  
  <li><a href="/categories/">分类</a></li>
  
  <li><a href="/cv/">简历</a></li>
  
  <li><a href="/note/">抄录</a></li>
  
  <li><a href="/todo/">事务</a></li>
  
  </ul>
</nav>

    </header>
    <header class="title">
      
<h1>【转载】C&#43;&#43;面试之 C/C&#43;&#43;基础</h1>


<h3>罗泽勋 / 
2022-01-11</h3>

<hr>


    </header>





<main>
<p>转载自<a href="https://github.com/huihut/interview">https://github.com/huihut/interview</a></p>
<h3 id="const">const</h3>
<h4 id="作用">作用</h4>
<ol>
<li>修饰变量，说明该变量不可以被改变；</li>
<li>修饰指针，分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer）；</li>
<li>修饰引用，指向常量的引用（reference to const），用于形参类型，即避免了拷贝，又避免了函数对值的修改；</li>
<li>修饰成员函数，说明该成员函数内不能修改成员变量。</li>
</ol>
<h4 id="const-的指针与引用">const 的指针与引用</h4>
<ul>
<li>指针
<ul>
<li>指向常量的指针（pointer to const）</li>
<li>自身是常量的指针（常量指针，const pointer）</li>
</ul>
</li>
<li>引用
<ul>
<li>指向常量的引用（reference to const）</li>
<li>没有 const reference，因为引用只是对象的别名，引用不是对象，不能用 const 修饰</li>
</ul>
</li>
</ul>
<blockquote>
<p>（为了方便记忆可以想成）被 const 修饰（在 const 后面）的值不可改变，如下文使用例子中的 <code>p2</code>、<code>p3</code></p>
</blockquote>
<h4 id="使用">使用</h4>
<p>const 使用</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// 类
</span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span>
{
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> a;                <span style="color:#75715e">// 常对象成员，可以使用初始化列表或者类内初始化
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#75715e">// 构造函数
</span><span style="color:#75715e"></span>    A() <span style="color:#f92672">:</span> a(<span style="color:#ae81ff">0</span>) { };
    A(<span style="color:#66d9ef">int</span> x) <span style="color:#f92672">:</span> a(x) { };        <span style="color:#75715e">// 初始化列表
</span><span style="color:#75715e"></span>
    <span style="color:#75715e">// const可用于对重载函数的区分
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">getValue</span>();             <span style="color:#75715e">// 普通成员函数
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">getValue</span>() <span style="color:#66d9ef">const</span>;       <span style="color:#75715e">// 常成员函数，不得修改类中的任何数据成员的值
</span><span style="color:#75715e"></span>};

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">function</span>()
{
    <span style="color:#75715e">// 对象
</span><span style="color:#75715e"></span>    A b;                        <span style="color:#75715e">// 普通对象，可以调用全部成员函数
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">const</span> A a;                  <span style="color:#75715e">// 常对象，只能调用常成员函数
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">const</span> A <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>a;            <span style="color:#75715e">// 指针变量，指向常对象
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">const</span> A <span style="color:#f92672">&amp;</span>q <span style="color:#f92672">=</span> a;             <span style="color:#75715e">// 指向常对象的引用
</span><span style="color:#75715e"></span>
    <span style="color:#75715e">// 指针
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">char</span> greeting[] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Hello&#34;</span>;
    <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> p1 <span style="color:#f92672">=</span> greeting;                <span style="color:#75715e">// 指针变量，指向字符数组变量
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> p2 <span style="color:#f92672">=</span> greeting;          <span style="color:#75715e">// 指针变量，指向字符数组常量（const 后面是 char，说明指向的字符（char）不可改变）
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> <span style="color:#66d9ef">const</span> p3 <span style="color:#f92672">=</span> greeting;          <span style="color:#75715e">// 自身是常量的指针，指向字符数组变量（const 后面是 p3，说明 p3 指针自身不可改变）
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> <span style="color:#66d9ef">const</span> p4 <span style="color:#f92672">=</span> greeting;    <span style="color:#75715e">// 自身是常量的指针，指向字符数组常量
</span><span style="color:#75715e"></span>}

<span style="color:#75715e">// 函数
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">function1</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> Var);           <span style="color:#75715e">// 传递过来的参数在函数内不可变
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">function2</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> Var);         <span style="color:#75715e">// 参数指针所指内容为常量
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">function3</span>(<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> <span style="color:#66d9ef">const</span> Var);         <span style="color:#75715e">// 参数指针为常量
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">function4</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">&amp;</span> Var);          <span style="color:#75715e">// 引用参数在函数内为常量
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// 函数返回值
</span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">function5</span>();      <span style="color:#75715e">// 返回一个常数
</span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> <span style="color:#a6e22e">function6</span>();     <span style="color:#75715e">// 返回一个指向常量的指针变量，使用：const int *p = function6();
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">function7</span>();     <span style="color:#75715e">// 返回一个指向变量的常指针，使用：int* const p = function7();
</span></code></pre></div><h4 id="宏定义-define-和-const-常量">宏定义 #define 和 const 常量</h4>
<table>
<thead>
<tr>
<th>宏定义 #define</th>
<th>const 常量</th>
</tr>
</thead>
<tbody>
<tr>
<td>宏定义，相当于字符替换</td>
<td>常量声明</td>
</tr>
<tr>
<td>预处理器处理</td>
<td>编译器处理</td>
</tr>
<tr>
<td>无类型安全检查</td>
<td>有类型安全检查</td>
</tr>
<tr>
<td>不分配内存</td>
<td>要分配内存</td>
</tr>
<tr>
<td>存储在代码段</td>
<td>存储在数据段</td>
</tr>
<tr>
<td>可通过 <code>#undef</code> 取消</td>
<td>不可取消</td>
</tr>
</tbody>
</table>
<h3 id="static">static</h3>
<h4 id="作用-1">作用</h4>
<ol>
<li>修饰普通变量，修改变量的存储区域和生命周期，使变量存储在静态区，在 main 函数运行前就分配了空间，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。</li>
<li>修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static。</li>
<li>修饰成员变量，修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员。</li>
<li>修饰成员函数，修饰成员函数使得不需要生成对象就可以访问该函数，但是在 static 函数内不能访问非静态成员。</li>
</ol>
<h3 id="this-指针">this 指针</h3>
<ol>
<li><code>this</code> 指针是一个隐含于每一个非静态成员函数中的特殊指针。它指向调用该成员函数的那个对象。</li>
<li>当对一个对象调用成员函数时，编译程序先将对象的地址赋给 <code>this</code> 指针，然后调用成员函数，每次成员函数存取数据成员时，都隐式使用 <code>this</code> 指针。</li>
<li>当一个成员函数被调用时，自动向它传递一个隐含的参数，该参数是一个指向这个成员函数所在的对象的指针。</li>
<li><code>this</code> 指针被隐含地声明为: <code>ClassName *const this</code>，这意味着不能给 <code>this</code> 指针赋值；在 <code>ClassName</code> 类的 <code>const</code> 成员函数中，<code>this</code> 指针的类型为：<code>const ClassName* const</code>，这说明不能对 <code>this</code> 指针所指向的这种对象是不可修改的（即不能对这种对象的数据成员进行赋值操作）；</li>
<li><code>this</code> 并不是一个常规变量，而是个右值，所以不能取得 <code>this</code> 的地址（不能 <code>&amp;this</code>）。</li>
<li>在以下场景中，经常需要显式引用 <code>this</code> 指针：
<ol>
<li>为实现对象的链式引用；</li>
<li>为避免对同一对象进行赋值操作；</li>
<li>在实现一些数据结构时，如 <code>list</code>。</li>
</ol>
</li>
</ol>
<h3 id="inline-内联函数">inline 内联函数</h3>
<h4 id="特征">特征</h4>
<ul>
<li>相当于把内联函数里面的内容写在调用内联函数处；</li>
<li>相当于不用执行进入函数的步骤，直接执行函数体；</li>
<li>相当于宏，却比宏多了类型检查，真正具有函数特性；</li>
<li>编译器一般不内联包含循环、递归、switch 等复杂操作的内联函数；</li>
<li>在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数。</li>
</ul>
<h4 id="使用-1">使用</h4>
<p>inline 使用</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// 声明1（加 inline，建议使用）
</span><span style="color:#75715e"></span><span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">functionName</span>(<span style="color:#66d9ef">int</span> first, <span style="color:#66d9ef">int</span> second,...);

<span style="color:#75715e">// 声明2（不加 inline）
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">functionName</span>(<span style="color:#66d9ef">int</span> first, <span style="color:#66d9ef">int</span> second,...);

<span style="color:#75715e">// 定义
</span><span style="color:#75715e"></span><span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">functionName</span>(<span style="color:#66d9ef">int</span> first, <span style="color:#66d9ef">int</span> second,...) {<span style="color:#75715e">/****/</span>};

<span style="color:#75715e">// 类内定义，隐式内联
</span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span> {
    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">doA</span>() { <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>; }         <span style="color:#75715e">// 隐式内联
</span><span style="color:#75715e"></span>}

<span style="color:#75715e">// 类外定义，需要显式内联
</span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span> {
    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">doA</span>();
}
<span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">int</span> A<span style="color:#f92672">::</span>doA() { <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>; }   <span style="color:#75715e">// 需要显式内联
</span></code></pre></div><h4 id="编译器对-inline-函数的处理步骤">编译器对 inline 函数的处理步骤</h4>
<ol>
<li>将 inline 函数体复制到 inline 函数调用点处；</li>
<li>为所用 inline 函数中的局部变量分配内存空间；</li>
<li>将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中；</li>
<li>如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 GOTO）。</li>
</ol>
<h4 id="优缺点">优缺点</h4>
<p>优点</p>
<ol>
<li>内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。</li>
<li>内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会。</li>
<li>在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能。</li>
<li>内联函数在运行时可调试，而宏定义不可以。</li>
</ol>
<p>缺点</p>
<ol>
<li>代码膨胀。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。</li>
<li>inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接。</li>
<li>是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。</li>
</ol>
<h4 id="虚函数virtual可以是内联函数inline吗">虚函数（virtual）可以是内联函数（inline）吗？</h4>
<blockquote>
<p><a href="http://www.cs.technion.ac.il/users/yechiel/c++-faq/inline-virtuals.html">Are &ldquo;inline virtual&rdquo; member functions ever actually &ldquo;inlined&rdquo;?</a></p>
</blockquote>
<ul>
<li>虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。</li>
<li>内联是在编译器建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。</li>
<li><code>inline virtual</code> 唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 <code>Base::who()</code>），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。</li>
</ul>
<p>虚函数内联使用</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;  </span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Base</span>
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	<span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> who()
	{
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;I am Base</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
	}
	<span style="color:#66d9ef">virtual</span> <span style="color:#f92672">~</span>Base() {}
};
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Derived</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Base
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	<span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">void</span> who()  <span style="color:#75715e">// 不写inline时隐式内联
</span><span style="color:#75715e"></span>	{
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;I am Derived</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
	}
};

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
	<span style="color:#75715e">// 此处的虚函数 who()，是通过类（Base）的具体对象（b）来调用的，编译期间就能确定了，所以它可以是内联的，但最终是否内联取决于编译器。 
</span><span style="color:#75715e"></span>	Base b;
	b.who();

	<span style="color:#75715e">// 此处的虚函数是通过指针调用的，呈现多态性，需要在运行时期间才能确定，所以不能为内联。  
</span><span style="color:#75715e"></span>	Base <span style="color:#f92672">*</span>ptr <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Derived();
	ptr<span style="color:#f92672">-&gt;</span>who();

	<span style="color:#75715e">// 因为Base有虚析构函数（virtual ~Base() {}），所以 delete 时，会先调用派生类（Derived）析构函数，再调用基类（Base）析构函数，防止内存泄漏。
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">delete</span> ptr;
	ptr <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;

	system(<span style="color:#e6db74">&#34;pause&#34;</span>);
	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
} 
</code></pre></div><h3 id="volatile">volatile</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">volatile</span> <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>; 
</code></pre></div><ul>
<li>volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以使用 volatile 告诉编译器不应对这样的对象进行优化。</li>
<li>volatile 关键字声明的变量，每次访问时都必须从内存中取出值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值）</li>
<li>const 可以是 volatile （如只读的状态寄存器）</li>
<li>指针可以是 volatile</li>
</ul>
<h3 id="assert">assert()</h3>
<p>断言，是宏，而非函数。assert 宏的原型定义在 <code>&lt;assert.h&gt;</code>（C）、<code>&lt;cassert&gt;</code>（C++）中，其作用是如果它的条件返回错误，则终止程序执行。可以通过定义 <code>NDEBUG</code> 来关闭 assert，但是需要在源代码的开头，<code>include &lt;assert.h&gt;</code> 之前。</p>
<p>assert() 使用</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#define NDEBUG          </span><span style="color:#75715e">// 加上这行，则 assert 不可用
</span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;assert.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
assert( p <span style="color:#f92672">!=</span> NULL );    <span style="color:#75715e">// assert 不可用
</span></code></pre></div><h3 id="sizeof">sizeof()</h3>
<ul>
<li>sizeof 对数组，得到整个数组所占空间大小。</li>
<li>sizeof 对指针，得到指针本身所占空间大小。</li>
</ul>
<h3 id="pragma-packn">#pragma pack(n)</h3>
<p>设定结构体、联合以及类成员变量以 n 字节方式对齐</p>
<p>#pragma pack(n) 使用</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#pragma pack(push)  </span><span style="color:#75715e">// 保存对齐状态
</span><span style="color:#75715e"></span><span style="color:#75715e">#pragma pack(4)     </span><span style="color:#75715e">// 设定为 4 字节对齐
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">test</span>
{
    <span style="color:#66d9ef">char</span> m1;
    <span style="color:#66d9ef">double</span> m4;
    <span style="color:#66d9ef">int</span> m3;
};

<span style="color:#75715e">#pragma pack(pop)   </span><span style="color:#75715e">// 恢复对齐状态
</span></code></pre></div><h3 id="位域">位域</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">Bit mode: <span style="color:#ae81ff">2</span>;    <span style="color:#75715e">// mode 占 2 位
</span></code></pre></div><p>类可以将其（非静态）数据成员定义为位域（bit-field），在一个位域中含有一定数量的二进制位。当一个程序需要向其他程序或硬件设备传递二进制数据时，通常会用到位域。</p>
<ul>
<li>位域在内存中的布局是与机器有关的</li>
<li>位域的类型必须是整型或枚举类型，带符号类型中的位域的行为将因具体实现而定</li>
<li>取地址运算符（&amp;）不能作用于位域，任何指针都无法指向类的位域</li>
</ul>
<h3 id="extern-c">extern &ldquo;C&rdquo;</h3>
<ul>
<li>被 extern 限定的函数或变量是 extern 类型的</li>
<li>被 <code>extern &quot;C&quot;</code> 修饰的变量和函数是按照 C 语言方式编译和链接的</li>
</ul>
<p><code>extern &quot;C&quot;</code> 的作用是让 C++ 编译器将 <code>extern &quot;C&quot;</code> 声明的代码当作 C 语言代码处理，可以避免 C++ 因符号修饰导致代码不能和C语言库中的符号进行链接的问题。</p>
<p>extern &ldquo;C&rdquo; 使用</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#ifdef __cplusplus
</span><span style="color:#75715e"></span><span style="color:#66d9ef">extern</span> <span style="color:#e6db74">&#34;C&#34;</span> {
<span style="color:#75715e">#endif
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">memset</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>, <span style="color:#66d9ef">int</span>, size_t);

<span style="color:#75715e">#ifdef __cplusplus
</span><span style="color:#75715e"></span>}
<span style="color:#75715e">#endif
</span></code></pre></div><h3 id="struct-和-typedef-struct">struct 和 typedef struct</h3>
<h4 id="c-中">C 中</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">// c
</span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> Student {
    <span style="color:#66d9ef">int</span> age; 
} S;
</code></pre></div><p>等价于</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">// c
</span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> Student { 
    <span style="color:#66d9ef">int</span> age; 
};

<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> Student S;
</code></pre></div><p>此时 <code>S</code> 等价于 <code>struct Student</code>，但两个标识符名称空间不相同。</p>
<p>另外还可以定义与 <code>struct Student</code> 不冲突的 <code>void Student() {}</code>。</p>
<h4 id="c-中-1">C++ 中</h4>
<p>由于编译器定位符号的规则（搜索规则）改变，导致不同于C语言。</p>
<p>一、如果在类标识符空间定义了 <code>struct Student {...};</code>，使用 <code>Student me;</code> 时，编译器将搜索全局标识符表，<code>Student</code> 未找到，则在类标识符内搜索。</p>
<p>即表现为可以使用 <code>Student</code> 也可以使用 <code>struct Student</code>，如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// cpp
</span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Student</span> { 
    <span style="color:#66d9ef">int</span> age; 
};

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">f</span>( Student me );       <span style="color:#75715e">// 正确，&#34;struct&#34; 关键字可省略
</span></code></pre></div><p>二、若定义了与 <code>Student</code> 同名函数之后，则 <code>Student</code> 只代表函数，不代表结构体，如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Student</span> { 
    <span style="color:#66d9ef">int</span> age; 
} S;

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Student</span>() {}           <span style="color:#75715e">// 正确，定义后 &#34;Student&#34; 只代表此函数
</span><span style="color:#75715e"></span>
<span style="color:#75715e">//void S() {}               // 错误，符号 &#34;S&#34; 已经被定义为一个 &#34;struct Student&#34; 的别名
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    Student(); 
    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Student</span> me;      <span style="color:#75715e">// 或者 &#34;S me&#34;;
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="c-中-struct-和-class">C++ 中 struct 和 class</h3>
<p>总的来说，struct 更适合看成是一个数据结构的实现体，class 更适合看成是一个对象的实现体。</p>
<h4 id="区别">区别</h4>
<ul>
<li>最本质的一个区别就是默认的访问控制
<ol>
<li>默认的继承访问权限。struct 是 public 的，class 是 private 的。</li>
<li>struct 作为数据结构的实现体，它默认的数据访问控制是 public 的，而 class 作为对象的实现体，它默认的成员变量访问控制是 private 的。</li>
</ol>
</li>
</ul>
<h3 id="union-联合">union 联合</h3>
<p>联合（union）是一种节省空间的特殊的类，一个 union 可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值。当某个成员被赋值后其他成员变为未定义状态。联合有如下特点：</p>
<ul>
<li>默认访问控制符为 public</li>
<li>可以含有构造函数、析构函数</li>
<li>不能含有引用类型的成员</li>
<li>不能继承自其他类，不能作为基类</li>
<li>不能含有虚函数</li>
<li>匿名 union 在定义所在作用域可直接访问 union 成员</li>
<li>匿名 union 不能包含 protected 成员或 private 成员</li>
<li>全局匿名联合必须是静态（static）的</li>
</ul>
<p>union 使用</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">union</span> <span style="color:#a6e22e">UnionTest</span> {
    UnionTest() <span style="color:#f92672">:</span> i(<span style="color:#ae81ff">10</span>) {};
    <span style="color:#66d9ef">int</span> i;
    <span style="color:#66d9ef">double</span> d;
};

<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">union</span> {
    <span style="color:#66d9ef">int</span> i;
    <span style="color:#66d9ef">double</span> d;
};

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    UnionTest u;

    <span style="color:#66d9ef">union</span> {
        <span style="color:#66d9ef">int</span> i;
        <span style="color:#66d9ef">double</span> d;
    };

    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> u.i <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;  <span style="color:#75715e">// 输出 UnionTest 联合的 10
</span><span style="color:#75715e"></span>
    <span style="color:#f92672">::</span>i <span style="color:#f92672">=</span> <span style="color:#ae81ff">20</span>;
    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">::</span>i <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;  <span style="color:#75715e">// 输出全局静态匿名联合的 20
</span><span style="color:#75715e"></span>
    i <span style="color:#f92672">=</span> <span style="color:#ae81ff">30</span>;
    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> i <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;    <span style="color:#75715e">// 输出局部匿名联合的 30
</span><span style="color:#75715e"></span>
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="c-实现-c-类">C 实现 C++ 类</h3>
<p>C 实现 C++ 的面向对象特性（封装、继承、多态）</p>
<ul>
<li>封装：使用函数指针把属性与方法封装到结构体中</li>
<li>继承：结构体嵌套</li>
<li>多态：父类与子类方法的函数指针不同</li>
</ul>
<blockquote>
<p><a href="https://stackoverflow.com/a/351745">Can you write object-oriented code in C? [closed]</a></p>
</blockquote>
<h3 id="explicit显式关键字">explicit（显式）关键字</h3>
<ul>
<li>explicit 修饰构造函数时，可以防止隐式转换和复制初始化</li>
<li>explicit 修饰转换函数时，可以防止隐式转换，但 <a href="https://zh.cppreference.com/w/cpp/language/implicit_conversion">按语境转换</a> 除外</li>
</ul>
<p>explicit 使用</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">A</span>
{
	A(<span style="color:#66d9ef">int</span>) { }
	<span style="color:#66d9ef">operator</span> <span style="color:#a6e22e">bool</span>() <span style="color:#66d9ef">const</span> { <span style="color:#66d9ef">return</span> true; }
};

<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">B</span>
{
	<span style="color:#66d9ef">explicit</span> <span style="color:#a6e22e">B</span>(<span style="color:#66d9ef">int</span>) {}
	<span style="color:#66d9ef">explicit</span> <span style="color:#66d9ef">operator</span> <span style="color:#a6e22e">bool</span>() <span style="color:#66d9ef">const</span> { <span style="color:#66d9ef">return</span> true; }
};

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">doA</span>(A a) {}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">doB</span>(B b) {}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
	A a1(<span style="color:#ae81ff">1</span>);		<span style="color:#75715e">// OK：直接初始化
</span><span style="color:#75715e"></span>	A a2 <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;		<span style="color:#75715e">// OK：复制初始化
</span><span style="color:#75715e"></span>	A a3{ <span style="color:#ae81ff">1</span> };		<span style="color:#75715e">// OK：直接列表初始化
</span><span style="color:#75715e"></span>	A a4 <span style="color:#f92672">=</span> { <span style="color:#ae81ff">1</span> };		<span style="color:#75715e">// OK：复制列表初始化
</span><span style="color:#75715e"></span>	A a5 <span style="color:#f92672">=</span> (A)<span style="color:#ae81ff">1</span>;		<span style="color:#75715e">// OK：允许 static_cast 的显式转换 
</span><span style="color:#75715e"></span>	doA(<span style="color:#ae81ff">1</span>);			<span style="color:#75715e">// OK：允许从 int 到 A 的隐式转换
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (a1);		<span style="color:#75715e">// OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">bool</span> a6(a1);		<span style="color:#75715e">// OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">bool</span> a7 <span style="color:#f92672">=</span> a1;		<span style="color:#75715e">// OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">bool</span> a8 <span style="color:#f92672">=</span> <span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span><span style="color:#f92672">&gt;</span>(a1);  <span style="color:#75715e">// OK ：static_cast 进行直接初始化
</span><span style="color:#75715e"></span>
	B b1(<span style="color:#ae81ff">1</span>);		<span style="color:#75715e">// OK：直接初始化
</span><span style="color:#75715e"></span>	B b2 <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;		<span style="color:#75715e">// 错误：被 explicit 修饰构造函数的对象不可以复制初始化
</span><span style="color:#75715e"></span>	B b3{ <span style="color:#ae81ff">1</span> };		<span style="color:#75715e">// OK：直接列表初始化
</span><span style="color:#75715e"></span>	B b4 <span style="color:#f92672">=</span> { <span style="color:#ae81ff">1</span> };		<span style="color:#75715e">// 错误：被 explicit 修饰构造函数的对象不可以复制列表初始化
</span><span style="color:#75715e"></span>	B b5 <span style="color:#f92672">=</span> (B)<span style="color:#ae81ff">1</span>;		<span style="color:#75715e">// OK：允许 static_cast 的显式转换
</span><span style="color:#75715e"></span>	doB(<span style="color:#ae81ff">1</span>);			<span style="color:#75715e">// 错误：被 explicit 修饰构造函数的对象不可以从 int 到 B 的隐式转换
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (b1);		<span style="color:#75715e">// OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">bool</span> b6(b1);		<span style="color:#75715e">// OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">bool</span> b7 <span style="color:#f92672">=</span> b1;		<span style="color:#75715e">// 错误：被 explicit 修饰转换函数 B::operator bool() 的对象不可以隐式转换
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">bool</span> b8 <span style="color:#f92672">=</span> <span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span><span style="color:#f92672">&gt;</span>(b1);  <span style="color:#75715e">// OK：static_cast 进行直接初始化
</span><span style="color:#75715e"></span>
	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="friend-友元类和友元函数">friend 友元类和友元函数</h3>
<ul>
<li>能访问私有成员</li>
<li>破坏封装性</li>
<li>友元关系不可传递</li>
<li>友元关系的单向性</li>
<li>友元声明的形式及数量不受限制</li>
</ul>
<h3 id="using">using</h3>
<h4 id="using-声明">using 声明</h4>
<p>一条 <code>using 声明</code> 语句一次只引入命名空间的一个成员。它使得我们可以清楚知道程序中所引用的到底是哪个名字。如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">using</span> namespace_name<span style="color:#f92672">::</span>name;
</code></pre></div><h4 id="构造函数的-using-声明">构造函数的 using 声明</h4>
<p>在 C++11 中，派生类能够重用其直接基类定义的构造函数。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Derived</span> <span style="color:#f92672">:</span> Base {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">using</span> Base<span style="color:#f92672">::</span>Base;
    <span style="color:#75715e">/* ... */</span>
};
</code></pre></div><p>如上 using 声明，对于基类的每个构造函数，编译器都生成一个与之对应（形参列表完全相同）的派生类构造函数。生成如下类型构造函数：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">Derived(parms) <span style="color:#f92672">:</span> Base(args) { }
</code></pre></div><h4 id="using-指示">using 指示</h4>
<p><code>using 指示</code> 使得某个特定命名空间中所有名字都可见，这样我们就无需再为它们添加任何前缀限定符了。如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">using</span> namespace_name name;
</code></pre></div><h4 id="尽量少使用-using-指示-污染命名空间">尽量少使用 <code>using 指示</code> 污染命名空间</h4>
<blockquote>
<p>一般说来，使用 using 命令比使用 using 编译命令更安全，这是由于它<strong>只导入了指定的名称</strong>。如果该名称与局部名称发生冲突，编译器将<strong>发出指示</strong>。using编译命令导入所有的名称，包括可能并不需要的名称。如果与局部名称发生冲突，则<strong>局部名称将覆盖名称空间版本</strong>，而编译器<strong>并不会发出警告</strong>。另外，名称空间的开放性意味着名称空间的名称可能分散在多个地方，这使得难以准确知道添加了哪些名称。</p>
</blockquote>
<p>using 使用</p>
<p>尽量少使用 <code>using 指示</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
</code></pre></div><p>应该多使用 <code>using 声明</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">int</span> x;
std<span style="color:#f92672">::</span>cin <span style="color:#f92672">&gt;&gt;</span> x ;
std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> x <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</code></pre></div><p>或者</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">using</span> std<span style="color:#f92672">::</span>cin;
<span style="color:#66d9ef">using</span> std<span style="color:#f92672">::</span>cout;
<span style="color:#66d9ef">using</span> std<span style="color:#f92672">::</span>endl;
<span style="color:#66d9ef">int</span> x;
cin <span style="color:#f92672">&gt;&gt;</span> x;
cout <span style="color:#f92672">&lt;&lt;</span> x <span style="color:#f92672">&lt;&lt;</span> endl;
</code></pre></div><h3 id="-范围解析运算符">:: 范围解析运算符</h3>
<h4 id="分类">分类</h4>
<ol>
<li>全局作用域符（<code>::name</code>）：用于类型名称（类、类成员、成员函数、变量等）前，表示作用域为全局命名空间</li>
<li>类作用域符（<code>class::name</code>）：用于表示指定类型的作用域范围是具体某个类的</li>
<li>命名空间作用域符（<code>namespace::name</code>）:用于表示指定类型的作用域范围是具体某个命名空间的</li>
</ol>
<p>:: 使用</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">int</span> count <span style="color:#f92672">=</span> <span style="color:#ae81ff">11</span>;         <span style="color:#75715e">// 全局（::）的 count
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> count;   <span style="color:#75715e">// 类 A 的 count（A::count）
</span><span style="color:#75715e"></span>};
<span style="color:#66d9ef">int</span> A<span style="color:#f92672">::</span>count <span style="color:#f92672">=</span> <span style="color:#ae81ff">21</span>;

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">fun</span>()
{
	<span style="color:#66d9ef">int</span> count <span style="color:#f92672">=</span> <span style="color:#ae81ff">31</span>;     <span style="color:#75715e">// 初始化局部的 count 为 31
</span><span style="color:#75715e"></span>	count <span style="color:#f92672">=</span> <span style="color:#ae81ff">32</span>;         <span style="color:#75715e">// 设置局部的 count 的值为 32
</span><span style="color:#75715e"></span>}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
	<span style="color:#f92672">::</span>count <span style="color:#f92672">=</span> <span style="color:#ae81ff">12</span>;       <span style="color:#75715e">// 测试 1：设置全局的 count 的值为 12
</span><span style="color:#75715e"></span>
	A<span style="color:#f92672">::</span>count <span style="color:#f92672">=</span> <span style="color:#ae81ff">22</span>;      <span style="color:#75715e">// 测试 2：设置类 A 的 count 为 22
</span><span style="color:#75715e"></span>
	fun();		        <span style="color:#75715e">// 测试 3
</span><span style="color:#75715e"></span>
	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="enum-枚举类型">enum 枚举类型</h3>
<h4 id="限定作用域的枚举类型">限定作用域的枚举类型</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">enum</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">open_modes</span> { input, output, append };
</code></pre></div><h4 id="不限定作用域的枚举类型">不限定作用域的枚举类型</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">color</span> { red, yellow, green };
<span style="color:#66d9ef">enum</span> { floatPrec <span style="color:#f92672">=</span> <span style="color:#ae81ff">6</span>, doublePrec <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span> };
</code></pre></div><h3 id="decltype">decltype</h3>
<p>decltype 关键字用于检查实体的声明类型或表达式的类型及值分类。语法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">decltype</span> ( expression )
</code></pre></div><p>decltype 使用</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// 尾置返回允许我们在参数列表之后声明返回类型
</span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> It<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">auto</span> fcn(It beg, It end) <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">decltype</span>(<span style="color:#f92672">*</span>beg)
{
    <span style="color:#75715e">// 处理序列
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span>beg;    <span style="color:#75715e">// 返回序列中一个元素的引用
</span><span style="color:#75715e"></span>}
<span style="color:#75715e">// 为了使用模板参数成员，必须用 typename
</span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> It<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">auto</span> fcn2(It beg, It end) <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">typename</span> remove_reference<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">decltype</span>(<span style="color:#f92672">*</span>beg)<span style="color:#f92672">&gt;::</span>type
{
    <span style="color:#75715e">// 处理序列
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span>beg;    <span style="color:#75715e">// 返回序列中一个元素的拷贝
</span><span style="color:#75715e"></span>}
</code></pre></div><h3 id="引用">引用</h3>
<h4 id="左值引用">左值引用</h4>
<p>常规引用，一般表示对象的身份。</p>
<h4 id="右值引用">右值引用</h4>
<p>右值引用就是必须绑定到右值（一个临时对象、将要销毁的对象）的引用，一般表示对象的值。</p>
<p>右值引用可实现转移语义（Move Sementics）和精确传递（Perfect Forwarding），它的主要目的有两个方面：</p>
<ul>
<li>消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。</li>
<li>能够更简洁明确地定义泛型函数。</li>
</ul>
<h4 id="引用折叠">引用折叠</h4>
<ul>
<li><code>X&amp; &amp;</code>、<code>X&amp; &amp;&amp;</code>、<code>X&amp;&amp; &amp;</code> 可折叠成 <code>X&amp;</code></li>
<li><code>X&amp;&amp; &amp;&amp;</code> 可折叠成 <code>X&amp;&amp;</code></li>
</ul>
<h3 id="宏">宏</h3>
<ul>
<li>宏定义可以实现类似于函数的功能，但是它终归不是函数，而宏定义中括弧中的“参数”也不是真的参数，在宏展开的时候对 “参数” 进行的是一对一的替换。</li>
</ul>
<h3 id="成员初始化列表">成员初始化列表</h3>
<p>好处</p>
<ul>
<li>更高效：少了一次调用默认构造函数的过程。</li>
<li>有些场合必须要用初始化列表：
<ol>
<li>常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面</li>
<li>引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面</li>
<li>没有默认构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化</li>
</ol>
</li>
</ul>
<h3 id="initializer_list-列表初始化">initializer_list 列表初始化</h3>
<p>用花括号初始化器列表初始化一个对象，其中对应构造函数接受一个 <code>std::initializer_list</code> 参数.</p>
<p>initializer_list 使用</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;initializer_list&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span> 
<span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">S</span> {
    std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> v;
    S(std<span style="color:#f92672">::</span>initializer_list<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> l) <span style="color:#f92672">:</span> v(l) {
         std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;constructed with a &#34;</span> <span style="color:#f92672">&lt;&lt;</span> l.size() <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;-element list</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
    }
    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">append</span>(std<span style="color:#f92672">::</span>initializer_list<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> l) {
        v.insert(v.end(), l.begin(), l.end());
    }
    std<span style="color:#f92672">::</span>pair<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">const</span> T<span style="color:#f92672">*</span>, std<span style="color:#f92672">::</span>size_t<span style="color:#f92672">&gt;</span> c_arr() <span style="color:#66d9ef">const</span> {
        <span style="color:#66d9ef">return</span> {<span style="color:#f92672">&amp;</span>v[<span style="color:#ae81ff">0</span>], v.size()};  <span style="color:#75715e">// 在 return 语句中复制列表初始化
</span><span style="color:#75715e"></span>                                   <span style="color:#75715e">// 这不使用 std::initializer_list
</span><span style="color:#75715e"></span>    }
};
 
<span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">void</span> templated_fn(T) {}
 
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
    S<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> s <span style="color:#f92672">=</span> {<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>}; <span style="color:#75715e">// 复制初始化
</span><span style="color:#75715e"></span>    s.append({<span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">8</span>});      <span style="color:#75715e">// 函数调用中的列表初始化
</span><span style="color:#75715e"></span> 
    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;The vector size is now &#34;</span> <span style="color:#f92672">&lt;&lt;</span> s.c_arr().second <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; ints:</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
 
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span> n : s.v)
        std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> n <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39; &#39;</span>;
    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
 
    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Range-for over brace-init-list: </span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
 
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> x : {<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">3</span>}) <span style="color:#75715e">// auto 的规则令此带范围 for 工作
</span><span style="color:#75715e"></span>        std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> x <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39; &#39;</span>;
    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
 
    <span style="color:#66d9ef">auto</span> al <span style="color:#f92672">=</span> {<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">11</span>, <span style="color:#ae81ff">12</span>};   <span style="color:#75715e">// auto 的特殊规则
</span><span style="color:#75715e"></span> 
    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;The list bound to auto has size() = &#34;</span> <span style="color:#f92672">&lt;&lt;</span> al.size() <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
 
<span style="color:#75715e">//    templated_fn({1, 2, 3}); // 编译错误！“ {1, 2, 3} ”不是表达式，
</span><span style="color:#75715e"></span>                             <span style="color:#75715e">// 它无类型，故 T 无法推导
</span><span style="color:#75715e"></span>    templated_fn<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>initializer_list<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span>({<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>}); <span style="color:#75715e">// OK
</span><span style="color:#75715e"></span>    templated_fn<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span>({<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>});           <span style="color:#75715e">// 也 OK
</span><span style="color:#75715e"></span>}
</code></pre></div><h3 id="面向对象">面向对象</h3>
<p>面向对象程序设计（Object-oriented programming，OOP）是种具有对象概念的程序编程典范，同时也是一种程序开发的抽象方针。</p>
<p><img src="https://gitee.com/huihut/interview/raw/master/images/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E6%9C%AC%E7%89%B9%E5%BE%81.png" alt="面向对象特征"></p>
<p>面向对象三大特征 —— 封装、继承、多态</p>
<h3 id="封装">封装</h3>
<p>把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。关键字：public, protected, private。不写默认为 private。</p>
<ul>
<li><code>public</code> 成员：可以被任意实体访问</li>
<li><code>protected</code> 成员：只允许被子类及本类的成员函数访问</li>
<li><code>private</code> 成员：只允许被本类的成员函数、友元类或友元函数访问</li>
</ul>
<h3 id="继承">继承</h3>
<ul>
<li>基类（父类）——&gt; 派生类（子类）</li>
</ul>
<h3 id="多态">多态</h3>
<ul>
<li>多态，即多种状态（形态）。简单来说，我们可以将多态定义为消息以多种形式显示的能力。</li>
<li>多态是以封装和继承为基础的。</li>
<li>C++ 多态分类及实现：
<ol>
<li>重载多态（Ad-hoc Polymorphism，编译期）：函数重载、运算符重载</li>
<li>子类型多态（Subtype Polymorphism，运行期）：虚函数</li>
<li>参数多态性（Parametric Polymorphism，编译期）：类模板、函数模板</li>
<li>强制多态（Coercion Polymorphism，编译期/运行期）：基本类型转换、自定义类型转换</li>
</ol>
</li>
</ul>
<blockquote>
<p><a href="https://catonmat.net/cpp-polymorphism">The Four Polymorphisms in C++</a></p>
</blockquote>
<h4 id="静态多态编译期早绑定">静态多态（编译期/早绑定）</h4>
<p>函数重载</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span>
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">void</span> <span style="color:#66d9ef">do</span>(<span style="color:#66d9ef">int</span> a);
    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">do</span>(<span style="color:#66d9ef">int</span> a, <span style="color:#66d9ef">int</span> b);
};
</code></pre></div><h4 id="动态多态运行期期晚绑定">动态多态（运行期期/晚绑定）</h4>
<ul>
<li>虚函数：用 virtual 修饰成员函数，使其成为虚函数</li>
<li>动态绑定：当使用基类的引用或指针调用一个虚函数时将发生动态绑定</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>可以将派生类的对象赋值给基类的指针或引用，反之不可</li>
<li>普通函数（非类成员函数）不能是虚函数</li>
<li>静态函数（static）不能是虚函数</li>
<li>构造函数不能是虚函数（因为在调用构造函数时，虚表指针并没有在对象的内存空间中，必须要构造函数调用完成后才会形成虚表指针）</li>
<li>内联函数不能是表现多态性时的虚函数，解释见：<a href="https://github.com/huihut/interview#%E8%99%9A%E5%87%BD%E6%95%B0virtual%E5%8F%AF%E4%BB%A5%E6%98%AF%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0inline%E5%90%97">虚函数（virtual）可以是内联函数（inline）吗？</a></li>
</ul>
<p>动态多态使用</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Shape</span>                     <span style="color:#75715e">// 形状类
</span><span style="color:#75715e"></span>{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">double</span> calcArea()
    {
        ...
    }
    <span style="color:#66d9ef">virtual</span> <span style="color:#f92672">~</span>Shape();
};
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Circle</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Shape     <span style="color:#75715e">// 圆形类
</span><span style="color:#75715e"></span>{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">double</span> calcArea();
    ...
};
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Rect</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Shape       <span style="color:#75715e">// 矩形类
</span><span style="color:#75715e"></span>{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">double</span> calcArea();
    ...
};
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
    Shape <span style="color:#f92672">*</span> shape1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Circle(<span style="color:#ae81ff">4.0</span>);
    Shape <span style="color:#f92672">*</span> shape2 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Rect(<span style="color:#ae81ff">5.0</span>, <span style="color:#ae81ff">6.0</span>);
    shape1<span style="color:#f92672">-&gt;</span>calcArea();         <span style="color:#75715e">// 调用圆形类里面的方法
</span><span style="color:#75715e"></span>    shape2<span style="color:#f92672">-&gt;</span>calcArea();         <span style="color:#75715e">// 调用矩形类里面的方法
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">delete</span> shape1;
    shape1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;
    <span style="color:#66d9ef">delete</span> shape2;
    shape2 <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="虚析构函数">虚析构函数</h3>
<p>虚析构函数是为了解决基类的指针指向派生类对象，并用基类的指针删除派生类对象。</p>
<p>虚析构函数使用</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Shape</span>
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    Shape();                    <span style="color:#75715e">// 构造函数不能是虚函数
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">double</span> <span style="color:#a6e22e">calcArea</span>();
    <span style="color:#66d9ef">virtual</span> <span style="color:#f92672">~</span>Shape();           <span style="color:#75715e">// 虚析构函数
</span><span style="color:#75715e"></span>};
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Circle</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Shape     <span style="color:#75715e">// 圆形类
</span><span style="color:#75715e"></span>{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">double</span> calcArea();
    ...
};
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
    Shape <span style="color:#f92672">*</span> shape1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Circle(<span style="color:#ae81ff">4.0</span>);
    shape1<span style="color:#f92672">-&gt;</span>calcArea();    
    <span style="color:#66d9ef">delete</span> shape1;  <span style="color:#75715e">// 因为Shape有虚析构函数，所以delete释放内存时，先调用子类析构函数，再调用基类析构函数，防止内存泄漏。
</span><span style="color:#75715e"></span>    shape1 <span style="color:#f92672">=</span> NULL;
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span><span style="color:#960050;background-color:#1e0010">；</span>
}
</code></pre></div><h3 id="纯虚函数">纯虚函数</h3>
<p>纯虚函数是一种特殊的虚函数，在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">A</span>() <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</code></pre></div><h3 id="虚函数纯虚函数">虚函数、纯虚函数</h3>
<ul>
<li>类里如果声明了虚函数，这个函数是实现的，哪怕是空实现，它的作用就是为了能让这个函数在它的子类里面可以被覆盖（override），这样的话，编译器就可以使用后期绑定来达到多态了。纯虚函数只是一个接口，是个函数的声明而已，它要留到子类里去实现。</li>
<li>虚函数在子类里面可以不重写；但纯虚函数必须在子类实现才可以实例化子类。</li>
<li>虚函数的类用于 “实作继承”，继承接口的同时也继承了父类的实现。纯虚函数关注的是接口的统一性，实现由子类完成。</li>
<li>带纯虚函数的类叫抽象类，这种类不能直接生成对象，而只有被继承，并重写其虚函数后，才能使用。抽象类被继承后，子类可以继续是抽象类，也可以是普通类。</li>
<li>虚基类是虚继承中的基类，具体见下文虚继承。</li>
</ul>
<blockquote>
<p><a href="https://blog.csdn.net/u012260238/article/details/53610462">CSDN . C++ 中的虚函数、纯虚函数区别和联系</a></p>
</blockquote>
<h3 id="虚函数指针虚函数表">虚函数指针、虚函数表</h3>
<ul>
<li>虚函数指针：在含有虚函数类的对象中，指向虚函数表，在运行时确定。</li>
<li>虚函数表：在程序只读数据段（<code>.rodata section</code>，见：<a href="#%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84">目标文件存储结构</a>），存放虚函数指针，如果派生类实现了基类的某个虚函数，则在虚表中覆盖原本基类的那个虚函数指针，在编译时根据类的声明创建。</li>
</ul>
<blockquote>
<p><a href="https://blog.twofei.com/496/">C++中的虚函数(表)实现机制以及用C语言对其进行的模拟实现</a></p>
</blockquote>
<h3 id="虚继承">虚继承</h3>
<p>虚继承用于解决多继承条件下的菱形继承问题（浪费存储空间、存在二义性）。</p>
<p>底层实现原理与编译器相关，一般通过<strong>虚基类指针</strong>和<strong>虚基类表</strong>实现，每个虚继承的子类都有一个虚基类指针（占用一个指针的存储空间，4字节）和虚基类表（不占用类对象的存储空间）（需要强调的是，虚基类依旧会在子类里面存在拷贝，只是仅仅最多存在一份而已，并不是不在子类里面了）；当虚继承的子类被当做父类继承时，虚基类指针也会被继承。</p>
<p>实际上，vbptr 指的是虚基类表指针（virtual base table pointer），该指针指向了一个虚基类表（virtual table），虚表中记录了虚基类与本类的偏移地址；通过偏移地址，这样就找到了虚基类成员，而虚继承也不用像普通多继承那样维持着公共基类（虚基类）的两份同样的拷贝，节省了存储空间。</p>
<h3 id="虚继承虚函数">虚继承、虚函数</h3>
<ul>
<li>相同之处：都利用了虚指针（均占用类的存储空间）和虚表（均不占用类的存储空间）</li>
<li>不同之处：
<ul>
<li>虚继承
<ul>
<li>虚基类依旧存在继承类中，只占用存储空间</li>
<li>虚基类表存储的是虚基类相对直接继承类的偏移</li>
</ul>
</li>
<li>虚函数
<ul>
<li>虚函数不占用存储空间</li>
<li>虚函数表存储的是虚函数地址</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="模板类成员模板虚函数">模板类、成员模板、虚函数</h3>
<ul>
<li>模板类中可以使用虚函数</li>
<li>一个类（无论是普通类还是类模板）的成员模板（本身是模板的成员函数）不能是虚函数</li>
</ul>
<h3 id="抽象类接口类聚合类">抽象类、接口类、聚合类</h3>
<ul>
<li>抽象类：含有纯虚函数的类</li>
<li>接口类：仅含有纯虚函数的抽象类</li>
<li>聚合类：用户可以直接访问其成员，并且具有特殊的初始化语法形式。满足如下特点：
<ul>
<li>所有成员都是 public</li>
<li>没有定义任何构造函数</li>
<li>没有类内初始化</li>
<li>没有基类，也没有 virtual 函数</li>
</ul>
</li>
</ul>
<h3 id="内存分配和管理">内存分配和管理</h3>
<h4 id="malloccallocreallocalloca">malloc、calloc、realloc、alloca</h4>
<ol>
<li>malloc：申请指定字节数的内存。申请到的内存中的初始值不确定。</li>
<li>calloc：为指定长度的对象，分配能容纳其指定个数的内存。申请到的内存的每一位（bit）都初始化为 0。</li>
<li>realloc：更改以前分配的内存长度（增加或减少）。当增加长度时，可能需将以前分配区的内容移到另一个足够大的区域，而新增区域内的初始值则不确定。</li>
<li>alloca：在栈上申请内存。程序在出栈的时候，会自动释放内存。但是需要注意的是，alloca 不具可移植性, 而且在没有传统堆栈的机器上很难实现。alloca 不宜使用在必须广泛移植的程序中。C99 中支持变长数组 (VLA)，可以用来替代 alloca。</li>
</ol>
<h4 id="mallocfree">malloc、free</h4>
<p>用于分配、释放内存</p>
<p>malloc、free 使用</p>
<p>申请内存，确认是否申请成功</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>str <span style="color:#f92672">=</span> (<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>) malloc(<span style="color:#ae81ff">100</span>);
assert(str <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nullptr</span>);
</code></pre></div><p>释放内存后指针置空</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">free(p); 
p <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;
</code></pre></div><h4 id="newdelete">new、delete</h4>
<ol>
<li>new / new[]：完成两件事，先底层调用 malloc 分配了内存，然后调用构造函数（创建对象）。</li>
<li>delete/delete[]：也完成两件事，先调用析构函数（清理资源），然后底层调用 free 释放空间。</li>
<li>new 在申请内存时会自动计算所需字节数，而 malloc 则需我们自己输入申请内存空间的字节数。</li>
</ol>
<p>new、delete 使用</p>
<p>申请内存，确认是否申请成功</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
    T<span style="color:#f92672">*</span> t <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> T();     <span style="color:#75715e">// 先内存分配 ，再构造函数
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">delete</span> t;           <span style="color:#75715e">// 先析构函数，再内存释放
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h4 id="定位-new">定位 new</h4>
<p>定位 new（placement new）允许我们向 new 传递额外的地址参数，从而在预先指定的内存区域创建对象。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">new</span> (place_address) type
<span style="color:#66d9ef">new</span> (place_address) type (initializers)
<span style="color:#66d9ef">new</span> (place_address) type [size]
<span style="color:#66d9ef">new</span> (place_address) type [size] { braced initializer list }
</code></pre></div><ul>
<li><code>place_address</code> 是个指针</li>
<li><code>initializers</code> 提供一个（可能为空的）以逗号分隔的初始值列表</li>
</ul>
<h3 id="delete-this-合法吗">delete this 合法吗？</h3>
<blockquote>
<p><a href="https://isocpp.org/wiki/faq/freestore-mgmt#delete-this">Is it legal (and moral) for a member function to say delete this?</a></p>
</blockquote>
<p>合法，但：</p>
<ol>
<li>必须保证 this 对象是通过 <code>new</code>（不是 <code>new[]</code>、不是 placement new、不是栈上、不是全局、不是其他对象成员）分配的</li>
<li>必须保证调用 <code>delete this</code> 的成员函数是最后一个调用 this 的成员函数</li>
<li>必须保证成员函数的 <code>delete this </code> 后面没有调用 this 了</li>
<li>必须保证 <code>delete this</code> 后没有人使用了</li>
</ol>
<h3 id="如何定义一个只能在堆上栈上生成对象的类">如何定义一个只能在堆上（栈上）生成对象的类？</h3>
<blockquote>
<p><a href="https://www.nowcoder.com/questionTerminal/0a584aa13f804f3ea72b442a065a7618">如何定义一个只能在堆上（栈上）生成对象的类?</a></p>
</blockquote>
<h4 id="只能在堆上">只能在堆上</h4>
<p>方法：将析构函数设置为私有</p>
<p>原因：C++ 是静态绑定语言，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。若析构函数不可访问，则不能在栈上创建对象。</p>
<h4 id="只能在栈上">只能在栈上</h4>
<p>方法：将 new 和 delete 重载为私有</p>
<p>原因：在堆上生成对象，使用 new 关键词操作，其过程分为两阶段：第一阶段，使用 new 在堆上寻找可用内存，分配给对象；第二阶段，调用构造函数生成对象。将 new 操作设置为私有，那么第一阶段就无法完成，就不能够在堆上生成对象。</p>
<h3 id="智能指针">智能指针</h3>
<h4 id="c-标准库stl中">C++ 标准库（STL）中</h4>
<p>头文件：<code>#include &lt;memory&gt;</code></p>
<h4 id="c-98">C++ 98</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">std<span style="color:#f92672">::</span>auto_ptr<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>string<span style="color:#f92672">&gt;</span> ps (<span style="color:#66d9ef">new</span> std<span style="color:#f92672">::</span>string(str))<span style="color:#960050;background-color:#1e0010">；</span>
</code></pre></div><h4 id="c-11">C++ 11</h4>
<ol>
<li>shared_ptr</li>
<li>unique_ptr</li>
<li>weak_ptr</li>
<li>auto_ptr（被 C++11 弃用）</li>
</ol>
<ul>
<li>Class shared_ptr 实现共享式拥有（shared ownership）概念。多个智能指针指向相同对象，该对象和其相关资源会在 “最后一个 reference 被销毁” 时被释放。为了在结构较复杂的情景中执行上述工作，标准库提供 weak_ptr、bad_weak_ptr 和 enable_shared_from_this 等辅助类。</li>
<li>Class unique_ptr 实现独占式拥有（exclusive ownership）或严格拥有（strict ownership）概念，保证同一时间内只有一个智能指针可以指向该对象。你可以移交拥有权。它对于避免内存泄漏（resource leak）——如 new 后忘记 delete ——特别有用。</li>
</ul>
<h5 id="shared_ptr">shared_ptr</h5>
<p>多个智能指针可以共享同一个对象，对象的最末一个拥有着有责任销毁对象，并清理与该对象相关的所有资源。</p>
<ul>
<li>支持定制型删除器（custom deleter），可防范 Cross-DLL 问题（对象在动态链接库（DLL）中被 new 创建，却在另一个 DLL 内被 delete 销毁）、自动解除互斥锁</li>
</ul>
<h5 id="weak_ptr">weak_ptr</h5>
<p>weak_ptr 允许你共享但不拥有某对象，一旦最末一个拥有该对象的智能指针失去了所有权，任何 weak_ptr 都会自动成空（empty）。因此，在 default 和 copy 构造函数之外，weak_ptr 只提供 “接受一个 shared_ptr” 的构造函数。</p>
<ul>
<li>可打破环状引用（cycles of references，两个其实已经没有被使用的对象彼此互指，使之看似还在 “被使用” 的状态）的问题</li>
</ul>
<h5 id="unique_ptr">unique_ptr</h5>
<p>unique_ptr 是 C++11 才开始提供的类型，是一种在异常时可以帮助避免资源泄漏的智能指针。采用独占式拥有，意味着可以确保一个对象和其相应的资源同一时间只被一个 pointer 拥有。一旦拥有着被销毁或编程 empty，或开始拥有另一个对象，先前拥有的那个对象就会被销毁，其任何相应资源亦会被释放。</p>
<ul>
<li>unique_ptr 用于取代 auto_ptr</li>
</ul>
<h5 id="auto_ptr">auto_ptr</h5>
<p>被 c++11 弃用，原因是缺乏语言特性如 “针对构造和赋值” 的 <code>std::move</code> 语义，以及其他瑕疵。</p>
<h5 id="auto_ptr-与-unique_ptr-比较">auto_ptr 与 unique_ptr 比较</h5>
<ul>
<li>auto_ptr 可以赋值拷贝，复制拷贝后所有权转移；unqiue_ptr 无拷贝赋值语义，但实现了<code>move</code> 语义；</li>
<li>auto_ptr 对象不能管理数组（析构调用 <code>delete</code>），unique_ptr 可以管理数组（析构调用 <code>delete[]</code> ）；</li>
</ul>
<h3 id="强制类型转换运算符">强制类型转换运算符</h3>
<blockquote>
<p><a href="https://msdn.microsoft.com/zh-CN/library/5f6c9f8h.aspx">MSDN . 强制转换运算符</a></p>
</blockquote>
<h4 id="static_cast">static_cast</h4>
<ul>
<li>用于非多态类型的转换</li>
<li>不执行运行时类型检查（转换安全性不如 dynamic_cast）</li>
<li>通常用于转换数值数据类型（如 float -&gt; int）</li>
<li>可以在整个类层次结构中移动指针，子类转化为父类安全（向上转换），父类转化为子类不安全（因为子类可能有不在父类的字段或方法）</li>
</ul>
<blockquote>
<p>向上转换是一种隐式转换。</p>
</blockquote>
<h4 id="dynamic_cast">dynamic_cast</h4>
<ul>
<li>用于多态类型的转换</li>
<li>执行行运行时类型检查</li>
<li>只适用于指针或引用</li>
<li>对不明确的指针的转换将失败（返回 nullptr），但不引发异常</li>
<li>可以在整个类层次结构中移动指针，包括向上转换、向下转换</li>
</ul>
<h4 id="const_cast">const_cast</h4>
<ul>
<li>用于删除 const、volatile 和 __unaligned 特性（如将 const int 类型转换为 int 类型 ）</li>
</ul>
<h4 id="reinterpret_cast">reinterpret_cast</h4>
<ul>
<li>用于位的简单重新解释</li>
<li>滥用 reinterpret_cast 运算符可能很容易带来风险。 除非所需转换本身是低级别的，否则应使用其他强制转换运算符之一。</li>
<li>允许将任何指针转换为任何其他指针类型（如 <code>char*</code> 到 <code>int*</code> 或 <code>One_class*</code> 到 <code>Unrelated_class*</code> 之类的转换，但其本身并不安全）</li>
<li>也允许将任何整数类型转换为任何指针类型以及反向转换。</li>
<li>reinterpret_cast 运算符不能丢掉 const、volatile 或 __unaligned 特性。</li>
<li>reinterpret_cast 的一个实际用途是在哈希函数中，即，通过让两个不同的值几乎不以相同的索引结尾的方式将值映射到索引。</li>
</ul>
<h4 id="bad_cast">bad_cast</h4>
<ul>
<li>由于强制转换为引用类型失败，dynamic_cast 运算符引发 bad_cast 异常。</li>
</ul>
<p>bad_cast 使用</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">try</span> {  
    Circle<span style="color:#f92672">&amp;</span> ref_circle <span style="color:#f92672">=</span> <span style="color:#66d9ef">dynamic_cast</span><span style="color:#f92672">&lt;</span>Circle<span style="color:#f92672">&amp;&gt;</span>(ref_shape);   
}  
<span style="color:#66d9ef">catch</span> (bad_cast b) {  
    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Caught: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> b.what();  
} 
</code></pre></div><h3 id="运行时类型信息-rtti">运行时类型信息 (RTTI)</h3>
<h4 id="dynamic_cast-1">dynamic_cast</h4>
<ul>
<li>用于多态类型的转换</li>
</ul>
<h4 id="typeid">typeid</h4>
<ul>
<li>typeid 运算符允许在运行时确定对象的类型</li>
<li>type_id 返回一个 type_info 对象的引用</li>
<li>如果想通过基类的指针获得派生类的数据类型，基类必须带有虚函数</li>
<li>只能获取对象的实际类型</li>
</ul>
<h4 id="type_info">type_info</h4>
<ul>
<li>type_info 类描述编译器在程序中生成的类型信息。 此类的对象可以有效存储指向类型的名称的指针。 type_info 类还可存储适合比较两个类型是否相等或比较其排列顺序的编码值。 类型的编码规则和排列顺序是未指定的，并且可能因程序而异。</li>
<li>头文件：<code>typeinfo</code></li>
</ul>
<p>typeid、type_info 使用</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Flyable</span>                       <span style="color:#75715e">// 能飞的
</span><span style="color:#75715e"></span>{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> takeoff() <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;     <span style="color:#75715e">// 起飞
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">land</span>() <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;        <span style="color:#75715e">// 降落
</span><span style="color:#75715e"></span>};
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Bird</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Flyable         <span style="color:#75715e">// 鸟
</span><span style="color:#75715e"></span>{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">void</span> foraging() {...}           <span style="color:#75715e">// 觅食
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">takeoff</span>() {...}
    <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">land</span>() {...}
    <span style="color:#66d9ef">virtual</span> <span style="color:#f92672">~</span>Bird(){}
};
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Plane</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Flyable        <span style="color:#75715e">// 飞机
</span><span style="color:#75715e"></span>{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">void</span> carry() {...}              <span style="color:#75715e">// 运输
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">takeoff</span>() {...}
    <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">land</span>() {...}
};

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">type_info</span>
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> name() <span style="color:#66d9ef">const</span>;
    <span style="color:#66d9ef">bool</span> <span style="color:#66d9ef">operator</span> <span style="color:#f92672">==</span> (<span style="color:#66d9ef">const</span> type_info <span style="color:#f92672">&amp;</span> rhs) <span style="color:#66d9ef">const</span>;
    <span style="color:#66d9ef">bool</span> <span style="color:#66d9ef">operator</span> <span style="color:#f92672">!=</span> (<span style="color:#66d9ef">const</span> type_info <span style="color:#f92672">&amp;</span> rhs) <span style="color:#66d9ef">const</span>;
    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">before</span>(<span style="color:#66d9ef">const</span> type_info <span style="color:#f92672">&amp;</span> rhs) <span style="color:#66d9ef">const</span>;
    <span style="color:#66d9ef">virtual</span> <span style="color:#f92672">~</span>type_info();
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
    ...
};

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">doSomething</span>(Flyable <span style="color:#f92672">*</span>obj)                 <span style="color:#75715e">// 做些事情
</span><span style="color:#75715e"></span>{
    obj<span style="color:#f92672">-&gt;</span>takeoff();

    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#66d9ef">typeid</span>(<span style="color:#f92672">*</span>obj).name() <span style="color:#f92672">&lt;&lt;</span> endl;        <span style="color:#75715e">// 输出传入对象类型（&#34;class Bird&#34; or &#34;class Plane&#34;）
</span><span style="color:#75715e"></span>
    <span style="color:#66d9ef">if</span>(<span style="color:#66d9ef">typeid</span>(<span style="color:#f92672">*</span>obj) <span style="color:#f92672">==</span> <span style="color:#66d9ef">typeid</span>(Bird))            <span style="color:#75715e">// 判断对象类型
</span><span style="color:#75715e"></span>    {
        Bird <span style="color:#f92672">*</span>bird <span style="color:#f92672">=</span> <span style="color:#66d9ef">dynamic_cast</span><span style="color:#f92672">&lt;</span>Bird <span style="color:#f92672">*&gt;</span>(obj); <span style="color:#75715e">// 对象转化
</span><span style="color:#75715e"></span>        bird<span style="color:#f92672">-&gt;</span>foraging();
    }

    obj<span style="color:#f92672">-&gt;</span>land();
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
	Bird <span style="color:#f92672">*</span>b <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Bird();
	doSomething(b);
	<span style="color:#66d9ef">delete</span> b;
	b <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;
	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div>
</main>

  <footer>
  
<nav class="post-nav">
  <span class="nav-prev">&larr; <a href="/post/2021/12/30/cprimer04/">【转载】C Primer 之 new, delete</a></span>
  <span class="nav-next"><a href="/post/2022/01/14/effectivec-/">【转载】C&#43;&#43; 面试之 Effective C&#43;&#43;</a> &rarr;</span>
</nav>

<script type="text/javascript">
document.addEventListener('keyup', function(e) {
  if (e.target.nodeName.toUpperCase() != 'BODY') return;
  var url = false;
  if (e.which == 37) {  
    
    url = '\/post\/2021\/12\/30\/cprimer04\/';
    
  } else if (e.which == 39) {  
    
    url = '\/post\/2022\/01\/14\/effectivec-\/';
    
  }
  if (url) window.location = url;
});
</script>






<script src="https://utteranc.es/client.js"
repo="lzxqaq/site-comment"
issue-term="title"
theme="github-light"
crossorigin="anonymous"
async>
</script>








<script async src="/js/center-img.js"></script>

<script async src="/js/right-quote.js"></script>

<script async src="/js/external-link.js"></script>

<script async src="/js/alt-title.js"></script>



  
  <hr/>
  © <a href="/">Zexun Luo</a> 2020 - 2022
  
  </footer>
  </body>
</html>

