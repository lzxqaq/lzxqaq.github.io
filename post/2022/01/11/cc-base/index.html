<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <title>C/C&#43;&#43;基础 - Zexun Luo | 罗泽勋</title>
    <meta property="og:title" content="C/C&#43;&#43;基础 - Zexun Luo | 罗泽勋">
    
    <meta name="twitter:card" content="summary">

    
      
    

    
      
      <meta property="description" content="// 类 class A { private: const int a; // 常对象成员，只能在初始化列表赋值  public: // 构造函数  A() { }; A(int x) : a(x) { }; // 初始化列表  // const可用于对重载函数的区分  int getValue(); // 普通成员函数  int getValue() const; // 常成员函数，不得修改类中 &amp;hellip;">
      <meta property="og:description" content="// 类 class A { private: const int a; // 常对象成员，只能在初始化列表赋值  public: // 构造函数  A() { }; A(int x) : a(x) { }; // 初始化列表  // const可用于对重载函数的区分  int getValue(); // 普通成员函数  int getValue() const; // 常成员函数，不得修改类中 &amp;hellip;">
      
    

    
    

    

    
    
    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/fonts.css" />
    <script async src="/js/load-typekit.js"></script>
<link rel="stylesheet" href="/css/custom.css" />
<link href="https://cdn.bootcss.com/aplayer/1.10.1/APlayer.min.css" rel="stylesheet">
<script src="https://cdn.bootcss.com/aplayer/1.10.1/APlayer.min.js"></script>

  </head>

  
  <body class="post">
    <header class="masthead">
      

<h1><a href="/"><img src="/images/logo.png" alt="Zexun Luo" /></a></h1>



      <nav class="menu">
  <ul>
  
  
  <li><a href="/">主页</a></li>
  
  <li><a href="/about/">关于</a></li>
  
  <li><a href="/blog/">日志</a></li>
  
  <li><a href="/post/">编程</a></li>
  
  <li><a href="/series/">标签</a></li>
  
  <li><a href="/categories/">分类</a></li>
  
  <li><a href="/cv/">简历</a></li>
  
  <li><a href="/note/">抄录</a></li>
  
  </ul>
</nav>

    </header>

    <article class="main">
      <header class="title">
      
<h1>C/C&#43;&#43;基础</h1>


<h3>罗泽勋 / 
2022-01-11</h3>

<hr>


      </header>





<h3 id="一const">一、const</h3>
<h4 id="作用">作用：</h4>
<ul>
<li>修饰变量，说明该变量不可变;</li>
<li>修饰指针，分为指向常量的指针和指针常量；</li>
<li>常量引用，用于行参类型，即避免了拷贝，又避免了函数对值的修改；</li>
<li>修饰成员函数，说明该成员函数不能修改成员变量。</li>
</ul>
<h4 id="使用">使用</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++">
<span style="color:#75715e">// 类
</span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span>
{
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> a;                <span style="color:#75715e">// 常对象成员，只能在初始化列表赋值
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#75715e">// 构造函数
</span><span style="color:#75715e"></span>    A() { };
    A(<span style="color:#66d9ef">int</span> x) <span style="color:#f92672">:</span> a(x) { };        <span style="color:#75715e">// 初始化列表
</span><span style="color:#75715e"></span>
    <span style="color:#75715e">// const可用于对重载函数的区分
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">getValue</span>();             <span style="color:#75715e">// 普通成员函数
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">getValue</span>() <span style="color:#66d9ef">const</span>;       <span style="color:#75715e">// 常成员函数，不得修改类中的任何数据成员的值
</span><span style="color:#75715e"></span>};

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">function</span>()
{
    <span style="color:#75715e">// 对象
</span><span style="color:#75715e"></span>    A b;                        <span style="color:#75715e">// 普通对象，可以调用全部成员函数
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">const</span> A a;                  <span style="color:#75715e">// 常对象，只能调用常成员函数、更新常成员变量
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">const</span> A <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>a;            <span style="color:#75715e">// 常指针
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">const</span> A <span style="color:#f92672">&amp;</span>q <span style="color:#f92672">=</span> a;             <span style="color:#75715e">// 常引用
</span><span style="color:#75715e"></span>
    <span style="color:#75715e">// 指针
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">char</span> greeting[] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;Hello&#34;</span>;
    <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> p1 <span style="color:#f92672">=</span> greeting;                <span style="color:#75715e">// 指针变量，指向字符数组变量
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> p2 <span style="color:#f92672">=</span> greeting;          <span style="color:#75715e">// 指针变量，指向字符数组常量
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> <span style="color:#66d9ef">const</span> p3 <span style="color:#f92672">=</span> greeting;          <span style="color:#75715e">// 常指针，指向字符数组变量
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> <span style="color:#66d9ef">const</span> p4 <span style="color:#f92672">=</span> greeting;    <span style="color:#75715e">// 常指针，指向字符数组常量
</span><span style="color:#75715e"></span>}

<span style="color:#75715e">// 函数
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">function1</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> Var);           <span style="color:#75715e">// 传递过来的参数在函数内不可变
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">function2</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> Var);         <span style="color:#75715e">// 参数指针所指内容为常量
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">function3</span>(<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> <span style="color:#66d9ef">const</span> Var);         <span style="color:#75715e">// 参数指针为常指针
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">function4</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">&amp;</span> Var);          <span style="color:#75715e">// 引用参数在函数内为常量
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// 函数返回值
</span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">function5</span>();      <span style="color:#75715e">// 返回一个常数
</span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> <span style="color:#a6e22e">function6</span>();     <span style="color:#75715e">// 返回一个指向常量的指针变量，使用：const int *p = function6();
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">function7</span>();     <span style="color:#75715e">// 返回一个指向变量的常指针，使用：int* const p = function7();
</span><span style="color:#75715e"></span>
</code></pre></div><h3 id="static">static</h3>
<h4 id="作用-1">作用</h4>
<ul>
<li>修饰普通变量，修改变量的存储区域和生命周期，使变量存储在静态区，在 main 函数运行前就分配了空间，如果有初始值就用初始值初始化它，如果没有初始值，系统用默认值初始化它。</li>
<li>修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命名函数重名，可以将函数定为 static。</li>
<li>修饰成员变量，修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员。</li>
<li>修饰成员函数，使得成员函数不需要生成对象就可以访问该函数，但是在 static 函数内不能访问非静态成员。</li>
</ul>
<h3 id="this-指针">this 指针</h3>
<ul>
<li>this 指针是一个隐含于每一个非静态成员函数中的特殊指针。它指向正在被该成员函数操作的那个对象。</li>
<li>当对一个对象调用成员函数时，编译程序先将对象的地址赋给 this 指针，然后调用成员函数，每次成员函数存取数据成员时，由隐含使用 this 指针。</li>
<li>当一个成员函数被调用时，自动向它传递一个隐含的参数，该参数是一个指向这个成员函数所在的对象的指针。</li>
<li>this 指针被隐含地声明为: ClassName const this<code>，这意味着不能给 </code>this<code>指针赋值；在</code>ClassName<code>类的</code>const<code> 成员函数中，</code>this<code> 指针的类型为：</code>const ClassName const，这说明不能对 this 指针所指向的这种对象是不可修改的（即不能对这种对象的数据成员进行赋值操作）；</li>
<li>this 并不是一个常规变量，而是个右值，所以不能取得 this 的地址（不能 &amp;this）。</li>
<li>在以下场景中，经常需要显式引用 this 指针：
<ul>
<li>
<p>为实现对象的链式引用；</p>
</li>
<li>
<p>为避免对同一对象进行赋值操作；</p>
</li>
<li>
<p>在实现一些数据结构时，如 <code>list</code>。</p>
</li>
</ul>
</li>
</ul>
<h3 id="inline-内联函数">inline 内联函数</h3>
<h4 id="特征">特征</h4>
<ul>
<li>
<p>相当于把内联函数里面的内容写在调用内联函数处；</p>
</li>
<li>
<p>相当于不用执行进入函数的步骤，直接执行函数体；</p>
</li>
<li>
<p>相当于宏，却比宏多了类型检查，真正具有函数特性；</p>
</li>
<li>
<p>不能包含循环、递归、switch 等复杂操作；</p>
</li>
<li>
<p>在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数。</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++">
<span style="color:#75715e">// 声明1（加 inline，建议使用）
</span><span style="color:#75715e"></span><span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">functionName</span>(<span style="color:#66d9ef">int</span> first, <span style="color:#66d9ef">int</span> secend,...);

<span style="color:#75715e">// 声明2（不加 inline）
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">functionName</span>(<span style="color:#66d9ef">int</span> first, <span style="color:#66d9ef">int</span> secend,...);

<span style="color:#75715e">// 定义
</span><span style="color:#75715e"></span><span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">functionName</span>(<span style="color:#66d9ef">int</span> first, <span style="color:#66d9ef">int</span> secend,...) {<span style="color:#75715e">/****/</span>};

<span style="color:#75715e">// 类内定义，隐式内联
</span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span> {
    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">doA</span>() { <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>; }         <span style="color:#75715e">// 隐式内联
</span><span style="color:#75715e"></span>}

<span style="color:#75715e">// 类外定义，需要显式内联
</span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span> {
    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">doA</span>();
}
<span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">int</span> A<span style="color:#f92672">::</span>doA() { <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>; }   <span style="color:#75715e">// 需要显式内联
</span><span style="color:#75715e"></span>
</code></pre></div><h4 id="编译器对-inline-函数的处理步骤">编译器对 inline 函数的处理步骤</h4>
<ul>
<li>
<p>将 inline 函数体复制到 inline 函数调用点处；</p>
</li>
<li>
<p>为所用 inline 函数中的局部变量分配内存空间；</p>
</li>
<li>
<p>将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中；</p>
</li>
<li>
<p>如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 GOTO）。</p>
</li>
</ul>
<h4 id="优缺点">优缺点</h4>
<p>优点</p>
<ul>
<li>
<p>内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。</p>
</li>
<li>
<p>内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会。</p>
</li>
<li>
<p>在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能。</p>
</li>
<li>
<p>内联函数在运行时可调试，而宏定义不可以。</p>
</li>
</ul>
<h4 id="缺点">缺点</h4>
<ul>
<li>
<p>代码膨胀。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。</p>
</li>
<li>
<p>inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接。</p>
</li>
<li>
<p>是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。</p>
</li>
</ul>
<h4 id="虚函数virtual可以是内联函数inline吗">虚函数（virtual）可以是内联函数（inline）吗？</h4>
<blockquote>
<p>Are &ldquo;inline virtual&rdquo; member functions ever actually &ldquo;inlined&rdquo;?<br>
答案：http://www.cs.technion.ac.il/users/yechiel/c++-faq/inline-virtuals.html</p>
</blockquote>
<ul>
<li>
<p>虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。</p>
</li>
<li>
<p>内联是在编译器建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。</p>
</li>
<li>
<p>inline virtual 唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 Base::who()），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。</p>
</li>
</ul>
<h4 id="虚函数内联使用">虚函数内联使用</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;  </span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Base</span>
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> who()
    {
        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;I am Base</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
    }
    <span style="color:#66d9ef">virtual</span> <span style="color:#f92672">~</span>Base() {}
};
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Derived</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Base
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">void</span> who()  <span style="color:#75715e">// 不写inline时隐式内联
</span><span style="color:#75715e"></span>    {
        cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;I am Derived</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
    }
};

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
    <span style="color:#75715e">// 此处的虚函数 who()，是通过类（Base）的具体对象（b）来调用的，编译期间就能确定了，所以它可以是内联的，但最终是否内联取决于编译器。 
</span><span style="color:#75715e"></span>    Base b;
    b.who();

    <span style="color:#75715e">// 此处的虚函数是通过指针调用的，呈现多态性，需要在运行时期间才能确定，所以不能为内联。  
</span><span style="color:#75715e"></span>    Base <span style="color:#f92672">*</span>ptr <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Derived();
    ptr<span style="color:#f92672">-&gt;</span>who();

    <span style="color:#75715e">// 因为Base有虚析构函数（virtual ~Base() {}），所以 delete 时，会先调用派生类（Derived）析构函数，再调用基类（Base）析构函数，防止内存泄漏。
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">delete</span> ptr;
    ptr <span style="color:#f92672">=</span> <span style="color:#66d9ef">nullptr</span>;

    system(<span style="color:#e6db74">&#34;pause&#34;</span>);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
} 
</code></pre></div><h3 id="assert">assert()</h3>
<p>断言，是宏，而非函数。assert 宏的原型定义在 &lt;assert.h&gt;（C）、<cassert>（C++）中，其作用是如果它的条件返回错误，则终止程序执行。可以通过定义 NDEBUG 来关闭 assert，但是需要在源代码的开头，include &lt;assert.h&gt; 之前。</p>
<h4 id="使用-1">使用</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#75715e">#define NDEBUG          </span><span style="color:#75715e">// 加上这行，则 assert 不可用
</span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;assert.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
assert( p <span style="color:#f92672">!=</span> NULL );    <span style="color:#75715e">// assert 不可用
</span></code></pre></div><h3 id="sizeof">sizeof()</h3>
<ul>
<li>
<p>sizeof 对数组，得到整个数组所占空间大小。</p>
</li>
<li>
<p>sizeof 对指针，得到指针本身所占空间大小。</p>
</li>
</ul>
<h3 id="未完待续">未完待续……</h3>



  <footer>
  
<nav class="post-nav">
  <span class="nav-prev">&larr; <a href="/post/2021/12/30/cprimer04/">【转载】C Primer 之 new, delete</a></span>
  <span class="nav-next"></span>
</nav>

<script type="text/javascript">
document.addEventListener('keyup', function(e) {
  if (e.target.nodeName.toUpperCase() != 'BODY') return;
  var url = false;
  if (e.which == 37) {  
    
    url = '\/post\/2021\/12\/30\/cprimer04\/';
    
  } else if (e.which == 39) {  
    
  }
  if (url) window.location = url;
});
</script>






<script src="https://utteranc.es/client.js"
repo="lzxqaq/site-comment"
issue-term="title"
theme="github-light"
crossorigin="anonymous"
async>
</script>








<script async src="/js/fix-toc.js"></script>

<script async src="/js/center-img.js"></script>

<script async src="/js/right-quote.js"></script>

<script async src="/js/fix-footnote.js"></script>

<script async src="/js/math-code.js"></script>

<script async src="/js/external-link.js"></script>

<script async src="/js/alt-title.js"></script>

<script async src="/js/header-link.js"></script>



  
  
  <hr>
  <div class="copyright">© <a href="/">Zexun Luo</a> 2020 - 2022</div>
  
  </footer>
  </article>
  
<script async src="https://www.googletagmanager.com/gtag/js?id=G-KDTTBGMLCQ"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-KDTTBGMLCQ', { 'anonymize_ip': false });
}
</script>

  </body>
</html>

