<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>技术文章 on 罗泽勋</title>
    <link>/post/</link>
    <description>Recent content in 技术文章 on 罗泽勋</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Mon, 07 Mar 2022 12:22:40 +0800</lastBuildDate>
    <atom:link href="/post/" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>从 Java 到 Qt/C&#43;&#43; 的一些经验总结</title>
      <link>/post/2022/03/07/java2c-/</link>
      <pubDate>Mon, 07 Mar 2022 12:22:40 +0800</pubDate>
      <author>糸色先生</author>
      <guid>/post/2022/03/07/java2c-/</guid>
      <description>
        <![CDATA[
        <h3 id="cc-代码编译成可执行程序的过程">C/C++ 代码编译成可执行程序的过程</h3>
<ul>
<li>
<p>预处理</p>
<ul>
<li>进行宏定义展开、头文件展开、条件编译，不检查语法。</li>
<li>gcc -E demo1.c -o demo1.i</li>
</ul>
</li>
<li>
<p>编译</p>
<ul>
<li>检查语法，将预处理过的文件编译生成汇编文件</li>
<li>gcc -S demo2.c  -o demo2.s</li>
</ul>
</li>
<li>
<p>汇编</p>
<ul>
<li>将汇编文件生成目标文件（二进制代码文件，即.o 文件）</li>
<li>gcc -c demo3.c  -o demo3.o</li>
</ul>
</li>
<li>
<p>链接</p>
<ul>
<li>找到依赖的库文件，将目标文件链接为可执行程序。</li>
<li>gcc demo4.c -o demo4 -L./ -llib1</li>
<li>通过gcc编译器让 demo4 链接自己制作的 lib1 动态库，并把 demo4 编译成可执行程序。</li>
</ul>
</li>
</ul>
<h3 id="java-代码编译和执行的过程">Java 代码编译和执行的过程</h3>
<ul>
<li>源文件由编译器编译成字节码</li>
<li>字节码由 Java 虚拟机解释运行。因为 Java 程序既要编译同时也要经过 JVM 的解释运行，所以 Java 也被称为半解释语言。</li>
</ul>
<h3 id="静态和动态">静态和动态</h3>
<ul>
<li>静态：在编译（编译 + 链接）阶段</li>
<li>动态：在执行阶段</li>
</ul>
<pre tabindex="0"><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
int main() {
  int m, n;
  int *p, *q;
  scanf(&#34;%d%d&#34;, &amp;m, &amp;n);
  p = (int*)malloc(sizeof(int) * m);
  q = (int*)malloc(sizeof(int) * n);
  return 0;
}
</code></pre><blockquote>
<p>m、n、p、q 静态分配内存。局部变量，要占多大空间、往哪里放，在编译时就已经确定。
malloc 函数动态分配内存，在堆区分配内存，把地址赋值给 p、q。</p>
</blockquote>
<p>进一步：静态和动态 + static 关键字</p>
<pre tabindex="0"><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
void hehe() {
  int k=0;
  static int sum = 0;
  k++;
  sum++;
  printf(&#34;%d %d\n&#34;, k, sum);
}
int main() {
  int *p;
  p = (int*)malloc(sizeof(int));
  hehe();
  hehe();
  return 0;
}
</code></pre><blockquote>
<p>k、sum 静态分配内存。局部变量，它们要占多大空间、往哪里放，在编译时就已经确定。
static 和静态、动态分配内存没关系，static 指 sum 变量的创建和销毁不会随着 hehe() 函数的调用而一次次创建销毁。</p>
</blockquote>
<h3 id="c-语言的内存分区">C 语言的内存分区</h3>
<ul>
<li>栈（Stack）</li>
<li>堆（Heap）</li>
<li>全局/静态 常量</li>
<li>文本（代码）Text(Code)</li>
</ul>
<pre tabindex="0"><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
int total = 0;//全局变量-&gt;全局/静态区
void hehe() {
  static int he = 0;//静态局部变量，只创建一次，静态区
  he++;
  total++;
}
int main() {
  int k = 3;//局部变量-&gt;栈， 3-&gt;文本区
  char *str = &#34;Hello&#34;;//str-&gt;栈  &#34;Hello&#34;-&gt;常量区
  int *p = (int*)malloc(sizeof(int));//p-&gt;栈  malloc分配控件-&gt;堆
  hehe();//函数每次结束，栈空间都会释放，而静态区不会
  free(p);
  return 0;
}

//文本区-&gt;放这个文件编译后的二进制码
</code></pre><h3 id="动态库静态库">动态库、静态库</h3>
<ul>
<li>
<p>库是写好的现有的，成熟的，可以复用的代码。</p>
</li>
<li>
<p>linux：</p>
<ul>
<li>静态库：.a</li>
<li>动态库：.so</li>
</ul>
</li>
<li>
<p>window：</p>
<ul>
<li>静态库：.lib</li>
<li>动态库：.dll</li>
</ul>
</li>
</ul>
<ul>
<li>静态库：是因为在链接阶段，会将汇编生成的目标文件.o与引用到的库一起链接打包到可执行文件中。因此对应的链接方式称为静态链接。</li>
<li>动态库：在程序编译时并不会被连接到目标代码中，而是在程序运行是才被载入。不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例。</li>
</ul>
<p>静态库的特点：</p>
<ul>
<li>1、使用静态库的时候，会将静态库的信息直接编译到可执行文件中（在编译时期完成的）</li>
<li>2、优点:当静态库被删除，对可执行文件没有影响</li>
<li>3、缺点:浪费内存空间。如果静态库被修改，可执行程序要重新编译</li>
</ul>
<p>动态库的特点：</p>
<ul>
<li>加载器在加载动态库时，操作系统会先检查动态库是否因为其它程序已经将这个动态库信息加载到了内存中。如果没有加载到内存中，操作系统会将动态库载入内存，并将它的引用计数设置为1;如果已经加载到内存，仅将动态库的引用计数加1。</li>
</ul>
<h3 id="动态库与模板">动态库与模板</h3>
<ul>
<li>由于模板实例化是在编译时执行，如果在动态库中导出模板类(函数)，因为实际的调用代码是在外部exe中，不在动态库本身中，所以在编译生成动态库的时候是不会生成实例的，这样在编译外部exe的时候就会报链接错误。</li>
<li>只有将导出库里面的模板函数或者模板类实例化，才能将实例化后模板函数的地址信息和模板类实例化的地址信息保存在导出库中。</li>
</ul>
<pre tabindex="0"><code>//TemplateLib.h  使用动态库
#ifdef	TEST_DLL_EXPORTS
	#define	TEST_API	__declspec(dllexport)
#else
	#define TEST_API	__declspec(dllimport)
#endif
 
 
// 导出模板函数
template&lt;typename T1&gt;
TEST_API	void	fun1(T1);
 
template&lt;typename T1,typename T2&gt;
TEST_API	void	fun2(T1 , T2);
 
 
// 模板类
template&lt;typename T,int size&gt;
class TEST_API	CTest
{
public:
	CTest()		{};
	~CTest()	{};
	T*	GetDataBuff()	{	return m_data;}
private:
	T	m_data[size];
};
</code></pre><pre tabindex="0"><code>// TemplateLib.cpp : 定义 DLL 应用程序的导出函数。
 
#include &#34;stdafx.h&#34;
#include &#34;TemplateLib.h&#34;
 
// 1.利用重载来实例化不同类型的模板，代码量大不说，基本上是重复的代码
// 2.库的设计者不知道用户会传入什么类型，也就是说设计者不可能实例化每一种类型的模板。
TEST_API	void fun1(int var1)		{}
 
TEST_API	void fun1(char var1)		{}
 
template&lt;typename T1,typename T2&gt;
TEST_API	void fun2( T1 var1, T2 var2)	{}
 
 
// 这个名字空间不作为导出使用，唯一作用是用来例化函数模板和类模板.
namespace implement_template_private
{
 
	void	implement_template()
	{
		int		idata = 10;
		char	chr	= &#39;x&#39;;
		float	fdata = 20.f;
		UINT	undata= 9;
		char*	str	=	&#34;hello&#34;;
 
		// 这种方式的实例化，代码量比重载方式少许多，但需运行一次该模板函数
		// 也许在某些时候凭空运行这个函数是不合理的。
		fun2(idata,chr);				// int,char
		fun2(undata,str);				// UINT,char*
		fun2&lt;float,char*&gt;(fdata,str);		// float,char* 显示参数
 
		// 导出类的实例化。
		// 1.除了要实例化提供给用户使用的公有成员函数外，这里面还隐含的实例化了构造函数和析构函数.
		// 2.注意这里每一个模板的实例化都是唯一的。
		// 3.假如客户如果在项目中使用了CTest&lt;char,30&gt; impl_obj; 将会连接错误， 模板的参数列表必须完全匹配。
		// 4.假如该模板类非常大，功能非常多，那么实例化工作可以想象是不堪忍受的。
		// 5.库的设计者不知道用户会传入什么类型，也就是说设计者不可能实例化每一种类型的模板。
		CTest&lt;char,20&gt;	impl_obj;
		impl_obj.GetDataBuff();
 
 
		CTest&lt;int,5&gt;	impl_obj2;
		impl_obj.GetDataBuff();
 
	}
 
};
</code></pre><ul>
<li>总结：不建议在导出库中使用模板相关的技术，假如你能够确定用户在使用你设计的模板函数时，将传入哪些类型，设计者要将这些类型的模板一一实例化。</li>
<li>在动态库和静态库使用模板:https://blog.csdn.net/xiexievv/article/details/8500234</li>
</ul>
<h3 id="autoc-11">auto（C++ 11）</h3>
<p>其核心在于类型推导，也就是让编译器根据等号右边的表达式来决定auto实际代表的类型。C++的auto只涉及到编译期的行为而不是运行期。</p>
<ul>
<li>优点：
<ul>
<li>可以极大的缩短代码的长度。</li>
</ul>
</li>
<li>缺点：
<ul>
<li>可能会降低代码的可读性。</li>
<li>可能会引入额外的性能开销。</li>
</ul>
</li>
</ul>
<p>如：</p>
<pre tabindex="0"><code> MyBigDataType&amp; func();
 ...
 auto value = func();
</code></pre><p>因为 auto 会移除表达式类型的引用属性，那么此时以上最后一行的行为就是拷贝构造一MyBigData实例，相信这不是此函数的实现者希望的。</p>
<ul>
<li>注意：在引用类型、const 等类型上使用 auto 时要小心。</li>
</ul>
<h3 id="c-引用">C++ 引用</h3>
<p>参数传递：注意值传递和引用传递的区别。</p>
<pre tabindex="0"><code>#include &lt;iostream&gt;
using namespace std;

void fun(int &amp;k) {
  k = 2;
}
int main() {
  int a = 1;
  fun(a);
  cout &lt;&lt; a &lt;&lt; endl;
  return 0;
}
</code></pre><h3 id="新的-for-循环c-11">新的 for 循环（C++ 11）</h3>
<pre tabindex="0"><code>int arr[5] = {1, 2, 3, 4, 5};
for (int x : arr) {
  x += 100;
  cout &lt;&lt; x &lt;&lt; &#39; &#39;;
}
cout &lt;&lt; arr[0];
</code></pre><ul>
<li>arr 到 x 是值传递，可以用 int &amp;x，或者 auto &amp;</li>
</ul>
<h3 id="lambdac">lambda（C++）</h3>
<p>定义一个匿名函数，还可以捕获外部一定范围内的变量。</p>
<pre tabindex="0"><code>auto f1 = [](int a, int b) -&gt; int{return a + b; };

auto f2 = [](auto a, auto b) -&gt; auto{return a + b; };

//编译器就根据 return 语句自动推导出返回值类型。
auto f3 = [](auto a, auto b){return a + b; };

int c = 9;
//按值捕获 c 变量，同时不捕获其他变量。
auto f4 = [c](auto a, auto b){return a + b + c; };

//捕获外部作用域中所有变量（按值捕获）
auto f5 = [=](auto a, auto b){return a + b + c; };

cout &lt;&lt; f1(1, 2) &lt;&lt; endl;
</code></pre><h3 id="类型转换c">类型转换（C++）</h3>
<pre tabindex="0"><code>  int k;
  k = 3.14;//在 Java 中会报错，在 C/C++ 编译器中正常（k==3）。
</code></pre><ul>
<li>Java 对类型转换更严格。</li>
<li>C/C++ 编译器给了程序员太多自由：编译器认为，程序员可以这样写，程序员应该知道他在干什么，也应该为自己的行为负责。</li>
</ul>
<h3 id="指针引用java">指针？引用（Java）</h3>
<p>Java：基本数据类型（int、long等）、引用数据类型（数组、类、接口）。</p>
<pre tabindex="0"><code>Student zs = new Student();     //Java，引用
Student *pzs = new Student();   //c++，指针
</code></pre><ul>
<li>实质是一样的。</li>
<li>要注意 Java 中的值传递和引用传递问题，实质上 Java 还是值传递的，只不过对于引用数据类型时，值的内容是它的引用（指针）。</li>
</ul>
<h3 id="for-循环java">for 循环（Java）</h3>
<pre tabindex="0"><code>int[] arr = new int[10];

for (int temp : arr) {
    temp++;
}
</code></pre><pre tabindex="0"><code>for (Student s : ss) {
  s.changeSomething();
}
</code></pre><h3 id="lamdajava">lamda（Java）</h3>
<pre tabindex="0"><code>(parameters) -&gt; expression
或
(parameters) -&gt;{ statements; }
</code></pre><ul>
<li>Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）</li>
</ul>
<pre tabindex="0"><code>// 1. 不需要参数,返回值为 5  
() -&gt; 5  
  
// 2. 接收一个参数(数字类型),返回其2倍的值  
x -&gt; 2 * x  
  
// 3. 接受2个参数(数字),并返回他们的差值  
(x, y) -&gt; x – y  
  
// 4. 接收2个int型整数,返回他们的和  
(int x, int y) -&gt; x + y  
  
// 5. 接受一个 string 对象,并在控制台打印,不返回任何值(看起来像是返回void)  
(String s) -&gt; System.out.print(s)
</code></pre><h3 id="理解封装">理解封装</h3>
<ul>
<li>类：某一类东西</li>
<li>对象：某类东西的实例</li>
<li>“封”：数据 + 操作
<ul>
<li>成员：成员变量、成员函数</li>
<li>属性，方法（服务）</li>
</ul>
</li>
<li>“装”：访问控制
<ul>
<li>public/protected/private/&hellip;</li>
</ul>
</li>
</ul>
<h3 id="构造和析构c">构造和析构（C++）</h3>
<ul>
<li>构造函数、析构函数</li>
<li>初始化列表
<ul>
<li>在构造函数中用初始化列表的方式对成员变量进行初始化，效率会更高，因为只进行构造，少了一次赋值。</li>
<li>成员变量的初始化顺序与初始化列表中列出的变量的顺序无关，它只与成员变量在类中声明的顺序有关。</li>
</ul>
</li>
</ul>
<pre tabindex="0"><code>#include &lt;iostream&gt;
using namespace std;
class Note {
public:
  int nid;
  Note(int id) :nid(id) {}
};

class Student {
private:
  int sid;
  string name;
  Note nt;
public:
  Student(int sid, string name, int id) : sid(sid), name(name), nt(id) {//初始化列表，进行初始化构造
    //写在这里的只能是赋值
  }
}
</code></pre><h3 id="对象的复制c">对象的复制（C++）</h3>
<ul>
<li>注意浅拷贝、深拷贝。</li>
<li>默认生成的赋值函数、拷贝构造函数都是浅拷贝（值拷贝），成员变量中有指针变量时，需要自己重写（深拷贝）。</li>
</ul>
<h3 id="java-类-与c不同">Java 类-与C++不同</h3>
<ul>
<li>没有析构</li>
<li>不支持默认参数</li>
<li>显示构造</li>
</ul>
<h3 id="对象的复制java">对象的复制（Java）</h3>
<pre tabindex="0"><code>Array a = new Array();
Array b = a;
</code></pre><p>其实是引用的复制。</p>
<pre tabindex="0"><code>Array b = new Array(a);
</code></pre><p>对象的复制（返回新对象的引用）</p>
<h3 id="理解继承">理解“继承”</h3>
<ul>
<li>目的：代码复用</li>
<li>代码复用：
<ul>
<li>组合（has-a）：窗口、按钮、文本框</li>
<li>继承（is-a）：人（id、姓名、性别）、学生（id、姓名、性别、学号）、教师（id、姓名、性别、教师号）</li>
</ul>
</li>
</ul>
<h3 id="c-的继承和java-的继承区别">C++ 的继承和Java 的继承区别</h3>
<ul>
<li>C++ 可以多继承</li>
<li>Java 单继承</li>
</ul>
<h3 id="多态-需求是什么">多态-需求是什么</h3>
<p>多态：指为不同数据类型的实体提供统一的接口。</p>
<p>是否有需要使用基类指针（引用）指向（引向）派生类对象？</p>
<pre tabindex="0"><code>class People {
public:
  void say() {
    cout &lt;&lt; &#34;I &#39;m a person!&#34; &lt;&lt; endl;
  }
};

class Student : public People {
public:
  void say() {
    cout &lt;&lt; &#34;I&#39;m a student!&#34; &lt;&lt; endl;
    }
};

int main() {
  People *zs = new Student();
  zs-&gt;say();
  return 0;
}
</code></pre><ul>
<li>这不是真需求，应该用 Student 指针，甚至是 Student 对象。</li>
</ul>
<pre tabindex="0"><code>class People {
public:
  void say() {}
};
class Student : public People {
public:
  void say() {}
};
class Teacher : public People {
public:
  void say() {}
};
void func(People *zs) { zs-&gt;say(); }
int main() {
  Student zs;
  Teacher ls;
  func(&amp;zs);
  func(&amp;ls);
  return 0;
}
</code></pre><ul>
<li>拿不同的派生类的对象干同一件事</li>
<li>func() 和具体的派生类型没关系。</li>
<li>用相同形式的东西（指针或引用），在具体调用的时候去执行不同对象或实体的行为</li>
<li>动态联编：编译时不确定，运行时才确定。</li>
</ul>
<h3 id="qt-隐式共享">Qt 隐式共享</h3>
<ul>
<li>Qt 中的许多 C++ 类使用隐式数据共享来最大化资源使用并最小化复制。</li>
<li>当作为参数传递时，隐式共享类既安全又高效，因为只有一个指向数据的指针被传递，并且只有当函数写入数据时才会复制数据，即copy-on-write。</li>
</ul>
<pre tabindex="0"><code>QPixmap p1, p2;
p1.load(&#34;image.bmp&#34;);
p2 = p1;                        // p1 and p2 share data

QPainter paint;
paint.begin(&amp;p2);               // cuts p2 loose from p1
paint.drawText(0,50, &#34;Hi&#34;);
paint.end();
</code></pre><ul>
<li>
<p>隐式共享对象的对象分配（使用 operator=()）是使用浅拷贝实现的。</p>
</li>
<li>
<p>隐式共享大多发生在幕后；程序员很少需要担心它。但是，Qt 的容器迭代器与 STL 的容器迭代器具有不同的行为。</p>
</li>
<li>
<p>Qt doc：https://doc.qt.io/qt-6/implicit-sharing.html</p>
</li>
</ul>
<h3 id="qlist">QList</h3>
<ul>
<li>
<p>QList 类是提供动态数组的模板类。该类中的所有函数都是可重入的(可以由多个线程同时调用)。另外两个常用的顺序容器 QStack 和 QQueue 继承自 Qlist。</p>
</li>
<li>
<p>对于大多数应用程序， QList 是最好使用的类型。 它提供了非常快速的追加。 如果你真的需要一个链表，使用 std::list。</p>
</li>
</ul>
<h3 id="qt-元对象系统">Qt 元对象系统</h3>
<p>Qt 的元对象系统为对象间通信、运行时类型信息和动态属性系统提供了信号和槽机制。</p>
<ul>
<li>
<p>QObject 类为可以利用元对象系统的对象提供基类 。</p>
</li>
<li>
<p>Q_OBJECT 宏用于启用元对象功能，例如动态属性、信号和插槽。</p>
</li>
<li>
<p>元对象编译器(moc)为每个 QObject 子类提供实现元对象功能所需的代码。</p>
</li>
</ul>
<ul>
<li>这 moc工具读取 C++ 源文件。 类声明 Q_OBJECT ，它会生成另一个 C++ 源文件，其中包含每个这些类的元对象代码。 这个生成的源文件是 #include 到类的源文件中，或者更常见的是，编译并链接到类的实现中。</li>
</ul>
<ul>
<li>
<p>Qt 对象应该被视为身份，而不是值。 因此，QObject和所有子类都禁用了拷贝构造函数和赋值操作符。</p>
</li>
<li>
<p>为了方便内存管理，QObject 的构造函数中会传入一个 Parent 父对象指针，当父对象析构的时候，这个子对象列表中的所有对象都会被析构，当析构子对象的时候，会自动从父对象的子对象列表中删除。</p>
</li>
<li>
<p>这种机制在 GUI 程序开发过程中是相当实用的。有一个很明显的现象就是我们会在窗口中new很多控件，但是却没有delete，因为在父控件销毁时这些子控件以及布局管理器对象会一并销毁。</p>
</li>
<li>
<p>C++中规定了析构顺序应该按照其创建顺序的相反过程。</p>
</li>
<li>
<p>先创建父对象再创建子类对象，并且在创建子对象时就指定父对象；</p>
</li>
</ul>
<h3 id="qt-跨平台和-java-跨平台">Qt 跨平台和 Java 跨平台</h3>
<ul>
<li>
<p>Qt 允许我们编写独立于平台的代码，其中相同的代码库可以在不同平台上编译和部署，而无需任何更改（理想状态）。</p>
</li>
<li>
<p>Java 运行在虚拟机上。</p>
</li>
<li>
<p>Java：在虚拟机上 一次编译到处运行，但虚拟机是平台各异的，执行代码格式统一。</p>
</li>
<li>
<p>Qt 程序的运行是建立在 Qt 框架上的，一次编码到处编译，但框架是平台各异的，编程接口统一。</p>
</li>
<li>
<p>java也为此付出了运行效率的代价。因为一般程序直接通过操作系统由 CPU 执行，而 java 语言需要先通过 JVM 再映射到操作系统里，最后由 CPU 执行，执行过程多了一步。</p>
</li>
<li>
<p>Qt平台并没有使用类似 JVM 的明显抽象层（但是原理类似，它底层封装了针对不同平台的类库，API之类的，只是这些都被上层做了封装，对开发者来说操作各种平台的接口都是一样的），因此在框架开发过程中处理各种平台问题的复杂性要超过java。</p>
</li>
</ul>

        
        ]]>
      </description>
    </item>
    
    
    
    <item>
      <title>Marp：使用 Markdown 创建漂亮的幻灯片</title>
      <link>/post/2022/02/28/marp%E4%BD%BF%E7%94%A8-markdown-%E5%88%9B%E5%BB%BA%E6%BC%82%E4%BA%AE%E7%9A%84%E5%B9%BB%E7%81%AF%E7%89%87/</link>
      <pubDate>Mon, 28 Feb 2022 14:17:47 +0800</pubDate>
      <author>糸色先生</author>
      <guid>/post/2022/02/28/marp%E4%BD%BF%E7%94%A8-markdown-%E5%88%9B%E5%BB%BA%E6%BC%82%E4%BA%AE%E7%9A%84%E5%B9%BB%E7%81%AF%E7%89%87/</guid>
      <description>
        <![CDATA[
        <h3 id="简介">简介</h3>
<p>Marp（Markdown Presentation Ecosystem）为创建漂亮的幻灯片提供了直观的体验。 你只需要专注于在 Markdown 文档中写你的故事。</p>
<h3 id="安装使用">安装使用</h3>
<p>Marp 有两个集成应用，<a href="https://github.com/marp-team/marp-vscode">Marp for VS Code</a> 和 <a href="https://github.com/marp-team/marp-cli">Marp CLI</a>。Marp for VS Code 是一个 VS Code 插件扩展，允许您在 VS Code 中编辑 Markdown 和预览幻灯片，Marp CLI 是一个命令行工具，允许您使用简单的 CLI 界面转换 Markdown。对普通用户而言，Marp for VS Code 已经足够了，本文只对其进行介绍。</p>
<p>安装：在 VS Code 左侧插件栏中搜索安装 Marp for VS Code 插件，同时你也可以选择再安装一个 Markdown All in One 插件，它有助于书写 Markdown。</p>
<p>使用：</p>
<p>方式1：新建或打开 md 格式文件，在开头写入：</p>
<pre tabindex="0"><code>---
marp: true
---
</code></pre><p>然后，在后面书写 Markdown 格式内容。</p>
<p>方式2：通过 VS Code 菜单：File -&gt; New File&hellip; -&gt; Marp Markdown，生成新文件。</p>
<h3 id="官方示例">官方示例</h3>
<p>源码：</p>
<pre tabindex="0"><code>---
marp: true
theme: gaia
_class: lead
paginate: true
backgroundColor: #fff
backgroundImage: url(&#39;https://marp.app/assets/hero-background.svg&#39;)
---

![bg left:40% 80%](https://marp.app/assets/marp.svg)

# **Marp**

Markdown Presentation Ecosystem

https://marp.app/

---

# How to write slides

Split pages by horizontal ruler (`---`). It&#39;s very simple! 😆

```markdown
# Slide 1

foobar

---

# Slide 2

foobar
</code></pre><p>效果图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2022-2-28/marp.png" alt="img"></p>

        
        ]]>
      </description>
    </item>
    
    
    
    <item>
      <title>由 hpp 头文件引发 C&#43;&#43; 编译的思考</title>
      <link>/post/2021/12/26/hpp/</link>
      <pubDate>Sun, 26 Dec 2021 12:55:54 +0800</pubDate>
      <author>糸色先生</author>
      <guid>/post/2021/12/26/hpp/</guid>
      <description>
        <![CDATA[
        <p>前一阵子，我注意到一位项目组新成员喜欢使用 hpp 头文件的方式来写，他解释说很多开源库都是以这样的方式实现，还问我 hpp 头文件和 h + cpp 方式的区别。这个问题很麻烦，解释起来可能需要理一遍 C++ 基础，对此，我劝告他：从本质来说 hpp 是将声明和实现放在一个文件，而 h + cpp 是将声明和实现分开在两个文件，采用 hpp 这种方式也是可以的，但是必须要清楚它的局限。我本来是希望他去学习 C++ 基础，但没想到从这里就埋下了一个坑，导致这篇文章的产生&hellip;..</p>
<p>很快，遇到第一个问题，redefined identifier。我解释说，这是重复 include hpp 文件引入实现，会引发这个重定义的问题。使用 #ifndef 可以防止头文件被重复包含和引入。</p>
<p>过了一阵，又遇到新的问题。我过去一看，循环依赖。第一个坑出现了。A 依赖 B，B 又 依赖 A，如果用 hpp 实现的话，那A、B 都互相包含对方，无尽循环……所以这种情况只能老老实实用回 h + cpp 的方式了，A 依赖 B，就在 A 的头文件中前向声明 B，然后在源文件中 include B，B 也如此操作。</p>
<p>就这样过了很久很久，突然有一天，我发现有很多库都需要重新编译，奇怪的是这些库不应该有改动的。一看是依赖的一个底层动态库发生变化，再看，是这个库里的一个 hpp 文件发生变化。大坑，我最开始的时候提醒过的。 那个库本身就有别的坑，实际上它更应该是静态库，但因为客观原因，它暂时还是一个动态库。然后就这样，一个 hpp 文件被嵌入这个底层动态库对外开放的接口里面。它一改动，所有依赖这个库的库都需要重新编译，还真是“牵一发而动全身”啊。</p>
<h3 id="补充">补充</h3>
<p>一、#include 指令</p>
<pre tabindex="0"><code>#include &#34;test.hpp&#34;
</code></pre><p>C++ 会使用一个预处理器，在进行主编译之前对源文件进行处理，它会在编译程序时自动运行。上面所示 #include &ldquo;test.hpp&rdquo;，该编译指令导致预处理器将 test.hpp 文件的内容添加到程序中。实际上，test.hpp 文件的内容将取代程序中的代码行 #include &ldquo;test.hpp&rdquo;。原始文件没有被修改，而是将源码和 test.hpp 文件组合成一个复合文件，编译的下一个阶段将使用该文件。</p>
<p>二、头文件名</p>
<table>
<thead>
<tr>
<th>头文件类型</th>
<th>约定</th>
<th>示例</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>C++ 旧式风格</td>
<td>以 .h 结尾</td>
<td>iostream.h</td>
<td>C++ 程序可以使用</td>
</tr>
<tr>
<td>C 旧式风格</td>
<td>以 .h 结尾</td>
<td>math.h</td>
<td>C、C++ 程序可以使用</td>
</tr>
<tr>
<td>C++ 新式风格</td>
<td>没有扩展名</td>
<td>iostream</td>
<td>C++ 程序可以使用，可以使用 namespace std</td>
</tr>
<tr>
<td>转换后的 C</td>
<td>加上前缀 c，没有扩展名</td>
<td>cmath</td>
<td>C++ 程序可以使用，可以使用不是 C 的特性，如 namespace std</td>
</tr>
</tbody>
</table>
<p>由于 C 使用不同的文件扩展名来表示不同文件类型，因此用一些特殊的扩展名（如 .hpp 或 .hxx）表示 C++ 头文件是有道理的，ANSI/ISO 委员会也这样认为。问题在于究竟使用哪种扩展名，因此最终他们一致同意不使用任何扩展名。:)</p>

        
        ]]>
      </description>
    </item>
    
    
    
    <item>
      <title>设计模式概述</title>
      <link>/post/2021/12/26/design/</link>
      <pubDate>Sun, 26 Dec 2021 10:10:12 +0800</pubDate>
      <author>糸色先生</author>
      <guid>/post/2021/12/26/design/</guid>
      <description>
        <![CDATA[
        <p>在软件开发生命周期的每一个阶段都存在着一些被认同的模式。</p>
<p>在软件模式中，设计模式是研究最为深入的分支，设计模式用于在特定的调剂爱你下为一些重复出现的软件设计问题提供合理的、有效的解决方案。</p>
<p>一般定义：设计模式（Design Pattern)是一套被反复使用、多数人知晓的、进过分类编目的代码设计经验的总结，使用设计模式是为了可重用代码、让代码更容易被他人理解并且保证代码可靠性。</p>
<p>狭义的设计模式是指 GoF 在《设计模式：可复用面向对象软件的基础》一书中所介绍的23种经典设计模式。不过设计模式并不仅仅只有这23种，越来越多的新模式不断诞生并得以应用。</p>
<p>23 种设计模式根据用途可分为创建型、结构型和行为型三种。其中创建型模式主要用于描述如何创建对象，结构型模式主要用于描述如何实现类或对象的组合，行为型模式主要用于描述类或对象怎样交互以及怎样分配职责。</p>
<p>值得注意的是，简单工厂模式没有在 23 种设计模式里面，但一般都会对它进行说明。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2021-12-26/design1.png" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2021-12-26/design2.png" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2021-12-26/design2.png" alt="img"></p>

        
        ]]>
      </description>
    </item>
    
    
    
    <item>
      <title>栈和队列</title>
      <link>/post/2021/12/26/stackqueue/</link>
      <pubDate>Sun, 26 Dec 2021 09:14:03 +0800</pubDate>
      <author>糸色先生</author>
      <guid>/post/2021/12/26/stackqueue/</guid>
      <description>
        <![CDATA[
        <p>从数据结构的角度看，栈和队列是操作受限的线性表，栈和队列的数据元素具有单一的前驱和后继的线性关系。</p>
<h3 id="栈">栈</h3>
<p>定义：栈是限定仅在表尾进行插入和删除操作的线性表，允许插入和删除的一端称为栈顶，另一端成为栈底。</p>
<p>栈中元素除了具有线性关系外，还具有<strong>后进先出</strong>的特性。</p>
<p>需要注意的是，栈只是对线性表的插入和删除操作的位置进行了限制，并没有限定插入和删除操作进行的时间，也就是说，出栈可以随时进行，只要某个元素位于栈顶就可以出栈。</p>
<h4 id="栈的顺序存储结构顺序栈">栈的顺序存储结构——顺序栈</h4>
<p>顺序栈的本质是顺序表的简化，唯一需要确定的是用数组的哪一端表示栈底。通常把数组下标为0的一端称为栈底，同时附设指针 top 指示栈顶元素在数组中的位置。</p>
<p>设存储栈元素的数组长度为 StackSize,则栈空时栈顶指针 top=-1；栈满时栈顶指针 top=StackSize-1。入栈时，栈顶指针 top 加 1；出栈时，栈顶指针 top 减 1。</p>
<h4 id="栈的链接存储结构链栈">栈的链接存储结构——链栈</h4>
<p>通常链栈用单链表表示。因为只能在栈顶执行插入和删除操作，显然以单链表的头部作为栈顶是最方便的。</p>
<h3 id="队列">队列</h3>
<p>定义：队列是只允许在一端进行插入操作，在另一端进行删除操作的线性表，允许插入（也称入队、进队）的一端成为队尾，允许删除（也称出队）的一端成为队头。</p>
<p>队中元素除了具有线性关系外，还具有<strong>先进先出</strong>的特性。</p>
<h4 id="队列的顺序存储结构循环队列">队列的顺序存储结构——循环队列</h4>
<p>队列是特殊的线性表，从这个出发点来考虑队列的顺序存储问题。</p>
<p>将存储队列的数组看成头尾相接的循环结构，即允许队列直接从数组中下标最大的位置延续到下标最小的位置，这通过取模操作很容易实现。队列的这种头尾相接的顺序存储结构称为循环队列。</p>
<p>要注意的是，在循环队列中还有一个很重要的问题：队空和队满的判定问题。</p>

        
        ]]>
      </description>
    </item>
    
    
    
    <item>
      <title>线性表</title>
      <link>/post/2021/12/16/linearlist/</link>
      <pubDate>Thu, 16 Dec 2021 12:43:02 +0800</pubDate>
      <author>糸色先生</author>
      <guid>/post/2021/12/16/linearlist/</guid>
      <description>
        <![CDATA[
        <p>线性表是一种最基本、最简单的数据结构，数据元素之间仅具有单一的前驱和后继关系。</p>
<h3 id="一线性表的逻辑结构">一、线性表的逻辑结构</h3>
<p>定义：线性表简称表，是 n(n&gt;=0) 个具有<strong>相同类型</strong>的数据元素的<strong>有限序列</strong>。</p>
<h3 id="二线性表的顺序存储结构顺序表">二、线性表的顺序存储结构——顺序表</h3>
<p>顺序表是用一段<strong>地址连续</strong>的存储单元依次存储线性表的元素。通常使用数组实现。</p>
<p>用数组存储顺序表，意味着要分配固定长度的数组空间，因此，必须确定数组的长度。</p>
<p>顺序表中数据元素的地址是其序号的线性函数，只要确定了存储顺序表的起始地址（即基地址），计算任意一个元素的存储地址的时间是相等的，具有这一特点的存储结构称为<strong>随机存储结构</strong>。</p>
<p>顺序表具有以下缺点：</p>
<ul>
<li>插入和删除操作需要移动大量元素。在顺序表上做插入和删除操作，等概率情况下，平均要移动表中一半的元素。</li>
<li>表的容量难以确定。由于数组的长度必须事先确定，因为此，当线性表的长度变化较大时，难以确定合适的存储规模。</li>
<li>造成存储空间的“碎片”。数组要求占用连续的存储空间，即使存储单元数超过所需的数目，如果不连续也不能使用，造成存储空间的“碎片”现象。</li>
</ul>
<p>造成上述顺序表的缺点的根本原因是静态存储分配，为了克服顺序表的缺点，可以采用动态存储分配连存储线性表，也就是采用链接存储结构。</p>
<h3 id="三线性表的链接存储结构及实现">三、线性表的链接存储结构及实现</h3>
<h4 id="单链表">单链表</h4>
<p>单链表是用一组任意的存储单元存放线性表的元素，这组存储单元可以连续也可以不连续，甚至可以零散分布在内存中的任意位置。每个存储单元在存储数据元素的同时，还必须存储其后继元素所在的地址信息，这个地址信息称为指针。这两部分组成数据元素的存储映射，称为节点。</p>
<p>单链表只有一个指针域（next）。</p>
<p>头节点：无论单链表是否为空，头指针始终指向头节点，因此空表和非空表的处理统一了。</p>
<h4 id="循环链表">循环链表</h4>
<p>在单链表中，如果将终端节点的指针域由空指针改为指向头节点，形成一个环，这种头尾相接的单链表称为循环链表。</p>
<p>从循环链表中任一节点出发，可以扫描到其他节点，增加了链表操作的灵活性。</p>
<p>但由于循环链表没有明显的尾端，要格外注意循环条件。通常判断用作循环变量的工作指针是否等于头一个制定指针（头指针或尾指针）。</p>
<h4 id="双链表">双链表</h4>
<p>如果希望快速确定表中任一节点的前驱节点，可以在单链表的每个节点中再设置一个指向其前驱节点的指针域，这样就形成了双链表。</p>
<h3 id="顺序表和链表的比较">顺序表和链表的比较</h3>
<h4 id="时间性能比较">时间性能比较</h4>
<p>按位置随机访问某个元素，顺序表更快一些，时间性能为 O(1)；相比之下链表需要从头开始遍历扫描，所需要的平均时间为 O(n)。</p>
<p>在链表进行插入和删除操作不需要移动元素，在给出指向某个位置的指针后，进行插入和删除操作所需的时间仅为 O(1)；在顺序表中进行插入和删除操作需要移动表长一半的元素，平均时间为 O(n)。</p>
<p>一般规律，如果线性表需要频繁查找却很少进行插入和删除，或其操作和“数据元素在线性表中的位置密切相关时，宜采用顺序表作为存储结构；如果线性表需要频繁进行插入和删除操作，则宜采用链表作为存储结构。</p>
<h4 id="空间性能比较">空间性能比较</h4>
<p>作为一般规律，当线性表中元素个数变化较大或未知时，最好采用链表实现；如果事先知道线性表的大致长度，采用顺序表的空间效率会更高。</p>

        
        ]]>
      </description>
    </item>
    
    
    
    <item>
      <title>C&#43;&#43; 基础总结</title>
      <link>/post/2021/12/15/cppbase/</link>
      <pubDate>Wed, 15 Dec 2021 12:35:27 +0800</pubDate>
      <author>糸色先生</author>
      <guid>/post/2021/12/15/cppbase/</guid>
      <description>
        <![CDATA[
        <h3 id="一语法基础">一、语法基础</h3>
<ul>
<li>指针和引用的概念</li>
<li>指针与内存关系</li>
<li>程序编译过程</li>
<li>static、const、#define的用法和区别</li>
<li>C和C++区别</li>
<li>内存模型</li>
<li>内存中的栈和堆分配</li>
</ul>
<h3 id="二面对对象基础">二、面对对象基础</h3>
<ul>
<li>
<p>面向对象理解</p>
</li>
<li>
<p>析构函数</p>
</li>
<li>
<p>构造函数</p>
</li>
<li>
<p>拷贝构造</p>
</li>
<li>
<p>多态</p>
</li>
<li>
<p>纯虚函数和虚函数</p>
</li>
<li>
<p>虚函数实现机制</p>
</li>
<li>
<p>虚函数表</p>
</li>
<li>
<p>访问限定符 public、private、protected</p>
</li>
<li>
<p>继承原理、虚继承、菱形继承</p>
</li>
<li>
<p>静态绑定和动态绑定</p>
</li>
<li>
<p>new/delete和malloc/free</p>
</li>
<li>
<p>重载、重写和隐藏</p>
</li>
</ul>
<h3 id="三语法进阶">三、语法进阶</h3>
<ul>
<li>智能指针</li>
<li>左值、右值引用和move语义</li>
<li>类型转换方式</li>
<li>常用的设计模式</li>
<li>线程安全的单例模式</li>
<li>内存溢出和内存泄漏</li>
<li>C++11新特性</li>
<li>静态链接库和动态链接库</li>
</ul>
<h3 id="四stl-标准模板库">四、STL 标准模板库</h3>
<ul>
<li>迭代器、空间配置器理解</li>
<li>常用容器特点、用法以及底层实现vector、list、deque、set、map、unorderedmap</li>
</ul>

        
        ]]>
      </description>
    </item>
    
    
    
    <item>
      <title>修改菜单栏和文章创作</title>
      <link>/post/2021/11/18/%E4%BF%AE%E6%94%B9%E8%8F%9C%E5%8D%95%E6%A0%8F%E5%92%8C%E6%96%87%E7%AB%A0%E5%88%9B%E4%BD%9C/</link>
      <pubDate>Thu, 18 Nov 2021 18:36:33 +0800</pubDate>
      <author>糸色先生</author>
      <guid>/post/2021/11/18/%E4%BF%AE%E6%94%B9%E8%8F%9C%E5%8D%95%E6%A0%8F%E5%92%8C%E6%96%87%E7%AB%A0%E5%88%9B%E4%BD%9C/</guid>
      <description>
        <![CDATA[
        <h3 id="前情提要">前情提要</h3>
<p>完成前面的工作后，我们的网站是下图这样的，非常符合极简之美。不过空荡荡的网站不是我们想要的，接下来我们就开始最核心的部分：修改网站内容。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2021-11-18/0.png" alt="img"></p>
<h3 id="一准备文本编辑工具">一、准备文本编辑工具</h3>
<p>（1）下载文本编辑工具。创作当然离不开文本的编辑，那么一款高效好用的文本编辑工具就非常重要了。这里我强烈推荐一个常用的工具 Visual Studio Code，它可以多文件管理。点击 <a href="https://code.visualstudio.com/Download">https://code.visualstudio.com/Download</a> 可以直达官网下载。接下来的讲述会使用到 VSCode，如果你选择其他文本编辑器，也无妨，找到对应的文件修改即可。</p>
<p>（2）用 VSCode 打开 blog 文件夹。打开 VSCode 后，点击左上角文件菜单，然后点击打开文件夹，选择 D:/hugo/site/blog 文件夹。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2021-11-18/1.png" alt="img"></p>
<p>（3）我们需要关注 content 文件夹、public 文件夹和 config.yaml 文件即可。content 存放网站的所有内容，我们平时写文章会在里面创建；public 存放网站的源代码，我们使用 hugo 命令时它会自动生成，我们需要将它上传到 Github ；config.yaml 是网站的配置文件，我们网站的基本信息都会在里面配置。</p>
<h3 id="二网站预览">二、网站预览</h3>
<p>用命令窗口进入网站 blog 根目录，执行 <code>hugo server</code>。打开浏览器，访问 localhost:1313。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2021-11-17/11.png" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2021-11-17/12.png" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2021-11-17/10.png" alt="img"></p>
<h3 id="三创建菜单栏">三、创建菜单栏</h3>
<p>可以看到我们的网站现在有五个菜单，如果你前面在网站配置把菜单改成中文的话，那么将是[主页]、[关于]、[分类]、[标签]、[订阅]。[主页]不用多说了，[分类]、[标签]、[订阅]是自动管理的，如果不需要的话可以在网站目录的 config.yaml 里删掉，[关于]现在点击的话，是访问不了的，因为我们还没有创建对应的文件夹或文件。</p>
<p>（1）打开 themes/hugo-ivy/exampleSite 文件夹，这是 hugo-ivy 主题作者提供的示例网站。复制其中的 content 文件夹下的所有文件和文件夹，放到我们网站根目录下的 content文件夹下面。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2021-11-18/2.png" alt="img"></p>
<p>（2）修改 config.yaml 文件，添加文章和记录两个菜单。对应的文件夹是 post 和 note。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2021-11-18/3.png" alt="img"></p>
<p>（3）这样，再回到浏览器上看。因为我们把示例的文章也复制过来了，所以网站已经有文章显示了。而我们添加的[文章]和[记录]文章也完成了。如果你需要添加其他菜单，可以参考现有的：在 content 文件夹下新建文件夹，然后在 config.yaml 文件中添加修改。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2021-11-18/4.png" alt="img"></p>
<h3 id="四新建文章">四、新建文章</h3>
<p>我们可以复制 content/post 或者 content/note 下的文件，然后修改里面的标题、作者、日期、分类、标签等等，因为我们使用 hugo server 预览网站，所以可以在浏览器上 localhost:1313 实时查看修改后的效果。不过更常见的做法是通过命令的方式来创建，下面演示在[文章]菜单下创建一篇文章。</p>
<p>（1）同样，在重新打开一个 cmd 命令窗口，进入网站根目录（blog)。和之前的做法一样这里就不贴图片了。</p>
<p>(2)执行 <code>hugo new post/2021-11-18.md</code> 命令，post 是存放的目标文件夹，2021-11-18.md 是将要生成的文件，文件名可以随意，注意不要使用中文。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2021-11-18/5.png" alt="img"></p>
<p>(3)在 VSCode 里面修改文件内容。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2021-11-18/6.png" alt="img"></p>
<h3 id="五推送到-github-平台">五、推送到 Github 平台</h3>
<p>（1）在 cmd 窗口，在网站根目录（blog）下先执行 <code>hugo</code> 生成网站源代码到 public 目录，然后执行 <code>cd pulic</code> 进入 public 目录。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2021-11-18/7.png" alt="img"></p>
<p>（2）分别执行 <code>git add .</code> 和 <code>git commit -m &quot;update&quot;</code> 和 <code>git push</code>完成上传。</p>
<h3 id="六完成">六、完成</h3>
<p>上传成功后，等一小会就可以通过 “你的 github 用户名.github.io” 域名访问你的网站啦。到这里，最基本的流程已经走完了，现在可以开始自行探索了！当然，还有很多内容会在后续补充，本系列教程仍存在不足的地方，如果你遇到问题可以联系我。祝愉快~</p>

        
        ]]>
      </description>
    </item>
    
    
    
    <item>
      <title>搭建</title>
      <link>/post/2021/11/17/%E6%90%AD%E5%BB%BA/</link>
      <pubDate>Wed, 17 Nov 2021 19:38:06 +0800</pubDate>
      <author>糸色先生</author>
      <guid>/post/2021/11/17/%E6%90%AD%E5%BB%BA/</guid>
      <description>
        <![CDATA[
        <h3 id="一在本地创建网站">一、在本地创建网站</h3>
<p>（1）使用 Hugo 建立网站。打开命令窗口，进入 D:\hugo\site 目录（便捷方法：在文件资源管理器中进入相应目录，单击地址栏右边空白地方，在最左边输入 <code>cmd </code> 加空格，回车。这样打开命令窗口的同时，进入了相应的目录），执行命令 <code>hugo new site blog</code> ，如出现 Congratulations! 提示则成功。（此时可在文件资源管理器中查看生成的文件，blog 是任意取的一个文件夹名字，但为了方便教程工作，请统一）</p>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2021-11-17/1.png" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2021-11-17/2.png" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2021-11-17/3.png" alt="img"></p>
<h3 id="二下载主题模板以-hugo-ivy-为例">二、下载主题模板（以 hugo-ivy ）为例</h3>
<p>（1）接着回到刚刚的命令窗口，输入执行 <code>cd blog\themes</code> 进入 themes 目录。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2021-11-17/4.png" alt="img"></p>
<p>（2）下载主题模板（ hugo-ivy ）。接上述步骤，在命令窗口中 执行 <code>git clone https://github.com/yihui/hugo-ivy.git</code> 来下载 hugo.386 主题。下载完成后，blog/themes 文件夹里面就可以看到下载好的主题了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2021-11-17/6.png" alt="img"></p>
<h3 id="三修改网站配置">三、修改网站配置</h3>
<p>将 themes/hugo-ivy/exampleSite 文件夹中的 config.yaml 文件复制到文件夹 blog 下，并删除原有的 config.toml 。用记事本或者其他文本编辑工具，根据需要修改相应的内容。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2021-11-17/7.png" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2021-11-17/8.png" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2021-11-17/9.png" alt="img"></p>
<h3 id="四网站本地预览">四、网站本地预览</h3>
<p>用命令窗口进入 blog 目录，先执行 <code>hugo</code> 生成网页文件，再执行 <code>hugo server</code> 开启预览。打开浏览器，访问 localhost:1313 。（注意，这个命令窗口需要保持到你不需要预览网站的时候，届时可以用两次 Ctrl + c 停止，或者直接关闭窗口）</p>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2021-11-17/11.png" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2021-11-17/12.png" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2021-11-17/10.png" alt="img"></p>
<h3 id="五将网站推送到-github-平台">五、将网站推送到 Github 平台</h3>
<p>（2）打开命令窗口，进入 blog\public 目录，分别执行</p>
<pre tabindex="0"><code>git init 
git add .
git commit -m &#34;first commit&#34;
git remote add origin https://github.com/你的Github名字/你的Github名字.github.io.git
git push --set-upstream origin master
</code></pre><p>输入 Github 账号名，密码，完成上传。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2021-11-17/13.png" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2021-11-17/14.png" alt="img"></p>
<p>（3）测试。访问 github.com 网站，在你之前创建的仓库可以看到刚刚上传的文件。访问提供的 <code>https://你的Github账户名.github.io</code> 访问你的网站，如果没有之前预览的网页，可以等待一会再刷新。</p>

        
        ]]>
      </description>
    </item>
    
    
    
    <item>
      <title>准备工作</title>
      <link>/post/2021/11/15/%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/</link>
      <pubDate>Mon, 15 Nov 2021 12:26:45 +0800</pubDate>
      <author>糸色先生</author>
      <guid>/post/2021/11/15/%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/</guid>
      <description>
        <![CDATA[
        <h3 id="一注册-github-帐号">一、注册 Github 帐号</h3>
<p>（1）.前往 <a href="https://github.com/">github.com</a> 注册一个帐号。（注意：慎重考虑注册的用户名，如果你不购买别的域名，这个用户名将是你网站域名的一部分）</p>
<p>（2）在 Github 中创建一个名为 你的仓库名字.github.io 的仓库。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2021-11-15/-2.png" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2021-11-15/-1.png" alt="img"></p>
<h3 id="二安装-git">二、安装 Git</h3>
<p>（1）下载安装。前往 <a href="https://git-scm.com/download/win" target="_blank">这里</a> ，点击下载 Git-**-64-bit.exe。然后安装，不懂的话一直 next 。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2021-11-15/0.png" alt="img"></p>
<p>（2）配置。在 win10 搜索 cmd ，打开命令提示符，输入 <code>git config --global user.email &quot;你注册Github所用的邮箱&quot;</code> 回车执行，再输入 <code>git config --global user.name &quot;你的昵称&quot;</code> 回车执行。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2021-11-15/1.png" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2021-11-15/2.png" alt="img"></p>
<p>注意：这种方式打开命令窗口会默认进入 C 盘的用户目录。如果需要切换到其他目录，比如我们后面所用的 <code>D:/hugo/site/blog</code> 目录，则需要先执行 <code>D:</code> 切换盘符，然后执行 <code>cd hugo/site/blog</code>，其中 <code>cd</code> 就是进入目录的命令，后面是需要进入的文件夹，有时候我们需要返回上一层目录，则可以执行 <code>cd ..</code> 来完成。后面会有相关操作。</p>
<h3 id="三安装-hugo">三、安装 Hugo</h3>
<p>（1）首先在 D 盘创建一个新文件夹 hugo，然后在里面创建 bin 和 site 两个文件夹。bin 将用来放 Hugo 的可执行文件，site 将用来放你的网站的源代码。</p>
<p>（2）前往<a href="https://github.com/spf13/hugo/releases">https://github.com/spf13/hugo/releases</a>，找到并下载 hugo_<em><em>Windows-64bit.zip。解压，如果是一个 hugo</em></em>_windows_amd64.exe 文件，将它改名为 hugo.exe。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2021-11-15/3.png" alt="img"></p>
<p>（3）将这个 hugo.exe 文件移动到刚刚创建的 bin 文件夹里。</p>
<p>（4）配置环境变量。在 win10 搜索环境变量，进去找到系统变量中的 Path，双击编辑，在弹出的界面点新建，然后将 <code>D:\hugo\bin</code> 复制进去，最后连续确定。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2021-11-15/4.png" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2021-11-15/5.png" alt="img"></p>
<p>（5）验证。重新打开命令窗口（关闭上一步骤使用的），输入执行 <code>hugo help</code>，如果你能看到下图所示的 Hugo 帮助文档，就证明配置成功，否则重新执行上一步骤。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2021-11-15/6.png" alt="img"></p>

        
        ]]>
      </description>
    </item>
    
    
    
    <item>
      <title>基础概念</title>
      <link>/post/2021/11/14/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</link>
      <pubDate>Sun, 14 Nov 2021 20:57:13 +0800</pubDate>
      <author>糸色先生</author>
      <guid>/post/2021/11/14/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</guid>
      <description>
        <![CDATA[
        <p>教程开始前，先来介绍一下最终的成果，以便确认是否符合你的需求。本篇教程以 Hugo 和 Github Pages 为基础，创建一个静态的网站。这个过程仅需要一台联网的电脑，不需要其他花费（注意：如果你想自定义域名，则需要自行购买域名，后面会有相关介绍）。下文提到的概念理论只需要有一个模糊的认识就足够了，不需要理解透彻，因为在后续文章中会具体介绍其用法，届时就会有更直观的认识了。</p>
<p>Hugo 和 Github Pages 稍后会介绍，我们先来了解什么是静态网站。静态网站是由静态网页文件（也就是HTML文件)组成，它不需要服务器运行，也不需要数据库。我们将组成网站的这些网页文件上传到服务器上，别人就可以在互联网上通过这台服务器的地址或域名（例如 <a href="https://www.lzxqaq.com">www.lzxqaq.com</a>)访问这些网页文件，这就是静态网站的大致原理。</p>
<p>不过，这里所说的服务器并非我们日常所用的电脑，因为我们日常所用的电脑都是在局域网里，是不能让整个互联网的人都能访问到的。所以一般都要用所谓的云服务器，例如阿里云服务器、华为云服务器等等。不过现在有一些平台提供了免费的站点服务，我们就不需要购买昂贵的服务器了。例如本教程中使用的 Github Pages 服务，我们可以将网站托管到 Github 平台上，让平台帮我们把网站跑起来并在互联网上可以访问。</p>
<p>这里提到的 Github 是一个代码托管平台，也是全世界最大的开源社区。在本教程中，我们只需要知道，它是帮我们帮网站跑起来的就行了。我们在自己的电脑上创建网站，然后将这些网页文件上传到 Github 平台，而 Github 会帮我们运行网站，这样网站就可以访问了。另外，我们还需要在 Github 下载网站主题（这会在后续介绍）。如何将我们的网站文件上传到 Github 或者从 Github 下载东西呢？这里我们会用到 Git 这个工具。</p>
<p>那么如何建立网站呢？需要去学习网页技术吗？答案是不需要，我们将使用静态网站生成器来完成这项繁琐的工作。在本教程里，我们会使用 Hugo 这款出色的静态网站生成器。我们只需要挑选别人制作好的博客模板，根据某种规则去生成网站就好了（这里说的规则可以简单理解成约定好的文本格式，我们在约定好的文本格式下写文字，网站生成器会将这些文字翻译成网页文件）。所以我们只需要关注网站的文本，也就是展示的文章那些。（理想状态下，就类似我们写微博、发说说，编辑好文本发送出去就可以了）</p>
<p>简单来说，我们的工作流程是：在自己的电脑上，用一个静态网站生成器工具生成网页文件，然后将网站文件上传到某个平台上，这样别人就可以访问我们的网站了。如果修改网站（比如添加文章），也是重复上述步骤：重新生成网页文件，重新上传。</p>
<p>后续文章我会细述搭建网站的具体步骤，尽可能考虑新手建站的情况。如果你在这过程中遇到问题，欢迎在评论中指出或着与我联系。</p>

        
        ]]>
      </description>
    </item>
    
    
    
    <item>
      <title>开篇</title>
      <link>/post/2021/11/14/%E5%BC%80%E7%AF%87/</link>
      <pubDate>Sun, 14 Nov 2021 20:57:13 +0800</pubDate>
      <author>糸色先生</author>
      <guid>/post/2021/11/14/%E5%BC%80%E7%AF%87/</guid>
      <description>
        <![CDATA[
        <p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2021-11-14/0.jpg" alt="img"></p>
<p>回顾过去，我刚接触互联网时，还是 2G 时代，那时各类论坛博客和聊天室正蓬勃发展。这种跨越时空的交流方式让我感到非常新奇，看着屏幕吐出文字的时候，就感觉打开了一个新世界的大门。通过一根根网线，就可以将世界连起来，人们可以在其中感知世界并畅所欲言。有趣的是，当时还是小学生的我，已经在一款网页文字游戏中建立队伍，和几十位素不相识的伙伴一起在游戏江湖里打拼了……</p>
<p>不过随着QQ、微信和微博等便捷交流平台的发展，传统博客和论坛逐渐淡出人们的视线。然而人们在选择这些便捷的平台时，也被其束缚着。特别是在内容分发推荐和主流媒体导流的当下，人们获取信息的的渠道看似变多了，但是这过程已经从主动变成了被动，我不认为这是什么好事。</p>
<p>“I web, therefore I am a spiderman.”，这是 hugo-ivy 主题作者谢益辉在他 <a href="https://bookdown.org/yihui/blogdown/">blogdown</a>一书提到的个人网站的作用，我深以为然。在当下，个人网站用来交流分享、内容创造或者记录人生仍是一个非常棒的选择。</p>
<p>值得高兴的是，个人网站搭建技术从未停下发展的脚步，现在搭建一个个人网站已经是一件很容易的事了～如果你拥有了它，那么你便在这嘈杂的网络世界有了一方净土。这需要感谢开源，感谢前人的努力。因为他们的努力，让搭建网站这类技术活变得更简单，让这世界充满自由与奉献的星光。</p>
<p>但即便如此，为了更自由、更多元化的需求，搭建和管理网站仍需要足够的耐心，特别是对于不了解这方面的人。为了前人的付出让更多的人知晓，让自由的表达有更多选择，我在这里开启系列教程，将搭建个人网站的步骤一一讲述。虽然有很多人做过类似的工作，但我还是希望我能做得更详细、更简单，为有需要的朋友省下一番功夫。注意，本系列教程默认读者为零基础的读者，所以会涉及很多基础概念，有一定基础的读者建议去查找其他教程。同时，因为技术会不停地发展，本教程的一些信息可能已经过时，如果你发现任何问题或者有改进建议，请在评论（需要注册 Github 帐号）指出或者联系我，我会及时更新。在此，感谢支持。</p>
<blockquote>
<p>当你面对一个陌生领域的挑战时，最困难的往往是开始动手这个决定。</p>
</blockquote>

        
        ]]>
      </description>
    </item>
    
    
    
    <item>
      <title>Qt单元测试基础笔记</title>
      <link>/post/2021/10/13/qt%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Wed, 13 Oct 2021 07:01:19 +0800</pubDate>
      <author>糸色先生</author>
      <guid>/post/2021/10/13/qt%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/</guid>
      <description>
        <![CDATA[
        <h3 id="一构建">一、构建</h3>
<p>构建时添加 <code>QT += testlib</code> 。</p>
<h3 id="二测试类">二、测试类</h3>
<p>测试类必须从 QObject 继承，头文件 <code>include &lt;QTest&gt;</code> ，并将测试函数声明 <code>private slot</code></p>
<h3 id="三qverifycondition-宏">三、QVERIFY(condition) 宏</h3>
<p>检查 condition（条件）是否为真。如果为真，则继续执行。如果没有，则测试日志中会记录失败，并且不会进一步执行测试。</p>
<p>如果需要在测试失败报告中加入附加信息，可以使用 QVERIFY2(condition, message)。</p>
<p>如果需要测试日志有更详细的输出，可以使用 QCOMPARE(actual, expected)。</p>
<h3 id="四qcompareactual-expected宏">四、QCOMPARE(actual, expected)宏</h3>
<p>使用相等运算符将 actual （实际值）与 expected （预期值）进行比较。如果实际和预期匹配，则继续执行。如果不是，则在测试日志中记录失败，并且测试函数返回而不尝试任何后续检查。</p>
<p>如果比较失败，QCOMPARE() 会尝试输出值的内容，因此可以从测试日志中看到比较失败的原因。</p>
<p>对于你自己的类，你可以使用 <code>QTest::toString ()</code> 来格式化输出到测试日志中的值。具体可参考 <a href="https://doc.qt.io/qt-6/qtest.html#QCOMPARE">Qt 文档</a>;</p>
<h3 id="五可执行文件">五、可执行文件</h3>
<p>如果需要将测试用例成为独立的可执行文件，需要添加以下两行：</p>
<pre tabindex="0"><code>QTEST_MAIN(YourClassName)
#include &#34;yourfilename.moc&#34;
</code></pre>
        
        ]]>
      </description>
    </item>
    
    
    
    <item>
      <title>开发指南-未完待续</title>
      <link>/post/2021/07/16/%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97-%E6%9C%AA%E5%AE%8C%E5%BE%85%E7%BB%AD/</link>
      <pubDate>Fri, 16 Jul 2021 14:24:34 +0800</pubDate>
      <author>糸色先生</author>
      <guid>/post/2021/07/16/%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97-%E6%9C%AA%E5%AE%8C%E5%BE%85%E7%BB%AD/</guid>
      <description>
        <![CDATA[
        <p>提高质量和生产率是软件工程要解决的核心问题。</p>
<p>软件开发：正确性、健壮性、可靠性、效率、易用性、可读性（可理解性）、可扩展性、可复用性、兼容性、可移植性等。</p>
<p>只记录实际目前为止比较困惑的。</p>
<h3 id="头文件的结构">头文件的结构</h3>
<p>1.为了防止头文件被重复引用，应当用 ifndef/define/endif 结构产生预处理块。</p>
<p>2.用 #include&lt;filename.h&gt;格式来引用非标准库的头文件（编译器将会从标准库目录开始搜索；用 #include&lt;Îy &ldquo;filename.h&rdquo; 格式来引用非标准库的头文件（编译器将从用户的工作目录开始搜索）。（注：一般将 &lt;&gt; 格式的放在前， &ldquo;&ldquo;格式的放在后，为了统一风格）</p>
<p>3.头文件只存放“声明”而不存放“定义”。（C++中，类的成员函数可以在声明的同时被定义，并且自动成为内联函数。但这样做会造成风格不一致，弊大于利！</p>
<p>4.不提倡使用全局变量，尽量不要在头文件中出现 extern int value 这类声明。</p>
<h3 id="头文件作用">头文件作用：</h3>
<ul>
<li>
<p>（1）通过头文件来调用库功能。在很多场合，源代码不便（或不准）向用户公布，只要向用户提供头文件和二进制的库即可。用户只需要按照头文件中的借口声明来调用库的功能，而不必关心接口怎么实现的。编译器会从库中提取相应的代码。</p>
</li>
<li>
<p>（2）头文件能加强类型安全检查。如果某个接口被实现或被使用时，其方式与头文件中的声明不一致，编译器就会指出错误，这一简单的规则能大大减轻程序员调试、改错的负担。</p>
</li>
</ul>
<h3 id="目录结构">目录结构</h3>
<p>如果一个软件的头文件数目比较多（如超过十个），通常应将头文件和定义文件分别保存于不同的目录，以便于维护。</p>
<p>例如可将头文件保存于 include 目录，将定义文件保存于 source 目录（可以是多级目录）。</p>
<p>如果某些头文件是私有的，它不会被用户的程序直接饮用，则没有必要公开其“声明”，可以把这些私有的头文件和定义文件存放于同一个目录。</p>
<h3 id="空行">空行</h3>
<p>1.类声明之后、函数定义结束之后要加空行。</p>
<p>2.在一个函数体内，逻辑上密切相关的语句之间不加空行，其他地方应加空行分割。</p>
<h3 id="代码行">代码行</h3>
<p>1.一行代码只做一件事情，如只定义一个变量，或只写一条语句。</p>
<p>2.if、for、while、do 等语句自占一行，执行语句不得紧跟其后。不论执行语句有多少都要加{}。这样可以防止书写失误。（注：也为了统一风格）</p>
<p>3.尽可能在定义变量的同时初始化该变量（就近原则）。（注：这样可以减少被野指针折磨的痛苦，强烈建议）</p>
<h3 id="代码行内的空格">代码行内的空格</h3>
<p>1.关键字之后要留一个空格。像 if、for、while 等关键字之后应留一个空格再跟左括号 &lsquo;(&rsquo;，以突出关键字。</p>
<p>2.函数名之后不要留空格，紧跟左括号&rsquo;(&rsquo;，以与关键字区别。</p>
<p>3.&rsquo;(&lsquo;向后紧跟，&rsquo;)&rsquo;、‘，’、‘；’向前紧跟，紧跟处不留空格。</p>
<p>4.&rsquo;,&lsquo;之后要留空格，如果&rsquo;;&lsquo;不是一行的结束符号，其后要留空格，如for(initialization; condition; update)。</p>
<p>5.【建议】对于表达式比较长的 for 语句和 if 语句，为了紧凑起见可以适当地去掉一些空格。（注：如果真的长到影响阅读，可以考虑）</p>
<h3 id="对齐">对齐</h3>
<p>1.‘{{’h和‘}}’应独占一行并且位于同一列，同时与引用它们的语句左对齐。</p>
<h3 id="长行拆分">长行拆分</h3>
<p>1.代码行最大长度应控制在 70 至 80 个字符以内。</p>
<p>2.【强烈】长表达式要在低优先级操作符处拆分成新行，操作符放在新行之首。</p>

        
        ]]>
      </description>
    </item>
    
    
    
    <item>
      <title>vim 操作备忘</title>
      <link>/post/2021/07/10/vim-%E6%93%8D%E4%BD%9C%E5%A4%87%E5%BF%98/</link>
      <pubDate>Sat, 10 Jul 2021 10:35:46 +0800</pubDate>
      
      <guid>/post/2021/07/10/vim-%E6%93%8D%E4%BD%9C%E5%A4%87%E5%BF%98/</guid>
      <description>
        <![CDATA[
        <h3 id="一存活">一、存活</h3>
<table>
<thead>
<tr>
<th style="text-align:left">操作</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">i</td>
<td style="text-align:left">Insert 模式，按 ESC 回到 Normal 模式。</td>
</tr>
<tr>
<td style="text-align:left">x</td>
<td style="text-align:left">删除当前光标所在的一个字符。</td>
</tr>
<tr>
<td style="text-align:left">:wq</td>
<td style="text-align:left">保存退出</td>
</tr>
<tr>
<td style="text-align:left">dd</td>
<td style="text-align:left">删除当前行，并存到剪切板</td>
</tr>
<tr>
<td style="text-align:left">p</td>
<td style="text-align:left">粘贴剪切板</td>
</tr>
<tr>
<td style="text-align:left">hjkl</td>
<td style="text-align:left">左下上右</td>
</tr>
<tr>
<td style="text-align:left">:help <command></td>
<td style="text-align:left">显示相关命令的帮助</td>
</tr>
</tbody>
</table>
<h3 id="二感觉良好">二、感觉良好</h3>
<p>1.各种插入模式</p>
<table>
<thead>
<tr>
<th style="text-align:left">操作</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">a</td>
<td style="text-align:left">在光标后插入</td>
</tr>
<tr>
<td style="text-align:left">o</td>
<td style="text-align:left">在当前行后插入一个新行</td>
</tr>
<tr>
<td style="text-align:left">O</td>
<td style="text-align:left">在当前行前插入一个新行</td>
</tr>
<tr>
<td style="text-align:left">cw</td>
<td style="text-align:left">替换从光标所在位置到一个单词结尾的字符</td>
</tr>
</tbody>
</table>
<p>2.简单的光标移动</p>
<table>
<thead>
<tr>
<th style="text-align:left">操作</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">0</td>
<td style="text-align:left">数字零，到行头</td>
</tr>
<tr>
<td style="text-align:left">^</td>
<td style="text-align:left">到本行第一个不是 blank 字符的位置（blank 字符就是空格、tab、换行、回车等）</td>
</tr>
<tr>
<td style="text-align:left">$</td>
<td style="text-align:left">到本行行尾</td>
</tr>
<tr>
<td style="text-align:left">g_</td>
<td style="text-align:left">到本行最后一个不是 blank 字符的位置</td>
</tr>
<tr>
<td style="text-align:left">/pattern</td>
<td style="text-align:left">搜索 pattern 的字符串（多个匹配时，按 n 到下一个）</td>
</tr>
</tbody>
</table>
<p>3.拷贝/粘贴</p>
<table>
<thead>
<tr>
<th style="text-align:left">操作</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">p</td>
<td style="text-align:left">粘贴</td>
</tr>
<tr>
<td style="text-align:left">yy</td>
<td style="text-align:left">拷贝当前行</td>
</tr>
</tbody>
</table>
<p>4.撤销反撤销</p>
<table>
<thead>
<tr>
<th style="text-align:left">操作</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">u</td>
<td style="text-align:left">撤销</td>
</tr>
<tr>
<td style="text-align:left">ctrl-r</td>
<td style="text-align:left">反撤销</td>
</tr>
</tbody>
</table>
<p>5.打开/保存/退出/改变文件（Buffer)</p>
<table>
<thead>
<tr>
<th style="text-align:left">操作</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">:e &lt;path/to/file&gt;</td>
<td style="text-align:left">打开一个文件</td>
</tr>
<tr>
<td style="text-align:left">:w</td>
<td style="text-align:left">保存</td>
</tr>
<tr>
<td style="text-align:left">:saveas &lt;path/to/file&gt;</td>
<td style="text-align:left">另存为</td>
</tr>
<tr>
<td style="text-align:left">:x, ZZ 或 :wq</td>
<td style="text-align:left">保存并退出(:x仅在需要时保存)</td>
</tr>
<tr>
<td style="text-align:left">:q!</td>
<td style="text-align:left">退出不保存</td>
</tr>
<tr>
<td style="text-align:left">:qa!</td>
<td style="text-align:left">强行退出所有正在编辑的文件</td>
</tr>
<tr>
<td style="text-align:left">:n， :bn</td>
<td style="text-align:left">下一个文件</td>
</tr>
<tr>
<td style="text-align:left">:bp</td>
<td style="text-align:left">上一个文件</td>
</tr>
</tbody>
</table>
<h3 id="三更好更强更快">三、更好、更强、更快</h3>
<h3 id="未完待续">未完待续</h3>

        
        ]]>
      </description>
    </item>
    
    
    
    <item>
      <title>从零开始搭建个人网站——小白篇</title>
      <link>/post/2021/06/01/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99%E5%B0%8F%E7%99%BD%E7%AF%87/</link>
      <pubDate>Tue, 01 Jun 2021 06:16:32 +0800</pubDate>
      <author>糸色先生</author>
      <guid>/post/2021/06/01/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99%E5%B0%8F%E7%99%BD%E7%AF%87/</guid>
      <description>
        <![CDATA[
        <h3 id="前言">前言</h3>
<p>小白篇和前面<a href="../2021-2-18-2/">正经篇</a>的区别是，懒人篇专门针对基础更浅（或者更懒的）朋友而设计，在这里不会新建一个网站，而是下载我预先准备好的<a href="https://gitee.com/lzxqaq/demosite.git">示例网站</a>，在这个示例上面做扩展。这样也是为了避免新手成功创建网站时，面对空荡荡的网站不知所措的尴尬。</p>
<h3 id="准备工作与前篇一致">准备工作（与前篇一致）</h3>
<p>1.注册 Github 帐号。前往 <a href="https://github.com/" target="_blank">github.com</a> 注册一个 Github 帐号。（友情提示：认真考虑注册时的用户名，它将是你网站网址的一部分）</p>
<p>补充：Github 是一个代码托管平台（远程仓库），你可以将网站的源代码放在上面，Github Pages 是一个免费的静态网站服务，你将网站的源文件放在上面，它会提供一个链接，使互联网上的人都能访问你的网站。</p>
<p>2.准备Git。</p>
<p>（1）下载安装。前往 <a href="https://git-scm.com/download/win" target="_blank">这里</a> ，点击下载 Git-**-64-bit.exe。然后安装，不懂的话一直 next 。</p>
<p>（2）配置。在 win10 搜索 cmd ，打开命令提示符，输入 <code>git config --global user.email &quot;你注册Github所用的邮箱&quot;</code> 回车执行，再输入 <code>git config --global user.name &quot;你的昵称&quot;</code> 回车执行。</p>
<p>3.安装 Hugo。（官方教程可看<a href="https://www.gohugo.org/doc/tutorials/installing-on-windows/" target="_blank">这里</a>)</p>
<p>（1）首先在 D 盘创建一个新文件夹 Hugo，然后在里面创建 bin 和 sites两个文件夹。bin 将用来放 Hugo 的可执行文件，sites 将用来放你的网站的源代码。</p>
<p>（2）前往<a href="https://github.com/spf13/hugo/releases" target="_blank">这里</a>，找到并下载 hugo_<em><em>Windows-64bit.zip。解压，如果是一个 hugo</em></em>_windows_amd64.exe 文件，将它改名为 hugo.exe。</p>
<p>（3）将这个 hugo.exe 文件移动到刚刚创建的 bin 文件夹里。</p>
<p>（4）配置环境变量。方法1:在 win10 搜索 cmd，右键<strong>以管理员身份打开</strong>命令提示符，将 <code>setx &quot;Path&quot; &quot;%PATH%;D:\Hugo\bin&quot; /m </code>复制粘贴上去，回车（输入命令后需回车执行，后文不再赘述）。 方法2：在 win10 搜索环境变量，进去找到系统变量中的 Path，-&gt;编辑-&gt;新建，然后将 <code>D:\Hugo\bin</code> 复制进去，确定。</p>
<p>（5）验证。重新打开命令提示符（关闭上一步骤使用的），输入执行 <code>hugo help</code>，如果你能看到 hugo 的帮助文档，就验证成功，否则检查上述步骤是否出错。</p>
<h3 id="开始">开始</h3>
<p>1.建立博客网站</p>
<p>（1）下载示例网站。打开命令提示符，执行 <code>D:</code> 切换 D 盘，然后执行 <code>cd D:\Hugo\sites</code> 进入 D:\Hugo\sites 目录（便捷方法：在文件资源管理器中进入相应目录，单击地址栏右边空白地方，在文本最左输入 <code>cmd </code> 加空格，回车），执行命令 <code>git clone https://gitee.com/lzxqaq/demosite.git</code> ，如最后出现 <code>** 100% ** 完成</code> 则成功。（此时可在文件资源管理器中查看下载的文件夹 <code>demosite</code>）</p>
<p>（2）预览。紧接上一步，在命令提示符中执行 <code>cd demosite</code> 进入 demosite 目录，先执行 <code>hugo</code> ，再执行 <code>hugo server</code>。打开浏览器，输入网址访问 localhost:1313。</p>
<p>2.将网站展示文件存放到 Github 远程仓库。</p>
<p>（1）在 Github 中创建一个名为 你的仓库名字.github.io 的仓库，在设置中检查 Github Pages。</p>
<p>（2）打开命令提示符，进入 demosite\public 目录，分别执行</p>
<pre tabindex="0"><code>git init 
git add .
git commit -m &#34;first commit&#34;
git remote add origin https://github.com/你的Github名字/你的Github名字.github.io.git
git push --set-upstream origin master
</code></pre><p>输入账号名，密码，完成上传。</p>
<p>（3）测试。访问 github.com 网站，在你之前创建的仓库可以看到刚刚上传的文件。随后检查 Github Pages 设置，打开网址 <code>https://你的Github账户名.github.io</code> 访问你的网站，如果没有之前预览的网页，可以等待一会再刷新。</p>
<p>3.自定义域名（可选、需要一定的时间）</p>
<p>（1）购买域名。在华为云、阿里云等服务商购买域名。注意：国内购买域名需要实名认证。</p>
<p>（2）配置。访问 github.com 网站，进入你的仓库，在 setting 中找到 Github Pages，在 Custom domain 输入框中输入你的域名，保存。</p>
<p>（3）测试。访问你的域名。</p>

        
        ]]>
      </description>
    </item>
    
    
    
    <item>
      <title>【规约】 C&#43;&#43; 编程篇</title>
      <link>/post/2021/05/28/%E8%A7%84%E7%BA%A6-c-%E7%BC%96%E7%A8%8B%E7%AF%87/</link>
      <pubDate>Fri, 28 May 2021 11:46:44 +0800</pubDate>
      
      <guid>/post/2021/05/28/%E8%A7%84%E7%BA%A6-c-%E7%BC%96%E7%A8%8B%E7%AF%87/</guid>
      <description>
        <![CDATA[
        <h3 id="前言">前言</h3>
<p>“码出高效，码出质量”。本文整理了比较常见的 C++ 编程规范，主要来源于华为《软件编程规范总则》。</p>
<h3 id="一排版">（一）排版</h3>
<p>1.程序块要采用缩进风格编写，缩进的空格数位 4 个。对齐只用空格键，不适用tab键。<br>
2.相对独立的程序块之间、变量说明之后必须加空行。<br>
3.较长的语句（&gt;80 字符）要分成多行书写，长表达式要在低优先级操作符划分新行，操作符放在新行之首。<br>
4.if、for、do、while、case、switch、default 等语句自占一行，且执行语句部分无论多少都要加括号 {}。</p>
<h3 id="二注释">（二）注释</h3>
<p>1.一般情况下，源程序有效注释量必须在 20% 以上。<br>
2.说明性文件（如头文件 .h 文件、.inc 文件、.def 文件等）头部应进行注释，注释必须列出：版权说明、版本号、生成日期、作者、内容、功能、与其他头文件关系、修改日志等，头文件注释中还应有函数功能简要说明。<br>
3.源文件头部应进行注释，列出：版权说明、版本号、生成日期、作者、模块目的/功能、主要函数及其功能、修改日志等。<br>
4.函数头部应进行注释，列出：函数的目的/功能、输入参数、输出参数、返回值、调用关系（函数、表）等。<br>
5.边写代码边注释，修改代码同时修改响应的注释。不再有用的注释 要删除。<br>
6.注释格式尽量统一，建议使用“/<em>…………</em>/”。<br>
7.注释应考虑程序易读性，建议使用中文。</p>
<h3 id="三标识符命名">（三）标识符命名</h3>
<p>1.命名规范必须与所使用的系统风格保持一致，并在同一项目中统一，比如采用 UNIX 的全小写加下划线风格或大小写混排的方式，不要将两种方式混合使用。用作特殊标识如标识成员变量或全局变量的 m_ 和 g_，其后加上大小写混排的方式是允许的。<br>
示例：Add_User 不允许，add_user、AddUser、m_AddUser允许。</p>
<p>2.用正确的反义词组命名具有互斥意义的变量或相反动作的函数等。<br>
说明：以下是一些在软件中常用的反义词组。<br>
add / remove    begin / end    create / destroy<br>
insert /delete    first / last    get / release<br>
increment / decrement    put / get<br>
add /delete    lock unlock    open /close<br>
min / max    old /new     stat / stop<br>
next /previous    source / target    show / hide<br>
send / receive    source / destination <br>
cut /paste    up / down<br>
示例：<br>
int min_sum;<br>
int max_sum;<br>
int add_user( BYTE *user_name );<br>
int delete_user( BYTE *user_name);</p>
<h3 id="四可测性">（四）可测性</h3>
<p>1.使用断言来发现软件问题，提高代码可测性。</p>
<h3 id="五程序效率">（五）程序效率</h3>
<p>1.多重循环中，应将最忙的循环放在最内层。<br>
2.尽量减少循环嵌套层次。<br>
3.尽量使用乘法或其他方法代替除法特别是浮点运算中的除法（占用较多 CPU 资源）。</p>
<h3 id="六质量保证">（六）质量保证</h3>
<p>1.防止引用已经释放的内存空间。<br>
2.过程/函数中分配的内存，在过程/函数退出之前要释放。<br>
3.过程/函数中申请的（为打开文件而使用的）文件句柄，在过程/函数退出之前要关闭。<br>
4.防止内存操作越界。<br>
5.编程时，要防止差 1 错误。（&lt;=、&lt;等注意）<br>
6.if 语句尽量加上 else 分支，switch 语句必须有 default 分支。<br>
7.Unix 下，多线程的子线程退出必需采用主动退出的方式，即子线程应 return 出口。<br>
8.时刻注意表达式是否会上溢、下溢。使用变量时要注意其边界值的情况。</p>

        
        ]]>
      </description>
    </item>
    
    
    
    <item>
      <title>【规约】 Java 编程篇</title>
      <link>/post/2021/05/28/%E8%A7%84%E7%BA%A6-java-%E7%BC%96%E7%A8%8B%E7%AF%87/</link>
      <pubDate>Fri, 28 May 2021 10:36:40 +0800</pubDate>
      
      <guid>/post/2021/05/28/%E8%A7%84%E7%BA%A6-java-%E7%BC%96%E7%A8%8B%E7%AF%87/</guid>
      <description>
        <![CDATA[
        <h3 id="前言">前言</h3>
<p>“码出高效，码出质量”。本文整理了比较常见的 Java 编程规范，主要来源于《阿里巴巴 Java 开发手册》。</p>
<h3 id="一命名风格">（一）命名风格</h3>
<p>1.【强制】类名使用 UpperCamelCase风格，但以下情形例外：DO  /  BO  /  DTO  /  VO  /  AO  /  PO  /  UID等。
正例：MarcoPolo  /  UserDO  /  XmlService  /  TcpUdpDeal  /TaPromotion</p>
<p>2.【强制】方法名、参数名、成员变量、局部变量都统一使用 lowerCamelCase 风格，必须遵从驼峰形式。<br>
正例：localValue  /  getHttpMessage()  /  inputUserId</p>
<p>3.【强制】常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。<br>
正例：MAX_STOCK_COUNT</p>
<p>4.【强制】抽象类命名使用 Abstract 或 Base 开头；异常类命名使用 Exception 结尾；测试类命名以它要测试的类的名称开始，以 Test 结尾。</p>
<p>5.【强制】类型与中括号紧挨起来表示数组。<br>
正例：int[] arrayDemo;</p>
<p>6.【强制】POJO 类中布尔类型的变量，都不要加 is 前缀。</p>
<p>7.【强制】包名统一使用小写，点分隔符之间有且只有一个自然语义的英语单词。包名统一使用单数形式，但是类名如果有复数含义，类名可以使用复数形式。<br>
正例：应用工具类包名为 com.alibaba.ai.util、类名为 MessageUtils。</p>
<p>8.【强制】杜绝完全不规范的缩写，任何自定义编程元素在命名时，使用尽量完整的单词组合来表达其意。</p>
<p>9.【推荐】如果模块、接口、类、方法使用了设计模式，在命名时需体系那具体模式。</p>
<p>10.【推荐】接口类的方法和属性不要加任何修饰符号（public 也不要加），保持代码整洁，并加上有效的 Javadoc 注释。</p>
<p>11.【强制】对于 Service 和 DAO 类，基于 SOA 的理念，暴露出来的一定时接口，内部的实现类用 Impl 的后缀与接口区别。<br>
正例：CacheServiceImpl 实现 CacheService。</p>
<p>12.【参考】各层命名规约：
A）Service/DAO 层方法命名规约<br>
1）获取单个对象的方法用 get 做前缀。<br>
2）获取多个对象的方法用 list 做前缀，复数形式结尾如： listObjects。<br>
3）获取统计值的方法用 count 做前缀。<br>
4）插入的方法用 save/insert 做前缀<br>
5）删除的方法用 remove/delete 做前缀<br>
6）修改的方法用 update 做前缀<br>
B）领域模型命名规约<br>
1）数据对象：xxxDO，xxx 即为数据表名。<br>
2）数据传输对象：xxxDTO，xxx 为业务领域相关的名称。<br>
3）展示对象：xxxVO，xxx 一般为网页名称。<br>
4) POJO 是 DO/DTO/BO/VO 的统称，禁止命名为 xxxPOJO。</p>
<p>13.【强制】不允许任何魔法值（即未经预先i当以的常量）出现在代码中。<br>
反例：String key = &ldquo;ID#taobao_&rdquo; + tradeId;</p>
<p>14.【强制】代码格式，具体见下面正例。
正例：</p>
<pre tabindex="0"><code>    public static void main(String[] args) {
        // 缩进4个空格，注释内空1格
        String say = &#34;hello&#34;;
        // 运算符左右必须有一个空格
        int flag = 0;
        // 关键词 if 与括号之间必须有一个空格
        if (flag == 0) {
            System.out.println(say);
        }

        // 左大括号前加空格且不换行，左大括号后换行。
        if (flag == 0) {
            System.out.println(&#34;world&#34;);
        //  右大括号前换行，右大括号后有 else，不用换行、
        }
        else {
            System.out.printLn(&#34;ok&#34;);
        }
    }
</code></pre>
        
        ]]>
      </description>
    </item>
    
    
    
    <item>
      <title>【规约】 MySQL 数据库篇</title>
      <link>/post/2021/05/28/%E8%A7%84%E7%BA%A6-mysql-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AF%87/</link>
      <pubDate>Fri, 28 May 2021 09:03:51 +0800</pubDate>
      
      <guid>/post/2021/05/28/%E8%A7%84%E7%BA%A6-mysql-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AF%87/</guid>
      <description>
        <![CDATA[
        <h3 id="前言">前言</h3>
<p>“码出高效，码出质量”。本文整理了比较常见的 MySQL 数据库编程规范，主要来源于《阿里巴巴 Java 开发手册》。</p>
<h3 id="一建表规约">(一)建表规约</h3>
<p>1.【强制】表达是与否概念的字段，必须使用 is_xxx 的方式命名，数据类型是 unsigned tinying(1 表示是，0 表示否)。<br>
说明：任何字段如果为非负数，必须是 unsigned。<br>
注意：POJO 类中任何布尔类型的变量，都不要加 is 前缀，所以，需要在 <resultMap> 设置从 is_xxx 到 Xxx 的映射关系。数据库表示是与否的值，使用 tinyint 类型，坚持 is_xxx 的命名方式是为了明确其取值含义与范围。<br>
正例：表达逻辑删除的字段名 is_deleted，1 表示删除，0 表示未删除。</p>
<p>2.【强制】表名、字段名必须使用小写字母或数字，禁止出现数字开头，禁止两个下划线中间只出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。<br>
说明:MySQL 在 Windows 下不区分大小写，但在 Linux 下默认是区分大小写。因此，数据库名、表名、字段名，都不允许出现任何大小写字母，避免节外生枝。<br>
正例：aliyun_admin, rdc_config, level3_name
反例：AliyunAdmin, rdcConfig, level_3_name</p>
<p>3.【强制】表明不使用复数名词。
说明：表名应该仅仅表示表里面的实体内容，不应该表示实体数量，对应于 DO 类名也是单数形式，符合表达习惯。</p>
<p>4.【强制】主键索引名为 pk_字段名；唯一索引名为 uk_字段名；普通索引名则为 idx_字段名。<br>
说明：pk_ 即 primary key；uk_ 即 unique key；idx_ 即 index 的简称。</p>
<p>5.【小数类型】为 decimal，禁止使用 float 和 double。<br>
说明：float 和 double 在存储的时候，存在精度损失的问题，很可能在值的比较时，得不到正确的结果。如果存储的数据范围超 decimal 的范围，建议将数据拆成整数和小数分开存储。</p>
<p>6.【强制】如果存储的字符串长度几乎相等，使用 char 定长字符串类型。</p>
<p>7.【强制】varchar 是可变字符串，不与先分配存储控件，长度不要超过 5000，如果存储长度大于此值，定义字段类型为 text,独立出来一张表，用主键来对应，避免影响其他字段索引效率。</p>
<p>8.【强制】表必备三字段：id, gmt_create, gmt_modified。<br>
说明：其中 id 必为主键，类型为 bigint unsigned、单表自增、步长为 1。gmt_create，gmt_modified 的类型均为 datetime 类型，前者现在时表示主动创建，后者过去分词表示被动更新。</p>
<p>9.【推荐】表的命名最好是加上”业务名称_表的作用“。<br>
正例：alipay_task   /   force_project   /   trade_config</p>
<p>10.【推荐】库名与应用名称尽量一致。</p>
<p>11.【推荐】字段允许适当冗余，以提高查询性能，但必须考虑数据一致。冗余字段应遵循：<br>
1）不是频繁修改的字段。<br>
2）不是 varchar 超长字段，更不能是 text 字段。<br>
正例：商品类目名称使用频率高，字段长度短，名称基本一成不变，可在相关联的表中冗余存储类目名称，避免关联查询。</p>
<p>12.【参考】合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检索速度。<br>
正例：  人  150岁之内   tinyint unsigned    1字节   无符号值：0 到 255<br>
龟  数百岁  smallint unsigned   2字节   无符号值：0 到65535</p>
<h3 id="二索引规约">（二）索引规约</h3>
<p>1.【强制】业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引。<br>
说明：不要以为唯一索引影响了 insert 速度，这个速度的损耗可以忽略，但提高查找速度是明显的；另外，只要没有唯一索引，必定有脏数据产生（墨菲定律）。</p>
<p>2.【强制】超过三个表禁止 join。需要 join 的字段，数据类型必须绝对一致；多表关联查询时，保证被关联的字段有索引。<br>
说明：join 需要注意表索引、SQL 性能。</p>
<p>3.【强制】在 varchar 字段上建立索引时，必须根据文本区分度指定索引长度。</p>
<p>4.【强制】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。<br>
说明：索引文件具有 B-Tree 的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。</p>
<p>5.【推荐】利用覆盖索引来进行查询操作，避免回表。</p>
<p>6.【参考】创建索引时避免有如下极端误解：<br>
1）宁滥勿缺。认为一个查询就需要建一个索引。<br>
2）宁缺毋滥。认为索引会消耗空间、严重拖慢更新和新增速度。<br>
3）抵制唯一索引。认为业务的唯一性一律需要在应用层通过”先查后插“方式解决。</p>
<h3 id="三sql-语句">（三）SQL 语句</h3>
<p>1.【强制】不要使用 count(列名) 或 count(常量) 来替代 count(*)。</p>
<p>2.【强制】使用 ISNULL() 来判断是否为 NULL 值。</p>
<p>3.【强制】不得使用外键和级联，一切外键概念不必在应用层解决。
说明：外键与级联更新使用于单机低并发，不适合分布式、高并发集群；级联更新时强阻塞，存在数据库过呢更新风暴的风险；外键影响数据库的插入速度。</p>
<p>4.【推荐】尽量避免 in 操作，若使用也需评估 in 后边的集合元素数量，控制在 1000 个之内。</p>

        
        ]]>
      </description>
    </item>
    
    
    
    <item>
      <title>[做点有趣的]C&#43;&#43;做一个哈夫曼压缩软件</title>
      <link>/post/2021/05/25/%E5%81%9A%E7%82%B9%E6%9C%89%E8%B6%A3%E7%9A%84c-%E5%81%9A%E4%B8%80%E4%B8%AA%E5%93%88%E5%A4%AB%E6%9B%BC%E5%8E%8B%E7%BC%A9%E8%BD%AF%E4%BB%B6/</link>
      <pubDate>Tue, 25 May 2021 07:12:32 +0800</pubDate>
      
      <guid>/post/2021/05/25/%E5%81%9A%E7%82%B9%E6%9C%89%E8%B6%A3%E7%9A%84c-%E5%81%9A%E4%B8%80%E4%B8%AA%E5%93%88%E5%A4%AB%E6%9B%BC%E5%8E%8B%E7%BC%A9%E8%BD%AF%E4%BB%B6/</guid>
      <description>
        <![CDATA[
        <h3 id="前言">前言</h3>
<p>这是以前的一个实训周作业，核心是哈夫曼编码和解码，软件界面由 QT 实现。代码量很小，比较简单。</p>
<p>源代码： <a href="https://gitee.com/lzxqaq/zxhan.git">https://gitee.com/lzxqaq/zxhan.git</a></p>
<p>介绍：<a href="https://lzxqaq.com/post/zxhan/">https://lzxqaq.com/post/zxhan/</a></p>
<p>算法参考：<a href="https://blog.csdn.net/small_hacker/article/details/52843738">Huffman压缩真正的C++实现</a></p>
<p>运行环境：Linux 系统（Windows系统下运行尚有 bug ),开发环境为 QT Creator。</p>
<p>运行截图：</p>
<div  align="center">    
 <img src="https://cdn.jsdelivr.net/gh/lzxqaq/zxhan@master/images/zxhan.png" width = "500" height = "200" alt="图片名称" align=center /></div>
<!-- ![img](https://cdn.jsdelivr.net/gh/lzxqaq/zxhan@master/images/zxhan.png) -->
<h3 id="核心实现">核心实现</h3>
<pre tabindex="0"><code>void create_node_array();//构造包含字符及其频率的数组
void create_pq();//构造优先级队列
void create_huffman_tree();//构造哈夫曼树
void create_map_table(Node* node,bool);//根据哈夫曼树建立哈夫曼映射表
bool calculate_huffman_codes();//计算哈夫曼编码
bool do_compress();//开始压缩
bool rebuid_huffman_tree();//从哈夫曼编码文件中重构哈夫曼树
void decode_huffman();//根据重构的哈夫曼树解码文件
</code></pre><h3 id="后续">后续</h3>
<p>该项目仍有许多不足之处，如果你对该项目有任何意见或建议，欢迎<a href="https://lzxqaq.com/about/">联系我</a>。如有任何问题，亦可与我一同探讨。</p>

        
        ]]>
      </description>
    </item>
    
    
    
    <item>
      <title>[做点有趣的]Java开发泡泡堂游戏（MVC架构）</title>
      <link>/post/2021/05/08/%E5%81%9A%E7%82%B9%E6%9C%89%E8%B6%A3%E7%9A%84java%E5%BC%80%E5%8F%91%E6%B3%A1%E6%B3%A1%E5%A0%82%E6%B8%B8%E6%88%8Fmvc%E6%9E%B6%E6%9E%84/</link>
      <pubDate>Sat, 08 May 2021 11:09:51 +0800</pubDate>
      
      <guid>/post/2021/05/08/%E5%81%9A%E7%82%B9%E6%9C%89%E8%B6%A3%E7%9A%84java%E5%BC%80%E5%8F%91%E6%B3%A1%E6%B3%A1%E5%A0%82%E6%B8%B8%E6%88%8Fmvc%E6%9E%B6%E6%9E%84/</guid>
      <description>
        <![CDATA[
        <h3 id="介绍">介绍</h3>
<p>本项目是一个很久以前的实训周项目，由我和我的组员 ljr 共同实现。整个项目思路清晰，整体难度不大，但是很多细节需要花功夫。本项目仍存在一些不足的地方，后续可能会进行优化，现在我将项目源代码和一些实现思路开源公布。</p>
<p>源代码：<a href="https://gitee.com/lzxqaq/CrazyArcade">https://gitee.com/lzxqaq/CrazyArcade</a></p>
<p>文章介绍：<a href="https://lzxqaq.com/post/java/paopaotang/">https://lzxqaq.com/post/java/paopaotang/</a></p>
<p>程序运行： 在终端下进入执行程序所在目录，执行 <code>java -jar CrazyArcade.jar</code> 或者双击 <code>CrazyArcade.jar</code>，或者在开发环境中打开源代码，运行 <code>GameStart.java</code>的 <code>main</code> 方法。</p>
<p>运行环境：Linux、Windows均可。开发环境：IDEA。</p>
<p>演示视频：</p>
<p>运行截图：</p>
<div  align="center">    
 <img src="https://cdn.jsdelivr.net/gh/lzxqaq/CrazyArcade@master/images/CrazyArcade.png" width = "500" height = "200" alt="图片1" align=center />
 <br/>
  <img src="https://cdn.jsdelivr.net/gh/lzxqaq/CrazyArcade/images/2.png" width = "500" height = "200" alt="图片2" align=center />
 </div>
<h3 id="功能">功能</h3>
<p>本项目实现的功能如下：</p>
<ul>
<li>绘制游戏启动界面、结束界面、地图、主角、道具</li>
<li>实现泡泡爆炸</li>
<li>实现双主角PK（积分制）</li>
<li>实现道具掉落和相应属性加成</li>
<li>实现游戏音效和背景音乐</li>
</ul>
<p>其中我们对游戏玩法做了调整，大致如下:</p>
<p>我们把游戏设计为双人pk积分赛模式，在这个模式里面，玩家只要率先达到一定分数既可以赢得比赛。玩家可以通过炸箱子可以得到少量的分数，也可以通过炸掉对手然后戳破包围对手的水泡得到大量分数。而玩家如果被泡泡爆炸击中，会被泡泡包裹一段时间，在这段时间内不可以移动和放泡泡，需要等时间过去或者被对手戳破水泡才能获得自由。但如果玩家被自己放的泡泡炸中，会扣一定的分数。</p>
<h3 id="思路和架构">思路和架构</h3>
<p>整个项目采用 MVC 架构，将项目整体分为数据模型层（M）、视图层（V）、控制层（C）。M层负责元素的创建、存储、管理，V层负责所有元素的显示（24帧/秒），C层负责交互（监听用户的操作），同时负责控制游戏的进程。</p>
<p>选择MVC架构最主要的原因是让这个游戏项目具有良好的可扩展性和更新功能，当然了，一个好的游戏也需要良好的交互功能，漂亮的UI设计。</p>
<p>架构设计图：</p>
<div  align="center">    
 <img src="https://cdn.jsdelivr.net/gh/lzxqaq/CrazyArcade@master/images/design.png" width = "500" height = "200" alt="图片名称" align=center /></div>
<h3 id="包结构">包结构</h3>
<p>未完待续……</p>
<h3 id="核心实现">核心实现</h3>
<p>未完待续……</p>
<h3 id="后续">后续</h3>
<p>该项目仍有许多不足之处，如果你对该项目有任何意见或建议，欢迎<a href="https://lzxqaq.com/about/">联系我</a>。如有任何问题，亦可与我一同探讨。</p>

        
        ]]>
      </description>
    </item>
    
    
    
    <item>
      <title>从零开始搭建个人网站（win10,Github,Hugo）</title>
      <link>/post/2021/02/18/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99win10githubhugo/</link>
      <pubDate>Thu, 18 Feb 2021 09:03:38 +0800</pubDate>
      <author>糸色先生</author>
      <guid>/post/2021/02/18/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99win10githubhugo/</guid>
      <description>
        <![CDATA[
        <h3 id="准备工作">准备工作</h3>
<p>1.注册 Github 帐号。前往 <a href="https://github.com/" target="_blank">github.com</a> 注册一个 Github 帐号。（友情提示：认真考虑注册时的用户名，它将是网址的一部分）</p>
<p>补充：Github 是一个代码托管平台（远程仓库），你可以将网站的源代码放在上面，Github Pages 是一个免费的静态网站服务，你将网站的源文件放在上面，它会提供一个链接，使互联网上的人都能访问你的网站。</p>
<p>2.准备Git。</p>
<p>（1）下载安装。前往 <a href="https://git-scm.com/download/win" target="_blank">这里</a> ，点击下载 Git-**-64-bit.exe。然后安装，不懂的话一直 next 。</p>
<p>（2）配置。在 win10 搜索 cmd ，打开命令提示符，输入 <code>git config --global user.email &quot;你注册Github所用的邮箱&quot;</code> 回车执行，再输入 <code>git config --global user.name &quot;你的昵称&quot;</code> 回车执行。</p>
<p>3.安装 Hugo。（官方教程可看<a href="https://www.gohugo.org/doc/tutorials/installing-on-windows/" target="_blank">这里</a>)</p>
<p>（1）首先在 D 盘创建一个新文件夹 Hugo，然后在里面创建 bin 和 sites两个文件夹。bin 将用来放 Hugo 的可执行文件，sites 将用来放你的网站的源代码。</p>
<p>（2）前往<a href="https://github.com/spf13/hugo/releases" target="_blank">这里</a>，找到并下载 hugo_<em><em>Windows-64bit.zip。解压，如果是一个 hugo</em></em>_windows_amd64.exe 文件，将它改名为 hugo.exe。</p>
<p>（3）将这个 hugo.exe 文件移动到刚刚创建的 bin 文件夹里。</p>
<p>（4）配置环境变量。方法1:在 win10 搜索 cmd，右键<strong>以管理员身份打开</strong>命令提示符，将 <code>setx &quot;Path&quot; &quot;%PATH%;D:\Hugo\bin&quot; /m </code>复制粘贴上去，回车（输入命令后需回车执行，后文不再赘述）。 方法2：在 win10 搜索环境变量，进去找到系统变量中的 Path，-&gt;编辑-&gt;新建，然后将 <code>D:\Hugo\bin</code> 复制进去，确定。</p>
<p>（5）验证。重新打开命令提示符（关闭上一步骤使用的），输入执行 <code>hugo help</code>，如果你能看到 hugo 的帮助文档，就验证成功，否则检查上述步骤是否出错。</p>
<h3 id="开始">开始</h3>
<p>1.建立博客网站</p>
<p>（1）使用 Hugo 建立网站。打开命令提示符，执行 <code>D:</code> 切换 D 盘，然后执行 <code>cd D:\Hugo\sites</code> 进入 D:\Hugo\sites 目录（便捷方法：在文件资源管理器中进入相应目录，单击地址栏右边空白地方，在最左边输入 <code>cmd </code> 加空格，回车），执行命令 <code>hugo new site blog</code> ，如出现 Congratulations! 提示则成功。（此时可在文件资源管理器中查看生成的文件）</p>
<p>（2）下载主题模板（以 Hugo.386 为例）。接上述步骤，在命令提示符中 执行 <code>git clone https://gitlab.com/maxlefou/hugo.386 themes/hugo.386 </code>来下载 hugo.386 主题。</p>
<p>（3）配置。将 hugo.386\exampleSite 文件夹中的 theme.toml 文件复制到文件夹 blog 中，替换原本的。根据需要修改其中的内容。</p>
<p>（4）预览。命令提示符进入 blog 目录，先执行 <code>hugo</code> ，再执行 <code>hugo server</code>。打开浏览器，访问 localhost:1313。</p>
<p>2.将网站展示文件存放到 Github 远程仓库。</p>
<p>（1）在 Github 中创建一个名为 你的仓库名字.github.io 的仓库，在设置 setting 中检查 Github Pages。</p>
<p>（2）打开命令提示符，进入 blog\public 目录，分别执行</p>
<pre tabindex="0"><code>git init 
git add .
git commit -m &#34;first commit&#34;
git remote add origin https://github.com/你的Github名字/你的Github名字.github.io.git
git push --set-upstream origin master
</code></pre><p>输入账号名，密码，完成上传。</p>
<p>（3）测试。访问 github.com 网站，在你之前创建的仓库可以看到刚刚上传的文件。随后检查 Github Pages 设置，访问提供的 <code>https://你的Github账户名.github.io</code> 访问你的网站，如果没有之前预览的网页，可以等待一会再刷新。</p>
<p>3.自定义域名（可选、需要一定的时间）</p>
<p>（1）购买域名。在华为云、阿里云等服务商购买域名。注意：国内购买域名需要实名认证。</p>
<p>（2）配置。访问 github.com 网站，进入你的仓库，在 setting 中找到 Github Pages，在 Custom domain 输入框中输入你的域名，保存。</p>
<p>（3）测试。访问你的域名。</p>

        
        ]]>
      </description>
    </item>
    
    
    
    <item>
      <title>Java I/O</title>
      <link>/post/2021/01/12/java-i/o/</link>
      <pubDate>Tue, 12 Jan 2021 08:46:08 +0800</pubDate>
      <author>糸色先生</author>
      <guid>/post/2021/01/12/java-i/o/</guid>
      <description>
        <![CDATA[
        <h3 id="一概览">一、概览</h3>
<p>Java 的 I/O 大概可以分成以下几类：</p>
<ul>
<li>磁盘操作：File</li>
<li>字节操作：InputStream 和 OutputStream</li>
<li>对象操作：Serializable</li>
<li>网络操作：Socket</li>
<li>新的输入/输出：NIO</li>
</ul>
<h3 id="二磁盘操作">二、磁盘操作</h3>
<p>File 类可以用于表示文件和目录的信息，但是它不表示文件的内容。
递归地列出一个目录的所有文件：</p>
<pre tabindex="0"><code>public static void listAllFiles(File dir){
    if(dir == null || !dir.exists()){
        return ;
    }
    if(dir.isFile()) {
        System.out.println(dir.getName());
        return ;
    }
    for (File:file : dir.listFiles()) {
        listAllFiles(file);
    }
}
</code></pre><p>从 Java 7 开始，可以使用 Paths 和 Files 代替 File。</p>
<h3 id="三字节操作">三、字节操作</h3>
<h4 id="实现文件复制">实现文件复制</h4>
<pre tabindex="0"><code>public static void copuFile(String src, String dist) throws IOException {
    FileInputStream in = new FileInputStream(src);
    FileOutputStream out = new FileOutStream(dist);

    byte[] buffer = new byte[20 * 1024];
    int cnt;
    // read() 最多读 buffer.length 个字节
    // 返回的是实际读取的个数
    // 返回 -1 的时候表示读到 eof,即文件结尾
    while ((cnt = in.read(buffer, 0, buffer.length)) != -1) {
        out.write(buffer, 0, cnt);
    }

    in.close();
    out.close();
}
</code></pre><h4 id="装饰者模式">装饰者模式</h4>
<p>Java I/O 使用了装饰者模式来实现。</p>
<p>实例化一个具有缓存功能的字节流对象时，只需要在 FileInputStream 对象上再套一层 BufferedInputStream 对象即可。</p>
<h3 id="七nio">七、NIO</h3>
<p>新的输入/输出（NIO）库是在 JDK1.4中引入的，弥补了原来的 I/O 的不足，提供了高速的、面向块的 I/O。</p>

        
        ]]>
      </description>
    </item>
    
    
    
    <item>
      <title>Java 并发</title>
      <link>/post/2021/01/09/java-%E5%B9%B6%E5%8F%91/</link>
      <pubDate>Sat, 09 Jan 2021 10:50:16 +0800</pubDate>
      <author>糸色先生</author>
      <guid>/post/2021/01/09/java-%E5%B9%B6%E5%8F%91/</guid>
      <description>
        <![CDATA[
        <h3 id="一使用线程">一、使用线程</h3>
<p>有三种使用线程的方法：</p>
<ul>
<li>实现 Runnable 接口；</li>
<li>实现 Callable接口；</li>
<li>继承 Tread 类；</li>
</ul>
<h4 id="实现-runnable-接口">实现 Runnable 接口</h4>
<p>需要实现接口中的 run() 方法。</p>
<pre tabindex="0"><code>public class MyRunnable implements Runnable {
    @Override
    public void run(){
        // ...
    }
}
</code></pre><p>使用 Runnable 实例再创建一个 Thread 实例，然后调用 Thread 实例的 start() 方法来启动线程。</p>
<pre tabindex="0"><code>public static void main(String[] args){
    MyRunnable instance = new MyRunnable();
    Thread thread = new Thread(instance);
    thread.start();
}
</code></pre><h4 id="实现-callable-接口">实现 Callable 接口</h4>
<p>与 Runnable 相比，Callable 可以有返回值，返回值通过 FutureTask 进行封装。</p>
<pre tabindex="0"><code>public class MyCallable implements Callable&lt;Integer&gt; {
    public Integer call(){
        return 123;
    }
}
</code></pre><pre tabindex="0"><code>public static void main(String[] args) throws ExecutionException,InterruptedException {
    MyCallable mc = new MyCallble();
    FutureTask&lt;Integer&gt; ft = new FutureTask&lt;&gt;(mc);
    Thread thread = new Thread(ft);
    thread.start();
    System.out.println(ft.get());
}
</code></pre><h3 id="继承-thread-类">继承 Thread 类</h3>
<p>同样也是需要实现 run() 方法，因为 Thread 类也实现了 Runnable 接口。</p>
<p>当调用 start() 方法启动一个线程时，虚拟机会将该线程放入就绪队列中等待被调度，当一个线程被调度时会执行该线程的 run() 方法。</p>
<pre tabindex="0"><code>public class MyThread extends Thread {
    public void run() {
        // ...
    }
}
</code></pre><pre tabindex="0"><code>public static void main(String[] args) {
    MyThread mt = new MyThread();
    mt.start();
}
</code></pre><h3 id="实现接口-vs-继承-thread">实现接口 VS 继承 Thread</h3>
<p>实现接口会更好一些，因为：</p>
<ul>
<li>Java 不支持多重继承，可以实现多个接口。</li>
<li>继承整个 Thread 类开销过大。</li>
</ul>
<h3 id="四互斥同步">四、互斥同步</h3>
<p>Java 提供了两种锁机制来控制多个线程对共享资源的互斥访问，第一个是 JVM 实现的 synchronized，而另一个是 JDK 实现的 ReentrantLock。</p>
<h4 id="synchronized">synchronized</h4>
<h5 id="1同步一个代码块">1.同步一个代码块</h5>
<pre tabindex="0"><code>public void func() {
    synchronized (this) {
        // ...
    }
}
</code></pre><p>它只作用于同一个对象，如果调用两个对象上的同步代码块，就不会进行同步。</p>
<p>对于以下代码，使用 ExecutorService 执行了两个线程，由于调用的是同一个对象的同步代码块，因此这两个线程会进行同步，当一个线程进入同步语句块时，另一个线程就必须等待。</p>
<pre tabindex="0"><code>public class SynchronizedExample {

    public void func1() {
        synchronized (this) {
            for (int i = 0; i &lt; 10; i++) {
                System.out.print(i + &#34; &#34;);
            }
        }
    }
}
</code></pre><pre tabindex="0"><code>public static void main(String[] args) {
    SynchronizedExample e1 = new SynchronizedExample();
    ExecutorService executorService = Executors.newCachedThreadPool();
    executorService.execute(() -&gt; e1.func1());
    executorService.execute(() -&gt; e1.func1());
}
</code></pre><pre tabindex="0"><code>0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9
</code></pre><p>对于以下代码，两个线程调用了不同对象的同步代码块，因此这两个线程就不需要同步。从输出结果可以看出，两个线程交叉执行。</p>
<pre tabindex="0"><code>public static void main(String[] args) {
    SynchronizedExample e1 = new SynchronizedExample();
    SynchronizedExample e2 = new SynchronizedExample();
    ExecutorService executorService = Executors.newCachedThreadPool();
    executorService.execute(() -&gt; e1.func1());
    executorService.execute(() -&gt; e2.func1());
}
</code></pre><pre tabindex="0"><code>0 0 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9
</code></pre><h5 id="2同步一个方法">2.同步一个方法</h5>
<pre tabindex="0"><code>public synchronized void func() {
    // ...
}
</code></pre><p>它和同步代码块一样，作用于同一个对象</p>
<h5 id="3同步一个类">3.同步一个类</h5>
<pre tabindex="0"><code>public void func() {
    synchronized (SynchronizedExample.class) {
        // ...
    }
}
</code></pre><p>作用于整个类，也就是说两个线程调用同一个类的不同对象上的这种同步语句块，也会进行同步。</p>
<pre tabindex="0"><code>public class SynchronizedExample {

    public void func2() {
        synchronized (SynchronizedExample.class) {
            for (int i = 0; i &lt; 10; i++) {
                System.out.print(i + &#34; &#34;);
            }
        }
    }
}
</code></pre><pre tabindex="0"><code>public static void main(String[] args) {
    SynchronizedExample e1 = new SynchronizedExample();
    SynchronizedExample e2 = new SynchronizedExample();
    ExecutorService executorService = Executors.newCachedThreadPool();
    executorService.execute(() -&gt; e1.func2());
    executorService.execute(() -&gt; e2.func2());
}
</code></pre><pre tabindex="0"><code>0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9
</code></pre><h5 id="4同步一个静态方法">4.同步一个静态方法</h5>
<pre tabindex="0"><code>public synchronized static void fun() {
    // ...
}
</code></pre><p>作用于整个类。</p>
<h4 id="reentrantlock">ReentrantLock</h4>
<p>ReentrantLock 是 java.util.concurrent（J.U.C)包中的锁。</p>
<pre tabindex="0"><code>public class LockExample {

    private Lock lock = new ReentrantLock();

    public void func() {
        lock.lock();
        try {
            for (int i = 0; i &lt; 10; i++) {
                System.out.print(i + &#34; &#34;);
            }
        } finally {
            lock.unlock(); // 确保释放锁，从而避免发生死锁。
        }
    }
}
</code></pre><pre tabindex="0"><code>public static void main(String[] args) {
    LockExample lockExample = new LockExample();
    ExecutorService executorService = Executors.newCachedThreadPool();
    executorService.execute(() -&gt; lockExample.func());
    executorService.execute(() -&gt; lockExample.func());
}
</code></pre><pre tabindex="0"><code>0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9
</code></pre><h5 id="使用选择">使用选择</h5>
<p>除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized。这是因为 synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。并且使用 synchronized 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放。</p>
<h3 id="六线程状态">六、线程状态</h3>
<h4 id="新建">新建</h4>
<h4 id="可运行">可运行</h4>
<h4 id="阻塞">阻塞</h4>
<h4 id="无限期等待">无限期等待</h4>
<h4 id="死亡">死亡</h4>

        
        ]]>
      </description>
    </item>
    
    
    
    <item>
      <title>Linux 不同发行版的选择</title>
      <link>/post/2020/12/26/linux-%E4%B8%8D%E5%90%8C%E5%8F%91%E8%A1%8C%E7%89%88%E7%9A%84%E9%80%89%E6%8B%A9/</link>
      <pubDate>Sat, 26 Dec 2020 22:33:13 +0800</pubDate>
      <author>糸色先生</author>
      <guid>/post/2020/12/26/linux-%E4%B8%8D%E5%90%8C%E5%8F%91%E8%A1%8C%E7%89%88%E7%9A%84%E9%80%89%E6%8B%A9/</guid>
      <description>
        <![CDATA[
        <p>如果你对 Linux 感兴趣但还不了解，想知道 Linux 的不同发行版之间的区别，我的这些经历应该对你有帮助。</p>
<p>我最初使用的是 Ubuntu，它以前经常被推荐为 Linux 入门选择。用了很长一段时间，它给我最大的感受是不稳定和笨重。会经常收到系统内部崩溃的通知，而且另一个问题是装其他显卡驱动时很艰难（做深度学习、玩游戏等等会用到），令我几度崩溃 T_T 。所以，我认为 Ubuntu 对新手非常不友好；</p>
<p>后来我开始尝试 Deepin 系统，这是一款由国内深之度公司推出的发行版，预装软件最符合国人习惯，而且上手简单，系统不需要怎么配置就能拥有漂亮的界面。但是很快我就不能忍受它的软件源的落后。软件获取、维护便捷本该是 Linux 系统的一大优点，它可以为很多工作带来便利。</p>
<p>接着我来到 Arch 的世界。遗憾的是 Arch Linux 我在尝试的中途便放弃了。它确实很棒，从零开始定制操作系统很诱人，但是因为时间关系，我需要的是能快速上手，成为主力的操作系统。</p>
<p>最后，我接触到了很多人推荐的 Manjaro，它是为了让用户更方便使用的 Arch 衍生版。安装之后确实让我很惊喜，它完美符合我对操作系统的需求：上手简单、使用高效、美。而且尝试过后我才知道 Arch 系的软件仓库 AUR 有多强大。AUR 是一个社区维护的软件包仓库，有了它，你可以轻易获取到很多想要的软件。因此我很推荐使用 Manjaro。</p>
<p>（顺便提一下最稳定发行版之一的 CentOS。当我想在服务器上尝试它时，它就被官宣抛弃了……）</p>

        
        ]]>
      </description>
    </item>
    
    
    
    <item>
      <title>String 类真的不可以改变吗？</title>
      <link>/post/2020/12/15/string-%E7%B1%BB%E7%9C%9F%E7%9A%84%E4%B8%8D%E5%8F%AF%E4%BB%A5%E6%94%B9%E5%8F%98%E5%90%97/</link>
      <pubDate>Tue, 15 Dec 2020 15:05:27 +0800</pubDate>
      <author>糸色先生</author>
      <guid>/post/2020/12/15/string-%E7%B1%BB%E7%9C%9F%E7%9A%84%E4%B8%8D%E5%8F%AF%E4%BB%A5%E6%94%B9%E5%8F%98%E5%90%97/</guid>
      <description>
        <![CDATA[
        <p>对于 java.lang.String 类，我相信很多人印象里都是它不能被改变。通过查看源码，可以知道 String 有一个 final char 数组的变量，这个变量初始化之后便不能重新赋值。虽然这个变量引用的 char 数组的值虽然可以改变，但是String 类中并没有主动修改 这个 char 数组的方法。这就是通常所说 String 类不可变的依据。</p>
<p>然而在学习反射的时候，我产生了一个疑问：我们不可以通过反射修改 String 内部的 char 数组的值吗？答案是可以的，了解 Java 反射的人很容易就做到这点。那为什么还说 String 不可变呢？在思考过后，我得出一个答案：String 的不可变说的是一种约束规范。换句话说，String 的不可变是有好处的。在实际工作中，代码是自己写来用的，没有人会费劲给自己找麻烦，而没有任何益处。</p>
<p>事情到这里就完了？不，最近我再去了解 String 、String Pool（字符串常量池）的时候，又有了一些疑惑，于是亲手操刀给String 来了一次手术。最后也是加深了对 String 的理解，也验证了上面的观点。先上代码（如果你对任一实验结果感到疑惑，没关系，请带着疑惑来看后面的对照实验）：</p>
<pre tabindex="0"><code>    //实验1
    String s1 = &#34;1&#34;;
    Field valueField = String.class.getDeclaredField(&#34;value&#34;);
    valueField.setAccessible(true);
    char[] value = (char[]) valueField.get(s1);
    value[0] = &#39;2&#39;;
    System.out.println(s1);                 //2
    System.out.println((s1 == &#34;1&#34;));        //true
</code></pre><p>上述实验 1 做的事情就是：用 <code>s1 = &quot;1&quot; </code> 的方式创建字符串，用反射修改它的值为 <code>&quot;2&quot;</code>,最后用它与 <code>&quot;1&quot;</code> 比较，结果是 <code>true</code> 。琢磨琢磨，再看下一段代码：</p>
<pre tabindex="0"><code>    //实验2
    String s2 = new String(&#34;1&#34;);
    Field valueField = String.class.getDeclaredField(&#34;value&#34;);
    valueField.setAccessible(true);
    char[] value2 = (char[]) valueField.get(s2);
    value2[0] = &#39;2&#39;;
    System.out.println(s2);                //2
    System.out.println((s2 == &#34;1&#34;));       //false
</code></pre><p>上述实验 2 和实验 1 唯一的区别是字符串创建方式，实验2是通过 <code>new String(&quot;1&quot;)</code> 方式创建，实验1是通过 <code>= &quot;1&quot;</code> 的方式创建。而实验2的结果： <code>s2 == &quot;1&quot;</code> 是 <code>false</code> 。</p>
<p>到这里，可以停一会了。很多技术文章中都做过类似上面的实验（通过比较创建方式的区别、反射修改等)，来分析 String 、String Pool 的原理和设计理念。但我总觉得以此说明最终的结论还不够严谨、或者说还不够直观。接下来请看——魔鬼实验：</p>
<pre tabindex="0"><code>    //实验3 
    String s1 = &#34;1&#34;;
    Field valueField = String.class.getDeclaredField(&#34;value&#34;);
    valueField.setAccessible(true);
    char[] value = (char[]) valueField.get(s1);
    value[0] = &#39;2&#39;;
    System.out.println(s1);                 //2
    System.out.println((s1 == &#34;1&#34;));        //true
    System.out.println(&#34;1&#34;);                //2
</code></pre><p>不难发现，实验3仅仅只是在实验1的基础上输出了 <code>&quot;1&quot;</code> 的值。然而 <code>&quot;1&quot;</code> 输出的值为 2，这样的结果，也许有人会困惑，没关系,看完几个对比实验，相信你会对相关理论（String 、String Pool 等）有了更直观的认识。接下来，请看终极实验：</p>
<pre tabindex="0"><code>    //实验4
    String s2 = new String(&#34;1&#34;);
    Field valueField = String.class.getDeclaredField(&#34;value&#34;);
    valueField.setAccessible(true);
    char[] value2 = (char[]) valueField.get(s2);
    value2[0] = &#39;2&#39;;
    System.out.println(s2);                 //2
    System.out.println((s2 == &#34;1&#34;));        //false
    System.out.println(&#34;1&#34;);                //2
</code></pre><p>同样的，上述实验 4 只是在实验 2 的基础上输出了 <code>&quot;1&quot;</code> 的值。结果 <code>&quot;1&quot;</code> 的值还是 2。</p>
<p><strong>结论：</strong><br>
基于对 String 类和字符串常量池（String Pool） 的了解，我对以上实验作出解释（详细理论下回贴出）:</p>
<p>实验 3 中 字符串 <code>s1</code> 通过直接赋值字符串常量 <code>&quot;1&quot;</code> 的方式创建，因此 <strong><code>s1</code> 会直接引用字符串常量池中 <code>&quot;1&quot;</code> 对应的对象</strong>。对 <code>s1</code> 的修改，也就是对常量池中 <code>&quot;1&quot;</code> 对象的修改，因此 <code>s1</code> 和 <code>&quot;1&quot;</code> 的值都是修改后的 2，而 <code>s1 == &quot;1&quot;</code> 也是 <code>true</code>,因为它们是同一个对象的引用。</p>
<p>实验 4 中 字符串 <code>s2</code> 通过 <code>new String(&quot;1&quot;)</code>的方式创建，因此，<strong><code>s2</code> 会被新建在堆中，并且，<code>s2</code> 的 <code>char</code> 数组变量会直接引用字符串常量池中 &ldquo;1&quot;对象的 <code>char</code> 数组</strong>，也就是说虽然 <code>s2</code> 是新创建的对象，但是 <code>s2</code> 里存储字符的 <code>char</code> 数组是创建时传进来的字符串常量 <code>&quot;1&quot;</code> 的 <code>char</code> 数组。因此，<code>s2</code> 修改 <code>char</code> 数组,<code>&quot;1&quot;</code> 的也会变。<code>s2</code> 和 <code>&quot;1&quot;</code> 的值都是修改后的 2 。而 <code>s2 == &quot;1&quot;</code> 是 <code>false</code> 的，因为它们引用的不是同一个对象。</p>
<p>最终结论，String 类真的是“不可以”变的！因为这不仅仅是它的特点，更是它的设计初衷。（<del>任何想通过反射修改它的人都应该被拉去祭天</del>)</p>
<p>如果你发现任何问题，请<a href="/about">联系</a>我。</p>

        
        ]]>
      </description>
    </item>
    
    
  </channel>
</rss>
