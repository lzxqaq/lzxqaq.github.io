<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>技术文章 on Zexun Luo | 罗泽勋</title>
    <link>/post/</link>
    <description>Recent content in 技术文章 on Zexun Luo | 罗泽勋</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Thu, 30 Dec 2021 07:13:11 +0800</lastBuildDate>
    <atom:link href="/post/" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>【转载】C Primer 之 new, delete</title>
      <link>/post/2021/12/30/cprimer04/</link>
      <pubDate>Thu, 30 Dec 2021 07:13:11 +0800</pubDate>
      <author>罗泽勋</author>
      <guid>/post/2021/12/30/cprimer04/</guid>
      <description>
        <![CDATA[
        <p>转载自<a href="https://github.com/andycai/cprimer">https://github.com/andycai/cprimer</a></p>
<p>new和delete运算符用于动态分配和撤销内存的运算符</p>
<h3 id="1-new用法">(1) new用法</h3>
<ol>
<li>开辟单变量地址空间</li>
</ol>
<ol>
<li>
<p>new int;  //开辟一个存放数组的存储空间,返回一个指向该存储空间的地址.int *a = new int 即为将一个int类型的地址赋值给整型指针a.</p>
</li>
<li>
<p>int *a = new int(5) 作用同上,但是同时将整数赋值为5</p>
</li>
</ol>
<ol start="2">
<li>
<p>开辟数组空间</p>
<p>一维:</p>
<pre><code> int *a = new int[100];  // 开辟一个大小为100的整型数组空间
</code></pre>
<p>二维:</p>
<pre><code> int **a = new int[5][6]
</code></pre>
<p>三维及其以上:依此类推</p>
</li>
</ol>
<p>一般用法: new 类型 [初值]</p>
<h3 id="2-delete用法">(2) delete用法</h3>
<ol>
<li>
<p>int *a = new int;</p>
<pre><code> delete a;   //释放单个int的空间
</code></pre>
</li>
<li>
<p>int *a = new int[5];</p>
<pre><code> delete [] a; //释放int数组空间
</code></pre>
</li>
</ol>
<p>要访问new所开辟的结构体空间,无法直接通过变量名进行,只能通过赋值的指针进行访问。</p>
<p>用new和delete可以动态开辟，撤销地址空间。在编程序时,若用完一个变量(一般是暂时存储的数组)，下次需要再用，但却又想省去重新初始化的功夫，可以在每次开始使用时开辟一个空间，在用完后撤销它。</p>
<h2 id="导航">导航</h2>
<ul>
<li><a href="00.md">目录</a></li>
<li>上一章：<a href="04.md">Chapter 4 - uint8_t, uint16_t, uint32_t, uint64_t</a></li>
</ul>

        
        ]]>
      </description>
    </item>
    
    
    
    <item>
      <title>【转载】C Primer 之 char*, char[], string</title>
      <link>/post/2021/12/30/cprimer03/</link>
      <pubDate>Thu, 30 Dec 2021 07:12:45 +0800</pubDate>
      <author>罗泽勋</author>
      <guid>/post/2021/12/30/cprimer03/</guid>
      <description>
        <![CDATA[
        <p>转载自<a href="https://github.com/andycai/cprimer">https://github.com/andycai/cprimer</a></p>
<h2 id="31-char-char-string">3.1 char*, char[], string</h2>
<p>在C中，并没有字符串这个数据类型，而是使用字符数组来保存字符串。C字符串实际上就是一个以null('\0')字符结尾的字符数组，null字符表示字符串的结束。需要注意的是：只有以null字符结尾的字符数组才是C字符串，否则只是一般的C字符数组。</p>
<p>C字符串定义时可以利用&quot;=&ldquo;号进行初始化，但是以后不能利用&rdquo;=&ldquo;对C字符串进行赋值。对C字符串的操作需要通过&quot;string&quot;文件中定义的字符串处理函数。例如：</p>
<pre><code>//字符串的初始化
char a[11] = &quot;huanying&quot;;
//字符串的赋值
strcpy(a,&quot;nihao&quot;)
//获取字符串的长度，不包括'\0'在内
strlen(a);
printf(&quot;%s&quot;,a);
</code></pre>
<p>在C中也可以使用字符指针来访问一个字符串,通过字符指针指向存放字符串数组的首元素地址来进行访问.
char *a = &ldquo;nihao&rdquo;;
printf(&quot;%s&rdquo;,a);</p>
<p>在C++中则把字符串封装成了一种数据类型string,可以直接声明变量并进行赋值等字符串操作。以下是C字符串和C++中string的区别：</p>
<pre><code>                             C字符串                 string对象
所需的头文件名称       	&lt;string&gt;或&lt;string.h&gt;        	&lt;string&gt;或&lt;string.h&gt;
为什么需要头文件       	为了使用字符串函数            为了使用string类
如何声明                 char name[20];              string name;
如何初始化               char name[20]=&quot;nihao&quot;;   	string name = &quot;nihao&quot;;
必须声明字符串长度么？		是                          否
使用一个null字符么？     	是                          否
怎样实现字符串赋值      	strcpy(name,&quot;John&quot;);        name = &quot;John&quot;;
其他优点               	更快                        更易于使用，优选方案
可以赋一个比现有字符更 	不能                        可以
长的字符串么？  
</code></pre>
<h3 id="1-c常用字符串函数">(1) C++常用字符串函数</h3>
<pre><code>char s1[]=&quot;I am a student&quot;;
char s2[20]=&quot;teacher&quot;;
char s3[]=&quot;student&quot;;
int result;
char s4[20],*p;
</code></pre>
<ol>
<li>
<p>串长度 int strlen(char *str)</p>
<p>cout&laquo;strlen(s1)&laquo;endl; 输出14
cout&laquo;strlen(s2)&laquo;endl; 输出7</p>
</li>
<li>
<p>串拷贝 char *strcpy(char *str1,char *str2)</p>
<p>strcpy(s4,s2);   //s4为&quot;teacher&quot;</p>
</li>
<li>
<p>串连接 char *strcat(char <em>str1,char</em>str2)</p>
<p>strcat(s2,s3); //s2为&quot;teacherstudent&quot;</p>
</li>
<li>
<p>串比较 int strcmp(char *str1,char *str) //比较的是对应字符的ASCII码值，如果str1&gt;str2,返回1</p>
<p>result=strcmp(s2,s3);   //result&gt;0
result=strcmp(s2,s2);   //result=0
result=strcmp(s3,s2);   //result&lt;0</p>
</li>
<li>
<p>串定位 char *strchr(char *str,char ch)</p>
<p>p=strchr(s1,&rsquo;s');    //找到返回字符在字串中的位置，否则返回-1
strcpy(p,s2);      //s1为&quot;I am a teacher&quot;</p>
</li>
<li>
<p>在一个串中查找是否存在和另一个串相等的子串</p>
</li>
<li>
<p>截取子串形成一个新串</p>
</li>
</ol>
<h3 id="2-字符串的输入">(2) 字符串的输入</h3>
<ol>
<li>
<p>方法一：使用输入操符来填充一个C字符串变量
例如：
char a[80];
cin&raquo;a;
注：以这种方式来读取C字符串时，会忽略最初的空白字符(空格、制表符和换行符)，而且输入会在下一个空格或者换行符处停止。</p>
</li>
<li>
<p>方法二：使用预定义函数getline获取整行输入(包括空格)
getline函数有两个参数：第一个参数用于接收输入的C字符串变量；第二个参数用于规定getline最多能接收的字符个数。
例如:
char a[80];
cin.getline(a,80);
当遇到行结束的时候，输入才会停止。</p>
</li>
</ol>
<h3 id="3-c-string类的输入">(3) C++ string类的输入</h3>
<ol>
<li>方法一：和C字符串输入的方法一相同。</li>
<li>方法二：使用getline函数。</li>
</ol>
<p>例如：</p>
<pre><code>string a;
getline(cin,a);
</code></pre>
<h3 id="4-string对象和c字符串之间的转换">(4) string对象和C字符串之间的转换</h3>
<p>可以将C字符串存储在string类型的变量中，例如：</p>
<pre><code>char a[] = &quot;nihao&quot;;
string b;
b=a;
</code></pre>
<p>但string对象不能自动的转换为C字符串，需要进行显式的类型转换，需要用到string类的成员函数c_str().
例如：</p>
<pre><code>strcpy(a,b.c_str());
</code></pre>
<h3 id="5-字符串到数字的转换">(5) 字符串到数字的转换</h3>
<p>atoi函数获取一个C字符串参数，返回对应的int值。如果参数不与一个int值对应，atoi就会返回0。atoi函数在文件为cstdlib的库中。如果数字太大，不能转换成int类型的值，可以使用atol将字符串转换为long类型的值。
例如:</p>
<pre><code>atoi(&quot;1234&quot;);   //返回整数1234
atoi(&quot;#123&quot;);   //返回0
</code></pre>
<h2 id="导航">导航</h2>
<ul>
<li><a href="00.md">目录</a></li>
<li>上一章：<a href="02.md">Chapter 2 - pointers, refrence</a></li>
<li>下一章：<a href="04.md">Chapter 4 - uint8_t, uint16_t, uint32_t, uint64_t</a></li>
</ul>

        
        ]]>
      </description>
    </item>
    
    
    
    <item>
      <title>【转载】C Primer 之 指针和引用</title>
      <link>/post/2021/12/30/cprimer02/</link>
      <pubDate>Thu, 30 Dec 2021 07:12:43 +0800</pubDate>
      <author>罗泽勋</author>
      <guid>/post/2021/12/30/cprimer02/</guid>
      <description>
        <![CDATA[
        <p>转载自<a href="https://github.com/andycai/cprimer">https://github.com/andycai/cprimer</a></p>
<h2 id="21-refrence-引用">2.1 refrence 引用</h2>
<p>引用是C++中的概念，初学者容易把引用和指针混淆一起。以下程序中，n 是 m 的一个引用（reference），m 是被引用物（referent）。</p>
<pre><code>int m; 
int &amp;n = m;
</code></pre>
<p>n 相当于 m 的别名（绰号），对 n 的任何操作就是对m的操作。所以 n 既不是 m 的拷贝，也不是指向 m 的指针，其实 n 就是 m 它自己。</p>
<p><strong>引用的规则：</strong></p>
<ul>
<li>引用被创建的同时必须被初始化（指针则可以在任何时候被初始化）。</li>
<li>不能有NULL引用，引用必须与合法的存储单元关联（指针则可以是NULL）。</li>
<li>一旦引用被初始化，就不能改变引用的关系（指针则可以随时改变所指的对象）。</li>
</ul>
<p>以下示例程序中，k 被初始化为 i 的引用。语句 k = j 并不能将 k 修改成为 j 的引用，只是把 k 的值改变成为6。由于 k 是 i 的引用，所以 i 的值也变成了6。</p>
<pre><code>int i = 5; 
int j = 6; 
int &amp;k = i; 
k = j; // k和i的值都变成了6; 
</code></pre>
<p><strong>引用的主要功能是传递函数的参数和返回值</strong>。</p>
<p>C++语言中，函数的参数和返回值的传递方式有三种：<strong>值传递、指针传递和引用传递</strong>。</p>
<h3 id="1-以下是值传递的示例程序">(1) 以下是&quot;值传递&quot;的示例程序</h3>
<p>由于Func1函数体内的x是外部变量n的一份拷贝，改变x的值不会影响n, 所以n的值仍然是0。</p>
<pre><code>void Func1(int x) 
{ 
	x = x + 10; 
} 
... 
int n = 0; 
Func1(n); 
cout &lt;&lt; &quot;n = &quot; &lt;&lt; n &lt;&lt; endl; // n = 0 
</code></pre>
<h3 id="2-以下是指针传递的示例程序">(2) 以下是&quot;指针传递&quot;的示例程序</h3>
<p>由于Func2函数体内的x是指向外部变量n的指针，改变该指针的内容将导致n的值改变，所以n的值成为10。</p>
<pre><code>void Func2(int *x) 
{ 
	(* x) = (* x) + 10; 
} 
... 
int n = 0; 
Func2(&amp;n); 
cout &lt;&lt; &quot;n = &quot; &lt;&lt; n &lt;&lt; endl; // n = 10 
</code></pre>
<h3 id="3-以下是引用传递的示例程序">(3) 以下是&quot;引用传递&quot;的示例程序</h3>
<p>由于Func3函数体内的x是外部变量n的引用，x和n是同一个东西，改变x等于改变n，所以n的值成为10。</p>
<pre><code>void Func3(int &amp;x) 
{ 
	x = x + 10; 
} 
... 
int n = 0; 
Func3(n); 
cout &lt;&lt; &quot;n = &quot; &lt;&lt; n &lt;&lt; endl; // n = 10 
</code></pre>
<p>对比上述三个示例程序，<strong>会发现&quot;引用传递&quot;的性质象&quot;指针传递&quot;，而书写方式象&quot;值传递&quot;</strong>。</p>
<p>实际上&quot;引用&quot;可以做的任何事情&quot;指针&quot;也都能够做，为什么还要&quot;引用&quot;这东西？
答案是&quot;用适当的工具做恰如其分的工作&quot;。</p>
<p>指针能够毫无约束地操作内存中的任何东西，尽管指针功能强大，但是非常危险。</p>
<p>如果的确只需要借用一下某个对象的&quot;别名&quot;，那么就用&quot;引用&quot;，而不要用&quot;指针&quot;，以免发生意外。</p>
<h2 id="导航">导航</h2>
<ul>
<li><a href="00.md">目录</a></li>
<li>上一章：<a href="01.md">Chapter 1 - const, inline，static, this</a></li>
<li>下一章：<a href="03.md">Chapter 3 - char*, char[], string</a></li>
</ul>

        
        ]]>
      </description>
    </item>
    
    
    
    <item>
      <title>【转载】C Primer 之 const, inline, static, this</title>
      <link>/post/2021/12/30/cprimer01/</link>
      <pubDate>Thu, 30 Dec 2021 07:12:38 +0800</pubDate>
      <author>罗泽勋</author>
      <guid>/post/2021/12/30/cprimer01/</guid>
      <description>
        <![CDATA[
        <p>转载自<a href="https://github.com/andycai/cprimer">https://github.com/andycai/cprimer</a></p>
<h2 id="11-const">1.1 const</h2>
<h3 id="1-const-基础">(1) const 基础</h3>
<p>如果const关键字不涉及到指针，我们很好理解，下面是涉及到指针的情况：</p>
<pre><code>int b = 500;
const int* a = &amp;b; [1]
int const *a = &amp;b; [2]
int* const a = &amp;b; [3]
const int* const a = &amp;b; [4]
</code></pre>
<p>如果你能区分出上述四种情况，那么，恭喜你，你已经迈出了可喜的一步。不知道，也没关系，我们可以参考《Effective c++》Item21上的做法，
如果 const 位于星号的左侧，则 const 就是用来修饰指针所指向的变量，即指针指向为常量；如果 const 位于星号的右侧，const 就是修饰指针本身，即指针本身是常量。</p>
<p>因此，[1]和[2]的情况相同，都是指针所指向的内容为常量（const放在变量声明符的位置无关），这种情况下不允许对内容进行更改操作，如不能*a = 3；[3]为指针本身是常量，而指针所指向的内容不是常量，这种情况下不能对指针本身进行更改操作，如a++是错误的；[4]为指针本身和指向的内容均为常量。</p>
<h3 id="2-作为参数">(2) 作为参数</h3>
<pre><code>void display(const double&amp; r);
void display(const double* r);
</code></pre>
<p>说明:</p>
<ol>
<li>在引用或者指针参数的时候使用 const 限制是有意义的，而对于值传递的参数使用 const 则没有意义</li>
<li>保证引用的变量的值不被改变</li>
<li>const 在 double 前或者后面意思相同，只是不同的人的写法不同</li>
</ol>
<h3 id="3-const对象">(3) const对象</h3>
<p>声明为 const 的对象只能访问类中声明为 const 的成员函数，不能调用其它成员函数。</p>
<h3 id="4-const成员函数">(4) const成员函数</h3>
<pre><code>类型说明符 函数名(参数表) const;
void print(int i) const;
</code></pre>
<p>说明:</p>
<ol>
<li>const 是函数类型的一个组成部分，因此在实现部分也要带 const 关键字</li>
<li>常成员函数不能更新对象的数据成员，也不能调用该类中没有用 const 修饰的成员函数</li>
</ol>
<h3 id="5-使用const的一些建议">(5) 使用const的一些建议</h3>
<ol>
<li>要大胆的使用 const，这将给你带来无尽的益处，但前提是你必须搞清楚原委</li>
<li>要避免最一般的赋值操作错误，如将 const 变量赋值，具体可见思考题</li>
<li>在参数中使用 const 应该使用引用或指针，而不是一般的对象实例，原因同上</li>
<li>const 在成员函数中的三种用法（参数、返回值、函数）要很好的使用</li>
<li>不要轻易的将函数的返回值类型定为 const</li>
<li>除了重载操作符外一般不要将返回值类型定为对某个对象的 const 引用</li>
</ol>
<h2 id="12-inline">1.2 inline</h2>
<h3 id="1-预处理宏">(1) 预处理宏</h3>
<p>介绍内联函数之前，有必要介绍一下预处理宏。内联函数的功能和预处理宏的功能相似。相信大家都用过预处理宏，我们会经常定义一些宏，如：</p>
<pre><code>#define TABLE_COMP(x) ((x)&gt;0 ? (x) : 0) 
</code></pre>
<p>就定义了一个宏。</p>
<p>为什么要使用宏呢？因为函数的调用必须要将程序执行的顺序转移到函数所存放在内存中的某个地址，将函数的程序内容执行完后，再返回到转去执行该函数前的地方。这种转移操作要求在转去执行前要保存现场并记忆执行的地址，转回后要恢复现场，并按原来保存地址继续执行。因此，函数调用要有一定的时间和空间方面的开销，于是将影响其效率。而宏只是在预处理的地方把代码展开，不需要额外的空间和时间方面的开销，所以调用一个宏比调用一个函数更有效率。</p>
<p>但是宏也有很多的不尽人意的地方。</p>
<ol>
<li>宏不能访问对象的私有成员。</li>
<li>宏的定义很容易产生二意性。</li>
</ol>
<p>我们举个例子：</p>
<pre><code>#define TABLE_MULTI(x) (x*x) 
</code></pre>
<p>我们用一个数字去调用它，TABLE_MULTI(10)，这样看上去没有什么错误，结果返回100，是正确的，但是如果我们用TABLE_MULTI(10+10)去调用的话，我们期望的结果是400，而宏的调用结果是(10+10*10+10)，结果是120，这显然不是我们要得到的结果。避免这些错误的方法，<strong>一定要给宏的参数都加上括号</strong>。</p>
<pre><code>#define TABLE_MULTI(x) ((x)*(x)) 
</code></pre>
<p>这样可以确保不会出错，但是，即使使用了这种定义，这个宏依然有可能出错，例如使用TABLE_MULTI(a++)调用它，他们本意是希望得到(a+1)<em>(a+1)的结果，而实际上呢？我们可以看看宏的展开结果: (a++)</em>(a++)，如果a的值是４，我们得到的结果是5<em>6=30。而我们期望的结果是5</em>5=25,这又出现了问题。事实上，在一些C的库函数中也有这些问题。例如: Toupper(*pChar++)就会对pChar执行两次++操作，因为Toupper实际上也是一个宏。</p>
<h3 id="2-inline-函数">(2) inline 函数</h3>
<p>我们可以看到宏有一些难以避免的问题，怎么解决呢？</p>
<p>下面就是用我要介绍的内联函数来解决这些问题，我们可以使用内联函数来取代宏的定义。而且事实上我们可以用内联函数完全取代预处理宏。</p>
<p>内联函数和宏的区别在于，宏是由预处理器对宏进行替代，而内联函数是通过编译器控制来实现的。而且内联函数是真正的函数，只是在需要用到的时候，内联函数像宏一样的展开，所以取消了函数的参数压栈，减少了调用的开销。你可以象调用函数一样来调用内联函数，而不必担心会产生于处理宏的一些问题。</p>
<p>我们可以用 inline 来定义内联函数，不过，<strong>任何在类的声明部分定义的函数都会被自动的认为是内联函数</strong>。</p>
<p>在函数声明或定义中函数返回类型前加上关键字 inline 即把min（）指定为内联。</p>
<pre><code>inline int min(int first, int secend) {/****/};
</code></pre>
<p>我们可以把它作为一般的函数一样调用。但是执行速度确比一般函数的执行速度要快。inline 函数对编译器而言必须是可见的，以便它能够在调用点内展开该函数。与非inline函数不同的是，inline函数必须在调用该函数的每个文本文件中定义。当然，对于同一程序的不同文件，如果C++ inline函数出现的话，其定义必须相同。</p>
<p>对于由两个文件compute.c和draw.c构成的程序来说，程序员不能定义这样的min()函数，它在compute.c中指一件事情，而在draw.c中指另外一件事情。如果两个定义不相同，程序将会有未定义的行为。</p>
<p>为保证不会发生这样的事情，建议把inline函数的定义放到头文件中。在每个调用该inline函数的文件中包含该头文件。这种方法保证对每个inline函数只有一个定义，且程序员无需复制代码，并且不可能在程序的生命期中引起无意的不匹配的事情。</p>
<h3 id="3-inline-函数的编程风格">(3) inline 函数的编程风格</h3>
<p>关键字inline 必须与函数定义体放在一起才能使函数成为内联，仅将 inline 放在函数声明前面不起任何作用。如下风格的函数Foo 不能成为内联函数：</p>
<pre><code>inline void Foo(int x, int y);   
// inline 仅与函数声明放在一起   
void Foo(int x, int y){}  
</code></pre>
<p>而如下风格的函数Foo 则成为内联函数：</p>
<pre><code>void Foo(int x, int y);   
inline void Foo(int x, int y)   
// inline 与函数定义体放在一起{} 
</code></pre>
<p>所以说，C++ inline函数是一种“用于实现的关键字”，而不是一种“用于声明的关键字”。一般地，用户可以阅读函数的声明，但是看不到函数的定义。尽管在大多数教科书中内联函数的声明、定义体前面都加了inline 关键字，但我认为inline 不应该出现在函数的声明中。这个细节虽然不会影响函数的功能，但是体现了高质量C++/C 程序设计风格的一个基本原则：声明与定义不可混为一谈，用户没有必要、也不应该知道函数是否需要内联。</p>
<p>定义在类声明之中的成员函数将自动地成为内联函数，例如：</p>
<pre><code>class A  
{  
public:
	void Foo(int x, int y) { }   
	// 自动地成为内联函数  
} 
</code></pre>
<p>将成员函数的定义体放在类声明之中虽然能带来书写上的方便，但不是一种良好的编程风格，上例应该改成：</p>
<pre><code>// 头文件  
class A  
{  
public:  
	void Foo(int x, int y);  
}  
// 定义文件  
inline void A::Foo(int x, int y){}  
</code></pre>
<p>内联函数在C++类中，应用最广的，应该是用来定义存取函数。我们定义的类中一般会把数据成员定义成私有的或者保护的，这样，外界就不能直接读写我们类成员的数据了。对于私有或者保护成员的读写就必须使用成员接口函数来进行。如果我们把这些读写成员函数定义成内联函数的话，将会获得比较好的效率。</p>
<pre><code>Class sample {
Private:
	int nTest;
Public:
	int readtest(){ return nTest;}
	Void settest(int I) {nTest=I;}
} 
</code></pre>
<p>当然，内联函数也有一定的局限性。就是函数中的执行代码不能太多了，如果，<strong>内联函数的函数体过大，一般的编译器会放弃内联方式</strong>，而采用普通的方式调用函数。这样，内联函数就和普通函数执行效率一样了。</p>
<h2 id="13-static">1.3 static</h2>
<h3 id="1-隐藏">(1) 隐藏</h3>
<p>当我们同时编译多个文件时，所有未加 static 前缀的全局变量和函数都具有全局可见性。</p>
<h3 id="2-保持变量内容的持久">(2) 保持变量内容的持久</h3>
<p>存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。共有两种变量存储在静态存储区：全局变量和 static 变量，只不过和全局变量比起来，static 可以控制变量的可见范围，说到底 static 还是用来隐藏的。</p>
<h3 id="3-默认初始化为-0">(3) 默认初始化为 0</h3>
<p>其实全局变量也具备这一属性，因为全局变量也存储在静态数据区。在静态数据区，内存中所有的字节默认值都是 <strong>0x00</strong>，某些时候这一特点可以减少程序员的工作量。</p>
<h2 id="14-this-指针">1.4 this 指针</h2>
<p>先要理解class的意思。class应该理解为一种类型，像int和char一样，是用户自定义的类型。（虽然比 int 和 char 这样 built-in 类型复杂的多，但首先要理解它们一样是类型)。用这个类型可以来声明一个变量，比如int x, myclass my等等。这样就像变量 x 具有 int 类型一样，变量 my 具有 myclass 类型。</p>
<p>理解了这个，就好解释 this 了，my 里的 this 就是指向 my 的指针。如果还有一个变量myclass mz，mz 的 this 就是指向 mz 的指针。这样就很容易理解this 的类型应该是 myclass *，而对其的解引用 *this 就应该是一个 myclass 类型的变量。</p>
<p>通常在class定义时要用到类型变量自身时，因为这时候还不知道变量名（为了通用也不可能固定实际的变量名），就用this这样的指针来使用变量自身。</p>
<h3 id="1-this指针的用处">(1) this指针的用处</h3>
<p>一个对象的 this 指针并不是对象本身的一部分，不会影响sizeof(对象)的结果。this作用域是在类内部，当在类的非静态成员函数中访问类的非静态成员的时候，编译器会自动将对象本身的地址作为一个隐含参数传递给函数。也就是说，即使你没有写上 this 指针，编译器在编译的时候也是加上 this 的，它作为非静态成员函数的隐含形参，对各成员的访问均通过 this 进行。</p>
<p>例如，调用 date.SetMonth(9) &lt;===&gt; SetMonth(&amp;date, 9)，this帮助完成了这一转换。</p>
<h3 id="2-this指针的使用">(2) this指针的使用</h3>
<p>一种情况就是，在类的非静态成员函数中返回类对象本身的时候，直接使用 return *this；另外一种情况是当参数与成员变量名相同时，如this-&gt;n = n （不能写成n = n）。</p>
<h3 id="3-this指针程序示例">(3) this指针程序示例</h3>
<p>this指针是存在与类的成员函数中,指向被调用函数所在的类实例的地址。根据以下程序来说明 this 指针：</p>
<pre><code>#include&lt;iostream.h&gt;
class Point
{ 
  int x, y;
public:
  Point(int a, int b) { x=a; y=b;}
  Void MovePoint( int a, int b){ x+=a; y+=b;}
  Void print(){ cout&lt;&lt;&quot;x=&quot;&lt;&lt;x&lt;&lt;&quot;y=&quot;&lt;&lt;y&lt;&lt;endl;}
};
void main( )
{
   Point point1( 10,10);
   point1.MovePoint(2,2);
   point1.print( );
}
</code></pre>
<p>当对象 point1 调用 MovePoint(2,2) 函数时，即将 point1 对象的地址传递给了 this 指针。</p>
<p>MovePoint 函数的原型应该是 void MovePoint( Point *this, int a, int b);第一个参数是指向该类对象的一个指针，我们在定义成员函数时没看见是因为这个参数在类中是隐含的。这样point1的地址传递给了 this，所以在 MovePoint 函数中便显式的写成：</p>
<pre><code>void MovePoint(int a, int b) { this-&gt;x +=a; this-&gt; y+= b;}
</code></pre>
<p>即可以知道，point1调用该函数后，也就是point1的数据成员被调用并更新了值。即该函数过程可写成 point1.x+= a; point1. y + = b;</p>
<h3 id="4-关于this指针的一个精典回答">(4) 关于this指针的一个精典回答</h3>
<p>当你进入一个房子后，你可以看见桌子、椅子、地板等，但是房子你是看不到全貌了。对于一个类的实例来说，你可以看到它的成员函数、成员变量，但是实例本身呢？this 是一个指针，它时时刻刻指向你这个实例本身。</p>
<h2 id="导航">导航</h2>
<ul>
<li><a href="00.md">目录</a></li>
<li>下一章：<a href="02.md">Chapter 2 - pointers, refrence</a></li>
</ul>

        
        ]]>
      </description>
    </item>
    
    
    
    <item>
      <title>【转载】面向对象设计原则之开闭原则</title>
      <link>/post/2021/12/28/oop/</link>
      <pubDate>Tue, 28 Dec 2021 08:07:08 +0800</pubDate>
      <author>罗泽勋</author>
      <guid>/post/2021/12/28/oop/</guid>
      <description>
        <![CDATA[
        <p>转载自<a href="https://blog.csdn.net/lovelion/article/details/17517213">https://blog.csdn.net/lovelion/article/details/17517213</a></p>
<p>开闭原则是面向对象的可复用设计的第一块基石，它是最重要的面向对象设计原则。开闭原则由Bertrand  Meyer于1988年提出，其定义如下：</p>
<blockquote>
<p>开闭原则(Open-Closed Principle, OCP)：一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。</p>
</blockquote>
<p>在开闭原则的定义中，软件实体可以指一个软件模块、一个由多个类组成的局部结构或一个独立的类。</p>
<p>任何软件都需要面临一个很重要的问题，即它们的需求会随时间的推移而发生变化。当软件系统需要面对新的需求时，我们应该尽量保证系统的设计框架是稳定的。如果一个软件设计符合开闭原则，那么可以非常方便地对系统进行扩展，而且在扩展时无须修改现有代码，使得软件系统在拥有适应性和灵活性的同时具备较好的稳定性和延续性。随着软件规模越来越大，软件寿命越来越长，软件维护成本越来越高，设计满足开闭原则的软件系统也变得越来越重要。</p>
<p>为了满足开闭原则，需要对系统进行抽象化设计，抽象化是开闭原则的关键。在Java、C#等编程语言中，可以为系统定义一个相对稳定的抽象层，而将不同的实现行为移至具体的实现层中完成。在很多面向对象编程语言中都提供了接口、抽象类等机制，可以通过它们定义系统的抽象层，再通过具体类来进行扩展。如果需要修改系统的行为，无须对抽象层进行任何改动，只需要增加新的具体类来实现新的业务功能即可，实现在不修改已有代码的基础上扩展系统的功能，达到开闭原则的要求。</p>
<blockquote>
<p>Sunny软件公司开发的CRM系统可以显示各种类型的图表，如饼状图和柱状图等，为了支持多种图表显示方式，原始设计方案如图1所示：</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2021-12-28/ocp1.jpg" alt="img"></p>
<p>图1 初始设计方案结构图</p>
<p>在ChartDisplay类的display()方法中存在如下代码片段：</p>
<pre tabindex="0"><code>......
if (type.equals(&quot;pie&quot;)) {
PieChart chart = new PieChart();
chart.display();
}
else if (type.equals(&quot;bar&quot;)) {
BarChart chart = new BarChart();
chart.display();
}
......
</code></pre><p>在该代码中，如果需要增加一个新的图表类，如折线图LineChart，则需要修改ChartDisplay类的display()方法的源代码，增加新的判断逻辑，违反了开闭原则。</p>
<p>现对该系统进行重构，使之符合开闭原则。</p>
<p>在本实例中，由于在ChartDisplay类的display()方法中针对每一个图表类编程，因此增加新的图表类不得不修改源代码。可以通过抽象化的方式对系统进行重构，使之增加新的图表类时无须修改源代码，满足开闭原则。具体做法如下：</p>
<p>(1) 增加一个抽象图表类AbstractChart，将各种具体图表类作为其子类；</p>
<p>(2)  ChartDisplay类针对抽象图表类进行编程，由客户端来决定使用哪种具体图表。</p>
<p>重构后结构如图2所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2021-12-28/ocp2.jpg" alt="img"></p>
<p>图2 重构后的结构图</p>
<p>在图2中，我们引入了抽象图表类AbstractChart，且ChartDisplay针对抽象图表类进行编程，并通过setChart()方法由客户端来设置实例化的具体图表对象，在ChartDisplay的display()方法中调用chart对象的display()方法显示图表。如果需要增加一种新的图表，如折线图LineChart，只需要将LineChart也作为AbstractChart的子类，在客户端向ChartDisplay中注入一个LineChart对象即可，无须修改现有类库的源代码。</p>
<p>注意：因为xml和properties等格式的配置文件是纯文本文件，可以直接通过VI编辑器或记事本进行编辑，且无须编译，因此在软件开发中，一般不把对配置文件的修改认为是对系统源代码的修改。如果一个系统在扩展时只涉及到修改配置文件，而原有的Java代码或C#代码没有做任何修改，该系统即可认为是一个符合开闭原则的系统。</p>

        
        ]]>
      </description>
    </item>
    
    
    
    <item>
      <title>【转载】面向对象设计原则之单一职责原则</title>
      <link>/post/2021/12/28/singleresponsibility/</link>
      <pubDate>Tue, 28 Dec 2021 07:40:16 +0800</pubDate>
      <author>罗泽勋</author>
      <guid>/post/2021/12/28/singleresponsibility/</guid>
      <description>
        <![CDATA[
        <p>转载自<a href="https://blog.csdn.net/lovelion/article/details/17517213">https://blog.csdn.net/lovelion/article/details/17517213</a></p>
<p>单一职责原则是最简单的面向对象设计原则，它用于控制类的粒度大小。单一职责原则定义如下：</p>
<p>单一职责原则(Single Responsibility Principle, SRP)：一个类只负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。</p>
<p>单一职责原则告诉我们：一个类不能太“累”！在软件系统中，一个类（大到模块，小到方法）承担的职责越多，它被复用的可能性就越小，而且一个类承担的职责过多，就相当于将这些职责耦合在一起，当其中一个职责变化时，可能会影响其他职责的运作，因此要将这些职责进行分离，将不同的职责封装在不同的类中，即将不同的变化原因封装在不同的类中，如果多个职责总是同时发生改变则可将它们封装在同一类中。</p>
<p>单一职责原则是实现高内聚、低耦合的指导方针，它是最简单但又最难运用的原则，需要设计人员发现类的不同职责并将其分离，而发现类的多重职责需要设计人员具有较强的分析设计能力和相关实践经验。</p>
<p>下面通过一个简单实例来进一步分析单一职责原则：</p>
<blockquote>
<p>Sunny软件公司开发人员针对某CRM（Customer Relationship  Management，客户关系管理）系统中客户信息图形统计模块提出了如图1所示初始设计方案：</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2021-12-28/srp.jpg" alt="img">
图1  初始设计方案结构图</p>
<blockquote>
<p>在图1中，CustomerDataChart类中的方法说明如下：getConnection()方法用于连接数据库，findCustomers()用于查询所有的客户信息，createChart()用于创建图表，displayChart()用于显示图表。</p>
</blockquote>
<p>现使用单一职责原则对其进行重构。</p>
<p>在图1中，CustomerDataChart类承担了太多的职责，既包含与数据库相关的方法，又包含与图表生成和显示相关的方法。如果在其他类中也需要连接数据库或者使用findCustomers()方法查询客户信息，则难以实现代码的重用。无论是修改数据库连接方式还是修改图表显示方式都需要修改该类，它不止一个引起它变化的原因，违背了单一职责原则。因此需要对该类进行拆分，使其满足单一职责原则，类CustomerDataChart可拆分为如下三个类：</p>
<p>(1) DBUtil：负责连接数据库，包含数据库连接方法getConnection()；</p>
<p>(2) CustomerDAO：负责操作数据库中的Customer表，包含对Customer表的增删改查等方法，如findCustomers()；</p>
<p>(3) CustomerDataChart：负责图表的生成和显示，包含方法createChart()和displayChart()。</p>
<p>使用单一职责原则重构后的结构如图2所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2021-12-28/srp2.jpg" alt="img">
图2  重构后的结构图</p>

        
        ]]>
      </description>
    </item>
    
    
    
    <item>
      <title>【转载】面向对象设计原则概述</title>
      <link>/post/2021/12/28/oop/</link>
      <pubDate>Tue, 28 Dec 2021 06:59:01 +0800</pubDate>
      <author>罗泽勋</author>
      <guid>/post/2021/12/28/oop/</guid>
      <description>
        <![CDATA[
        <p>转载自<a href="https://blog.csdn.net/lovelion/article/details/17517213">https://blog.csdn.net/lovelion/article/details/17517213</a></p>
<p>对于面向对象软件系统的设计而言，在支持可维护性的同时，提高系统的可复用性是一个至关重要的问题，如何同时提高一个软件系统的可维护性和可复用性是面向对象设计需要解决的核心问题之一。在面向对象设计中，可维护性的复用是以设计原则为基础的。每一个原则都蕴含一些面向对象设计的思想，可以从不同的角度提升一个软件结构的设计水平。</p>
<p>面向对象设计原则为支持可维护性复用而诞生，这些原则蕴含在很多设计模式中，它们是从许多设计方案中总结出的指导性原则。面向对象设计原则也是我们用于评价一个设计模式的使用效果的重要指标之一，在设计模式的学习中，大家经常会看到诸如“XXX模式符合XXX原则”、“XXX模式违反了XXX原则”这样的语句。</p>
<p>最常见的7种面向对象设计原则如下表所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2021-12-28/oop.png" alt="img"></p>

        
        ]]>
      </description>
    </item>
    
    
    
    <item>
      <title>【转载】简单工厂模式</title>
      <link>/post/2021/12/28/singlefactory/</link>
      <pubDate>Tue, 28 Dec 2021 06:50:56 +0800</pubDate>
      <author>罗泽勋</author>
      <guid>/post/2021/12/28/singlefactory/</guid>
      <description>
        <![CDATA[
        <p>转载自<a href="https://blog.csdn.net/lovelion/article/details/17517213">https://blog.csdn.net/lovelion/article/details/17517213</a></p>
<p>工厂模式是最常用的一类创建型设计模式，通常我们所说的工厂模式是指工厂方法模式，它也是使用频率最高的工厂模式。本章将要学习的简单工厂模式是工厂方法模式的“小弟”，它不属于GoF 23种设计模式，但在软件开发中应用也较为频繁，通常将它作为学习其他工厂模式的入门。此外，工厂方法模式还有一位“大哥”——抽象工厂模式。这三种工厂模式各具特色，难度也逐个加大，在软件开发中它们都得到了广泛的应用，成为面向对象软件中常用的创建对象的工具。</p>
<h3 id="一图表库的设计">一、图表库的设计</h3>
<blockquote>
<p>Sunny软件公司欲基于Java语言开发一套图表库，该图表库可以为应用系统提供各种不同外观的图表，例如柱状图、饼状图、折线图等。Sunny软件公司图表库设计人员希望为应用系统开发人员提供一套灵活易用的图表库，而且可以较为方便地对图表库进行扩展，以便能够在将来增加一些新类型的图表。</p>
</blockquote>
<p>Sunny软件公司图表库设计人员提出了一个初始设计方案，将所有图表的实现代码封装在一个Chart类中，其框架代码如下所示：</p>
<pre tabindex="0"><code>class Chart {
private String type; //图表类型

public Chart(Object[][] data, String type) {
this.type = type;
if (type.equalsIgnoreCase(&quot;histogram&quot;)) {
    //初始化柱状图
}
else if (type.equalsIgnoreCase(&quot;pie&quot;)) {
    //初始化饼状图
}
else if (type.equalsIgnoreCase(&quot;line&quot;)) {
    //初始化折线图
}
}

public void display() {
if (this.type.equalsIgnoreCase(&quot;histogram&quot;)) {
    //显示柱状图
}
else if (this.type.equalsIgnoreCase(&quot;pie&quot;)) {
    //显示饼状图
}
else if (this.type.equalsIgnoreCase(&quot;line&quot;)) {
    //显示折线图
}	
}
}
</code></pre><p>客户端代码通过调用Chart类的构造函数来创建图表对象，根据参数type的不同可以得到不同类型的图表，然后再调用display()方法来显示相应的图表。</p>
<p>不难看出，Chart类是一个“巨大的”类，在该类的设计中存在如下几个问题：</p>
<p>(1) 在Chart类中包含很多“if…else…”代码块，整个类的代码相当冗长，代码越长，阅读难度、维护难度和测试难度也越大；而且大量条件语句的存在还将影响系统的性能，程序在执行过程中需要做大量的条件判断。</p>
<p>(2) Chart类的职责过重，它负责初始化和显示所有的图表对象，将各种图表对象的初始化代码和显示代码集中在一个类中实现，违反了“单一职责原则”，不利于类的重用和维护；而且将大量的对象初始化代码都写在构造函数中将导致构造函数非常庞大，对象在创建时需要进行条件判断，降低了对象创建的效率。</p>
<p>(3) 当需要增加新类型的图表时，必须修改Chart类的源代码，违反了“开闭原则”。</p>
<p>(4) 客户端只能通过new关键字来直接创建Chart对象，Chart类与客户端类耦合度较高，对象的创建和使用无法分离。</p>
<p>(5) 客户端在创建Chart对象之前可能还需要进行大量初始化设置，例如设置柱状图的颜色、高度等，如果在Chart类的构造函数中没有提供一个默认设置，那就只能由客户端来完成初始设置，这些代码在每次创建Chart对象时都会出现，导致代码的重复。</p>
<p>面对一个如此巨大、职责如此重，且与客户端代码耦合度非常高的类，我们应该怎么办？本章将要介绍的简单工厂模式将在一定程度上解决上述问题。</p>
<h3 id="二简单工厂模式概述">二、简单工厂模式概述</h3>
<p>简单工厂模式并不属于GoF 23个经典设计模式，但通常将它作为学习其他工厂模式的基础，它的设计思想很简单，其基本流程如下：</p>
<p>首先将需要创建的各种不同对象（例如各种不同的Chart对象）的相关代码封装到不同的类中，这些类称为具体产品类，而将它们公共的代码进行抽象和提取后封装在一个抽象产品类中，每一个具体产品类都是抽象产品类的子类；然后提供一个工厂类用于创建各种产品，在工厂类中提供一个创建产品的工厂方法，该方法可以根据所传入的参数不同创建不同的具体产品对象；客户端只需调用工厂类的工厂方法并传入相应的参数即可得到一个产品对象。</p>
<p>简单工厂模式定义如下：</p>
<p>简单工厂模式(Simple Factory Pattern)：定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。因为在简单工厂模式中用于创建实例的方法是静态(static)方法，因此简单工厂模式又被称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。</p>
<p>简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。简单工厂模式结构比较简单，其核心是工厂类的设计，其结构如图1所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2021-12-28/factory1.jpeg" alt="img"></p>
<p>在简单工厂模式结构图中包含如下几个角色：</p>
<ul>
<li>
<p>Factory（工厂角色）：工厂角色即工厂类，它是简单工厂模式的核心，负责实现创建所有产品实例的内部逻辑；工厂类可以被外界直接调用，创建所需的产品对象；在工厂类中提供了静态的工厂方法factoryMethod()，它的返回类型为抽象产品类型Product。</p>
</li>
<li>
<p>Product（抽象产品角色）：它是工厂类所创建的所有对象的父类，封装了各种产品对象的公有方法，它的引入将提高系统的灵活性，使得在工厂类中只需定义一个通用的工厂方法，因为所有创建的具体产品对象都是其子类对象。</p>
</li>
<li>
<p>ConcreteProduct（具体产品角色）：它是简单工厂模式的创建目标，所有被创建的对象都充当这个角色的某个具体类的实例。每一个具体产品角色都继承了抽象产品角色，需要实现在抽象产品中声明的抽象方法。</p>
</li>
</ul>
<p>在简单工厂模式中，客户端通过工厂类来创建一个产品类的实例，而无须直接使用new关键字来创建对象，它是工厂模式家族中最简单的一员。</p>
<p>在使用简单工厂模式时，首先需要对产品类进行重构，不能设计一个包罗万象的产品类，而需根据实际情况设计一个产品层次结构，将所有产品类公共的代码移至抽象产品类，并在抽象产品类中声明一些抽象方法，以供不同的具体产品类来实现，典型的抽象产品类代码如下所示：</p>
<pre tabindex="0"><code>abstract class Product {
//所有产品类的公共业务方法
public void methodSame() {
//公共方法的实现
}

//声明抽象业务方法
public abstract void methodDiff();
}

</code></pre><p>在具体产品类中实现了抽象产品类中声明的抽象业务方法，不同的具体产品类可以提供不同的实现，典型的具体产品类代码如下所示：</p>
<pre tabindex="0"><code>class ConcreteProduct extends Product {
//实现业务方法
public void methodDiff() {
//业务方法的实现
}
}
</code></pre><p>简单工厂模式的核心是工厂类，在没有工厂类之前，客户端一般会使用new关键字来直接创建产品对象，而在引入工厂类之后，客户端可以通过工厂类来创建产品，在简单工厂模式中，工厂类提供了一个静态工厂方法供客户端使用，根据所传入的参数不同可以创建不同的产品对象，典型的工厂类代码如下所示：</p>
<pre tabindex="0"><code>class Factory {
//静态工厂方法
public static Product getProduct(String arg) {
Product product = null;
if (arg.equalsIgnoreCase(&quot;A&quot;)) {
    product = new ConcreteProductA();
    //初始化设置product
}
else if (arg.equalsIgnoreCase(&quot;B&quot;)) {
    product = new ConcreteProductB();
    //初始化设置product
}
return product;
}
}
</code></pre><p>在客户端代码中，我们通过调用工厂类的工厂方法即可得到产品对象，典型代码如下所示：</p>
<pre tabindex="0"><code>class Client {
public static void main(String args[]) {
Product product; 
product = Factory.getProduct(&quot;A&quot;); //通过工厂类创建产品对象
product.methodSame();
product.methodDiff();
}
}
</code></pre><h3 id="三完整解决方案">三、完整解决方案</h3>
<p>为了将Chart类的职责分离，同时将Chart对象的创建和使用分离，Sunny软件公司开发人员决定使用简单工厂模式对图表库进行重构，重构后的结构如图2所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2021-12-28/factory2.jpeg" alt="img"></p>
<p>在上图中，Chart接口充当抽象产品类，其子类HistogramChart、PieChart和LineChart充当具体产品类，ChartFactory充当工厂类。完整代码如下所示：</p>
<pre tabindex="0"><code>//抽象图表接口：抽象产品类
interface Chart {
public void display();
}

//柱状图类：具体产品类
class HistogramChart implements Chart {
public HistogramChart() {
System.out.println(&quot;创建柱状图！&quot;);
}

public void display() {
System.out.println(&quot;显示柱状图！&quot;);
}
}

//饼状图类：具体产品类
class PieChart implements Chart {
public PieChart() {
System.out.println(&quot;创建饼状图！&quot;);
}

public void display() {
System.out.println(&quot;显示饼状图！&quot;);
}
}

//折线图类：具体产品类
class LineChart implements Chart {
public LineChart() {
System.out.println(&quot;创建折线图！&quot;);
}

public void display() {
System.out.println(&quot;显示折线图！&quot;);
}
}

//图表工厂类：工厂类
class ChartFactory {
//静态工厂方法
public static Chart getChart(String type) {
Chart chart = null;
if (type.equalsIgnoreCase(&quot;histogram&quot;)) {
    chart = new HistogramChart();
    System.out.println(&quot;初始化设置柱状图！&quot;);
}
else if (type.equalsIgnoreCase(&quot;pie&quot;)) {
    chart = new PieChart();
    System.out.println(&quot;初始化设置饼状图！&quot;);
}
else if (type.equalsIgnoreCase(&quot;line&quot;)) {
    chart = new LineChart();
    System.out.println(&quot;初始化设置折线图！&quot;);			
}
return chart;
}
}
</code></pre><p>编写如下客户端测试代码：</p>
<pre tabindex="0"><code>class Client {
public static void main(String args[]) {
Chart chart;
chart = ChartFactory.getChart(&quot;histogram&quot;); //通过静态工厂方法创建产品
chart.display();
}
}
</code></pre><p>编译并运行程序，输出结果如下：</p>
<pre tabindex="0"><code>创建柱状图！

初始化设置柱状图！

显示柱状图！
</code></pre><p>在客户端测试类中，我们使用工厂类的静态工厂方法创建产品对象，如果需要更换产品，只需修改静态工厂方法中的参数即可，例如将柱状图改为饼状图，只需将代码：</p>
<pre tabindex="0"><code>chart = ChartFactory.getChart(&quot;histogram&quot;);
</code></pre><p>改为：</p>
<pre tabindex="0"><code>chart = ChartFactory.getChart(&quot;pie&quot;);
</code></pre><p>编译并运行程序，输出结果如下：</p>
<pre tabindex="0"><code>创建饼状图！

初始化设置饼状图！

显示饼状图！
</code></pre><h3 id="四方案的改进">四、方案的改进</h3>
<p>Sunny软件公司开发人员发现在创建具体Chart对象时，每更换一个Chart对象都需要修改客户端代码中静态工厂方法的参数，客户端代码将要重新编译，这对于客户端而言，违反了“开闭原则”，有没有一种方法能够在不修改客户端代码的前提下更换具体产品对象呢？答案是肯定的，下面将介绍一种常用的实现方式。</p>
<p>我们可以将静态工厂方法的参数存储在XML或properties格式的配置文件中，如下config.xml所示：</p>
<pre tabindex="0"><code>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;config&gt;
&lt;chartType&gt;histogram&lt;/chartType&gt;
&lt;/config&gt;
</code></pre><p>再通过一个工具类XMLUtil来读取配置文件中的字符串参数，XMLUtil类的代码如下所示：</p>
<pre tabindex="0"><code>import javax.xml.parsers.*;
import org.w3c.dom.*;
import org.xml.sax.SAXException;
import java.io.*;

public class XMLUtil {
//该方法用于从XML配置文件中提取图表类型，并返回类型名
public static String getChartType() {
try {
    //创建文档对象
    DocumentBuilderFactory dFactory = DocumentBuilderFactory.newInstance();
    DocumentBuilder builder = dFactory.newDocumentBuilder();
    Document doc;							
    doc = builder.parse(new File(&quot;config.xml&quot;)); 

    //获取包含图表类型的文本节点
    NodeList nl = doc.getElementsByTagName(&quot;chartType&quot;);
    Node classNode = nl.item(0).getFirstChild();
    String chartType = classNode.getNodeValue().trim();
    return chartType;
}   
catch(Exception e) {
    e.printStackTrace();
    return null;
}
}
}
</code></pre><p>在引入了配置文件和工具类XMLUtil之后，客户端代码修改如下：</p>
<pre tabindex="0"><code>class Client {
public static void main(String args[]) {
Chart chart;
String type = XMLUtil.getChartType(); //读取配置文件中的参数
chart = ChartFactory.getChart(type); //创建产品对象
chart.display();
}
}
</code></pre><p>不难发现，在上述客户端代码中不包含任何与具体图表对象相关的信息，如果需要更换具体图表对象，只需修改配置文件config.xml，无须修改任何源代码，符合“开闭原则”。</p>
<h3 id="五简单工厂模式的简化">五、简单工厂模式的简化</h3>
<p>有时候，为了简化简单工厂模式，我们可以将抽象产品类和工厂类合并，将静态工厂方法移至抽象产品类中，如图3所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2021-12-28/factory3.jpeg" alt="img"></p>
<p>在图3中，客户端可以通过产品父类的静态工厂方法，根据参数的不同创建不同类型的产品子类对象，这种做法在JDK等类库和框架中也广泛存在。</p>
<h3 id="六简单工厂模式总结">六、简单工厂模式总结</h3>
<p>简单工厂模式提供了专门的工厂类用于创建对象，将对象的创建和对象的使用分离开，它作为一种最简单的工厂模式在软件开发中得到了较为广泛的应用。</p>
<ol>
<li>主要优点</li>
</ol>
<p>简单工厂模式的主要优点如下：</p>
<p>(1) 工厂类包含必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的职责，而仅仅“消费”产品，简单工厂模式实现了对象创建和使用的分离。</p>
<p>(2) 客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以在一定程度减少使用者的记忆量。</p>
<p>(3) 通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。</p>
<ol start="2">
<li>主要缺点</li>
</ol>
<p>简单工厂模式的主要缺点如下：</p>
<p>(1) 由于工厂类集中了所有产品的创建逻辑，职责过重，一旦不能正常工作，整个系统都要受到影响。</p>
<p>(2) 使用简单工厂模式势必会增加系统中类的个数（引入了新的工厂类），增加了系统的复杂度和理解难度。</p>
<p>(3) 系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。</p>
<p>(4) 简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。</p>
<ol start="3">
<li>适用场景</li>
</ol>
<p>在以下情况下可以考虑使用简单工厂模式：</p>
<p>(1) 工厂类负责创建的对象比较少，由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。</p>
<p>(2) 客户端只知道传入工厂类的参数，对于如何创建对象并不关心。</p>

        
        ]]>
      </description>
    </item>
    
    
    
    <item>
      <title>由 hpp 头文件引发 C&#43;&#43; 编译的思考</title>
      <link>/post/2021/12/26/hpp/</link>
      <pubDate>Sun, 26 Dec 2021 12:55:54 +0800</pubDate>
      <author>罗泽勋</author>
      <guid>/post/2021/12/26/hpp/</guid>
      <description>
        <![CDATA[
        <p>前一阵子，我注意到一位项目组新成员喜欢使用 hpp 头文件的方式来写，他解释说很多开源库都是以这样的方式实现，还问我 hpp 头文件和 h + cpp 方式的区别。这个问题很麻烦，解释起来可能需要理一遍 C++ 基础，对此，我劝告他：从本质来说 hpp 是将声明和实现放在一个文件，而 h + cpp 是将声明和实现分开在两个文件，采用 hpp 这种方式也是可以的，但是必须要清楚它的局限。我本来是希望他去学习 C++ 基础，但没想到从这里就埋下了一个坑，导致这篇文章的产生&hellip;..</p>
<p>很快，遇到第一个问题，redefined identifier。我解释说，这是重复 include hpp 文件引入实现，会引发这个重定义的问题。使用 #ifndef 可以防止头文件被重复包含和引入。</p>
<p>过了一阵，又遇到新的问题。我过去一看，循环依赖。第一个坑出现了。A 依赖 B，B 又 依赖 A，如果用 hpp 实现的话，那A、B 都互相包含对方，无尽循环……所以这种情况只能老老实实用回 h + cpp 的方式了，A 依赖 B，就在 A 的头文件中前向声明 B，然后在源文件中 include B，B 也如此操作。</p>
<p>就这样过了很久很久，突然有一天，我发现有很多库都需要重新编译，奇怪的是这些库不应该有改动的。一看是依赖的一个底层动态库发生变化，再看，是这个库里的一个 hpp 文件发生变化。大坑，我最开始的时候提醒过的。 那个库本身就有别的坑，实际上它更应该是静态库，但因为客观原因，它暂时还是一个动态库。然后就这样，一个 hpp 文件被嵌入这个底层动态库对外开放的接口里面。它一改动，所有依赖这个库的库都需要重新编译，还真是“牵一发而动全身”啊。</p>
<h3 id="补充">补充</h3>
<p>一、#include 指令</p>
<pre tabindex="0"><code>#include &quot;test.hpp&quot;
</code></pre><p>C++ 会使用一个预处理器，在进行主编译之前对源文件进行处理，它会在编译程序时自动运行。上面所示 #include &ldquo;test.hpp&rdquo;，该编译指令导致预处理器将 test.hpp 文件的内容添加到程序中。实际上，test.hpp 文件的内容将取代程序中的代码行 #include &ldquo;test.hpp&rdquo;。原始文件没有被修改，而是将源码和 test.hpp 文件组合成一个复合文件，编译的下一个阶段将使用该文件。</p>
<p>二、头文件名</p>
<table>
<thead>
<tr>
<th>头文件类型</th>
<th>约定</th>
<th>示例</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>C++ 旧式风格</td>
<td>以 .h 结尾</td>
<td>iostream.h</td>
<td>C++ 程序可以使用</td>
</tr>
<tr>
<td>C 旧式风格</td>
<td>以 .h 结尾</td>
<td>math.h</td>
<td>C、C++ 程序可以使用</td>
</tr>
<tr>
<td>C++ 新式风格</td>
<td>没有扩展名</td>
<td>iostream</td>
<td>C++ 程序可以使用，可以使用 namespace std</td>
</tr>
<tr>
<td>转换后的 C</td>
<td>加上前缀 c，没有扩展名</td>
<td>cmath</td>
<td>C++ 程序可以使用，可以使用不是 C 的特性，如 namespace std</td>
</tr>
</tbody>
</table>
<p>由于 C 使用不同的文件扩展名来表示不同文件类型，因此用一些特殊的扩展名（如 .hpp 或 .hxx）表示 C++ 头文件是有道理的，ANSI/ISO 委员会也这样认为。问题在于究竟使用哪种扩展名，因此最终他们一致同意不使用任何扩展名。:)</p>

        
        ]]>
      </description>
    </item>
    
    
    
    <item>
      <title>设计模式概述</title>
      <link>/post/2021/12/26/design/</link>
      <pubDate>Sun, 26 Dec 2021 10:10:12 +0800</pubDate>
      <author>罗泽勋</author>
      <guid>/post/2021/12/26/design/</guid>
      <description>
        <![CDATA[
        <p>在软件开发生命周期的每一个阶段都存在着一些被认同的模式。</p>
<p>在软件模式中，设计模式是研究最为深入的分支，设计模式用于在特定的调剂爱你下为一些重复出现的软件设计问题提供合理的、有效的解决方案。</p>
<p>一般定义：设计模式（Design Pattern)是一套被反复使用、多数人知晓的、进过分类编目的代码设计经验的总结，使用设计模式是为了可重用代码、让代码更容易被他人理解并且保证代码可靠性。</p>
<p>狭义的设计模式是指 GoF 在《设计模式：可复用面向对象软件的基础》一书中所介绍的23种经典设计模式。不过设计模式并不仅仅只有这23种，越来越多的新模式不断诞生并得以应用。</p>
<p>23 种设计模式根据用途可分为创建型、结构型和行为型三种。其中创建型模式主要用于描述如何创建对象，结构型模式主要用于描述如何实现类或对象的组合，行为型模式主要用于描述类或对象怎样交互以及怎样分配职责。</p>
<p>值得注意的是，简单工厂模式没有在 23 种设计模式里面，但一般都会对它进行说明。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2021-12-26/design1.png" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2021-12-26/design2.png" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2021-12-26/design2.png" alt="img"></p>

        
        ]]>
      </description>
    </item>
    
    
    
    <item>
      <title>栈和队列</title>
      <link>/post/2021/12/26/stackqueue/</link>
      <pubDate>Sun, 26 Dec 2021 09:14:03 +0800</pubDate>
      <author>罗泽勋</author>
      <guid>/post/2021/12/26/stackqueue/</guid>
      <description>
        <![CDATA[
        <p>从数据结构的角度看，栈和队列是操作受限的线性表，栈和队列的数据元素具有单一的前驱和后继的线性关系。</p>
<h3 id="栈">栈</h3>
<p>定义：栈是限定仅在表尾进行插入和删除操作的线性表，允许插入和删除的一端称为栈顶，另一端成为栈底。</p>
<p>栈中元素除了具有线性关系外，还具有<strong>后进先出</strong>的特性。</p>
<p>需要注意的是，栈只是对线性表的插入和删除操作的位置进行了限制，并没有限定插入和删除操作进行的时间，也就是说，出栈可以随时进行，只要某个元素位于栈顶就可以出栈。</p>
<h4 id="栈的顺序存储结构顺序栈">栈的顺序存储结构——顺序栈</h4>
<p>顺序栈的本质是顺序表的简化，唯一需要确定的是用数组的哪一端表示栈底。通常把数组下标为0的一端称为栈底，同时附设指针 top 指示栈顶元素在数组中的位置。</p>
<p>设存储栈元素的数组长度为 StackSize,则栈空时栈顶指针 top=-1；栈满时栈顶指针 top=StackSize-1。入栈时，栈顶指针 top 加 1；出栈时，栈顶指针 top 减 1。</p>
<h4 id="栈的链接存储结构链栈">栈的链接存储结构——链栈</h4>
<p>通常链栈用单链表表示。因为只能在栈顶执行插入和删除操作，显然以单链表的头部作为栈顶是最方便的。</p>
<h3 id="队列">队列</h3>
<p>定义：队列是只允许在一端进行插入操作，在另一端进行删除操作的线性表，允许插入（也称入队、进队）的一端成为队尾，允许删除（也称出队）的一端成为队头。</p>
<p>队中元素除了具有线性关系外，还具有<strong>先进先出</strong>的特性。</p>
<h4 id="队列的顺序存储结构循环队列">队列的顺序存储结构——循环队列</h4>
<p>队列是特殊的线性表，从这个出发点来考虑队列的顺序存储问题。</p>
<p>将存储队列的数组看成头尾相接的循环结构，即允许队列直接从数组中下标最大的位置延续到下标最小的位置，这通过取模操作很容易实现。队列的这种头尾相接的顺序存储结构称为循环队列。</p>
<p>要注意的是，在循环队列中还有一个很重要的问题：队空和队满的判定问题。</p>

        
        ]]>
      </description>
    </item>
    
    
    
    <item>
      <title>【转载】面向对象思想</title>
      <link>/post/2021/12/22/%E8%BD%AC%E8%BD%BD%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3/</link>
      <pubDate>Wed, 22 Dec 2021 23:41:54 +0800</pubDate>
      <author>罗泽勋</author>
      <guid>/post/2021/12/22/%E8%BD%AC%E8%BD%BD%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3/</guid>
      <description>
        <![CDATA[
        <h1 id="面向对象思想">面向对象思想</h1>
<!-- GFM-TOC -->
<ul>
<li><a href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3">面向对象思想</a>
<ul>
<li><a href="#%E4%B8%80%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7">一、三大特性</a>
<ul>
<li><a href="#%E5%B0%81%E8%A3%85">封装</a></li>
<li><a href="#%E7%BB%A7%E6%89%BF">继承</a></li>
<li><a href="#%E5%A4%9A%E6%80%81">多态</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C%E7%B1%BB%E5%9B%BE">二、类图</a>
<ul>
<li><a href="#%E6%B3%9B%E5%8C%96%E5%85%B3%E7%B3%BB-generalization">泛化关系 (Generalization)</a></li>
<li><a href="#%E5%AE%9E%E7%8E%B0%E5%85%B3%E7%B3%BB-realization">实现关系 (Realization)</a></li>
<li><a href="#%E8%81%9A%E5%90%88%E5%85%B3%E7%B3%BB-aggregation">聚合关系 (Aggregation)</a></li>
<li><a href="#%E7%BB%84%E5%90%88%E5%85%B3%E7%B3%BB-composition">组合关系 (Composition)</a></li>
<li><a href="#%E5%85%B3%E8%81%94%E5%85%B3%E7%B3%BB-association">关联关系 (Association)</a></li>
<li><a href="#%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB-dependency">依赖关系 (Dependency)</a></li>
</ul>
</li>
<li><a href="#%E4%B8%89%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99">三、设计原则</a>
<ul>
<li><a href="#solid">S.O.L.I.D</a></li>
<li><a href="#%E5%85%B6%E4%BB%96%E5%B8%B8%E8%A7%81%E5%8E%9F%E5%88%99">其他常见原则</a></li>
</ul>
</li>
<li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
</li>
</ul>
<!-- GFM-TOC -->
<h2 id="一三大特性">一、三大特性</h2>
<h3 id="封装">封装</h3>
<p>利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体。数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外的接口使其与外部发生联系。用户无需关心对象内部的细节，但可以通过对象对外提供的接口来访问该对象。</p>
<p>优点：</p>
<ul>
<li>减少耦合：可以独立地开发、测试、优化、使用、理解和修改</li>
<li>减轻维护的负担：可以更容易被理解，并且在调试的时候可以不影响其他模块</li>
<li>有效地调节性能：可以通过剖析来确定哪些模块影响了系统的性能</li>
<li>提高软件的可重用性</li>
<li>降低了构建大型系统的风险：即使整个系统不可用，但是这些独立的模块却有可能是可用的</li>
</ul>
<p>以下 Person 类封装 name、gender、age 等属性，外界只能通过 get() 方法获取一个 Person 对象的 name 属性和 gender 属性，而无法获取 age 属性，但是 age 属性可以供 work() 方法使用。</p>
<p>注意到 gender 属性使用 int 数据类型进行存储，封装使得用户注意不到这种实现细节。并且在需要修改 gender 属性使用的数据类型时，也可以在不影响客户端代码的情况下进行。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Person</span> <span style="color:#f92672">{</span>

    <span style="color:#66d9ef">private</span> String name<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> gender<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> age<span style="color:#f92672">;</span>

    <span style="color:#66d9ef">public</span> String <span style="color:#a6e22e">getName</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> name<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> String <span style="color:#a6e22e">getGender</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> gender <span style="color:#f92672">==</span> 0 <span style="color:#f92672">?</span> <span style="color:#e6db74">&#34;man&#34;</span> <span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;woman&#34;</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">work</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>18 <span style="color:#f92672">&lt;=</span> age <span style="color:#f92672">&amp;&amp;</span> age <span style="color:#f92672">&lt;=</span> 50<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>name <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34; is working very hard!&#34;</span><span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
            System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>name <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34; can&#39;t work any more!&#34;</span><span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><h3 id="继承">继承</h3>
<p>继承实现了   <strong>IS-A</strong>   关系，例如 Cat 和 Animal 就是一种 IS-A 关系，因此 Cat 可以继承自 Animal，从而获得 Animal 非 private 的属性和方法。</p>
<p>继承应该遵循里氏替换原则，子类对象必须能够替换掉所有父类对象。</p>
<p>Cat 可以当做 Animal 来使用，也就是说可以使用 Animal 引用 Cat 对象。父类引用指向子类对象称为   <strong>向上转型</strong>  。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">Animal animal <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Cat<span style="color:#f92672">();</span>
</code></pre></div><h3 id="多态">多态</h3>
<p>多态分为编译时多态和运行时多态：</p>
<ul>
<li>编译时多态主要指方法的重载</li>
<li>运行时多态指程序中定义的对象引用所指向的具体类型在运行期间才确定</li>
</ul>
<p>运行时多态有三个条件：</p>
<ul>
<li>继承</li>
<li>覆盖（重写）</li>
<li>向上转型</li>
</ul>
<p>下面的代码中，乐器类（Instrument）有两个子类：Wind 和 Percussion，它们都覆盖了父类的 play() 方法，并且在 main() 方法中使用父类 Instrument 来引用 Wind 和 Percussion 对象。在 Instrument 引用调用 play() 方法时，会执行实际引用对象所在类的 play() 方法，而不是 Instrument 类的方法。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Instrument</span> <span style="color:#f92672">{</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">play</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Instument is playing...&#34;</span><span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Wind</span> <span style="color:#66d9ef">extends</span> Instrument <span style="color:#f92672">{</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">play</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Wind is playing...&#34;</span><span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Percussion</span> <span style="color:#66d9ef">extends</span> Instrument <span style="color:#f92672">{</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">play</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;Percussion is playing...&#34;</span><span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Music</span> <span style="color:#f92672">{</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        List<span style="color:#f92672">&lt;</span>Instrument<span style="color:#f92672">&gt;</span> instruments <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ArrayList<span style="color:#f92672">&lt;&gt;();</span>
        instruments<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> Wind<span style="color:#f92672">());</span>
        instruments<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> Percussion<span style="color:#f92672">());</span>
        <span style="color:#66d9ef">for</span><span style="color:#f92672">(</span>Instrument instrument <span style="color:#f92672">:</span> instruments<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            instrument<span style="color:#f92672">.</span><span style="color:#a6e22e">play</span><span style="color:#f92672">();</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><pre tabindex="0"><code>Wind is playing...
Percussion is playing...
</code></pre><h2 id="二类图">二、类图</h2>
<p>以下类图使用 <a href="https://www.planttext.com/">PlantUML</a> 绘制，更多语法及使用请参考：http://plantuml.com/ 。</p>
<h3 id="泛化关系-generalization">泛化关系 (Generalization)</h3>
<p>用来描述继承关系，在 Java 中使用 extends 关键字。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/c0874e0a-dba3-467e-9c86-dd9313e0843e.jpg" width="180px"> </div><br>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">@startuml

title Generalization

class Vihical
class Car
class Trunck

Vihical &lt;|-- Car
Vihical &lt;|-- Trunck

@enduml
</code></pre></div><h3 id="实现关系-realization">实现关系 (Realization)</h3>
<p>用来实现一个接口，在 Java 中使用 implements 关键字。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/83d466bd-946b-4430-854a-cf7b0696d4c8.jpg" width="170px"> </div><br>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">@startuml

title Realization

interface MoveBehavior
class Fly
class Run

MoveBehavior &lt;|.. Fly
MoveBehavior &lt;|.. Run

@enduml
</code></pre></div><h3 id="聚合关系-aggregation">聚合关系 (Aggregation)</h3>
<p>表示整体由部分组成，但是整体和部分不是强依赖的，整体不存在了部分还是会存在。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a0ce43b7-afa8-4397-a96e-5c12a070f2ae.jpg" width="300px"> </div><br>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">@startuml

title Aggregation

class Computer
class Keyboard
class Mouse
class Screen

Computer o-- Keyboard
Computer o-- Mouse
Computer o-- Screen

@enduml
</code></pre></div><h3 id="组合关系-composition">组合关系 (Composition)</h3>
<p>和聚合不同，组合中整体和部分是强依赖的，整体不存在了部分也不存在了。比如公司和部门，公司没了部门就不存在了。但是公司和员工就属于聚合关系了，因为公司没了员工还在。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/6a88a398-c494-41f5-bb62-9f7fb811df7c.jpg" width="280px"> </div><br>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">@startuml

title Composition

class Company
class DepartmentA
class DepartmentB

Company *-- DepartmentA
Company *-- DepartmentB

@enduml
</code></pre></div><h3 id="关联关系-association">关联关系 (Association)</h3>
<p>表示不同类对象之间有关联，这是一种静态关系，与运行过程的状态无关，在最开始就可以确定。因此也可以用 1 对 1、多对 1、多对多这种关联关系来表示。比如学生和学校就是一种关联关系，一个学校可以有很多学生，但是一个学生只属于一个学校，因此这是一种多对一的关系，在运行开始之前就可以确定。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/a3e4dc62-0da5-4d22-94f2-140078281812.jpg" width="200px"> </div><br>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">@startuml

title Association

class School
class Student

School &#34;1&#34; - &#34;n&#34; Student

@enduml
</code></pre></div><h3 id="依赖关系-dependency">依赖关系 (Dependency)</h3>
<p>和关联关系不同的是，依赖关系是在运行过程中起作用的。A 类和 B 类是依赖关系主要有三种形式：</p>
<ul>
<li>A 类是 B 类方法的局部变量；</li>
<li>A 类是 B 类方法的参数；</li>
<li>A 类向 B 类发送消息，从而影响 B 类发生变化。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/379444c9-f1d1-45cd-b7aa-b0c18427d388.jpg" width="330px"> </div><br>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">@startuml

title Dependency

class Vihicle {
    move(MoveBehavior)
}

interface MoveBehavior {
    move()
}

note &#34;MoveBehavior.move()&#34; as N

Vihicle ..&gt; MoveBehavior

Vihicle .. N

@enduml
</code></pre></div><h2 id="三设计原则">三、设计原则</h2>
<h3 id="solid">S.O.L.I.D</h3>
<table>
<thead>
<tr>
<th style="text-align:center">简写</th>
<th style="text-align:center">全拼</th>
<th style="text-align:center">中文翻译</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">SRP</td>
<td style="text-align:center">The Single Responsibility Principle</td>
<td style="text-align:center">单一责任原则</td>
</tr>
<tr>
<td style="text-align:center">OCP</td>
<td style="text-align:center">The Open Closed Principle</td>
<td style="text-align:center">开放封闭原则</td>
</tr>
<tr>
<td style="text-align:center">LSP</td>
<td style="text-align:center">The Liskov Substitution Principle</td>
<td style="text-align:center">里氏替换原则</td>
</tr>
<tr>
<td style="text-align:center">ISP</td>
<td style="text-align:center">The Interface Segregation Principle</td>
<td style="text-align:center">接口分离原则</td>
</tr>
<tr>
<td style="text-align:center">DIP</td>
<td style="text-align:center">The Dependency Inversion Principle</td>
<td style="text-align:center">依赖倒置原则</td>
</tr>
</tbody>
</table>
<h4 id="1-单一责任原则">1. 单一责任原则</h4>
<blockquote>
<p>修改一个类的原因应该只有一个。</p>
</blockquote>
<p>换句话说就是让一个类只负责一件事，当这个类需要做过多事情的时候，就需要分解这个类。</p>
<p>如果一个类承担的职责过多，就等于把这些职责耦合在了一起，一个职责的变化可能会削弱这个类完成其它职责的能力。</p>
<h4 id="2-开放封闭原则">2. 开放封闭原则</h4>
<blockquote>
<p>类应该对扩展开放，对修改关闭。</p>
</blockquote>
<p>扩展就是添加新功能的意思，因此该原则要求在添加新功能时不需要修改代码。</p>
<p>符合开闭原则最典型的设计模式是装饰者模式，它可以动态地将责任附加到对象上，而不用去修改类的代码。</p>
<h4 id="3-里氏替换原则">3. 里氏替换原则</h4>
<blockquote>
<p>子类对象必须能够替换掉所有父类对象。</p>
</blockquote>
<p>继承是一种 IS-A 关系，子类需要能够当成父类来使用，并且需要比父类更特殊。</p>
<p>如果不满足这个原则，那么各个子类的行为上就会有很大差异，增加继承体系的复杂度。</p>
<h4 id="4-接口分离原则">4. 接口分离原则</h4>
<blockquote>
<p>不应该强迫客户依赖于它们不用的方法。</p>
</blockquote>
<p>因此使用多个专门的接口比使用单一的总接口要好。</p>
<h4 id="5-依赖倒置原则">5. 依赖倒置原则</h4>
<blockquote>
<p>高层模块不应该依赖于低层模块，二者都应该依赖于抽象；</br>抽象不应该依赖于细节，细节应该依赖于抽象。</p>
</blockquote>
<p>高层模块包含一个应用程序中重要的策略选择和业务模块，如果高层模块依赖于低层模块，那么低层模块的改动就会直接影响到高层模块，从而迫使高层模块也需要改动。</p>
<p>依赖于抽象意味着：</p>
<ul>
<li>任何变量都不应该持有一个指向具体类的指针或者引用；</li>
<li>任何类都不应该从具体类派生；</li>
<li>任何方法都不应该覆写它的任何基类中的已经实现的方法。</li>
</ul>
<h3 id="其他常见原则">其他常见原则</h3>
<p>除了上述的经典原则，在实际开发中还有下面这些常见的设计原则。</p>
<table>
<thead>
<tr>
<th style="text-align:center">简写</th>
<th style="text-align:center">全拼</th>
<th style="text-align:center">中文翻译</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">LOD</td>
<td style="text-align:center">The Law of Demeter</td>
<td style="text-align:center">迪米特法则</td>
</tr>
<tr>
<td style="text-align:center">CRP</td>
<td style="text-align:center">The Composite Reuse Principle</td>
<td style="text-align:center">合成复用原则</td>
</tr>
<tr>
<td style="text-align:center">CCP</td>
<td style="text-align:center">The Common Closure Principle</td>
<td style="text-align:center">共同封闭原则</td>
</tr>
<tr>
<td style="text-align:center">SAP</td>
<td style="text-align:center">The Stable Abstractions Principle</td>
<td style="text-align:center">稳定抽象原则</td>
</tr>
<tr>
<td style="text-align:center">SDP</td>
<td style="text-align:center">The Stable Dependencies Principle</td>
<td style="text-align:center">稳定依赖原则</td>
</tr>
</tbody>
</table>
<h4 id="1-迪米特法则">1. 迪米特法则</h4>
<p>迪米特法则又叫作最少知识原则（Least Knowledge Principle，简写 LKP），就是说一个对象应当对其他对象有尽可能少的了解，不和陌生人说话。</p>
<h4 id="2-合成复用原则">2. 合成复用原则</h4>
<p>尽量使用对象组合，而不是通过继承来达到复用的目的。</p>
<h4 id="3-共同封闭原则">3. 共同封闭原则</h4>
<p>一起修改的类，应该组合在一起（同一个包里）。如果必须修改应用程序里的代码，我们希望所有的修改都发生在一个包里（修改关闭），而不是遍布在很多包里。</p>
<h4 id="4-稳定抽象原则">4. 稳定抽象原则</h4>
<p>最稳定的包应该是最抽象的包，不稳定的包应该是具体的包，即包的抽象程度跟它的稳定性成正比。</p>
<h4 id="5-稳定依赖原则">5. 稳定依赖原则</h4>
<p>包之间的依赖关系都应该是稳定方向依赖的，包要依赖的包要比自己更具有稳定性。</p>
<h2 id="参考资料">参考资料</h2>
<ul>
<li>Java 编程思想</li>
<li>敏捷软件开发：原则、模式与实践</li>
<li><a href="http://www.cnblogs.com/shanyou/archive/2009/09/21/1570716.html">面向对象设计的 SOLID 原则</a></li>
<li><a href="http://design-patterns.readthedocs.io/zh_CN/latest/read_uml.html#generalization">看懂 UML 类图和时序图</a></li>
<li><a href="http://www.cnblogs.com/wolf-sun/p/UML-Sequence-diagram.html">UML 系列——时序图（顺序图）sequence diagram</a></li>
<li><a href="http://blog.csdn.net/jianyuerensheng/article/details/51602015">面向对象编程三大特性 &mdash;&mdash; 封装、继承、多态</a></li>
</ul>

        
        ]]>
      </description>
    </item>
    
    
    
    <item>
      <title>【转载】缓存</title>
      <link>/post/2021/12/22/%E8%BD%AC%E8%BD%BD%E7%BC%93%E5%AD%98/</link>
      <pubDate>Wed, 22 Dec 2021 23:37:55 +0800</pubDate>
      <author>罗泽勋</author>
      <guid>/post/2021/12/22/%E8%BD%AC%E8%BD%BD%E7%BC%93%E5%AD%98/</guid>
      <description>
        <![CDATA[
        <h1 id="缓存">缓存</h1>
<!-- GFM-TOC -->
<ul>
<li><a href="#%E7%BC%93%E5%AD%98">缓存</a>
<ul>
<li><a href="#%E4%B8%80%E7%BC%93%E5%AD%98%E7%89%B9%E5%BE%81">一、缓存特征</a></li>
<li><a href="#%E4%BA%8C%E7%BC%93%E5%AD%98%E4%BD%8D%E7%BD%AE">二、缓存位置</a></li>
<li><a href="#%E4%B8%89cdn">三、CDN</a></li>
<li><a href="#%E5%9B%9B%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98">四、缓存问题</a></li>
<li><a href="#%E4%BA%94%E6%95%B0%E6%8D%AE%E5%88%86%E5%B8%83">五、数据分布</a></li>
<li><a href="#%E5%85%AD%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C">六、一致性哈希</a></li>
<li><a href="#%E4%B8%83lru">七、LRU</a></li>
<li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
</li>
</ul>
<!-- GFM-TOC -->
<h2 id="一缓存特征">一、缓存特征</h2>
<h3 id="命中率">命中率</h3>
<p>当某个请求能够通过访问缓存而得到响应时，称为缓存命中。</p>
<p>缓存命中率越高，缓存的利用率也就越高。</p>
<h3 id="最大空间">最大空间</h3>
<p>缓存通常位于内存中，内存的空间通常比磁盘空间小的多，因此缓存的最大空间不可能非常大。</p>
<p>当缓存存放的数据量超过最大空间时，就需要淘汰部分数据来存放新到达的数据。</p>
<h3 id="淘汰策略">淘汰策略</h3>
<ul>
<li>
<p>FIFO（First In First Out）：先进先出策略，在实时性的场景下，需要经常访问最新的数据，那么就可以使用 FIFO，使得最先进入的数据（最晚的数据）被淘汰。</p>
</li>
<li>
<p>LRU（Least Recently Used）：最近最久未使用策略，优先淘汰最久未使用的数据，也就是上次被访问时间距离现在最久的数据。该策略可以保证内存中的数据都是热点数据，也就是经常被访问的数据，从而保证缓存命中率。</p>
</li>
<li>
<p>LFU（Least Frequently Used）：最不经常使用策略，优先淘汰一段时间内使用次数最少的数据。</p>
</li>
</ul>
<h2 id="二缓存位置">二、缓存位置</h2>
<h3 id="浏览器">浏览器</h3>
<p>当 HTTP 响应允许进行缓存时，浏览器会将 HTML、CSS、JavaScript、图片等静态资源进行缓存。</p>
<h3 id="isp">ISP</h3>
<p>网络服务提供商（ISP）是网络访问的第一跳，通过将数据缓存在 ISP 中能够大大提高用户的访问速度。</p>
<h3 id="反向代理">反向代理</h3>
<p>反向代理位于服务器之前，请求与响应都需要经过反向代理。通过将数据缓存在反向代理，在用户请求反向代理时就可以直接使用缓存进行响应。</p>
<h3 id="本地缓存">本地缓存</h3>
<p>使用 Guava Cache 将数据缓存在服务器本地内存中，服务器代码可以直接读取本地内存中的缓存，速度非常快。</p>
<h3 id="分布式缓存">分布式缓存</h3>
<p>使用 Redis、Memcache 等分布式缓存将数据缓存在分布式缓存系统中。</p>
<p>相对于本地缓存来说，分布式缓存单独部署，可以根据需求分配硬件资源。不仅如此，服务器集群都可以访问分布式缓存，而本地缓存需要在服务器集群之间进行同步，实现难度和性能开销上都非常大。</p>
<h3 id="数据库缓存">数据库缓存</h3>
<p>MySQL 等数据库管理系统具有自己的查询缓存机制来提高查询效率。</p>
<h3 id="java-内部的缓存">Java 内部的缓存</h3>
<p>Java 为了优化空间，提高字符串、基本数据类型包装类的创建效率，设计了字符串常量池及 Byte、Short、Character、Integer、Long、Boolean 这六种包装类缓冲池。</p>
<h3 id="cpu-多级缓存">CPU 多级缓存</h3>
<p>CPU 为了解决运算速度与主存 IO 速度不匹配的问题，引入了多级缓存结构，同时使用 MESI 等缓存一致性协议来解决多核 CPU 缓存数据一致性的问题。</p>
<h2 id="三cdn">三、CDN</h2>
<p>内容分发网络（Content distribution network，CDN）是一种互连的网络系统，它利用更靠近用户的服务器从而更快更可靠地将 HTML、CSS、JavaScript、音乐、图片、视频等静态资源分发给用户。</p>
<p>CDN 主要有以下优点：</p>
<ul>
<li>更快地将数据分发给用户；</li>
<li>通过部署多台服务器，从而提高系统整体的带宽性能；</li>
<li>多台服务器可以看成是一种冗余机制，从而具有高可用性。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/15313ed8-a520-4799-a300-2b6b36be314f.jpg"/> </div><br>
<h2 id="四缓存问题">四、缓存问题</h2>
<h3 id="缓存穿透">缓存穿透</h3>
<p>指的是对某个一定不存在的数据进行请求，该请求将会穿透缓存到达数据库。</p>
<p>解决方案：</p>
<ul>
<li>对这些不存在的数据缓存一个空数据；</li>
<li>对这类请求进行过滤。</li>
</ul>
<h3 id="缓存雪崩">缓存雪崩</h3>
<p>指的是由于数据没有被加载到缓存中，或者缓存数据在同一时间大面积失效（过期），又或者缓存服务器宕机，导致大量的请求都到达数据库。</p>
<p>在有缓存的系统中，系统非常依赖于缓存，缓存分担了很大一部分的数据请求。当发生缓存雪崩时，数据库无法处理这么大的请求，导致数据库崩溃。</p>
<p>解决方案：</p>
<ul>
<li>为了防止缓存在同一时间大面积过期导致的缓存雪崩，可以通过观察用户行为，合理设置缓存过期时间来实现；</li>
<li>为了防止缓存服务器宕机出现的缓存雪崩，可以使用分布式缓存，分布式缓存中每一个节点只缓存部分的数据，当某个节点宕机时可以保证其它节点的缓存仍然可用。</li>
<li>也可以进行缓存预热，避免在系统刚启动不久由于还未将大量数据进行缓存而导致缓存雪崩。</li>
</ul>
<h3 id="缓存一致性">缓存一致性</h3>
<p>缓存一致性要求数据更新的同时缓存数据也能够实时更新。</p>
<p>解决方案：</p>
<ul>
<li>在数据更新的同时立即去更新缓存；</li>
<li>在读缓存之前先判断缓存是否是最新的，如果不是最新的先进行更新。</li>
</ul>
<p>要保证缓存一致性需要付出很大的代价，缓存数据最好是那些对一致性要求不高的数据，允许缓存数据存在一些脏数据。</p>
<h3 id="缓存-无底洞-现象">缓存 “无底洞” 现象</h3>
<p>指的是为了满足业务要求添加了大量缓存节点，但是性能不但没有好转反而下降了的现象。</p>
<p>产生原因：缓存系统通常采用 hash 函数将 key 映射到对应的缓存节点，随着缓存节点数目的增加，键值分布到更多的节点上，导致客户端一次批量操作会涉及多次网络操作，这意味着批量操作的耗时会随着节点数目的增加而不断增大。此外，网络连接数变多，对节点的性能也有一定影响。</p>
<p>解决方案：</p>
<ul>
<li>优化批量数据操作命令；</li>
<li>减少网络通信次数；</li>
<li>降低接入成本，使用长连接 / 连接池，NIO 等。</li>
</ul>
<h2 id="五数据分布">五、数据分布</h2>
<h3 id="哈希分布">哈希分布</h3>
<p>哈希分布就是将数据计算哈希值之后，按照哈希值分配到不同的节点上。例如有 N 个节点，数据的主键为 key，则将该数据分配的节点序号为：hash(key)%N。</p>
<p>传统的哈希分布算法存在一个问题：当节点数量变化时，也就是 N 值变化，那么几乎所有的数据都需要重新分布，将导致大量的数据迁移。</p>
<h3 id="顺序分布">顺序分布</h3>
<p>将数据划分为多个连续的部分，按数据的 ID 或者时间分布到不同节点上。例如 User 表的 ID 范围为 1 ~ 7000，使用顺序分布可以将其划分成多个子表，对应的主键范围为 1 ~ 1000，1001 ~ 2000，&hellip;，6001 ~ 7000。</p>
<p>顺序分布相比于哈希分布的主要优点如下：</p>
<ul>
<li>能保持数据原有的顺序；</li>
<li>并且能够准确控制每台服务器存储的数据量，从而使得存储空间的利用率最大。</li>
</ul>
<h2 id="六一致性哈希">六、一致性哈希</h2>
<p>Distributed Hash Table（DHT） 是一种哈希分布方式，其目的是为了克服传统哈希分布在服务器节点数量变化时大量数据迁移的问题。</p>
<h3 id="基本原理">基本原理</h3>
<p>将哈希空间 [0, 2<sup>n</sup>-1] 看成一个哈希环，每个服务器节点都配置到哈希环上。每个数据对象通过哈希取模得到哈希值之后，存放到哈希环中顺时针方向第一个大于等于该哈希值的节点上。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/68b110b9-76c6-4ee2-b541-4145e65adb3e.jpg"/> </div><br>
<p>一致性哈希在增加或者删除节点时只会影响到哈希环中相邻的节点，例如下图中新增节点 X，只需要将它前一个节点 C 上的数据重新进行分布即可，对于节点 A、B、D 都没有影响。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/66402828-fb2b-418f-83f6-82153491bcfe.jpg"/> </div><br>
<h3 id="虚拟节点">虚拟节点</h3>
<p>上面描述的一致性哈希存在数据分布不均匀的问题，节点存储的数据量有可能会存在很大的不同。</p>
<p>数据不均匀主要是因为节点在哈希环上分布的不均匀，这种情况在节点数量很少的情况下尤其明显。</p>
<p>解决方式是通过增加虚拟节点，然后将虚拟节点映射到真实节点上。虚拟节点的数量比真实节点来得多，那么虚拟节点在哈希环上分布的均匀性就会比原来的真实节点好，从而使得数据分布也更加均匀。</p>
<h2 id="七lru">七、LRU</h2>
<p>以下是基于 双向链表 + HashMap 的 LRU 算法实现，对算法的解释如下：</p>
<ul>
<li>访问某个节点时，将其从原来的位置删除，并重新插入到链表头部。这样就能保证链表尾部存储的就是最近最久未使用的节点，当节点数量大于缓存最大空间时就淘汰链表尾部的节点。</li>
<li>为了使删除操作时间复杂度为 O(1)，就不能采用遍历的方式找到某个节点。HashMap 存储着 Key 到节点的映射，通过 Key 就能以 O(1) 的时间得到节点，然后再以 O(1) 的时间将其从双向队列中删除。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">LRU</span><span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span> V<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">implements</span> Iterable<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">&gt;</span> <span style="color:#f92672">{</span>

    <span style="color:#66d9ef">private</span> Node head<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">private</span> Node tail<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">private</span> HashMap<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span> Node<span style="color:#f92672">&gt;</span> map<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> maxSize<span style="color:#f92672">;</span>

    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Node</span> <span style="color:#f92672">{</span>

        Node pre<span style="color:#f92672">;</span>
        Node next<span style="color:#f92672">;</span>
        K k<span style="color:#f92672">;</span>
        V v<span style="color:#f92672">;</span>

        <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">Node</span><span style="color:#f92672">(</span>K k<span style="color:#f92672">,</span> V v<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">k</span> <span style="color:#f92672">=</span> k<span style="color:#f92672">;</span>
            <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">v</span> <span style="color:#f92672">=</span> v<span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>


    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">LRU</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> maxSize<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>

        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">maxSize</span> <span style="color:#f92672">=</span> maxSize<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">map</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> HashMap<span style="color:#f92672">&lt;&gt;(</span>maxSize <span style="color:#f92672">*</span> 4 <span style="color:#f92672">/</span> 3<span style="color:#f92672">);</span>

        head <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Node<span style="color:#f92672">(</span><span style="color:#66d9ef">null</span><span style="color:#f92672">,</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">);</span>
        tail <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Node<span style="color:#f92672">(</span><span style="color:#66d9ef">null</span><span style="color:#f92672">,</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">);</span>

        head<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> tail<span style="color:#f92672">;</span>
        tail<span style="color:#f92672">.</span><span style="color:#a6e22e">pre</span> <span style="color:#f92672">=</span> head<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>


    <span style="color:#66d9ef">public</span> V <span style="color:#a6e22e">get</span><span style="color:#f92672">(</span>K key<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>

        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span>map<span style="color:#f92672">.</span><span style="color:#a6e22e">containsKey</span><span style="color:#f92672">(</span>key<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>

        Node node <span style="color:#f92672">=</span> map<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">(</span>key<span style="color:#f92672">);</span>
        unlink<span style="color:#f92672">(</span>node<span style="color:#f92672">);</span>
        appendHead<span style="color:#f92672">(</span>node<span style="color:#f92672">);</span>

        <span style="color:#66d9ef">return</span> node<span style="color:#f92672">.</span><span style="color:#a6e22e">v</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>


    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">put</span><span style="color:#f92672">(</span>K key<span style="color:#f92672">,</span> V value<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>

        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>map<span style="color:#f92672">.</span><span style="color:#a6e22e">containsKey</span><span style="color:#f92672">(</span>key<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
            Node node <span style="color:#f92672">=</span> map<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">(</span>key<span style="color:#f92672">);</span>
            unlink<span style="color:#f92672">(</span>node<span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>

        Node node <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Node<span style="color:#f92672">(</span>key<span style="color:#f92672">,</span> value<span style="color:#f92672">);</span>
        map<span style="color:#f92672">.</span><span style="color:#a6e22e">put</span><span style="color:#f92672">(</span>key<span style="color:#f92672">,</span> node<span style="color:#f92672">);</span>
        appendHead<span style="color:#f92672">(</span>node<span style="color:#f92672">);</span>

        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>map<span style="color:#f92672">.</span><span style="color:#a6e22e">size</span><span style="color:#f92672">()</span> <span style="color:#f92672">&gt;</span> maxSize<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            Node toRemove <span style="color:#f92672">=</span> removeTail<span style="color:#f92672">();</span>
            map<span style="color:#f92672">.</span><span style="color:#a6e22e">remove</span><span style="color:#f92672">(</span>toRemove<span style="color:#f92672">.</span><span style="color:#a6e22e">k</span><span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>


    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">unlink</span><span style="color:#f92672">(</span>Node node<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>

        Node pre <span style="color:#f92672">=</span> node<span style="color:#f92672">.</span><span style="color:#a6e22e">pre</span><span style="color:#f92672">;</span>
        Node next <span style="color:#f92672">=</span> node<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">;</span>

        pre<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> next<span style="color:#f92672">;</span>
        next<span style="color:#f92672">.</span><span style="color:#a6e22e">pre</span> <span style="color:#f92672">=</span> pre<span style="color:#f92672">;</span>

        node<span style="color:#f92672">.</span><span style="color:#a6e22e">pre</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
        node<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>


    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">appendHead</span><span style="color:#f92672">(</span>Node node<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        Node next <span style="color:#f92672">=</span> head<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">;</span>
        node<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> next<span style="color:#f92672">;</span>
        next<span style="color:#f92672">.</span><span style="color:#a6e22e">pre</span> <span style="color:#f92672">=</span> node<span style="color:#f92672">;</span>
        node<span style="color:#f92672">.</span><span style="color:#a6e22e">pre</span> <span style="color:#f92672">=</span> head<span style="color:#f92672">;</span>
        head<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> node<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>


    <span style="color:#66d9ef">private</span> Node <span style="color:#a6e22e">removeTail</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>

        Node node <span style="color:#f92672">=</span> tail<span style="color:#f92672">.</span><span style="color:#a6e22e">pre</span><span style="color:#f92672">;</span>

        Node pre <span style="color:#f92672">=</span> node<span style="color:#f92672">.</span><span style="color:#a6e22e">pre</span><span style="color:#f92672">;</span>
        tail<span style="color:#f92672">.</span><span style="color:#a6e22e">pre</span> <span style="color:#f92672">=</span> pre<span style="color:#f92672">;</span>
        pre<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> tail<span style="color:#f92672">;</span>

        node<span style="color:#f92672">.</span><span style="color:#a6e22e">pre</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
        node<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>

        <span style="color:#66d9ef">return</span> node<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>


    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">public</span> Iterator<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">iterator</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>

        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> Iterator<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">&gt;()</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">private</span> Node cur <span style="color:#f92672">=</span> head<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">;</span>

            <span style="color:#a6e22e">@Override</span>
            <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">hasNext</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
                <span style="color:#66d9ef">return</span> cur <span style="color:#f92672">!=</span> tail<span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span>

            <span style="color:#a6e22e">@Override</span>
            <span style="color:#66d9ef">public</span> K <span style="color:#a6e22e">next</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
                Node node <span style="color:#f92672">=</span> cur<span style="color:#f92672">;</span>
                cur <span style="color:#f92672">=</span> cur<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">;</span>
                <span style="color:#66d9ef">return</span> node<span style="color:#f92672">.</span><span style="color:#a6e22e">k</span><span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">};</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><h2 id="参考资料">参考资料</h2>
<ul>
<li>大规模分布式存储系统</li>
<li><a href="https://tech.meituan.com/cache_about.html">缓存那些事</a></li>
<li><a href="https://my.oschina.net/jayhu/blog/732849">一致性哈希算法</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E5%85%A7%E5%AE%B9%E5%82%B3%E9%81%9E%E7%B6%B2%E8%B7%AF">内容分发网络</a></li>
<li><a href="https://www.aspirationhosting.com/aspiration-cdn/">How Aspiration CDN helps to improve your website loading speed?</a></li>
</ul>

        
        ]]>
      </description>
    </item>
    
    
    
    <item>
      <title>【转载】Redis</title>
      <link>/post/2021/12/22/%E8%BD%AC%E8%BD%BDredis/</link>
      <pubDate>Wed, 22 Dec 2021 23:34:10 +0800</pubDate>
      <author>罗泽勋</author>
      <guid>/post/2021/12/22/%E8%BD%AC%E8%BD%BDredis/</guid>
      <description>
        <![CDATA[
        <h1 id="redis">Redis</h1>
<!-- GFM-TOC -->
<ul>
<li><a href="#redis">Redis</a>
<ul>
<li><a href="#%E4%B8%80%E6%A6%82%E8%BF%B0">一、概述</a></li>
<li><a href="#%E4%BA%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">二、数据类型</a>
<ul>
<li><a href="#string">STRING</a></li>
<li><a href="#list">LIST</a></li>
<li><a href="#set">SET</a></li>
<li><a href="#hash">HASH</a></li>
<li><a href="#zset">ZSET</a></li>
</ul>
</li>
<li><a href="#%E4%B8%89%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">三、数据结构</a>
<ul>
<li><a href="#%E5%AD%97%E5%85%B8">字典</a></li>
<li><a href="#%E8%B7%B3%E8%B7%83%E8%A1%A8">跳跃表</a></li>
</ul>
</li>
<li><a href="#%E5%9B%9B%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">四、使用场景</a>
<ul>
<li><a href="#%E8%AE%A1%E6%95%B0%E5%99%A8">计数器</a></li>
<li><a href="#%E7%BC%93%E5%AD%98">缓存</a></li>
<li><a href="#%E6%9F%A5%E6%89%BE%E8%A1%A8">查找表</a></li>
<li><a href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97">消息队列</a></li>
<li><a href="#%E4%BC%9A%E8%AF%9D%E7%BC%93%E5%AD%98">会话缓存</a></li>
<li><a href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%AE%9E%E7%8E%B0">分布式锁实现</a></li>
<li><a href="#%E5%85%B6%E5%AE%83">其它</a></li>
</ul>
</li>
<li><a href="#%E4%BA%94redis-%E4%B8%8E-memcached">五、Redis 与 Memcached</a>
<ul>
<li><a href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">数据类型</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96">数据持久化</a></li>
<li><a href="#%E5%88%86%E5%B8%83%E5%BC%8F">分布式</a></li>
<li><a href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6">内存管理机制</a></li>
</ul>
</li>
<li><a href="#%E5%85%AD%E9%94%AE%E7%9A%84%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4">六、键的过期时间</a></li>
<li><a href="#%E4%B8%83%E6%95%B0%E6%8D%AE%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5">七、数据淘汰策略</a></li>
<li><a href="#%E5%85%AB%E6%8C%81%E4%B9%85%E5%8C%96">八、持久化</a>
<ul>
<li><a href="#rdb-%E6%8C%81%E4%B9%85%E5%8C%96">RDB 持久化</a></li>
<li><a href="#aof-%E6%8C%81%E4%B9%85%E5%8C%96">AOF 持久化</a></li>
</ul>
</li>
<li><a href="#%E4%B9%9D%E4%BA%8B%E5%8A%A1">九、事务</a></li>
<li><a href="#%E5%8D%81%E4%BA%8B%E4%BB%B6">十、事件</a>
<ul>
<li><a href="#%E6%96%87%E4%BB%B6%E4%BA%8B%E4%BB%B6">文件事件</a></li>
<li><a href="#%E6%97%B6%E9%97%B4%E4%BA%8B%E4%BB%B6">时间事件</a></li>
<li><a href="#%E4%BA%8B%E4%BB%B6%E7%9A%84%E8%B0%83%E5%BA%A6%E4%B8%8E%E6%89%A7%E8%A1%8C">事件的调度与执行</a></li>
</ul>
</li>
<li><a href="#%E5%8D%81%E4%B8%80%E5%A4%8D%E5%88%B6">十一、复制</a>
<ul>
<li><a href="#%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%A8%8B">连接过程</a></li>
<li><a href="#%E4%B8%BB%E4%BB%8E%E9%93%BE">主从链</a></li>
</ul>
</li>
<li><a href="#%E5%8D%81%E4%BA%8Csentinel">十二、Sentinel</a></li>
<li><a href="#%E5%8D%81%E4%B8%89%E5%88%86%E7%89%87">十三、分片</a></li>
<li><a href="#%E5%8D%81%E5%9B%9B%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E8%AE%BA%E5%9D%9B%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90">十四、一个简单的论坛系统分析</a>
<ul>
<li><a href="#%E6%96%87%E7%AB%A0%E4%BF%A1%E6%81%AF">文章信息</a></li>
<li><a href="#%E7%82%B9%E8%B5%9E%E5%8A%9F%E8%83%BD">点赞功能</a></li>
<li><a href="#%E5%AF%B9%E6%96%87%E7%AB%A0%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F">对文章进行排序</a></li>
</ul>
</li>
<li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
</li>
</ul>
<!-- GFM-TOC -->
<h2 id="一概述">一、概述</h2>
<p>Redis 是速度非常快的非关系型（NoSQL）内存键值数据库，可以存储键和五种不同类型的值之间的映射。</p>
<p>键的类型只能为字符串，值支持五种数据类型：字符串、列表、集合、散列表、有序集合。</p>
<p>Redis 支持很多特性，例如将内存中的数据持久化到硬盘中，使用复制来扩展读性能，使用分片来扩展写性能。</p>
<h2 id="二数据类型">二、数据类型</h2>
<table>
<thead>
<tr>
<th style="text-align:center">数据类型</th>
<th style="text-align:center">可以存储的值</th>
<th style="text-align:center">操作</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">STRING</td>
<td style="text-align:center">字符串、整数或者浮点数</td>
<td style="text-align:center">对整个字符串或者字符串的其中一部分执行操作&lt;/br&gt; 对整数和浮点数执行自增或者自减操作</td>
</tr>
<tr>
<td style="text-align:center">LIST</td>
<td style="text-align:center">列表</td>
<td style="text-align:center">从两端压入或者弹出元素 &lt;/br&gt; 对单个或者多个元素进行修剪，&lt;/br&gt; 只保留一个范围内的元素</td>
</tr>
<tr>
<td style="text-align:center">SET</td>
<td style="text-align:center">无序集合</td>
<td style="text-align:center">添加、获取、移除单个元素&lt;/br&gt; 检查一个元素是否存在于集合中&lt;/br&gt; 计算交集、并集、差集&lt;/br&gt; 从集合里面随机获取元素</td>
</tr>
<tr>
<td style="text-align:center">HASH</td>
<td style="text-align:center">包含键值对的无序散列表</td>
<td style="text-align:center">添加、获取、移除单个键值对&lt;/br&gt; 获取所有键值对&lt;/br&gt; 检查某个键是否存在</td>
</tr>
<tr>
<td style="text-align:center">ZSET</td>
<td style="text-align:center">有序集合</td>
<td style="text-align:center">添加、获取、删除元素&lt;/br&gt; 根据分值范围或者成员来获取元素&lt;/br&gt; 计算一个键的排名</td>
</tr>
</tbody>
</table>
<blockquote>
<p><a href="https://redislabs.com/ebook/part-1-getting-started/chapter-1-getting-to-know-redis/1-2-what-redis-data-structures-look-like/">What Redis data structures look like</a></p>
</blockquote>
<h3 id="string">STRING</h3>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/6019b2db-bc3e-4408-b6d8-96025f4481d6.png" width="400"/> </div><br>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">&gt; set hello world
OK
&gt; get hello
&#34;world&#34;
&gt; del hello
(integer) 1
&gt; get hello
(nil)
</code></pre></div><h3 id="list">LIST</h3>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/fb327611-7e2b-4f2f-9f5b-38592d408f07.png" width="400"/> </div><br>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">&gt; rpush list-key item
(integer) 1
&gt; rpush list-key item2
(integer) 2
&gt; rpush list-key item
(integer) 3

&gt; lrange list-key 0 -1
1) &#34;item&#34;
2) &#34;item2&#34;
3) &#34;item&#34;

&gt; lindex list-key 1
&#34;item2&#34;

&gt; lpop list-key
&#34;item&#34;

&gt; lrange list-key 0 -1
1) &#34;item2&#34;
2) &#34;item&#34;
</code></pre></div><h3 id="set">SET</h3>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/cd5fbcff-3f35-43a6-8ffa-082a93ce0f0e.png" width="400"/> </div><br>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">&gt; sadd set-key item
(integer) 1
&gt; sadd set-key item2
(integer) 1
&gt; sadd set-key item3
(integer) 1
&gt; sadd set-key item
(integer) 0

&gt; smembers set-key
1) &#34;item&#34;
2) &#34;item2&#34;
3) &#34;item3&#34;

&gt; sismember set-key item4
(integer) 0
&gt; sismember set-key item
(integer) 1

&gt; srem set-key item2
(integer) 1
&gt; srem set-key item2
(integer) 0

&gt; smembers set-key
1) &#34;item&#34;
2) &#34;item3&#34;
</code></pre></div><h3 id="hash">HASH</h3>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/7bd202a7-93d4-4f3a-a878-af68ae25539a.png" width="400"/> </div><br>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">&gt; hset hash-key sub-key1 value1
(integer) 1
&gt; hset hash-key sub-key2 value2
(integer) 1
&gt; hset hash-key sub-key1 value1
(integer) 0

&gt; hgetall hash-key
1) &#34;sub-key1&#34;
2) &#34;value1&#34;
3) &#34;sub-key2&#34;
4) &#34;value2&#34;

&gt; hdel hash-key sub-key2
(integer) 1
&gt; hdel hash-key sub-key2
(integer) 0

&gt; hget hash-key sub-key1
&#34;value1&#34;

&gt; hgetall hash-key
1) &#34;sub-key1&#34;
2) &#34;value1&#34;
</code></pre></div><h3 id="zset">ZSET</h3>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1202b2d6-9469-4251-bd47-ca6034fb6116.png" width="400"/> </div><br>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">&gt; zadd zset-key 728 member1
(integer) 1
&gt; zadd zset-key 982 member0
(integer) 1
&gt; zadd zset-key 982 member0
(integer) 0

&gt; zrange zset-key 0 -1 withscores
1) &#34;member1&#34;
2) &#34;728&#34;
3) &#34;member0&#34;
4) &#34;982&#34;

&gt; zrangebyscore zset-key 0 800 withscores
1) &#34;member1&#34;
2) &#34;728&#34;

&gt; zrem zset-key member1
(integer) 1
&gt; zrem zset-key member1
(integer) 0

&gt; zrange zset-key 0 -1 withscores
1) &#34;member0&#34;
2) &#34;982&#34;
</code></pre></div><h2 id="三数据结构">三、数据结构</h2>
<h3 id="字典">字典</h3>
<p>dictht 是一个散列表结构，使用拉链法解决哈希冲突。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">/* This is our hash table structure. Every dictionary has two of this as we
</span><span style="color:#75715e"> * implement incremental rehashing, for the old to the new table. */</span>
<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> dictht {
    dictEntry <span style="color:#f92672">**</span>table;
    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> size;
    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> sizemask;
    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> used;
} dictht;
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> dictEntry {
    <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>key;
    <span style="color:#66d9ef">union</span> {
        <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>val;
        <span style="color:#66d9ef">uint64_t</span> u64;
        <span style="color:#66d9ef">int64_t</span> s64;
        <span style="color:#66d9ef">double</span> d;
    } v;
    <span style="color:#66d9ef">struct</span> dictEntry <span style="color:#f92672">*</span>next;
} dictEntry;
</code></pre></div><p>Redis 的字典 dict 中包含两个哈希表 dictht，这是为了方便进行 rehash 操作。在扩容时，将其中一个 dictht 上的键值对 rehash 到另一个 dictht 上面，完成之后释放空间并交换两个 dictht 的角色。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> dict {
    dictType <span style="color:#f92672">*</span>type;
    <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>privdata;
    dictht ht[<span style="color:#ae81ff">2</span>];
    <span style="color:#66d9ef">long</span> rehashidx; <span style="color:#75715e">/* rehashing not in progress if rehashidx == -1 */</span>
    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> iterators; <span style="color:#75715e">/* number of iterators currently running */</span>
} dict;
</code></pre></div><p>rehash 操作不是一次性完成，而是采用渐进方式，这是为了避免一次性执行过多的 rehash 操作给服务器带来过大的负担。</p>
<p>渐进式 rehash 通过记录 dict 的 rehashidx 完成，它从 0 开始，然后每执行一次 rehash 都会递增。例如在一次 rehash 中，要把 dict[0] rehash 到 dict[1]，这一次会把 dict[0] 上 table[rehashidx] 的键值对 rehash 到 dict[1] 上，dict[0] 的 table[rehashidx] 指向 null，并令 rehashidx++。</p>
<p>在 rehash 期间，每次对字典执行添加、删除、查找或者更新操作时，都会执行一次渐进式 rehash。</p>
<p>采用渐进式 rehash 会导致字典中的数据分散在两个 dictht 上，因此对字典的查找操作也需要到对应的 dictht 去执行。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">/* Performs N steps of incremental rehashing. Returns 1 if there are still
</span><span style="color:#75715e"> * keys to move from the old to the new hash table, otherwise 0 is returned.
</span><span style="color:#75715e"> *
</span><span style="color:#75715e"> * Note that a rehashing step consists in moving a bucket (that may have more
</span><span style="color:#75715e"> * than one key as we use chaining) from the old to the new hash table, however
</span><span style="color:#75715e"> * since part of the hash table may be composed of empty spaces, it is not
</span><span style="color:#75715e"> * guaranteed that this function will rehash even a single bucket, since it
</span><span style="color:#75715e"> * will visit at max N*10 empty buckets in total, otherwise the amount of
</span><span style="color:#75715e"> * work it does would be unbound and the function may block for a long time. */</span>
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">dictRehash</span>(dict <span style="color:#f92672">*</span>d, <span style="color:#66d9ef">int</span> n) {
    <span style="color:#66d9ef">int</span> empty_visits <span style="color:#f92672">=</span> n <span style="color:#f92672">*</span> <span style="color:#ae81ff">10</span>; <span style="color:#75715e">/* Max number of empty buckets to visit. */</span>
    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>dictIsRehashing(d)) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;

    <span style="color:#66d9ef">while</span> (n<span style="color:#f92672">--</span> <span style="color:#f92672">&amp;&amp;</span> d<span style="color:#f92672">-&gt;</span>ht[<span style="color:#ae81ff">0</span>].used <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>) {
        dictEntry <span style="color:#f92672">*</span>de, <span style="color:#f92672">*</span>nextde;

        <span style="color:#75715e">/* Note that rehashidx can&#39;t overflow as we are sure there are more
</span><span style="color:#75715e">         * elements because ht[0].used != 0 */</span>
        assert(d<span style="color:#f92672">-&gt;</span>ht[<span style="color:#ae81ff">0</span>].size <span style="color:#f92672">&gt;</span> (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>) d<span style="color:#f92672">-&gt;</span>rehashidx);
        <span style="color:#66d9ef">while</span> (d<span style="color:#f92672">-&gt;</span>ht[<span style="color:#ae81ff">0</span>].table[d<span style="color:#f92672">-&gt;</span>rehashidx] <span style="color:#f92672">==</span> NULL) {
            d<span style="color:#f92672">-&gt;</span>rehashidx<span style="color:#f92672">++</span>;
            <span style="color:#66d9ef">if</span> (<span style="color:#f92672">--</span>empty_visits <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
        }
        de <span style="color:#f92672">=</span> d<span style="color:#f92672">-&gt;</span>ht[<span style="color:#ae81ff">0</span>].table[d<span style="color:#f92672">-&gt;</span>rehashidx];
        <span style="color:#75715e">/* Move all the keys in this bucket from the old to the new hash HT */</span>
        <span style="color:#66d9ef">while</span> (de) {
            <span style="color:#66d9ef">uint64_t</span> h;

            nextde <span style="color:#f92672">=</span> de<span style="color:#f92672">-&gt;</span>next;
            <span style="color:#75715e">/* Get the index in the new hash table */</span>
            h <span style="color:#f92672">=</span> dictHashKey(d, de<span style="color:#f92672">-&gt;</span>key) <span style="color:#f92672">&amp;</span> d<span style="color:#f92672">-&gt;</span>ht[<span style="color:#ae81ff">1</span>].sizemask;
            de<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> d<span style="color:#f92672">-&gt;</span>ht[<span style="color:#ae81ff">1</span>].table[h];
            d<span style="color:#f92672">-&gt;</span>ht[<span style="color:#ae81ff">1</span>].table[h] <span style="color:#f92672">=</span> de;
            d<span style="color:#f92672">-&gt;</span>ht[<span style="color:#ae81ff">0</span>].used<span style="color:#f92672">--</span>;
            d<span style="color:#f92672">-&gt;</span>ht[<span style="color:#ae81ff">1</span>].used<span style="color:#f92672">++</span>;
            de <span style="color:#f92672">=</span> nextde;
        }
        d<span style="color:#f92672">-&gt;</span>ht[<span style="color:#ae81ff">0</span>].table[d<span style="color:#f92672">-&gt;</span>rehashidx] <span style="color:#f92672">=</span> NULL;
        d<span style="color:#f92672">-&gt;</span>rehashidx<span style="color:#f92672">++</span>;
    }

    <span style="color:#75715e">/* Check if we already rehashed the whole table... */</span>
    <span style="color:#66d9ef">if</span> (d<span style="color:#f92672">-&gt;</span>ht[<span style="color:#ae81ff">0</span>].used <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
        zfree(d<span style="color:#f92672">-&gt;</span>ht[<span style="color:#ae81ff">0</span>].table);
        d<span style="color:#f92672">-&gt;</span>ht[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> d<span style="color:#f92672">-&gt;</span>ht[<span style="color:#ae81ff">1</span>];
        _dictReset(<span style="color:#f92672">&amp;</span>d<span style="color:#f92672">-&gt;</span>ht[<span style="color:#ae81ff">1</span>]);
        d<span style="color:#f92672">-&gt;</span>rehashidx <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
    }

    <span style="color:#75715e">/* More to rehash... */</span>
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
}
</code></pre></div><h3 id="跳跃表">跳跃表</h3>
<p>是有序集合的底层实现之一。</p>
<p>跳跃表是基于多指针有序链表实现的，可以看成多个有序链表。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/beba612e-dc5b-4fc2-869d-0b23408ac90a.png" width="600px"/> </div><br>
<p>在查找时，从上层指针开始查找，找到对应的区间之后再到下一层去查找。下图演示了查找 22 的过程。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/0ea37ee2-c224-4c79-b895-e131c6805c40.png" width="600px"/> </div><br>
<p>与红黑树等平衡树相比，跳跃表具有以下优点：</p>
<ul>
<li>插入速度非常快速，因为不需要进行旋转等操作来维护平衡性；</li>
<li>更容易实现；</li>
<li>支持无锁操作。</li>
</ul>
<h2 id="四使用场景">四、使用场景</h2>
<h3 id="计数器">计数器</h3>
<p>可以对 String 进行自增自减运算，从而实现计数器功能。</p>
<p>Redis 这种内存型数据库的读写性能非常高，很适合存储频繁读写的计数量。</p>
<h3 id="缓存">缓存</h3>
<p>将热点数据放到内存中，设置内存的最大使用量以及淘汰策略来保证缓存的命中率。</p>
<h3 id="查找表">查找表</h3>
<p>例如 DNS 记录就很适合使用 Redis 进行存储。</p>
<p>查找表和缓存类似，也是利用了 Redis 快速的查找特性。但是查找表的内容不能失效，而缓存的内容可以失效，因为缓存不作为可靠的数据来源。</p>
<h3 id="消息队列">消息队列</h3>
<p>List 是一个双向链表，可以通过 lpush 和 rpop 写入和读取消息</p>
<p>不过最好使用 Kafka、RabbitMQ 等消息中间件。</p>
<h3 id="会话缓存">会话缓存</h3>
<p>可以使用 Redis 来统一存储多台应用服务器的会话信息。</p>
<p>当应用服务器不再存储用户的会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务器，从而更容易实现高可用性以及可伸缩性。</p>
<h3 id="分布式锁实现">分布式锁实现</h3>
<p>在分布式场景下，无法使用单机环境下的锁来对多个节点上的进程进行同步。</p>
<p>可以使用 Redis 自带的 SETNX 命令实现分布式锁，除此之外，还可以使用官方提供的 RedLock 分布式锁实现。</p>
<h3 id="其它">其它</h3>
<p>Set 可以实现交集、并集等操作，从而实现共同好友等功能。</p>
<p>ZSet 可以实现有序性操作，从而实现排行榜等功能。</p>
<h2 id="五redis-与-memcached">五、Redis 与 Memcached</h2>
<p>两者都是非关系型内存键值数据库，主要有以下不同：</p>
<h3 id="数据类型">数据类型</h3>
<p>Memcached 仅支持字符串类型，而 Redis 支持五种不同的数据类型，可以更灵活地解决问题。</p>
<h3 id="数据持久化">数据持久化</h3>
<p>Redis 支持两种持久化策略：RDB 快照和 AOF 日志，而 Memcached 不支持持久化。</p>
<h3 id="分布式">分布式</h3>
<p>Memcached 不支持分布式，只能通过在客户端使用一致性哈希来实现分布式存储，这种方式在存储和查询时都需要先在客户端计算一次数据所在的节点。</p>
<p>Redis Cluster 实现了分布式的支持。</p>
<h3 id="内存管理机制">内存管理机制</h3>
<ul>
<li>
<p>在 Redis 中，并不是所有数据都一直存储在内存中，可以将一些很久没用的 value 交换到磁盘，而 Memcached 的数据则会一直在内存中。</p>
</li>
<li>
<p>Memcached 将内存分割成特定长度的块来存储数据，以完全解决内存碎片的问题。但是这种方式会使得内存的利用率不高，例如块的大小为 128 bytes，只存储 100 bytes 的数据，那么剩下的 28 bytes 就浪费掉了。</p>
</li>
</ul>
<h2 id="六键的过期时间">六、键的过期时间</h2>
<p>Redis 可以为每个键设置过期时间，当键过期时，会自动删除该键。</p>
<p>对于散列表这种容器，只能为整个键设置过期时间（整个散列表），而不能为键里面的单个元素设置过期时间。</p>
<h2 id="七数据淘汰策略">七、数据淘汰策略</h2>
<p>可以设置内存最大使用量，当内存使用量超出时，会施行数据淘汰策略。</p>
<p>Redis 具体有 6 种淘汰策略：</p>
<table>
<thead>
<tr>
<th style="text-align:center">策略</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">volatile-lru</td>
<td style="text-align:center">从已设置过期时间的数据集中挑选最近最少使用的数据淘汰</td>
</tr>
<tr>
<td style="text-align:center">volatile-ttl</td>
<td style="text-align:center">从已设置过期时间的数据集中挑选将要过期的数据淘汰</td>
</tr>
<tr>
<td style="text-align:center">volatile-random</td>
<td style="text-align:center">从已设置过期时间的数据集中任意选择数据淘汰</td>
</tr>
<tr>
<td style="text-align:center">allkeys-lru</td>
<td style="text-align:center">从所有数据集中挑选最近最少使用的数据淘汰</td>
</tr>
<tr>
<td style="text-align:center">allkeys-random</td>
<td style="text-align:center">从所有数据集中任意选择数据进行淘汰</td>
</tr>
<tr>
<td style="text-align:center">noeviction</td>
<td style="text-align:center">禁止驱逐数据</td>
</tr>
</tbody>
</table>
<p>作为内存数据库，出于对性能和内存消耗的考虑，Redis 的淘汰算法实际实现上并非针对所有 key，而是抽样一小部分并且从中选出被淘汰的 key。</p>
<p>使用 Redis 缓存数据时，为了提高缓存命中率，需要保证缓存数据都是热点数据。可以将内存最大使用量设置为热点数据占用的内存量，然后启用 allkeys-lru 淘汰策略，将最近最少使用的数据淘汰。</p>
<p>Redis 4.0 引入了 volatile-lfu 和 allkeys-lfu 淘汰策略，LFU 策略通过统计访问频率，将访问频率最少的键值对淘汰。</p>
<h2 id="八持久化">八、持久化</h2>
<p>Redis 是内存型数据库，为了保证数据在断电后不会丢失，需要将内存中的数据持久化到硬盘上。</p>
<h3 id="rdb-持久化">RDB 持久化</h3>
<p>将某个时间点的所有数据都存放到硬盘上。</p>
<p>可以将快照复制到其它服务器从而创建具有相同数据的服务器副本。</p>
<p>如果系统发生故障，将会丢失最后一次创建快照之后的数据。</p>
<p>如果数据量很大，保存快照的时间会很长。</p>
<h3 id="aof-持久化">AOF 持久化</h3>
<p>将写命令添加到 AOF 文件（Append Only File）的末尾。</p>
<p>使用 AOF 持久化需要设置同步选项，从而确保写命令同步到磁盘文件上的时机。这是因为对文件进行写入并不会马上将内容同步到磁盘上，而是先存储到缓冲区，然后由操作系统决定什么时候同步到磁盘。有以下同步选项：</p>
<table>
<thead>
<tr>
<th style="text-align:center">选项</th>
<th style="text-align:center">同步频率</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">always</td>
<td style="text-align:center">每个写命令都同步</td>
</tr>
<tr>
<td style="text-align:center">everysec</td>
<td style="text-align:center">每秒同步一次</td>
</tr>
<tr>
<td style="text-align:center">no</td>
<td style="text-align:center">让操作系统来决定何时同步</td>
</tr>
</tbody>
</table>
<ul>
<li>always 选项会严重减低服务器的性能；</li>
<li>everysec 选项比较合适，可以保证系统崩溃时只会丢失一秒左右的数据，并且 Redis 每秒执行一次同步对服务器性能几乎没有任何影响；</li>
<li>no 选项并不能给服务器性能带来多大的提升，而且也会增加系统崩溃时数据丢失的数量。</li>
</ul>
<p>随着服务器写请求的增多，AOF 文件会越来越大。Redis 提供了一种将 AOF 重写的特性，能够去除 AOF 文件中的冗余写命令。</p>
<h2 id="九事务">九、事务</h2>
<p>一个事务包含了多个命令，服务器在执行事务期间，不会改去执行其它客户端的命令请求。</p>
<p>事务中的多个命令被一次性发送给服务器，而不是一条一条发送，这种方式被称为流水线，它可以减少客户端与服务器之间的网络通信次数从而提升性能。</p>
<p>Redis 最简单的事务实现方式是使用 MULTI 和 EXEC 命令将事务操作包围起来。</p>
<h2 id="十事件">十、事件</h2>
<p>Redis 服务器是一个事件驱动程序。</p>
<h3 id="文件事件">文件事件</h3>
<p>服务器通过套接字与客户端或者其它服务器进行通信，文件事件就是对套接字操作的抽象。</p>
<p>Redis 基于 Reactor 模式开发了自己的网络事件处理器，使用 I/O 多路复用程序来同时监听多个套接字，并将到达的事件传送给文件事件分派器，分派器会根据套接字产生的事件类型调用相应的事件处理器。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/9ea86eb5-000a-4281-b948-7b567bd6f1d8.png" width=""/> </div><br>
<h3 id="时间事件">时间事件</h3>
<p>服务器有一些操作需要在给定的时间点执行，时间事件是对这类定时操作的抽象。</p>
<p>时间事件又分为：</p>
<ul>
<li>定时事件：是让一段程序在指定的时间之内执行一次；</li>
<li>周期性事件：是让一段程序每隔指定时间就执行一次。</li>
</ul>
<p>Redis 将所有时间事件都放在一个无序链表中，通过遍历整个链表查找出已到达的时间事件，并调用相应的事件处理器。</p>
<h3 id="事件的调度与执行">事件的调度与执行</h3>
<p>服务器需要不断监听文件事件的套接字才能得到待处理的文件事件，但是不能一直监听，否则时间事件无法在规定的时间内执行，因此监听时间应该根据距离现在最近的时间事件来决定。</p>
<p>事件调度与执行由 aeProcessEvents 函数负责，伪代码如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">aeProcessEvents</span>():
    <span style="color:#75715e"># 获取到达时间离当前时间最接近的时间事件</span>
    time_event <span style="color:#f92672">=</span> aeSearchNearestTimer()
    <span style="color:#75715e"># 计算最接近的时间事件距离到达还有多少毫秒</span>
    remaind_ms <span style="color:#f92672">=</span> time_event<span style="color:#f92672">.</span>when <span style="color:#f92672">-</span> unix_ts_now()
    <span style="color:#75715e"># 如果事件已到达，那么 remaind_ms 的值可能为负数，将它设为 0</span>
    <span style="color:#66d9ef">if</span> remaind_ms <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>:
        remaind_ms <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
    <span style="color:#75715e"># 根据 remaind_ms 的值，创建 timeval</span>
    timeval <span style="color:#f92672">=</span> create_timeval_with_ms(remaind_ms)
    <span style="color:#75715e"># 阻塞并等待文件事件产生，最大阻塞时间由传入的 timeval 决定</span>
    aeApiPoll(timeval)
    <span style="color:#75715e"># 处理所有已产生的文件事件</span>
    procesFileEvents()
    <span style="color:#75715e"># 处理所有已到达的时间事件</span>
    processTimeEvents()
</code></pre></div><p>将 aeProcessEvents 函数置于一个循环里面，加上初始化和清理函数，就构成了 Redis 服务器的主函数，伪代码如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">main</span>():
    <span style="color:#75715e"># 初始化服务器</span>
    init_server()
    <span style="color:#75715e"># 一直处理事件，直到服务器关闭为止</span>
    <span style="color:#66d9ef">while</span> server_is_not_shutdown():
        aeProcessEvents()
    <span style="color:#75715e"># 服务器关闭，执行清理操作</span>
    clean_server()
</code></pre></div><p>从事件处理的角度来看，服务器运行流程如下：</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/c0a9fa91-da2e-4892-8c9f-80206a6f7047.png" width="350"/> </div><br>
<h2 id="十一复制">十一、复制</h2>
<p>通过使用 slaveof host port 命令来让一个服务器成为另一个服务器的从服务器。</p>
<p>一个从服务器只能有一个主服务器，并且不支持主主复制。</p>
<h3 id="连接过程">连接过程</h3>
<ol>
<li>
<p>主服务器创建快照文件，发送给从服务器，并在发送期间使用缓冲区记录执行的写命令。快照文件发送完毕之后，开始向从服务器发送存储在缓冲区中的写命令；</p>
</li>
<li>
<p>从服务器丢弃所有旧数据，载入主服务器发来的快照文件，之后从服务器开始接受主服务器发来的写命令；</p>
</li>
<li>
<p>主服务器每执行一次写命令，就向从服务器发送相同的写命令。</p>
</li>
</ol>
<h3 id="主从链">主从链</h3>
<p>随着负载不断上升，主服务器可能无法很快地更新所有从服务器，或者重新连接和重新同步从服务器将导致系统超载。为了解决这个问题，可以创建一个中间层来分担主服务器的复制工作。中间层的服务器是最上层服务器的从服务器，又是最下层服务器的主服务器。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/395a9e83-b1a1-4a1d-b170-d081e7bb5bab.png" width="600"/> </div><br>
<h2 id="十二sentinel">十二、Sentinel</h2>
<p>Sentinel（哨兵）可以监听集群中的服务器，并在主服务器进入下线状态时，自动从从服务器中选举出新的主服务器。</p>
<h2 id="十三分片">十三、分片</h2>
<p>分片是将数据划分为多个部分的方法，可以将数据存储到多台机器里面，这种方法在解决某些问题时可以获得线性级别的性能提升。</p>
<p>假设有 4 个 Redis 实例 R0，R1，R2，R3，还有很多表示用户的键 user:1，user:2，&hellip; ，有不同的方式来选择一个指定的键存储在哪个实例中。</p>
<ul>
<li>最简单的方式是范围分片，例如用户 id 从 0~1000 的存储到实例 R0 中，用户 id 从 1001~2000 的存储到实例 R1 中，等等。但是这样需要维护一张映射范围表，维护操作代价很高。</li>
<li>还有一种方式是哈希分片，使用 CRC32 哈希函数将键转换为一个数字，再对实例数量求模就能知道应该存储的实例。</li>
</ul>
<p>根据执行分片的位置，可以分为三种分片方式：</p>
<ul>
<li>客户端分片：客户端使用一致性哈希等算法决定键应当分布到哪个节点。</li>
<li>代理分片：将客户端请求发送到代理上，由代理转发请求到正确的节点上。</li>
<li>服务器分片：Redis Cluster。</li>
</ul>
<h2 id="十四一个简单的论坛系统分析">十四、一个简单的论坛系统分析</h2>
<p>该论坛系统功能如下：</p>
<ul>
<li>可以发布文章；</li>
<li>可以对文章进行点赞；</li>
<li>在首页可以按文章的发布时间或者文章的点赞数进行排序显示。</li>
</ul>
<h3 id="文章信息">文章信息</h3>
<p>文章包括标题、作者、赞数等信息，在关系型数据库中很容易构建一张表来存储这些信息，在 Redis 中可以使用 HASH 来存储每种信息以及其对应的值的映射。</p>
<p>Redis 没有关系型数据库中的表这一概念来将同种类型的数据存放在一起，而是使用命名空间的方式来实现这一功能。键名的前面部分存储命名空间，后面部分的内容存储 ID，通常使用 : 来进行分隔。例如下面的 HASH 的键名为 article:92617，其中 article 为命名空间，ID 为 92617。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/7c54de21-e2ff-402e-bc42-4037de1c1592.png" width="400"/> </div><br>
<h3 id="点赞功能">点赞功能</h3>
<p>当有用户为一篇文章点赞时，除了要对该文章的 votes 字段进行加 1 操作，还必须记录该用户已经对该文章进行了点赞，防止用户点赞次数超过 1。可以建立文章的已投票用户集合来进行记录。</p>
<p>为了节约内存，规定一篇文章发布满一周之后，就不能再对它进行投票，而文章的已投票集合也会被删除，可以为文章的已投票集合设置一个一周的过期时间就能实现这个规定。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/485fdf34-ccf8-4185-97c6-17374ee719a0.png" width="400"/> </div><br>
<h3 id="对文章进行排序">对文章进行排序</h3>
<p>为了按发布时间和点赞数进行排序，可以建立一个文章发布时间的有序集合和一个文章点赞数的有序集合。（下图中的 score 就是这里所说的点赞数；下面所示的有序集合分值并不直接是时间和点赞数，而是根据时间和点赞数间接计算出来的）</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f7d170a3-e446-4a64-ac2d-cb95028f81a8.png" width="800"/> </div><br>
<h2 id="参考资料">参考资料</h2>
<ul>
<li>Carlson J L. Redis in Action[J]. Media.johnwiley.com.au, 2013.</li>
<li><a href="http://redisbook.com/index.html">黄健宏. Redis 设计与实现 [M]. 机械工业出版社, 2014.</a></li>
<li><a href="https://redislabs.com/ebook/foreword/">REDIS IN ACTION</a></li>
<li><a href="http://ticki.github.io/blog/skip-lists-done-right/">Skip Lists: Done Right</a></li>
<li><a href="http://www.cnblogs.com/loveincode/p/7411911.html">论述 Redis 和 Memcached 的差异</a></li>
<li><a href="http://wiki.jikexueyuan.com/project/redis-guide">Redis 3.0 中文版- 分片</a></li>
<li><a href="http://www.scienjus.com/redis-use-case/">Redis 应用场景</a></li>
<li><a href="https://redis.io/topics/lru-cache">Using Redis as an LRU cache</a></li>
</ul>

        
        ]]>
      </description>
    </item>
    
    
    
    <item>
      <title>【转载】SQL 练习</title>
      <link>/post/2021/12/22/%E8%BD%AC%E8%BD%BDsql-%E7%BB%83%E4%B9%A0/</link>
      <pubDate>Wed, 22 Dec 2021 23:32:38 +0800</pubDate>
      <author>罗泽勋</author>
      <guid>/post/2021/12/22/%E8%BD%AC%E8%BD%BDsql-%E7%BB%83%E4%B9%A0/</guid>
      <description>
        <![CDATA[
        <h1 id="sql-练习">SQL 练习</h1>
<!-- GFM-TOC -->
<ul>
<li><a href="#sql-%E7%BB%83%E4%B9%A0">SQL 练习</a>
<ul>
<li><a href="#595-big-countries">595. Big Countries</a></li>
<li><a href="#627-swap-salary">627. Swap Salary</a></li>
<li><a href="#620-not-boring-movies">620. Not Boring Movies</a></li>
<li><a href="#596-classes-more-than-5-students">596. Classes More Than 5 Students</a></li>
<li><a href="#182-duplicate-emails">182. Duplicate Emails</a></li>
<li><a href="#196-delete-duplicate-emails">196. Delete Duplicate Emails</a></li>
<li><a href="#175-combine-two-tables">175. Combine Two Tables</a></li>
<li><a href="#181-employees-earning-more-than-their-managers">181. Employees Earning More Than Their Managers</a></li>
<li><a href="#183-customers-who-never-order">183. Customers Who Never Order</a></li>
<li><a href="#184-department-highest-salary">184. Department Highest Salary</a></li>
<li><a href="#176-second-highest-salary">176. Second Highest Salary</a></li>
<li><a href="#177-nth-highest-salary">177. Nth Highest Salary</a></li>
<li><a href="#178-rank-scores">178. Rank Scores</a></li>
<li><a href="#180-consecutive-numbers">180. Consecutive Numbers</a></li>
<li><a href="#626-exchange-seats">626. Exchange Seats</a></li>
</ul>
</li>
</ul>
<!-- GFM-TOC -->
<h2 id="595-big-countries">595. Big Countries</h2>
<p><a href="https://leetcode.com/problems/big-countries/description/">https://leetcode.com/problems/big-countries/description/</a></p>
<h3 id="description">Description</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">+-----------------+------------+------------+--------------+---------------+
| name            | continent  | area       | population   | gdp           |
+-----------------+------------+------------+--------------+---------------+
| Afghanistan     | Asia       | 652230     | 25500100     | 20343000      |
| Albania         | Europe     | 28748      | 2831741      | 12960000      |
| Algeria         | Africa     | 2381741    | 37100000     | 188681000     |
| Andorra         | Europe     | 468        | 78115        | 3712000       |
| Angola          | Africa     | 1246700    | 20609294     | 100990000     |
+-----------------+------------+------------+--------------+---------------+
</code></pre></div><p>查找面积超过 3,000,000 或者人口数超过 25,000,000 的国家。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">+--------------+-------------+--------------+
| name         | population  | area         |
+--------------+-------------+--------------+
| Afghanistan  | 25500100    | 652230       |
| Algeria      | 37100000    | 2381741      |
+--------------+-------------+--------------+
</code></pre></div><h3 id="solution">Solution</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span> name,
    population,
    area
<span style="color:#66d9ef">FROM</span>
    World
<span style="color:#66d9ef">WHERE</span>
    area <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">3000000</span>
    <span style="color:#66d9ef">OR</span> population <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">25000000</span>;
</code></pre></div><h3 id="sql-schema">SQL Schema</h3>
<p>SQL Schema 用于在本地环境下创建表结构并导入数据，从而方便在本地环境调试。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">DROP</span> <span style="color:#66d9ef">TABLE</span>
<span style="color:#66d9ef">IF</span>
    <span style="color:#66d9ef">EXISTS</span> World;
<span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">TABLE</span> World ( NAME VARCHAR ( <span style="color:#ae81ff">255</span> ), continent VARCHAR ( <span style="color:#ae81ff">255</span> ), area INT, population INT, gdp INT );
<span style="color:#66d9ef">INSERT</span> <span style="color:#66d9ef">INTO</span> World ( NAME, continent, area, population, gdp )
<span style="color:#66d9ef">VALUES</span>
    ( <span style="color:#e6db74">&#39;Afghanistan&#39;</span>, <span style="color:#e6db74">&#39;Asia&#39;</span>, <span style="color:#e6db74">&#39;652230&#39;</span>, <span style="color:#e6db74">&#39;25500100&#39;</span>, <span style="color:#e6db74">&#39;203430000&#39;</span> ),
    ( <span style="color:#e6db74">&#39;Albania&#39;</span>, <span style="color:#e6db74">&#39;Europe&#39;</span>, <span style="color:#e6db74">&#39;28748&#39;</span>, <span style="color:#e6db74">&#39;2831741&#39;</span>, <span style="color:#e6db74">&#39;129600000&#39;</span> ),
    ( <span style="color:#e6db74">&#39;Algeria&#39;</span>, <span style="color:#e6db74">&#39;Africa&#39;</span>, <span style="color:#e6db74">&#39;2381741&#39;</span>, <span style="color:#e6db74">&#39;37100000&#39;</span>, <span style="color:#e6db74">&#39;1886810000&#39;</span> ),
    ( <span style="color:#e6db74">&#39;Andorra&#39;</span>, <span style="color:#e6db74">&#39;Europe&#39;</span>, <span style="color:#e6db74">&#39;468&#39;</span>, <span style="color:#e6db74">&#39;78115&#39;</span>, <span style="color:#e6db74">&#39;37120000&#39;</span> ),
    ( <span style="color:#e6db74">&#39;Angola&#39;</span>, <span style="color:#e6db74">&#39;Africa&#39;</span>, <span style="color:#e6db74">&#39;1246700&#39;</span>, <span style="color:#e6db74">&#39;20609294&#39;</span>, <span style="color:#e6db74">&#39;1009900000&#39;</span> );
</code></pre></div><h2 id="627-swap-salary">627. Swap Salary</h2>
<p><a href="https://leetcode.com/problems/swap-salary/description/">https://leetcode.com/problems/swap-salary/description/</a></p>
<h3 id="description-1">Description</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">| id | name | sex | salary |
|----|------|-----|--------|
| 1  | A    | m   | 2500   |
| 2  | B    | f   | 1500   |
| 3  | C    | m   | 5500   |
| 4  | D    | f   | 500    |
</code></pre></div><p>只用一个 SQL 查询，将 sex 字段反转。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">| id | name | sex | salary |
|----|------|-----|--------|
| 1  | A    | f   | 2500   |
| 2  | B    | m   | 1500   |
| 3  | C    | f   | 5500   |
| 4  | D    | m   | 500    |
</code></pre></div><h3 id="solution-1">Solution</h3>
<p>两个相等的数异或的结果为 0，而 0 与任何一个数异或的结果为这个数。</p>
<p>sex  字段只有两个取值：&lsquo;f&rsquo; 和 &rsquo;m'，并且有以下规律：</p>
<pre tabindex="0"><code>'f' ^ ('m' ^ 'f') = 'm' ^ ('f' ^ 'f') = 'm'
'm' ^ ('m' ^ 'f') = 'f' ^ ('m' ^ 'm') = 'f'
</code></pre><p>因此将 sex 字段和 &rsquo;m' ^ &lsquo;f&rsquo; 进行异或操作，最后就能反转 sex 字段。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">UPDATE</span> salary
<span style="color:#66d9ef">SET</span> sex <span style="color:#f92672">=</span> CHAR ( ASCII(sex) <span style="color:#f92672">^</span> ASCII( <span style="color:#e6db74">&#39;m&#39;</span> ) <span style="color:#f92672">^</span> ASCII( <span style="color:#e6db74">&#39;f&#39;</span> ) );
</code></pre></div><h3 id="sql-schema-1">SQL Schema</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">DROP</span> <span style="color:#66d9ef">TABLE</span>
<span style="color:#66d9ef">IF</span>
    <span style="color:#66d9ef">EXISTS</span> salary;
<span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">TABLE</span> salary ( id INT, NAME VARCHAR ( <span style="color:#ae81ff">100</span> ), sex CHAR ( <span style="color:#ae81ff">1</span> ), salary INT );
<span style="color:#66d9ef">INSERT</span> <span style="color:#66d9ef">INTO</span> salary ( id, NAME, sex, salary )
<span style="color:#66d9ef">VALUES</span>
    ( <span style="color:#e6db74">&#39;1&#39;</span>, <span style="color:#e6db74">&#39;A&#39;</span>, <span style="color:#e6db74">&#39;m&#39;</span>, <span style="color:#e6db74">&#39;2500&#39;</span> ),
    ( <span style="color:#e6db74">&#39;2&#39;</span>, <span style="color:#e6db74">&#39;B&#39;</span>, <span style="color:#e6db74">&#39;f&#39;</span>, <span style="color:#e6db74">&#39;1500&#39;</span> ),
    ( <span style="color:#e6db74">&#39;3&#39;</span>, <span style="color:#e6db74">&#39;C&#39;</span>, <span style="color:#e6db74">&#39;m&#39;</span>, <span style="color:#e6db74">&#39;5500&#39;</span> ),
    ( <span style="color:#e6db74">&#39;4&#39;</span>, <span style="color:#e6db74">&#39;D&#39;</span>, <span style="color:#e6db74">&#39;f&#39;</span>, <span style="color:#e6db74">&#39;500&#39;</span> );
</code></pre></div><h2 id="620-not-boring-movies">620. Not Boring Movies</h2>
<p><a href="https://leetcode.com/problems/not-boring-movies/description/">https://leetcode.com/problems/not-boring-movies/description/</a></p>
<h3 id="description-2">Description</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">+---------+-----------+--------------+-----------+
|   id    | movie     |  description |  rating   |
+---------+-----------+--------------+-----------+
|   1     | War       |   great 3D   |   8.9     |
|   2     | Science   |   fiction    |   8.5     |
|   3     | irish     |   boring     |   6.2     |
|   4     | Ice song  |   Fantacy    |   8.6     |
|   5     | House card|   Interesting|   9.1     |
+---------+-----------+--------------+-----------+
</code></pre></div><p>查找 id 为奇数，并且 description 不是 boring 的电影，按 rating 降序。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">+---------+-----------+--------------+-----------+
|   id    | movie     |  description |  rating   |
+---------+-----------+--------------+-----------+
|   5     | House card|   Interesting|   9.1     |
|   1     | War       |   great 3D   |   8.9     |
+---------+-----------+--------------+-----------+
</code></pre></div><h3 id="solution-2">Solution</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span>
    <span style="color:#f92672">*</span>
<span style="color:#66d9ef">FROM</span>
    cinema
<span style="color:#66d9ef">WHERE</span>
    id <span style="color:#f92672">%</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
    <span style="color:#66d9ef">AND</span> description <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#39;boring&#39;</span>
<span style="color:#66d9ef">ORDER</span> <span style="color:#66d9ef">BY</span>
    rating <span style="color:#66d9ef">DESC</span>;
</code></pre></div><h3 id="sql-schema-2">SQL Schema</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">DROP</span> <span style="color:#66d9ef">TABLE</span>
<span style="color:#66d9ef">IF</span>
    <span style="color:#66d9ef">EXISTS</span> cinema;
<span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">TABLE</span> cinema ( id INT, movie VARCHAR ( <span style="color:#ae81ff">255</span> ), description VARCHAR ( <span style="color:#ae81ff">255</span> ), rating FLOAT ( <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">1</span> ) );
<span style="color:#66d9ef">INSERT</span> <span style="color:#66d9ef">INTO</span> cinema ( id, movie, description, rating )
<span style="color:#66d9ef">VALUES</span>
    ( <span style="color:#ae81ff">1</span>, <span style="color:#e6db74">&#39;War&#39;</span>, <span style="color:#e6db74">&#39;great 3D&#39;</span>, <span style="color:#ae81ff">8</span>.<span style="color:#ae81ff">9</span> ),
    ( <span style="color:#ae81ff">2</span>, <span style="color:#e6db74">&#39;Science&#39;</span>, <span style="color:#e6db74">&#39;fiction&#39;</span>, <span style="color:#ae81ff">8</span>.<span style="color:#ae81ff">5</span> ),
    ( <span style="color:#ae81ff">3</span>, <span style="color:#e6db74">&#39;irish&#39;</span>, <span style="color:#e6db74">&#39;boring&#39;</span>, <span style="color:#ae81ff">6</span>.<span style="color:#ae81ff">2</span> ),
    ( <span style="color:#ae81ff">4</span>, <span style="color:#e6db74">&#39;Ice song&#39;</span>, <span style="color:#e6db74">&#39;Fantacy&#39;</span>, <span style="color:#ae81ff">8</span>.<span style="color:#ae81ff">6</span> ),
    ( <span style="color:#ae81ff">5</span>, <span style="color:#e6db74">&#39;House card&#39;</span>, <span style="color:#e6db74">&#39;Interesting&#39;</span>, <span style="color:#ae81ff">9</span>.<span style="color:#ae81ff">1</span> );
</code></pre></div><h2 id="596-classes-more-than-5-students">596. Classes More Than 5 Students</h2>
<p><a href="https://leetcode.com/problems/classes-more-than-5-students/description/">https://leetcode.com/problems/classes-more-than-5-students/description/</a></p>
<h3 id="description-3">Description</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">+---------+------------+
| student | class      |
+---------+------------+
| A       | Math       |
| B       | English    |
| C       | Math       |
| D       | Biology    |
| E       | Math       |
| F       | Computer   |
| G       | Math       |
| H       | Math       |
| I       | Math       |
+---------+------------+
</code></pre></div><p>查找有五名及以上 student 的 class。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">+---------+
| class   |
+---------+
| Math    |
+---------+
</code></pre></div><h3 id="solution-3">Solution</h3>
<p>对 class 列进行分组之后，再使用 count 汇总函数统计每个分组的记录个数，之后使用 HAVING 进行筛选。HAVING  针对分组进行筛选，而 WHERE 针对每个记录（行）进行筛选。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span>
    <span style="color:#66d9ef">class</span>
<span style="color:#66d9ef">FROM</span>
    courses
<span style="color:#66d9ef">GROUP</span> <span style="color:#66d9ef">BY</span>
    <span style="color:#66d9ef">class</span>
<span style="color:#66d9ef">HAVING</span>
    <span style="color:#66d9ef">count</span>( <span style="color:#66d9ef">DISTINCT</span> student ) <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">5</span>;
</code></pre></div><h3 id="sql-schema-3">SQL Schema</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">DROP</span> <span style="color:#66d9ef">TABLE</span>
<span style="color:#66d9ef">IF</span>
    <span style="color:#66d9ef">EXISTS</span> courses;
<span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">TABLE</span> courses ( student VARCHAR ( <span style="color:#ae81ff">255</span> ), <span style="color:#66d9ef">class</span> VARCHAR ( <span style="color:#ae81ff">255</span> ) );
<span style="color:#66d9ef">INSERT</span> <span style="color:#66d9ef">INTO</span> courses ( student, <span style="color:#66d9ef">class</span> )
<span style="color:#66d9ef">VALUES</span>
    ( <span style="color:#e6db74">&#39;A&#39;</span>, <span style="color:#e6db74">&#39;Math&#39;</span> ),
    ( <span style="color:#e6db74">&#39;B&#39;</span>, <span style="color:#e6db74">&#39;English&#39;</span> ),
    ( <span style="color:#e6db74">&#39;C&#39;</span>, <span style="color:#e6db74">&#39;Math&#39;</span> ),
    ( <span style="color:#e6db74">&#39;D&#39;</span>, <span style="color:#e6db74">&#39;Biology&#39;</span> ),
    ( <span style="color:#e6db74">&#39;E&#39;</span>, <span style="color:#e6db74">&#39;Math&#39;</span> ),
    ( <span style="color:#e6db74">&#39;F&#39;</span>, <span style="color:#e6db74">&#39;Computer&#39;</span> ),
    ( <span style="color:#e6db74">&#39;G&#39;</span>, <span style="color:#e6db74">&#39;Math&#39;</span> ),
    ( <span style="color:#e6db74">&#39;H&#39;</span>, <span style="color:#e6db74">&#39;Math&#39;</span> ),
    ( <span style="color:#e6db74">&#39;I&#39;</span>, <span style="color:#e6db74">&#39;Math&#39;</span> );
</code></pre></div><h2 id="182-duplicate-emails">182. Duplicate Emails</h2>
<p><a href="https://leetcode.com/problems/duplicate-emails/description/">https://leetcode.com/problems/duplicate-emails/description/</a></p>
<h3 id="description-4">Description</h3>
<p>邮件地址表：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">+----+---------+
| Id | Email   |
+----+---------+
| 1  | a@b.com |
| 2  | c@d.com |
| 3  | a@b.com |
+----+---------+
</code></pre></div><p>查找重复的邮件地址：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">+---------+
| Email   |
+---------+
| a@b.com |
+---------+
</code></pre></div><h3 id="solution-4">Solution</h3>
<p>对 Email 进行分组，如果并使用 COUNT 进行计数统计，结果大于等于 2 的表示 Email  重复。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span>
    Email
<span style="color:#66d9ef">FROM</span>
    Person
<span style="color:#66d9ef">GROUP</span> <span style="color:#66d9ef">BY</span>
    Email
<span style="color:#66d9ef">HAVING</span>
    <span style="color:#66d9ef">COUNT</span>( <span style="color:#f92672">*</span> ) <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">2</span>;
</code></pre></div><h3 id="sql-schema-4">SQL Schema</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">DROP</span> <span style="color:#66d9ef">TABLE</span>
<span style="color:#66d9ef">IF</span>
    <span style="color:#66d9ef">EXISTS</span> Person;
<span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">TABLE</span> Person ( Id INT, Email VARCHAR ( <span style="color:#ae81ff">255</span> ) );
<span style="color:#66d9ef">INSERT</span> <span style="color:#66d9ef">INTO</span> Person ( Id, Email )
<span style="color:#66d9ef">VALUES</span>
    ( <span style="color:#ae81ff">1</span>, <span style="color:#e6db74">&#39;a@b.com&#39;</span> ),
    ( <span style="color:#ae81ff">2</span>, <span style="color:#e6db74">&#39;c@d.com&#39;</span> ),
    ( <span style="color:#ae81ff">3</span>, <span style="color:#e6db74">&#39;a@b.com&#39;</span> );
</code></pre></div><h2 id="196-delete-duplicate-emails">196. Delete Duplicate Emails</h2>
<p><a href="https://leetcode.com/problems/delete-duplicate-emails/description/">https://leetcode.com/problems/delete-duplicate-emails/description/</a></p>
<h3 id="description-5">Description</h3>
<p>邮件地址表：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">+----+---------+
| Id | Email   |
+----+---------+
| 1  | john@example.com |
| 2  | bob@example.com |
| 3  | john@example.com |
+----+---------+
</code></pre></div><p>删除重复的邮件地址：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">+----+------------------+
| Id | Email            |
+----+------------------+
| 1  | john@example.com |
| 2  | bob@example.com  |
+----+------------------+
</code></pre></div><h3 id="solution-5">Solution</h3>
<p>只保留相同 Email 中 Id 最小的那一个，然后删除其它的。</p>
<p>连接查询：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">DELETE</span> p1
<span style="color:#66d9ef">FROM</span>
    Person p1,
    Person p2
<span style="color:#66d9ef">WHERE</span>
    p1.Email <span style="color:#f92672">=</span> p2.Email
    <span style="color:#66d9ef">AND</span> p1.Id <span style="color:#f92672">&gt;</span> p2.Id
</code></pre></div><p>子查询：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">DELETE</span>
<span style="color:#66d9ef">FROM</span>
    Person
<span style="color:#66d9ef">WHERE</span>
    id <span style="color:#66d9ef">NOT</span> <span style="color:#66d9ef">IN</span> (
        <span style="color:#66d9ef">SELECT</span> id 
        <span style="color:#66d9ef">FROM</span> ( 
            <span style="color:#66d9ef">SELECT</span> <span style="color:#66d9ef">min</span>( id ) <span style="color:#66d9ef">AS</span> id 
            <span style="color:#66d9ef">FROM</span> Person
            <span style="color:#66d9ef">GROUP</span> <span style="color:#66d9ef">BY</span> email
        ) <span style="color:#66d9ef">AS</span> m
    );
</code></pre></div><p>应该注意的是上述解法额外嵌套了一个 SELECT 语句，如果不这么做，会出现错误：You can&rsquo;t specify target table &lsquo;Person&rsquo; for update in FROM clause。以下演示了这种错误解法。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">DELETE</span>
<span style="color:#66d9ef">FROM</span>
    Person
<span style="color:#66d9ef">WHERE</span>
    id <span style="color:#66d9ef">NOT</span> <span style="color:#66d9ef">IN</span> ( 
        <span style="color:#66d9ef">SELECT</span> <span style="color:#66d9ef">min</span>( id ) <span style="color:#66d9ef">AS</span> id 
        <span style="color:#66d9ef">FROM</span> Person 
        <span style="color:#66d9ef">GROUP</span> <span style="color:#66d9ef">BY</span> email 
    );
</code></pre></div><p>参考：<a href="https://stackoverflow.com/questions/45494/mysql-error-1093-cant-specify-target-table-for-update-in-from-clause">pMySQL Error 1093 - Can&rsquo;t specify target table for update in FROM clause</a></p>
<h3 id="sql-schema-5">SQL Schema</h3>
<p>与 182 相同。</p>
<h2 id="175-combine-two-tables">175. Combine Two Tables</h2>
<p><a href="https://leetcode.com/problems/combine-two-tables/description/">https://leetcode.com/problems/combine-two-tables/description/</a></p>
<h3 id="description-6">Description</h3>
<p>Person 表：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">+-------------+---------+
| Column Name | Type    |
+-------------+---------+
| PersonId    | int     |
| FirstName   | varchar |
| LastName    | varchar |
+-------------+---------+
PersonId is the primary key column for this table.
</code></pre></div><p>Address 表：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">+-------------+---------+
| Column Name | Type    |
+-------------+---------+
| AddressId   | int     |
| PersonId    | int     |
| City        | varchar |
| State       | varchar |
+-------------+---------+
AddressId is the primary key column for this table.
</code></pre></div><p>查找 FirstName, LastName, City, State 数据，而不管一个用户有没有填地址信息。</p>
<h3 id="solution-6">Solution</h3>
<p>涉及到 Person 和 Address 两个表，在对这两个表执行连接操作时，因为要保留 Person 表中的信息，即使在 Address 表中没有关联的信息也要保留。此时可以用左外连接，将 Person 表放在 LEFT JOIN 的左边。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span>
    FirstName,
    LastName,
    City,
    <span style="color:#66d9ef">State</span>
<span style="color:#66d9ef">FROM</span>
    Person P
    <span style="color:#66d9ef">LEFT</span> <span style="color:#66d9ef">JOIN</span> Address A
    <span style="color:#66d9ef">ON</span> P.PersonId <span style="color:#f92672">=</span> A.PersonId;
</code></pre></div><h3 id="sql-schema-6">SQL Schema</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">DROP</span> <span style="color:#66d9ef">TABLE</span>
<span style="color:#66d9ef">IF</span>
    <span style="color:#66d9ef">EXISTS</span> Person;
<span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">TABLE</span> Person ( PersonId INT, FirstName VARCHAR ( <span style="color:#ae81ff">255</span> ), LastName VARCHAR ( <span style="color:#ae81ff">255</span> ) );
<span style="color:#66d9ef">DROP</span> <span style="color:#66d9ef">TABLE</span>
<span style="color:#66d9ef">IF</span>
    <span style="color:#66d9ef">EXISTS</span> Address;
<span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">TABLE</span> Address ( AddressId INT, PersonId INT, City VARCHAR ( <span style="color:#ae81ff">255</span> ), <span style="color:#66d9ef">State</span> VARCHAR ( <span style="color:#ae81ff">255</span> ) );
<span style="color:#66d9ef">INSERT</span> <span style="color:#66d9ef">INTO</span> Person ( PersonId, LastName, FirstName )
<span style="color:#66d9ef">VALUES</span>
    ( <span style="color:#ae81ff">1</span>, <span style="color:#e6db74">&#39;Wang&#39;</span>, <span style="color:#e6db74">&#39;Allen&#39;</span> );
<span style="color:#66d9ef">INSERT</span> <span style="color:#66d9ef">INTO</span> Address ( AddressId, PersonId, City, <span style="color:#66d9ef">State</span> )
<span style="color:#66d9ef">VALUES</span>
    ( <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#e6db74">&#39;New York City&#39;</span>, <span style="color:#e6db74">&#39;New York&#39;</span> );
</code></pre></div><h2 id="181-employees-earning-more-than-their-managers">181. Employees Earning More Than Their Managers</h2>
<p><a href="https://leetcode.com/problems/employees-earning-more-than-their-managers/description/">https://leetcode.com/problems/employees-earning-more-than-their-managers/description/</a></p>
<h3 id="description-7">Description</h3>
<p>Employee 表：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">+----+-------+--------+-----------+
| Id | Name  | Salary | ManagerId |
+----+-------+--------+-----------+
| 1  | Joe   | 70000  | 3         |
| 2  | Henry | 80000  | 4         |
| 3  | Sam   | 60000  | NULL      |
| 4  | Max   | 90000  | NULL      |
+----+-------+--------+-----------+
</code></pre></div><p>查找薪资大于其经理薪资的员工信息。</p>
<h3 id="solution-7">Solution</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span>
    E1.NAME <span style="color:#66d9ef">AS</span> Employee
<span style="color:#66d9ef">FROM</span>
    Employee E1
    <span style="color:#66d9ef">INNER</span> <span style="color:#66d9ef">JOIN</span> Employee E2
    <span style="color:#66d9ef">ON</span> E1.ManagerId <span style="color:#f92672">=</span> E2.Id
    <span style="color:#66d9ef">AND</span> E1.Salary <span style="color:#f92672">&gt;</span> E2.Salary;
</code></pre></div><h3 id="sql-schema-7">SQL Schema</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">DROP</span> <span style="color:#66d9ef">TABLE</span>
<span style="color:#66d9ef">IF</span>
    <span style="color:#66d9ef">EXISTS</span> Employee;
<span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">TABLE</span> Employee ( Id INT, NAME VARCHAR ( <span style="color:#ae81ff">255</span> ), Salary INT, ManagerId INT );
<span style="color:#66d9ef">INSERT</span> <span style="color:#66d9ef">INTO</span> Employee ( Id, NAME, Salary, ManagerId )
<span style="color:#66d9ef">VALUES</span>
    ( <span style="color:#ae81ff">1</span>, <span style="color:#e6db74">&#39;Joe&#39;</span>, <span style="color:#ae81ff">70000</span>, <span style="color:#ae81ff">3</span> ),
    ( <span style="color:#ae81ff">2</span>, <span style="color:#e6db74">&#39;Henry&#39;</span>, <span style="color:#ae81ff">80000</span>, <span style="color:#ae81ff">4</span> ),
    ( <span style="color:#ae81ff">3</span>, <span style="color:#e6db74">&#39;Sam&#39;</span>, <span style="color:#ae81ff">60000</span>, <span style="color:#66d9ef">NULL</span> ),
    ( <span style="color:#ae81ff">4</span>, <span style="color:#e6db74">&#39;Max&#39;</span>, <span style="color:#ae81ff">90000</span>, <span style="color:#66d9ef">NULL</span> );
</code></pre></div><h2 id="183-customers-who-never-order">183. Customers Who Never Order</h2>
<p><a href="https://leetcode.com/problems/customers-who-never-order/description/">https://leetcode.com/problems/customers-who-never-order/description/</a></p>
<h3 id="description-8">Description</h3>
<p>Customers 表：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">+----+-------+
| Id | Name  |
+----+-------+
| 1  | Joe   |
| 2  | Henry |
| 3  | Sam   |
| 4  | Max   |
+----+-------+
</code></pre></div><p>Orders 表：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">+----+------------+
| Id | CustomerId |
+----+------------+
| 1  | 3          |
| 2  | 1          |
+----+------------+
</code></pre></div><p>查找没有订单的顾客信息：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">+-----------+
| Customers |
+-----------+
| Henry     |
| Max       |
+-----------+
</code></pre></div><h3 id="solution-8">Solution</h3>
<p>左外链接</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span>
    <span style="color:#66d9ef">C</span>.Name <span style="color:#66d9ef">AS</span> Customers
<span style="color:#66d9ef">FROM</span>
    Customers <span style="color:#66d9ef">C</span>
    <span style="color:#66d9ef">LEFT</span> <span style="color:#66d9ef">JOIN</span> Orders O
    <span style="color:#66d9ef">ON</span> <span style="color:#66d9ef">C</span>.Id <span style="color:#f92672">=</span> O.CustomerId
<span style="color:#66d9ef">WHERE</span>
    O.CustomerId <span style="color:#66d9ef">IS</span> <span style="color:#66d9ef">NULL</span>;
</code></pre></div><p>子查询</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span>
    Name <span style="color:#66d9ef">AS</span> Customers
<span style="color:#66d9ef">FROM</span>
    Customers
<span style="color:#66d9ef">WHERE</span>
    Id <span style="color:#66d9ef">NOT</span> <span style="color:#66d9ef">IN</span> ( 
        <span style="color:#66d9ef">SELECT</span> CustomerId 
        <span style="color:#66d9ef">FROM</span> Orders 
    );
</code></pre></div><h3 id="sql-schema-8">SQL Schema</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">DROP</span> <span style="color:#66d9ef">TABLE</span>
<span style="color:#66d9ef">IF</span>
    <span style="color:#66d9ef">EXISTS</span> Customers;
<span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">TABLE</span> Customers ( Id INT, NAME VARCHAR ( <span style="color:#ae81ff">255</span> ) );
<span style="color:#66d9ef">DROP</span> <span style="color:#66d9ef">TABLE</span>
<span style="color:#66d9ef">IF</span>
    <span style="color:#66d9ef">EXISTS</span> Orders;
<span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">TABLE</span> Orders ( Id INT, CustomerId INT );
<span style="color:#66d9ef">INSERT</span> <span style="color:#66d9ef">INTO</span> Customers ( Id, NAME )
<span style="color:#66d9ef">VALUES</span>
    ( <span style="color:#ae81ff">1</span>, <span style="color:#e6db74">&#39;Joe&#39;</span> ),
    ( <span style="color:#ae81ff">2</span>, <span style="color:#e6db74">&#39;Henry&#39;</span> ),
    ( <span style="color:#ae81ff">3</span>, <span style="color:#e6db74">&#39;Sam&#39;</span> ),
    ( <span style="color:#ae81ff">4</span>, <span style="color:#e6db74">&#39;Max&#39;</span> );
<span style="color:#66d9ef">INSERT</span> <span style="color:#66d9ef">INTO</span> Orders ( Id, CustomerId )
<span style="color:#66d9ef">VALUES</span>
    ( <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">3</span> ),
    ( <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">1</span> );
</code></pre></div><h2 id="184-department-highest-salary">184. Department Highest Salary</h2>
<p><a href="https://leetcode.com/problems/department-highest-salary/description/">https://leetcode.com/problems/department-highest-salary/description/</a></p>
<h3 id="description-9">Description</h3>
<p>Employee 表：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">+----+-------+--------+--------------+
| Id | Name  | Salary | DepartmentId |
+----+-------+--------+--------------+
| 1  | Joe   | 70000  | 1            |
| 2  | Henry | 80000  | 2            |
| 3  | Sam   | 60000  | 2            |
| 4  | Max   | 90000  | 1            |
+----+-------+--------+--------------+
</code></pre></div><p>Department 表：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">+----+----------+
| Id | Name     |
+----+----------+
| 1  | IT       |
| 2  | Sales    |
+----+----------+
</code></pre></div><p>查找一个 Department 中收入最高者的信息：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">+------------+----------+--------+
| Department | Employee | Salary |
+------------+----------+--------+
| IT         | Max      | 90000  |
| Sales      | Henry    | 80000  |
+------------+----------+--------+
</code></pre></div><h3 id="solution-9">Solution</h3>
<p>创建一个临时表，包含了部门员工的最大薪资。可以对部门进行分组，然后使用 MAX() 汇总函数取得最大薪资。</p>
<p>之后使用连接找到一个部门中薪资等于临时表中最大薪资的员工。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span>
    D.NAME Department,
    E.NAME Employee,
    E.Salary
<span style="color:#66d9ef">FROM</span>
    Employee E,
    Department D,
    ( <span style="color:#66d9ef">SELECT</span> DepartmentId, <span style="color:#66d9ef">MAX</span>( Salary ) Salary 
     <span style="color:#66d9ef">FROM</span> Employee 
     <span style="color:#66d9ef">GROUP</span> <span style="color:#66d9ef">BY</span> DepartmentId ) M
<span style="color:#66d9ef">WHERE</span>
    E.DepartmentId <span style="color:#f92672">=</span> D.Id
    <span style="color:#66d9ef">AND</span> E.DepartmentId <span style="color:#f92672">=</span> M.DepartmentId
    <span style="color:#66d9ef">AND</span> E.Salary <span style="color:#f92672">=</span> M.Salary;
</code></pre></div><h3 id="sql-schema-9">SQL Schema</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">DROP</span> <span style="color:#66d9ef">TABLE</span> <span style="color:#66d9ef">IF</span> <span style="color:#66d9ef">EXISTS</span> Employee;
<span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">TABLE</span> Employee ( Id INT, NAME VARCHAR ( <span style="color:#ae81ff">255</span> ), Salary INT, DepartmentId INT );
<span style="color:#66d9ef">DROP</span> <span style="color:#66d9ef">TABLE</span> <span style="color:#66d9ef">IF</span> <span style="color:#66d9ef">EXISTS</span> Department;
<span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">TABLE</span> Department ( Id INT, NAME VARCHAR ( <span style="color:#ae81ff">255</span> ) );
<span style="color:#66d9ef">INSERT</span> <span style="color:#66d9ef">INTO</span> Employee ( Id, NAME, Salary, DepartmentId )
<span style="color:#66d9ef">VALUES</span>
    ( <span style="color:#ae81ff">1</span>, <span style="color:#e6db74">&#39;Joe&#39;</span>, <span style="color:#ae81ff">70000</span>, <span style="color:#ae81ff">1</span> ),
    ( <span style="color:#ae81ff">2</span>, <span style="color:#e6db74">&#39;Henry&#39;</span>, <span style="color:#ae81ff">80000</span>, <span style="color:#ae81ff">2</span> ),
    ( <span style="color:#ae81ff">3</span>, <span style="color:#e6db74">&#39;Sam&#39;</span>, <span style="color:#ae81ff">60000</span>, <span style="color:#ae81ff">2</span> ),
    ( <span style="color:#ae81ff">4</span>, <span style="color:#e6db74">&#39;Max&#39;</span>, <span style="color:#ae81ff">90000</span>, <span style="color:#ae81ff">1</span> );
<span style="color:#66d9ef">INSERT</span> <span style="color:#66d9ef">INTO</span> Department ( Id, NAME )
<span style="color:#66d9ef">VALUES</span>
    ( <span style="color:#ae81ff">1</span>, <span style="color:#e6db74">&#39;IT&#39;</span> ),
    ( <span style="color:#ae81ff">2</span>, <span style="color:#e6db74">&#39;Sales&#39;</span> );
</code></pre></div><h2 id="176-second-highest-salary">176. Second Highest Salary</h2>
<p><a href="https://leetcode.com/problems/second-highest-salary/description/">https://leetcode.com/problems/second-highest-salary/description/</a></p>
<h3 id="description-10">Description</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">+----+--------+
| Id | Salary |
+----+--------+
| 1  | 100    |
| 2  | 200    |
| 3  | 300    |
+----+--------+
</code></pre></div><p>查找工资第二高的员工。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">+---------------------+
| SecondHighestSalary |
+---------------------+
| 200                 |
+---------------------+
</code></pre></div><p>没有找到返回 null 而不是不返回数据。</p>
<h3 id="solution-10">Solution</h3>
<p>为了在没有查找到数据时返回 null，需要在查询结果外面再套一层 SELECT。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span>
    ( <span style="color:#66d9ef">SELECT</span> <span style="color:#66d9ef">DISTINCT</span> Salary 
     <span style="color:#66d9ef">FROM</span> Employee 
     <span style="color:#66d9ef">ORDER</span> <span style="color:#66d9ef">BY</span> Salary <span style="color:#66d9ef">DESC</span> 
     <span style="color:#66d9ef">LIMIT</span> <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span> ) SecondHighestSalary;
</code></pre></div><h3 id="sql-schema-10">SQL Schema</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">DROP</span> <span style="color:#66d9ef">TABLE</span>
<span style="color:#66d9ef">IF</span>
    <span style="color:#66d9ef">EXISTS</span> Employee;
<span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">TABLE</span> Employee ( Id INT, Salary INT );
<span style="color:#66d9ef">INSERT</span> <span style="color:#66d9ef">INTO</span> Employee ( Id, Salary )
<span style="color:#66d9ef">VALUES</span>
    ( <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">100</span> ),
    ( <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">200</span> ),
    ( <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">300</span> );
</code></pre></div><h2 id="177-nth-highest-salary">177. Nth Highest Salary</h2>
<h3 id="description-11">Description</h3>
<p>查找工资第 N 高的员工。</p>
<h3 id="solution-11">Solution</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">FUNCTION</span> getNthHighestSalary ( N INT ) <span style="color:#66d9ef">RETURNS</span> INT <span style="color:#66d9ef">BEGIN</span>

<span style="color:#66d9ef">SET</span> N <span style="color:#f92672">=</span> N <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
<span style="color:#66d9ef">RETURN</span> ( 
    <span style="color:#66d9ef">SELECT</span> ( 
        <span style="color:#66d9ef">SELECT</span> <span style="color:#66d9ef">DISTINCT</span> Salary 
        <span style="color:#66d9ef">FROM</span> Employee 
        <span style="color:#66d9ef">ORDER</span> <span style="color:#66d9ef">BY</span> Salary <span style="color:#66d9ef">DESC</span> 
        <span style="color:#66d9ef">LIMIT</span> N, <span style="color:#ae81ff">1</span> 
    ) 
);

<span style="color:#66d9ef">END</span>
</code></pre></div><h3 id="sql-schema-11">SQL Schema</h3>
<p>同 176。</p>
<h2 id="178-rank-scores">178. Rank Scores</h2>
<p><a href="https://leetcode.com/problems/rank-scores/description/">https://leetcode.com/problems/rank-scores/description/</a></p>
<h3 id="description-12">Description</h3>
<p>得分表：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">+----+-------+
| Id | Score |
+----+-------+
| 1  | 3.50  |
| 2  | 3.65  |
| 3  | 4.00  |
| 4  | 3.85  |
| 5  | 4.00  |
| 6  | 3.65  |
+----+-------+
</code></pre></div><p>将得分排序，并统计排名。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">+-------+------+
| Score | Rank |
+-------+------+
| 4.00  | 1    |
| 4.00  | 1    |
| 3.85  | 2    |
| 3.65  | 3    |
| 3.65  | 3    |
| 3.50  | 4    |
+-------+------+
</code></pre></div><h3 id="solution-12">Solution</h3>
<p>要统计某个 score 的排名，只要统计大于等于该 score 的 score 数量。</p>
<table>
<thead>
<tr>
<th style="text-align:center">Id</th>
<th style="text-align:center">score</th>
<th style="text-align:center">大于等于该 score 的 score 数量</th>
<th style="text-align:center">排名</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">4.1</td>
<td style="text-align:center">3</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">4.2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">4.3</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
<p>使用连接操作找到某个 score 对应的大于等于其值的记录：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span>
	<span style="color:#f92672">*</span>
<span style="color:#66d9ef">FROM</span>
    Scores S1
    <span style="color:#66d9ef">INNER</span> <span style="color:#66d9ef">JOIN</span> Scores S2
    <span style="color:#66d9ef">ON</span> S1.score <span style="color:#f92672">&lt;=</span> S2.score
<span style="color:#66d9ef">ORDER</span> <span style="color:#66d9ef">BY</span>
    S1.score <span style="color:#66d9ef">DESC</span>, S1.Id;
</code></pre></div><table>
<thead>
<tr>
<th style="text-align:center">S1.Id</th>
<th style="text-align:center">S1.score</th>
<th style="text-align:center">S2.Id</th>
<th style="text-align:center">S2.score</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">4.3</td>
<td style="text-align:center">3</td>
<td style="text-align:center">4.3</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">4.2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">4.2</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">4.2</td>
<td style="text-align:center">3</td>
<td style="text-align:center">4.3</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">4.1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">4.1</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">4.1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">4.2</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">4.1</td>
<td style="text-align:center">3</td>
<td style="text-align:center">4.3</td>
</tr>
</tbody>
</table>
<p>可以看到每个 S1.score 都有对应好几条记录，我们再进行分组，并统计每个分组的数量作为 &lsquo;Rank&rsquo;</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span>
    S1.score <span style="color:#e6db74">&#39;Score&#39;</span>,
    <span style="color:#66d9ef">COUNT</span>(<span style="color:#f92672">*</span>) <span style="color:#e6db74">&#39;Rank&#39;</span>
<span style="color:#66d9ef">FROM</span>
    Scores S1
    <span style="color:#66d9ef">INNER</span> <span style="color:#66d9ef">JOIN</span> Scores S2
    <span style="color:#66d9ef">ON</span> S1.score <span style="color:#f92672">&lt;=</span> S2.score
<span style="color:#66d9ef">GROUP</span> <span style="color:#66d9ef">BY</span>
    S1.id, S1.score
<span style="color:#66d9ef">ORDER</span> <span style="color:#66d9ef">BY</span>
    S1.score <span style="color:#66d9ef">DESC</span>, S1.Id;
</code></pre></div><table>
<thead>
<tr>
<th style="text-align:center">score</th>
<th style="text-align:center">Rank</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">4.3</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">4.2</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">4.1</td>
<td style="text-align:center">3</td>
</tr>
</tbody>
</table>
<p>上面的解法看似没问题，但是对于以下数据，它却得到了错误的结果：</p>
<table>
<thead>
<tr>
<th style="text-align:center">Id</th>
<th style="text-align:center">score</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">4.1</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">4.2</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">4.2</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:center">score</th>
<th style="text-align:center">Rank</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">4.2</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">4.2</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">4.1</td>
<td style="text-align:center">3</td>
</tr>
</tbody>
</table>
<p>而我们希望的结果为：</p>
<table>
<thead>
<tr>
<th style="text-align:center">score</th>
<th style="text-align:center">Rank</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">4.2</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">4.2</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">4.1</td>
<td style="text-align:center">2</td>
</tr>
</tbody>
</table>
<p>连接情况如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">S1.Id</th>
<th style="text-align:center">S1.score</th>
<th style="text-align:center">S2.Id</th>
<th style="text-align:center">S2.score</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">4.2</td>
<td style="text-align:center">3</td>
<td style="text-align:center">4.2</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">4.2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">4.2</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">4.2</td>
<td style="text-align:center">3</td>
<td style="text-align:center">4.2</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">4.2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">4.1</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">4.1</td>
<td style="text-align:center">3</td>
<td style="text-align:center">4.2</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">4.1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">4.2</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">4.1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">4.1</td>
</tr>
</tbody>
</table>
<p>我们想要的结果是，把分数相同的放在同一个排名，并且相同分数只占一个位置，例如上面的分数，Id=2 和 Id=3 的记录都有相同的分数，并且最高，他们并列第一。而 Id=1 的记录应该排第二名，而不是第三名。所以在进行 COUNT 计数统计时，我们需要使用 COUNT( DISTINCT S2.score ) 从而只统计一次相同的分数。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span>
    S1.score <span style="color:#e6db74">&#39;Score&#39;</span>,
    <span style="color:#66d9ef">COUNT</span>( <span style="color:#66d9ef">DISTINCT</span> S2.score ) <span style="color:#e6db74">&#39;Rank&#39;</span>
<span style="color:#66d9ef">FROM</span>
    Scores S1
    <span style="color:#66d9ef">INNER</span> <span style="color:#66d9ef">JOIN</span> Scores S2
    <span style="color:#66d9ef">ON</span> S1.score <span style="color:#f92672">&lt;=</span> S2.score
<span style="color:#66d9ef">GROUP</span> <span style="color:#66d9ef">BY</span>
    S1.id, S1.score
<span style="color:#66d9ef">ORDER</span> <span style="color:#66d9ef">BY</span>
    S1.score <span style="color:#66d9ef">DESC</span>;
</code></pre></div><h3 id="sql-schema-12">SQL Schema</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">DROP</span> <span style="color:#66d9ef">TABLE</span>
<span style="color:#66d9ef">IF</span>
    <span style="color:#66d9ef">EXISTS</span> Scores;
<span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">TABLE</span> Scores ( Id INT, Score DECIMAL ( <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">2</span> ) );
<span style="color:#66d9ef">INSERT</span> <span style="color:#66d9ef">INTO</span> Scores ( Id, Score )
<span style="color:#66d9ef">VALUES</span>
    ( <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">4</span>.<span style="color:#ae81ff">1</span> ),
    ( <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">4</span>.<span style="color:#ae81ff">1</span> ),
    ( <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>.<span style="color:#ae81ff">2</span> ),
    ( <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">4</span>.<span style="color:#ae81ff">2</span> ),
    ( <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">4</span>.<span style="color:#ae81ff">3</span> ),
    ( <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">4</span>.<span style="color:#ae81ff">3</span> );
</code></pre></div><h2 id="180-consecutive-numbers">180. Consecutive Numbers</h2>
<p><a href="https://leetcode.com/problems/consecutive-numbers/description/">https://leetcode.com/problems/consecutive-numbers/description/</a></p>
<h3 id="description-13">Description</h3>
<p>数字表：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">+----+-----+
| Id | Num |
+----+-----+
| 1  |  1  |
| 2  |  1  |
| 3  |  1  |
| 4  |  2  |
| 5  |  1  |
| 6  |  2  |
| 7  |  2  |
+----+-----+
</code></pre></div><p>查找连续出现三次的数字。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">+-----------------+
| ConsecutiveNums |
+-----------------+
| 1               |
+-----------------+
</code></pre></div><h3 id="solution-13">Solution</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span>
    <span style="color:#66d9ef">DISTINCT</span> L1.num ConsecutiveNums
<span style="color:#66d9ef">FROM</span>
    Logs L1,
    Logs L2,
    Logs L3
<span style="color:#66d9ef">WHERE</span> L1.id <span style="color:#f92672">=</span> l2.id <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>
    <span style="color:#66d9ef">AND</span> L2.id <span style="color:#f92672">=</span> L3.id <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>
    <span style="color:#66d9ef">AND</span> L1.num <span style="color:#f92672">=</span> L2.num
    <span style="color:#66d9ef">AND</span> l2.num <span style="color:#f92672">=</span> l3.num;
</code></pre></div><h3 id="sql-schema-13">SQL Schema</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">DROP</span> <span style="color:#66d9ef">TABLE</span>
<span style="color:#66d9ef">IF</span>
    <span style="color:#66d9ef">EXISTS</span> LOGS;
<span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">TABLE</span> LOGS ( Id INT, Num INT );
<span style="color:#66d9ef">INSERT</span> <span style="color:#66d9ef">INTO</span> LOGS ( Id, Num )
<span style="color:#66d9ef">VALUES</span>
    ( <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span> ),
    ( <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">1</span> ),
    ( <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">1</span> ),
    ( <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">2</span> ),
    ( <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">1</span> ),
    ( <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">2</span> ),
    ( <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">2</span> );
</code></pre></div><h2 id="626-exchange-seats">626. Exchange Seats</h2>
<p><a href="https://leetcode.com/problems/exchange-seats/description/">https://leetcode.com/problems/exchange-seats/description/</a></p>
<h3 id="description-14">Description</h3>
<p>seat 表存储着座位对应的学生。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">+---------+---------+
|    id   | student |
+---------+---------+
|    1    | Abbot   |
|    2    | Doris   |
|    3    | Emerson |
|    4    | Green   |
|    5    | Jeames  |
+---------+---------+
</code></pre></div><p>要求交换相邻座位的两个学生，如果最后一个座位是奇数，那么不交换这个座位上的学生。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">+---------+---------+
|    id   | student |
+---------+---------+
|    1    | Doris   |
|    2    | Abbot   |
|    3    | Green   |
|    4    | Emerson |
|    5    | Jeames  |
+---------+---------+
</code></pre></div><h3 id="solution-14">Solution</h3>
<p>使用多个 union。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#f92672">##</span> <span style="color:#960050;background-color:#1e0010">处理偶数</span> id<span style="color:#960050;background-color:#1e0010">，让</span> id <span style="color:#960050;background-color:#1e0010">减</span> <span style="color:#ae81ff">1</span>
<span style="color:#f92672">##</span> <span style="color:#960050;background-color:#1e0010">例如</span> <span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">4</span>,<span style="color:#ae81ff">6</span>,... <span style="color:#960050;background-color:#1e0010">变成</span> <span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">5</span>,...
<span style="color:#66d9ef">SELECT</span>
    s1.id <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> <span style="color:#66d9ef">AS</span> id,
    s1.student
<span style="color:#66d9ef">FROM</span>
    seat s1
<span style="color:#66d9ef">WHERE</span>
    s1.id <span style="color:#66d9ef">MOD</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span> <span style="color:#66d9ef">UNION</span>
<span style="color:#f92672">##</span> <span style="color:#960050;background-color:#1e0010">处理奇数</span> id<span style="color:#960050;background-color:#1e0010">，让</span> id <span style="color:#960050;background-color:#1e0010">加</span> <span style="color:#ae81ff">1</span><span style="color:#960050;background-color:#1e0010">。但是如果最大的</span> id <span style="color:#960050;background-color:#1e0010">为奇数，则不做处理</span>
<span style="color:#f92672">##</span> <span style="color:#960050;background-color:#1e0010">例如</span> <span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">5</span>,... <span style="color:#960050;background-color:#1e0010">变成</span> <span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">4</span>,<span style="color:#ae81ff">6</span>,...
<span style="color:#66d9ef">SELECT</span>
    s2.id <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#66d9ef">AS</span> id,
    s2.student
<span style="color:#66d9ef">FROM</span>
    seat s2
<span style="color:#66d9ef">WHERE</span>
    s2.id <span style="color:#66d9ef">MOD</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
    <span style="color:#66d9ef">AND</span> s2.id <span style="color:#f92672">!=</span> ( <span style="color:#66d9ef">SELECT</span> <span style="color:#66d9ef">max</span>( s3.id ) <span style="color:#66d9ef">FROM</span> seat s3 ) <span style="color:#66d9ef">UNION</span>
<span style="color:#f92672">##</span> <span style="color:#960050;background-color:#1e0010">如果最大的</span> id <span style="color:#960050;background-color:#1e0010">为奇数，单独取出这个数</span>
<span style="color:#66d9ef">SELECT</span>
    s4.id <span style="color:#66d9ef">AS</span> id,
    s4.student
<span style="color:#66d9ef">FROM</span>
    seat s4
<span style="color:#66d9ef">WHERE</span>
    s4.id <span style="color:#66d9ef">MOD</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
    <span style="color:#66d9ef">AND</span> s4.id <span style="color:#f92672">=</span> ( <span style="color:#66d9ef">SELECT</span> <span style="color:#66d9ef">max</span>( s5.id ) <span style="color:#66d9ef">FROM</span> seat s5 )
<span style="color:#66d9ef">ORDER</span> <span style="color:#66d9ef">BY</span>
    id;
</code></pre></div><h3 id="sql-schema-14">SQL Schema</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">DROP</span> <span style="color:#66d9ef">TABLE</span>
<span style="color:#66d9ef">IF</span>
    <span style="color:#66d9ef">EXISTS</span> seat;
<span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">TABLE</span> seat ( id INT, student VARCHAR ( <span style="color:#ae81ff">255</span> ) );
<span style="color:#66d9ef">INSERT</span> <span style="color:#66d9ef">INTO</span> seat ( id, student )
<span style="color:#66d9ef">VALUES</span>
    ( <span style="color:#e6db74">&#39;1&#39;</span>, <span style="color:#e6db74">&#39;Abbot&#39;</span> ),
    ( <span style="color:#e6db74">&#39;2&#39;</span>, <span style="color:#e6db74">&#39;Doris&#39;</span> ),
    ( <span style="color:#e6db74">&#39;3&#39;</span>, <span style="color:#e6db74">&#39;Emerson&#39;</span> ),
    ( <span style="color:#e6db74">&#39;4&#39;</span>, <span style="color:#e6db74">&#39;Green&#39;</span> ),
    ( <span style="color:#e6db74">&#39;5&#39;</span>, <span style="color:#e6db74">&#39;Jeames&#39;</span> );
</code></pre></div>
        
        ]]>
      </description>
    </item>
    
    
    
    <item>
      <title>【转载】Mysql</title>
      <link>/post/2021/12/22/%E8%BD%AC%E8%BD%BDmysql/</link>
      <pubDate>Wed, 22 Dec 2021 23:30:39 +0800</pubDate>
      <author>罗泽勋</author>
      <guid>/post/2021/12/22/%E8%BD%AC%E8%BD%BDmysql/</guid>
      <description>
        <![CDATA[
        <h1 id="mysql">MySQL</h1>
<!-- GFM-TOC -->
<ul>
<li><a href="#mysql">MySQL</a>
<ul>
<li><a href="#%E4%B8%80%E7%B4%A2%E5%BC%95">一、索引</a>
<ul>
<li><a href="#b-tree-%E5%8E%9F%E7%90%86">B+ Tree 原理</a></li>
<li><a href="#mysql-%E7%B4%A2%E5%BC%95">MySQL 索引</a></li>
<li><a href="#%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96">索引优化</a></li>
<li><a href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E7%82%B9">索引的优点</a></li>
<li><a href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BD%BF%E7%94%A8%E6%9D%A1%E4%BB%B6">索引的使用条件</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96">二、查询性能优化</a>
<ul>
<li><a href="#%E4%BD%BF%E7%94%A8-explain-%E8%BF%9B%E8%A1%8C%E5%88%86%E6%9E%90">使用 Explain 进行分析</a></li>
<li><a href="#%E4%BC%98%E5%8C%96%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE">优化数据访问</a></li>
<li><a href="#%E9%87%8D%E6%9E%84%E6%9F%A5%E8%AF%A2%E6%96%B9%E5%BC%8F">重构查询方式</a></li>
</ul>
</li>
<li><a href="#%E4%B8%89%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E">三、存储引擎</a>
<ul>
<li><a href="#innodb">InnoDB</a></li>
<li><a href="#myisam">MyISAM</a></li>
<li><a href="#%E6%AF%94%E8%BE%83">比较</a></li>
</ul>
</li>
<li><a href="#%E5%9B%9B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">四、数据类型</a>
<ul>
<li><a href="#%E6%95%B4%E5%9E%8B">整型</a></li>
<li><a href="#%E6%B5%AE%E7%82%B9%E6%95%B0">浮点数</a></li>
<li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2">字符串</a></li>
<li><a href="#%E6%97%B6%E9%97%B4%E5%92%8C%E6%97%A5%E6%9C%9F">时间和日期</a></li>
</ul>
</li>
<li><a href="#%E4%BA%94%E5%88%87%E5%88%86">五、切分</a>
<ul>
<li><a href="#%E6%B0%B4%E5%B9%B3%E5%88%87%E5%88%86">水平切分</a></li>
<li><a href="#%E5%9E%82%E7%9B%B4%E5%88%87%E5%88%86">垂直切分</a></li>
<li><a href="#sharding-%E7%AD%96%E7%95%A5">Sharding 策略</a></li>
<li><a href="#sharding-%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98">Sharding 存在的问题</a></li>
</ul>
</li>
<li><a href="#%E5%85%AD%E5%A4%8D%E5%88%B6">六、复制</a>
<ul>
<li><a href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6">主从复制</a></li>
<li><a href="#%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB">读写分离</a></li>
</ul>
</li>
<li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
</li>
</ul>
<!-- GFM-TOC -->
<h2 id="一索引">一、索引</h2>
<h3 id="b-tree-原理">B+ Tree 原理</h3>
<h4 id="1-数据结构">1. 数据结构</h4>
<p>B Tree 指的是 Balance Tree，也就是平衡树。平衡树是一颗查找树，并且所有叶子节点位于同一层。</p>
<p>B+ Tree 是基于 B Tree 和叶子节点顺序访问指针进行实现，它具有 B Tree 的平衡性，并且通过顺序访问指针来提高区间查询的性能。</p>
<p>在 B+ Tree 中，一个节点中的 key 从左到右非递减排列，如果某个指针的左右相邻 key 分别是 key<sub>i</sub> 和 key<sub>i+1</sub>，且不为 null，则该指针指向节点的所有 key 大于等于 key<sub>i</sub> 且小于等于 key<sub>i+1</sub>。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/33576849-9275-47bb-ada7-8ded5f5e7c73.png" width="350px"> </div><br>
<h4 id="2-操作">2. 操作</h4>
<p>进行查找操作时，首先在根节点进行二分查找，找到一个 key 所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找出 key 所对应的 data。</p>
<p>插入删除操作会破坏平衡树的平衡性，因此在进行插入删除操作之后，需要对树进行分裂、合并、旋转等操作来维护平衡性。</p>
<h4 id="3-与红黑树的比较">3. 与红黑树的比较</h4>
<p>红黑树等平衡树也可以用来实现索引，但是文件系统及数据库系统普遍采用 B+ Tree 作为索引结构，这是因为使用 B+ 树访问磁盘数据有更高的性能。</p>
<p>（一）B+ 树有更低的树高</p>
<p>平衡树的树高 O(h)=O(log<sub>d</sub>N)，其中 d 为每个节点的出度。红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多。</p>
<p>（二）磁盘访问原理</p>
<p>操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点。</p>
<p>如果数据不在同一个磁盘块上，那么通常需要移动制动手臂进行寻道，而制动手臂因为其物理结构导致了移动效率低下，从而增加磁盘数据读取时间。B+ 树相对于红黑树有更低的树高，进行寻道的次数与树高成正比，在同一个磁盘块上进行访问只需要很短的磁盘旋转时间，所以 B+ 树更适合磁盘数据的读取。</p>
<p>（三）磁盘预读特性</p>
<p>为了减少磁盘 I/O 操作，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的磁盘旋转时间，速度会非常快。并且可以利用预读特性，相邻的节点也能够被预先载入。</p>
<h3 id="mysql-索引">MySQL 索引</h3>
<p>索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。</p>
<h4 id="1-btree-索引">1. B+Tree 索引</h4>
<p>是大多数 MySQL 存储引擎的默认索引类型。</p>
<p>因为不再需要进行全表扫描，只需要对树进行搜索即可，所以查找速度快很多。</p>
<p>因为 B+ Tree 的有序性，所以除了用于查找，还可以用于排序和分组。</p>
<p>可以指定多个列作为索引列，多个索引列共同组成键。</p>
<p>适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引。</p>
<p>InnoDB 的 B+Tree 索引分为主索引和辅助索引。主索引的叶子节点 data 域记录着完整的数据记录，这种索引方式被称为聚簇索引。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/45016e98-6879-4709-8569-262b2d6d60b9.png" width="350px"> </div><br>
<p>辅助索引的叶子节点的 data 域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/7c349b91-050b-4d72-a7f8-ec86320307ea.png" width="350px"> </div><br>
<h4 id="2-哈希索引">2. 哈希索引</h4>
<p>哈希索引能以 O(1) 时间进行查找，但是失去了有序性：</p>
<ul>
<li>无法用于排序与分组；</li>
<li>只支持精确查找，无法用于部分查找和范围查找。</li>
</ul>
<p>InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。</p>
<h4 id="3-全文索引">3. 全文索引</h4>
<p>MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。</p>
<p>查找条件使用 MATCH AGAINST，而不是普通的 WHERE。</p>
<p>全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。</p>
<p>InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。</p>
<h4 id="4-空间数据索引">4. 空间数据索引</h4>
<p>MyISAM 存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。</p>
<p>必须使用 GIS 相关的函数来维护数据。</p>
<h3 id="索引优化">索引优化</h3>
<h4 id="1-独立的列">1. 独立的列</h4>
<p>在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。</p>
<p>例如下面的查询不能使用 actor_id 列的索引：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span> actor_id <span style="color:#66d9ef">FROM</span> sakila.actor <span style="color:#66d9ef">WHERE</span> actor_id <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>;
</code></pre></div><h4 id="2-多列索引">2. 多列索引</h4>
<p>在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。例如下面的语句中，最好把 actor_id 和 film_id 设置为多列索引。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span> film_id, actor_ id <span style="color:#66d9ef">FROM</span> sakila.film_actor
<span style="color:#66d9ef">WHERE</span> actor_id <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> <span style="color:#66d9ef">AND</span> film_id <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</code></pre></div><h4 id="3-索引列的顺序">3. 索引列的顺序</h4>
<p>让选择性最强的索引列放在前面。</p>
<p>索引的选择性是指：不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，每个记录的区分度越高，查询效率也越高。</p>
<p>例如下面显示的结果中 customer_id 的选择性比 staff_id 更高，因此最好把 customer_id 列放在多列索引的前面。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span> <span style="color:#66d9ef">COUNT</span>(<span style="color:#66d9ef">DISTINCT</span> staff_id)<span style="color:#f92672">/</span><span style="color:#66d9ef">COUNT</span>(<span style="color:#f92672">*</span>) <span style="color:#66d9ef">AS</span> staff_id_selectivity,
<span style="color:#66d9ef">COUNT</span>(<span style="color:#66d9ef">DISTINCT</span> customer_id)<span style="color:#f92672">/</span><span style="color:#66d9ef">COUNT</span>(<span style="color:#f92672">*</span>) <span style="color:#66d9ef">AS</span> customer_id_selectivity,
<span style="color:#66d9ef">COUNT</span>(<span style="color:#f92672">*</span>)
<span style="color:#66d9ef">FROM</span> payment;
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">   staff_id_selectivity: 0.0001
customer_id_selectivity: 0.0373
               COUNT(*): 16049
</code></pre></div><h4 id="4-前缀索引">4. 前缀索引</h4>
<p>对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。</p>
<p>前缀长度的选取需要根据索引选择性来确定。</p>
<h4 id="5-覆盖索引">5. 覆盖索引</h4>
<p>索引包含所有需要查询的字段的值。</p>
<p>具有以下优点：</p>
<ul>
<li>索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。</li>
<li>一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。</li>
<li>对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。</li>
</ul>
<h3 id="索引的优点">索引的优点</h3>
<ul>
<li>
<p>大大减少了服务器需要扫描的数据行数。</p>
</li>
<li>
<p>帮助服务器避免进行排序和分组，以及避免创建临时表（B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，不需要排序和分组，也就不需要创建临时表）。</p>
</li>
<li>
<p>将随机 I/O 变为顺序 I/O（B+Tree 索引是有序的，会将相邻的数据都存储在一起）。</p>
</li>
</ul>
<h3 id="索引的使用条件">索引的使用条件</h3>
<ul>
<li>
<p>对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效；</p>
</li>
<li>
<p>对于中到大型的表，索引就非常有效；</p>
</li>
<li>
<p>但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。</p>
</li>
</ul>
<h2 id="二查询性能优化">二、查询性能优化</h2>
<h3 id="使用-explain-进行分析">使用 Explain 进行分析</h3>
<p>Explain 用来分析 SELECT 查询语句，开发人员可以通过分析 Explain 结果来优化查询语句。</p>
<p>比较重要的字段有：</p>
<ul>
<li>select_type : 查询类型，有简单查询、联合查询、子查询等</li>
<li>key : 使用的索引</li>
<li>rows : 扫描的行数</li>
</ul>
<h3 id="优化数据访问">优化数据访问</h3>
<h4 id="1-减少请求的数据量">1. 减少请求的数据量</h4>
<ul>
<li>只返回必要的列：最好不要使用 SELECT * 语句。</li>
<li>只返回必要的行：使用 LIMIT 语句来限制返回的数据。</li>
<li>缓存重复查询的数据：使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的。</li>
</ul>
<h4 id="2-减少服务器端扫描的行数">2. 减少服务器端扫描的行数</h4>
<p>最有效的方式是使用索引来覆盖查询。</p>
<h3 id="重构查询方式">重构查询方式</h3>
<h4 id="1-切分大查询">1. 切分大查询</h4>
<p>一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">DELETE</span> <span style="color:#66d9ef">FROM</span> messages <span style="color:#66d9ef">WHERE</span> <span style="color:#66d9ef">create</span> <span style="color:#f92672">&lt;</span> DATE_SUB(NOW(), INTERVAL <span style="color:#ae81ff">3</span> <span style="color:#66d9ef">MONTH</span>);
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql">rows_affected <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
<span style="color:#66d9ef">do</span> <span style="color:#960050;background-color:#1e0010">{</span>
    rows_affected <span style="color:#f92672">=</span> do_query(
    <span style="color:#e6db74">&#34;DELETE FROM messages WHERE create  &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH) LIMIT 10000&#34;</span>)
<span style="color:#960050;background-color:#1e0010">}</span> while rows_affected <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>
</code></pre></div><h4 id="2-分解大连接查询">2. 分解大连接查询</h4>
<p>将一个大连接查询分解成对每一个表进行一次单表查询，然后在应用程序中进行关联，这样做的好处有：</p>
<ul>
<li>让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用。</li>
<li>分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余记录的查询。</li>
<li>减少锁竞争；</li>
<li>在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可伸缩。</li>
<li>查询本身效率也可能会有所提升。例如下面的例子中，使用 IN() 代替连接查询，可以让 MySQL 按照 ID 顺序进行查询，这可能比随机的连接要更高效。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> tag
<span style="color:#66d9ef">JOIN</span> tag_post <span style="color:#66d9ef">ON</span> tag_post.tag_id<span style="color:#f92672">=</span>tag.id
<span style="color:#66d9ef">JOIN</span> post <span style="color:#66d9ef">ON</span> tag_post.post_id<span style="color:#f92672">=</span>post.id
<span style="color:#66d9ef">WHERE</span> tag.tag<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;mysql&#39;</span>;
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> tag <span style="color:#66d9ef">WHERE</span> tag<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;mysql&#39;</span>;
<span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> tag_post <span style="color:#66d9ef">WHERE</span> tag_id<span style="color:#f92672">=</span><span style="color:#ae81ff">1234</span>;
<span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> post <span style="color:#66d9ef">WHERE</span> post.id <span style="color:#66d9ef">IN</span> (<span style="color:#ae81ff">123</span>,<span style="color:#ae81ff">456</span>,<span style="color:#ae81ff">567</span>,<span style="color:#ae81ff">9098</span>,<span style="color:#ae81ff">8904</span>);
</code></pre></div><h2 id="三存储引擎">三、存储引擎</h2>
<h3 id="innodb">InnoDB</h3>
<p>是 MySQL 默认的事务型存储引擎，只有在需要它不支持的特性时，才考虑使用其它存储引擎。</p>
<p>实现了四个标准的隔离级别，默认级别是可重复读（REPEATABLE READ）。在可重复读隔离级别下，通过多版本并发控制（MVCC）+ Next-Key Locking 防止幻影读。</p>
<p>主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。</p>
<p>内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。</p>
<p>支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。</p>
<h3 id="myisam">MyISAM</h3>
<p>设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。</p>
<p>提供了大量的特性，包括压缩表、空间数据索引等。</p>
<p>不支持事务。</p>
<p>不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入（CONCURRENT INSERT）。</p>
<p>可以手工或者自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数据丢失，而且修复操作是非常慢的。</p>
<p>如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。</p>
<h3 id="比较">比较</h3>
<ul>
<li>
<p>事务：InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句。</p>
</li>
<li>
<p>并发：MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。</p>
</li>
<li>
<p>外键：InnoDB 支持外键。</p>
</li>
<li>
<p>备份：InnoDB 支持在线热备份。</p>
</li>
<li>
<p>崩溃恢复：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。</p>
</li>
<li>
<p>其它特性：MyISAM 支持压缩表和空间数据索引。</p>
</li>
</ul>
<h2 id="四数据类型">四、数据类型</h2>
<h3 id="整型">整型</h3>
<p>TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT 分别使用 8, 16, 24, 32, 64 位存储空间，一般情况下越小的列越好。</p>
<p>INT(11) 中的数字只是规定了交互工具显示字符的个数，对于存储和计算来说是没有意义的。</p>
<h3 id="浮点数">浮点数</h3>
<p>FLOAT 和 DOUBLE 为浮点类型，DECIMAL 为高精度小数类型。CPU 原生支持浮点运算，但是不支持 DECIMAl 类型的计算，因此 DECIMAL 的计算比浮点类型需要更高的代价。</p>
<p>FLOAT、DOUBLE 和 DECIMAL 都可以指定列宽，例如 DECIMAL(18, 9) 表示总共 18 位，取 9 位存储小数部分，剩下 9 位存储整数部分。</p>
<h3 id="字符串">字符串</h3>
<p>主要有 CHAR 和 VARCHAR 两种类型，一种是定长的，一种是变长的。</p>
<p>VARCHAR 这种变长类型能够节省空间，因为只需要存储必要的内容。但是在执行 UPDATE 时可能会使行变得比原来长，当超出一个页所能容纳的大小时，就要执行额外的操作。MyISAM 会将行拆成不同的片段存储，而 InnoDB 则需要分裂页来使行放进页内。</p>
<p>在进行存储和检索时，会保留 VARCHAR 末尾的空格，而会删除 CHAR 末尾的空格。</p>
<h3 id="时间和日期">时间和日期</h3>
<p>MySQL 提供了两种相似的日期时间类型：DATETIME 和 TIMESTAMP。</p>
<h4 id="1-datetime">1. DATETIME</h4>
<p>能够保存从 1000 年到 9999 年的日期和时间，精度为秒，使用 8 字节的存储空间。</p>
<p>它与时区无关。</p>
<p>默认情况下，MySQL 以一种可排序的、无歧义的格式显示 DATETIME 值，例如“2008-01-16 22:37:08”，这是 ANSI 标准定义的日期和时间表示方法。</p>
<h4 id="2-timestamp">2. TIMESTAMP</h4>
<p>和 UNIX 时间戳相同，保存从 1970 年 1 月 1 日午夜（格林威治时间）以来的秒数，使用 4 个字节，只能表示从 1970 年到 2038 年。</p>
<p>它和时区有关，也就是说一个时间戳在不同的时区所代表的具体时间是不同的。</p>
<p>MySQL 提供了 FROM_UNIXTIME() 函数把 UNIX 时间戳转换为日期，并提供了 UNIX_TIMESTAMP() 函数把日期转换为 UNIX 时间戳。</p>
<p>默认情况下，如果插入时没有指定 TIMESTAMP 列的值，会将这个值设置为当前时间。</p>
<p>应该尽量使用 TIMESTAMP，因为它比 DATETIME 空间效率更高。</p>
<h2 id="五切分">五、切分</h2>
<h3 id="水平切分">水平切分</h3>
<p>水平切分又称为 Sharding，它是将同一个表中的记录拆分到多个结构相同的表中。</p>
<p>当一个表的数据不断增多时，Sharding 是必然的选择，它可以将数据分布到集群的不同节点上，从而缓存单个数据库的压力。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/63c2909f-0c5f-496f-9fe5-ee9176b31aba.jpg" width=""> </div><br>
<h3 id="垂直切分">垂直切分</h3>
<p>垂直切分是将一张表按列切分成多个表，通常是按照列的关系密集程度进行切分，也可以利用垂直切分将经常被使用的列和不经常被使用的列切分到不同的表中。</p>
<p>在数据库的层面使用垂直切分将按数据库中表的密集程度部署到不同的库中，例如将原来的电商数据库垂直切分成商品数据库、用户数据库等。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/e130e5b8-b19a-4f1e-b860-223040525cf6.jpg" width=""> </div><br>
<h3 id="sharding-策略">Sharding 策略</h3>
<ul>
<li>哈希取模：hash(key) % N；</li>
<li>范围：可以是 ID 范围也可以是时间范围；</li>
<li>映射表：使用单独的一个数据库来存储映射关系。</li>
</ul>
<h3 id="sharding-存在的问题">Sharding 存在的问题</h3>
<h4 id="1-事务问题">1. 事务问题</h4>
<p>使用分布式事务来解决，比如 XA 接口。</p>
<h4 id="2-连接">2. 连接</h4>
<p>可以将原来的连接分解成多个单表查询，然后在用户程序中进行连接。</p>
<h4 id="3-id-唯一性">3. ID 唯一性</h4>
<ul>
<li>使用全局唯一 ID（GUID）</li>
<li>为每个分片指定一个 ID 范围</li>
<li>分布式 ID 生成器 (如 Twitter 的 Snowflake 算法)</li>
</ul>
<h2 id="六复制">六、复制</h2>
<h3 id="主从复制">主从复制</h3>
<p>主要涉及三个线程：binlog 线程、I/O 线程和 SQL 线程。</p>
<ul>
<li><strong>binlog 线程</strong>  ：负责将主服务器上的数据更改写入二进制日志（Binary log）中。</li>
<li><strong>I/O 线程</strong>  ：负责从主服务器上读取二进制日志，并写入从服务器的中继日志（Relay log）。</li>
<li><strong>SQL 线程</strong>  ：负责读取中继日志，解析出主服务器已经执行的数据更改并在从服务器中重放（Replay）。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/master-slave.png" width=""> </div><br>
<h3 id="读写分离">读写分离</h3>
<p>主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。</p>
<p>读写分离能提高性能的原因在于：</p>
<ul>
<li>主从服务器负责各自的读和写，极大程度缓解了锁的争用；</li>
<li>从服务器可以使用 MyISAM，提升查询性能以及节约系统开销；</li>
<li>增加冗余，提高可用性。</li>
</ul>
<p>读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/master-slave-proxy.png" width=""> </div><br>
<h2 id="参考资料">参考资料</h2>
<ul>
<li>BaronScbwartz, PeterZaitsev, VadimTkacbenko, 等. 高性能 MySQL[M]. 电子工业出版社, 2013.</li>
<li>姜承尧. MySQL 技术内幕: InnoDB 存储引擎 [M]. 机械工业出版社, 2011.</li>
<li><a href="https://www.jfox.info/20-tiao-mysql-xing-nen-you-hua-de-zui-jia-jing-yan.html">20+ 条 MySQL 性能优化的最佳经验</a></li>
<li><a href="http://blog.720ui.com/2017/mysql_core_09_multi_db_table2/" title="服务端指南 数据存储篇 | MySQL（09） 分库与分表带来的分布式困境与应对之策">服务端指南 数据存储篇 | MySQL（09） 分库与分表带来的分布式困境与应对之策</a></li>
<li><a href="https://stackoverflow.com/questions/788829/how-to-create-unique-row-id-in-sharded-databases">How to create unique row ID in sharded databases?</a></li>
<li><a href="http://geekswithblogs.net/shaunxu/archive/2012/01/07/sql-azure-federation-ndash-introduction.aspx" title="Title of this entry.">SQL Azure Federation – Introduction</a></li>
<li><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html">MySQL 索引背后的数据结构及算法原理</a></li>
<li><a href="https://segmentfault.com/a/1190000008131735">MySQL 性能优化神器 Explain 使用分析</a></li>
<li><a href="https://medium.com/@jeeyoungk/how-sharding-works-b4dec46b3f6">How Sharding Works</a></li>
<li><a href="https://tech.meituan.com/dianping_order_db_sharding.html">大众点评订单系统分库分表实践</a></li>
<li><a href="https://zh.wikipedia.org/wiki/B%2B%E6%A0%91">B + 树</a></li>
</ul>

        
        ]]>
      </description>
    </item>
    
    
    
    <item>
      <title>【转载】数据库系统原理</title>
      <link>/post/2021/12/22/%E8%BD%AC%E8%BD%BD%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/</link>
      <pubDate>Wed, 22 Dec 2021 23:28:00 +0800</pubDate>
      <author>罗泽勋</author>
      <guid>/post/2021/12/22/%E8%BD%AC%E8%BD%BD%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/</guid>
      <description>
        <![CDATA[
        <h1 id="数据库系统原理">数据库系统原理</h1>
<!-- GFM-TOC -->
<ul>
<li><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86">数据库系统原理</a>
<ul>
<li><a href="#%E4%B8%80%E4%BA%8B%E5%8A%A1">一、事务</a>
<ul>
<li><a href="#%E6%A6%82%E5%BF%B5">概念</a></li>
<li><a href="#acid">ACID</a></li>
<li><a href="#autocommit">AUTOCOMMIT</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C%E5%B9%B6%E5%8F%91%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98">二、并发一致性问题</a>
<ul>
<li><a href="#%E4%B8%A2%E5%A4%B1%E4%BF%AE%E6%94%B9">丢失修改</a></li>
<li><a href="#%E8%AF%BB%E8%84%8F%E6%95%B0%E6%8D%AE">读脏数据</a></li>
<li><a href="#%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB">不可重复读</a></li>
<li><a href="#%E5%B9%BB%E5%BD%B1%E8%AF%BB">幻影读</a></li>
</ul>
</li>
<li><a href="#%E4%B8%89%E5%B0%81%E9%94%81">三、封锁</a>
<ul>
<li><a href="#%E5%B0%81%E9%94%81%E7%B2%92%E5%BA%A6">封锁粒度</a></li>
<li><a href="#%E5%B0%81%E9%94%81%E7%B1%BB%E5%9E%8B">封锁类型</a></li>
<li><a href="#%E5%B0%81%E9%94%81%E5%8D%8F%E8%AE%AE">封锁协议</a></li>
<li><a href="#mysql-%E9%9A%90%E5%BC%8F%E4%B8%8E%E6%98%BE%E5%BC%8F%E9%94%81%E5%AE%9A">MySQL 隐式与显式锁定</a></li>
</ul>
</li>
<li><a href="#%E5%9B%9B%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB">四、隔离级别</a>
<ul>
<li><a href="#%E6%9C%AA%E6%8F%90%E4%BA%A4%E8%AF%BBread-uncommitted">未提交读（READ UNCOMMITTED）</a></li>
<li><a href="#%E6%8F%90%E4%BA%A4%E8%AF%BBread-committed">提交读（READ COMMITTED）</a></li>
<li><a href="#%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BBrepeatable-read">可重复读（REPEATABLE READ）</a></li>
<li><a href="#%E5%8F%AF%E4%B8%B2%E8%A1%8C%E5%8C%96serializable">可串行化（SERIALIZABLE）</a></li>
</ul>
</li>
<li><a href="#%E4%BA%94%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6">五、多版本并发控制</a>
<ul>
<li><a href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3">基本思想</a></li>
<li><a href="#%E7%89%88%E6%9C%AC%E5%8F%B7">版本号</a></li>
<li><a href="#undo-%E6%97%A5%E5%BF%97">Undo 日志</a></li>
<li><a href="#readview">ReadView</a></li>
<li><a href="#%E5%BF%AB%E7%85%A7%E8%AF%BB%E4%B8%8E%E5%BD%93%E5%89%8D%E8%AF%BB">快照读与当前读</a></li>
</ul>
</li>
<li><a href="#%E5%85%ADnext-key-locks">六、Next-Key Locks</a>
<ul>
<li><a href="#record-locks">Record Locks</a></li>
<li><a href="#gap-locks">Gap Locks</a></li>
<li><a href="#next-key-locks">Next-Key Locks</a></li>
</ul>
</li>
<li><a href="#%E4%B8%83%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E7%90%86%E8%AE%BA">七、关系数据库设计理论</a>
<ul>
<li><a href="#%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96">函数依赖</a></li>
<li><a href="#%E5%BC%82%E5%B8%B8">异常</a></li>
<li><a href="#%E8%8C%83%E5%BC%8F">范式</a></li>
</ul>
</li>
<li><a href="#%E5%85%ABer-%E5%9B%BE">八、ER 图</a>
<ul>
<li><a href="#%E5%AE%9E%E4%BD%93%E7%9A%84%E4%B8%89%E7%A7%8D%E8%81%94%E7%B3%BB">实体的三种联系</a></li>
<li><a href="#%E8%A1%A8%E7%A4%BA%E5%87%BA%E7%8E%B0%E5%A4%9A%E6%AC%A1%E7%9A%84%E5%85%B3%E7%B3%BB">表示出现多次的关系</a></li>
<li><a href="#%E8%81%94%E7%B3%BB%E7%9A%84%E5%A4%9A%E5%90%91%E6%80%A7">联系的多向性</a></li>
<li><a href="#%E8%A1%A8%E7%A4%BA%E5%AD%90%E7%B1%BB">表示子类</a></li>
</ul>
</li>
<li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
</li>
</ul>
<!-- GFM-TOC -->
<h2 id="一事务">一、事务</h2>
<h3 id="概念">概念</h3>
<p>事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207222237925.png"/> </div><br>
<h3 id="acid">ACID</h3>
<h4 id="1-原子性atomicity">1. 原子性（Atomicity）</h4>
<p>事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。</p>
<p>回滚可以用回滚日志（Undo Log）来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。</p>
<h4 id="2-一致性consistency">2. 一致性（Consistency）</h4>
<p>数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对同一个数据的读取结果都是相同的。</p>
<h4 id="3-隔离性isolation">3. 隔离性（Isolation）</h4>
<p>一个事务所做的修改在最终提交以前，对其它事务是不可见的。</p>
<h4 id="4-持久性durability">4. 持久性（Durability）</h4>
<p>一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。</p>
<p>系统发生崩溃可以用重做日志（Redo Log）进行恢复，从而实现持久性。与回滚日志记录数据的逻辑修改不同，重做日志记录的是数据页的物理修改。</p>
<hr>
<p>事务的 ACID 特性概念简单，但不是很好理解，主要是因为这几个特性不是一种平级关系：</p>
<ul>
<li>只有满足一致性，事务的执行结果才是正确的。</li>
<li>在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。</li>
<li>在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。</li>
<li>事务满足持久化是为了能应对系统崩溃的情况。</li>
</ul>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207210437023.png"/> </div><br>
<h3 id="autocommit">AUTOCOMMIT</h3>
<p>MySQL 默认采用自动提交模式。也就是说，如果不显式使用<code>START TRANSACTION</code>语句来开始一个事务，那么每个查询操作都会被当做一个事务并自动提交。</p>
<h2 id="二并发一致性问题">二、并发一致性问题</h2>
<p>在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。</p>
<h3 id="丢失修改">丢失修改</h3>
<p>丢失修改指一个事务的更新操作被另外一个事务的更新操作替换。一般在现实生活中常会遇到，例如：T<sub>1</sub> 和 T<sub>2</sub> 两个事务都对一个数据进行修改，T<sub>1</sub> 先修改并提交生效，T<sub>2</sub> 随后修改，T<sub>2</sub> 的修改覆盖了 T<sub>1</sub> 的修改。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207221744244.png"/> </div><br>
<h3 id="读脏数据">读脏数据</h3>
<p>读脏数据指在不同的事务下，当前事务可以读到另外事务未提交的数据。例如：T<sub>1</sub> 修改一个数据但未提交，T<sub>2</sub> 随后读取这个数据。如果 T<sub>1</sub> 撤销了这次修改，那么 T<sub>2</sub> 读取的数据是脏数据。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207221920368.png"/> </div><br>
<h3 id="不可重复读">不可重复读</h3>
<p>不可重复读指在一个事务内多次读取同一数据集合。在这一事务还未结束前，另一事务也访问了该同一数据集合并做了修改，由于第二个事务的修改，第一次事务的两次读取的数据可能不一致。例如：T<sub>2</sub> 读取一个数据，T<sub>1</sub> 对该数据做了修改。如果 T<sub>2</sub> 再次读取这个数据，此时读取的结果和第一次读取的结果不同。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207222102010.png"/> </div><br>
<h3 id="幻影读">幻影读</h3>
<p>幻读本质上也属于不可重复读的情况，T<sub>1</sub> 读取某个范围的数据，T<sub>2</sub> 在这个范围内插入新的数据，T<sub>1</sub> 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207222134306.png"/> </div><br>
<hr>
<p>产生并发不一致性问题的主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。</p>
<h2 id="三封锁">三、封锁</h2>
<h3 id="封锁粒度">封锁粒度</h3>
<p>MySQL 中提供了两种封锁粒度：行级锁以及表级锁。</p>
<p>应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。</p>
<p>但是加锁需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此封锁粒度越小，系统开销就越大。</p>
<p>在选择封锁粒度时，需要在锁开销和并发程度之间做一个权衡。</p>
<h3 id="封锁类型">封锁类型</h3>
<h4 id="1-读写锁">1. 读写锁</h4>
<ul>
<li>互斥锁（Exclusive），简写为 X 锁，又称写锁。</li>
<li>共享锁（Shared），简写为 S 锁，又称读锁。</li>
</ul>
<p>有以下两个规定：</p>
<ul>
<li>一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。</li>
<li>一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。</li>
</ul>
<p>锁的兼容关系如下：</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207213523777.png"/> </div><br>
<h4 id="2-意向锁">2. 意向锁</h4>
<p>使用意向锁（Intention Locks）可以更容易地支持多粒度封锁。</p>
<p>在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。</p>
<p>意向锁在原来的 X/S 锁之上引入了 IX/IS，IX/IS 都是表锁，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。有以下两个规定：</p>
<ul>
<li>一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；</li>
<li>一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。</li>
</ul>
<p>通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。</p>
<p>各种锁的兼容关系如下：</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207214442687.png"/> </div><br>
<p>解释如下：</p>
<ul>
<li>任意 IS/IX 锁之间都是兼容的，因为它们只表示想要对表加锁，而不是真正加锁；</li>
<li>这里兼容关系针对的是表级锁，而表级的 IX 锁和行级的 X 锁兼容，两个事务可以对两个数据行加 X 锁。（事务 T<sub>1</sub> 想要对数据行 R<sub>1</sub> 加 X 锁，事务 T<sub>2</sub> 想要对同一个表的数据行 R<sub>2</sub> 加 X 锁，两个事务都需要对该表加 IX 锁，但是 IX 锁是兼容的，并且 IX 锁与行级的 X 锁也是兼容的，因此两个事务都能加锁成功，对同一个表中的两个数据行做修改。）</li>
</ul>
<h3 id="封锁协议">封锁协议</h3>
<h4 id="1-三级封锁协议">1. 三级封锁协议</h4>
<p><strong>一级封锁协议</strong></p>
<p>事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁。</p>
<p>可以解决丢失修改问题，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207220440451.png"/> </div><br>
<p><strong>二级封锁协议</strong></p>
<p>在一级的基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁。</p>
<p>可以解决读脏数据问题，因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207220831843.png"/> </div><br>
<p><strong>三级封锁协议</strong></p>
<p>在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁。</p>
<p>可以解决不可重复读的问题，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207221313819.png"/> </div><br>
<h4 id="2-两段锁协议">2. 两段锁协议</h4>
<p>加锁和解锁分为两个阶段进行。</p>
<p>可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。串行执行的事务互不干扰，不会出现并发一致性问题。</p>
<p>事务遵循两段锁协议是保证可串行化调度的充分条件。例如以下操作满足两段锁协议，它是可串行化调度。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">lock-x(A)...lock-s(B)...lock-s(C)...unlock(A)...unlock(C)...unlock(B)
</code></pre></div><p>但不是必要条件，例如以下操作不满足两段锁协议，但它还是可串行化调度。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">lock-x(A)...unlock(A)...lock-s(B)...unlock(B)...lock-s(C)...unlock(C)
</code></pre></div><h3 id="mysql-隐式与显式锁定">MySQL 隐式与显式锁定</h3>
<p>MySQL 的 InnoDB 存储引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定。</p>
<p>InnoDB 也可以使用特定的语句进行显示锁定：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span> ... <span style="color:#66d9ef">LOCK</span> <span style="color:#66d9ef">In</span> <span style="color:#66d9ef">SHARE</span> <span style="color:#66d9ef">MODE</span>;
<span style="color:#66d9ef">SELECT</span> ... <span style="color:#66d9ef">FOR</span> <span style="color:#66d9ef">UPDATE</span>;
</code></pre></div><h2 id="四隔离级别">四、隔离级别</h2>
<h3 id="未提交读read-uncommitted">未提交读（READ UNCOMMITTED）</h3>
<p>事务中的修改，即使没有提交，对其它事务也是可见的。</p>
<h3 id="提交读read-committed">提交读（READ COMMITTED）</h3>
<p>一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。</p>
<h3 id="可重复读repeatable-read">可重复读（REPEATABLE READ）</h3>
<p>保证在同一个事务中多次读取同一数据的结果是一样的。</p>
<h3 id="可串行化serializable">可串行化（SERIALIZABLE）</h3>
<p>强制事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题。</p>
<p>该隔离级别需要加锁实现，因为要使用加锁机制保证同一时间只有一个事务执行，也就是保证事务串行执行。</p>
<hr>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191207223400787.png"/> </div><br>
<h2 id="五多版本并发控制">五、多版本并发控制</h2>
<p>多版本并发控制（Multi-Version Concurrency Control, MVCC）是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。而未提交读隔离级别总是读取最新的数据行，要求很低，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。</p>
<h3 id="基本思想">基本思想</h3>
<p>在封锁一节中提到，加锁能解决多个事务同时执行时出现的并发一致性问题。在实际场景中读操作往往多于写操作，因此又引入了读写锁来避免不必要的加锁操作，例如读和读没有互斥关系。读写锁中读和写操作仍然是互斥的，而 MVCC 利用了多版本的思想，写操作更新最新的版本快照，而读操作去读旧版本快照，没有互斥关系，这一点和 CopyOnWrite 类似。</p>
<p>在 MVCC 中事务的修改操作（DELETE、INSERT、UPDATE）会为数据行新增一个版本快照。</p>
<p>脏读和不可重复读最根本的原因是事务读取到其它事务未提交的修改。在事务进行读取操作时，为了解决脏读和不可重复读问题，MVCC 规定只能读取已经提交的快照。当然一个事务可以读取自身未提交的快照，这不算是脏读。</p>
<h3 id="版本号">版本号</h3>
<ul>
<li>系统版本号 SYS_ID：是一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。</li>
<li>事务版本号 TRX_ID ：事务开始时的系统版本号。</li>
</ul>
<h3 id="undo-日志">Undo 日志</h3>
<p>MVCC 的多版本指的是多个版本的快照，快照存储在 Undo 日志中，该日志通过回滚指针 ROLL_PTR 把一个数据行的所有快照连接起来。</p>
<p>例如在 MySQL 创建一个表 t，包含主键 id 和一个字段 x。我们先插入一个数据行，然后对该数据行执行两次更新操作。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">INSERT</span> <span style="color:#66d9ef">INTO</span> t(id, x) <span style="color:#66d9ef">VALUES</span>(<span style="color:#ae81ff">1</span>, <span style="color:#e6db74">&#34;a&#34;</span>);
<span style="color:#66d9ef">UPDATE</span> t <span style="color:#66d9ef">SET</span> x<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;b&#34;</span> <span style="color:#66d9ef">WHERE</span> id<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;
<span style="color:#66d9ef">UPDATE</span> t <span style="color:#66d9ef">SET</span> x<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;c&#34;</span> <span style="color:#66d9ef">WHERE</span> id<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;
</code></pre></div><p>因为没有使用 <code>START TRANSACTION</code> 将上面的操作当成一个事务来执行，根据 MySQL 的 AUTOCOMMIT 机制，每个操作都会被当成一个事务来执行，所以上面的操作总共涉及到三个事务。快照中除了记录事务版本号 TRX_ID 和操作之外，还记录了一个 bit 的 DEL 字段，用于标记是否被删除。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208164808217.png"/> </div><br>
<p>INSERT、UPDATE、DELETE 操作会创建一个日志，并将事务版本号 TRX_ID  写入。DELETE 可以看成是一个特殊的 UPDATE，还会额外将 DEL 字段设置为 1。</p>
<h3 id="readview">ReadView</h3>
<p>MVCC 维护了一个 ReadView 结构，主要包含了当前系统未提交的事务列表 TRX_IDs {TRX_ID_1, TRX_ID_2, &hellip;}，还有该列表的最小值 TRX_ID_MIN 和 TRX_ID_MAX。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20191208171445674.png"/> </div><br>
<p>在进行 SELECT 操作时，根据数据行快照的 TRX_ID 与 TRX_ID_MIN 和 TRX_ID_MAX 之间的关系，从而判断数据行快照是否可以使用：</p>
<ul>
<li>
<p>TRX_ID &lt; TRX_ID_MIN，表示该数据行快照时在当前所有未提交事务之前进行更改的，因此可以使用。</p>
</li>
<li>
<p>TRX_ID &gt; TRX_ID_MAX，表示该数据行快照是在事务启动之后被更改的，因此不可使用。</p>
</li>
<li>
<p>TRX_ID_MIN &lt;= TRX_ID &lt;= TRX_ID_MAX，需要根据隔离级别再进行判断：</p>
<ul>
<li>提交读：如果 TRX_ID  在 TRX_IDs  列表中，表示该数据行快照对应的事务还未提交，则该快照不可使用。否则表示已经提交，可以使用。</li>
<li>可重复读：都不可以使用。因为如果可以使用的话，那么其它事务也可以读到这个数据行快照并进行修改，那么当前事务再去读这个数据行得到的值就会发生改变，也就是出现了不可重复读问题。</li>
</ul>
</li>
</ul>
<p>在数据行快照不可使用的情况下，需要沿着 Undo Log 的回滚指针 ROLL_PTR  找到下一个快照，再进行上面的判断。</p>
<h3 id="快照读与当前读">快照读与当前读</h3>
<h4 id="1-快照读">1. 快照读</h4>
<p>MVCC 的 SELECT 操作是快照中的数据，不需要进行加锁操作。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> <span style="color:#66d9ef">table</span> ...;
</code></pre></div><h4 id="2-当前读">2. 当前读</h4>
<p>MVCC 其它会对数据库进行修改的操作（INSERT、UPDATE、DELETE）需要进行加锁操作，从而读取最新的数据。可以看到 MVCC 并不是完全不用加锁，而只是避免了 SELECT 的加锁操作。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">INSERT</span>;
<span style="color:#66d9ef">UPDATE</span>;
<span style="color:#66d9ef">DELETE</span>;
</code></pre></div><p>在进行 SELECT 操作时，可以强制指定进行加锁操作。以下第一个语句需要加 S 锁，第二个需要加 X 锁。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> <span style="color:#66d9ef">table</span> <span style="color:#66d9ef">WHERE</span> <span style="color:#f92672">?</span> <span style="color:#66d9ef">lock</span> <span style="color:#66d9ef">in</span> <span style="color:#66d9ef">share</span> <span style="color:#66d9ef">mode</span>;
<span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> <span style="color:#66d9ef">table</span> <span style="color:#66d9ef">WHERE</span> <span style="color:#f92672">?</span> <span style="color:#66d9ef">for</span> <span style="color:#66d9ef">update</span>;
</code></pre></div><h2 id="六next-key-locks">六、Next-Key Locks</h2>
<p>Next-Key Locks 是 MySQL 的 InnoDB 存储引擎的一种锁实现。</p>
<p>MVCC 不能解决幻影读问题，Next-Key Locks 就是为了解决这个问题而存在的。在可重复读（REPEATABLE READ）隔离级别下，使用 MVCC + Next-Key Locks 可以解决幻读问题。</p>
<h3 id="record-locks">Record Locks</h3>
<p>锁定一个记录上的索引，而不是记录本身。</p>
<p>如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚簇索引，因此 Record Locks 依然可以使用。</p>
<h3 id="gap-locks">Gap Locks</h3>
<p>锁定索引之间的间隙，但是不包含索引本身。例如当一个事务执行以下语句，其它事务就不能在 t.c 中插入 15。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span> <span style="color:#66d9ef">c</span> <span style="color:#66d9ef">FROM</span> t <span style="color:#66d9ef">WHERE</span> <span style="color:#66d9ef">c</span> <span style="color:#66d9ef">BETWEEN</span> <span style="color:#ae81ff">10</span> <span style="color:#66d9ef">and</span> <span style="color:#ae81ff">20</span> <span style="color:#66d9ef">FOR</span> <span style="color:#66d9ef">UPDATE</span>;
</code></pre></div><h3 id="next-key-locks">Next-Key Locks</h3>
<p>它是 Record Locks 和 Gap Locks 的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙。它锁定一个前开后闭区间，例如一个索引包含以下值：10, 11, 13, and 20，那么就需要锁定以下区间：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql">(<span style="color:#f92672">-</span><span style="color:#960050;background-color:#1e0010">∞</span>, <span style="color:#ae81ff">10</span>]
(<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">11</span>]
(<span style="color:#ae81ff">11</span>, <span style="color:#ae81ff">13</span>]
(<span style="color:#ae81ff">13</span>, <span style="color:#ae81ff">20</span>]
(<span style="color:#ae81ff">20</span>, <span style="color:#f92672">+</span><span style="color:#960050;background-color:#1e0010">∞</span>)
</code></pre></div><h2 id="七关系数据库设计理论">七、关系数据库设计理论</h2>
<h3 id="函数依赖">函数依赖</h3>
<p>记 A-&gt;B 表示 A 函数决定 B，也可以说 B 函数依赖于 A。</p>
<p>如果 {A1，A2，&hellip; ，An} 是关系的一个或多个属性的集合，该集合函数决定了关系的其它所有属性并且是最小的，那么该集合就称为键码。</p>
<p>对于 A-&gt;B，如果能找到 A 的真子集 A'，使得 A'-&gt; B，那么 A-&gt;B 就是部分函数依赖，否则就是完全函数依赖。</p>
<p>对于 A-&gt;B，B-&gt;C，则 A-&gt;C 是一个传递函数依赖。</p>
<h3 id="异常">异常</h3>
<p>以下的学生课程关系的函数依赖为 {Sno, Cname} -&gt; {Sname, Sdept, Mname, Grade}，键码为 {Sno, Cname}。也就是说，确定学生和课程之后，就能确定其它信息。</p>
<table>
<thead>
<tr>
<th style="text-align:center">Sno</th>
<th style="text-align:center">Sname</th>
<th style="text-align:center">Sdept</th>
<th style="text-align:center">Mname</th>
<th style="text-align:center">Cname</th>
<th style="text-align:center">Grade</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">学生-1</td>
<td style="text-align:center">学院-1</td>
<td style="text-align:center">院长-1</td>
<td style="text-align:center">课程-1</td>
<td style="text-align:center">90</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">学生-2</td>
<td style="text-align:center">学院-2</td>
<td style="text-align:center">院长-2</td>
<td style="text-align:center">课程-2</td>
<td style="text-align:center">80</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">学生-2</td>
<td style="text-align:center">学院-2</td>
<td style="text-align:center">院长-2</td>
<td style="text-align:center">课程-1</td>
<td style="text-align:center">100</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">学生-3</td>
<td style="text-align:center">学院-2</td>
<td style="text-align:center">院长-2</td>
<td style="text-align:center">课程-2</td>
<td style="text-align:center">95</td>
</tr>
</tbody>
</table>
<p>不符合范式的关系，会产生很多异常，主要有以下四种异常：</p>
<ul>
<li>冗余数据：例如 <code>学生-2</code> 出现了两次。</li>
<li>修改异常：修改了一个记录中的信息，但是另一个记录中相同的信息却没有被修改。</li>
<li>删除异常：删除一个信息，那么也会丢失其它信息。例如删除了 <code>课程-1</code> 需要删除第一行和第三行，那么 <code>学生-1</code> 的信息就会丢失。</li>
<li>插入异常：例如想要插入一个学生的信息，如果这个学生还没选课，那么就无法插入。</li>
</ul>
<h3 id="范式">范式</h3>
<p>范式理论是为了解决以上提到四种异常。</p>
<p>高级别范式的依赖于低级别的范式，1NF 是最低级别的范式。</p>
<h4 id="1-第一范式-1nf">1. 第一范式 (1NF)</h4>
<p>属性不可分。</p>
<h4 id="2-第二范式-2nf">2. 第二范式 (2NF)</h4>
<p>每个非主属性完全函数依赖于键码。</p>
<p>可以通过分解来满足。</p>
<p><font size=4>  <strong>分解前</strong>  </font><br></p>
<table>
<thead>
<tr>
<th style="text-align:center">Sno</th>
<th style="text-align:center">Sname</th>
<th style="text-align:center">Sdept</th>
<th style="text-align:center">Mname</th>
<th style="text-align:center">Cname</th>
<th style="text-align:center">Grade</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">学生-1</td>
<td style="text-align:center">学院-1</td>
<td style="text-align:center">院长-1</td>
<td style="text-align:center">课程-1</td>
<td style="text-align:center">90</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">学生-2</td>
<td style="text-align:center">学院-2</td>
<td style="text-align:center">院长-2</td>
<td style="text-align:center">课程-2</td>
<td style="text-align:center">80</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">学生-2</td>
<td style="text-align:center">学院-2</td>
<td style="text-align:center">院长-2</td>
<td style="text-align:center">课程-1</td>
<td style="text-align:center">100</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">学生-3</td>
<td style="text-align:center">学院-2</td>
<td style="text-align:center">院长-2</td>
<td style="text-align:center">课程-2</td>
<td style="text-align:center">95</td>
</tr>
</tbody>
</table>
<p>以上学生课程关系中，{Sno, Cname} 为键码，有如下函数依赖：</p>
<ul>
<li>Sno -&gt; Sname, Sdept</li>
<li>Sdept -&gt; Mname</li>
<li>Sno, Cname-&gt; Grade</li>
</ul>
<p>Grade 完全函数依赖于键码，它没有任何冗余数据，每个学生的每门课都有特定的成绩。</p>
<p>Sname, Sdept 和 Mname 都部分依赖于键码，当一个学生选修了多门课时，这些数据就会出现多次，造成大量冗余数据。</p>
<p><font size=4>  <strong>分解后</strong>  </font><br></p>
<p>关系-1</p>
<table>
<thead>
<tr>
<th style="text-align:center">Sno</th>
<th style="text-align:center">Sname</th>
<th style="text-align:center">Sdept</th>
<th style="text-align:center">Mname</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">学生-1</td>
<td style="text-align:center">学院-1</td>
<td style="text-align:center">院长-1</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">学生-2</td>
<td style="text-align:center">学院-2</td>
<td style="text-align:center">院长-2</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">学生-3</td>
<td style="text-align:center">学院-2</td>
<td style="text-align:center">院长-2</td>
</tr>
</tbody>
</table>
<p>有以下函数依赖：</p>
<ul>
<li>Sno -&gt; Sname, Sdept</li>
<li>Sdept -&gt; Mname</li>
</ul>
<p>关系-2</p>
<table>
<thead>
<tr>
<th style="text-align:center">Sno</th>
<th style="text-align:center">Cname</th>
<th style="text-align:center">Grade</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">课程-1</td>
<td style="text-align:center">90</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">课程-2</td>
<td style="text-align:center">80</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">课程-1</td>
<td style="text-align:center">100</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">课程-2</td>
<td style="text-align:center">95</td>
</tr>
</tbody>
</table>
<p>有以下函数依赖：</p>
<ul>
<li>Sno, Cname -&gt;  Grade</li>
</ul>
<h4 id="3-第三范式-3nf">3. 第三范式 (3NF)</h4>
<p>非主属性不传递函数依赖于键码。</p>
<p>上面的 关系-1 中存在以下传递函数依赖：</p>
<ul>
<li>Sno -&gt; Sdept -&gt; Mname</li>
</ul>
<p>可以进行以下分解：</p>
<p>关系-11</p>
<table>
<thead>
<tr>
<th style="text-align:center">Sno</th>
<th style="text-align:center">Sname</th>
<th style="text-align:center">Sdept</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">学生-1</td>
<td style="text-align:center">学院-1</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">学生-2</td>
<td style="text-align:center">学院-2</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">学生-3</td>
<td style="text-align:center">学院-2</td>
</tr>
</tbody>
</table>
<p>关系-12</p>
<table>
<thead>
<tr>
<th style="text-align:center">Sdept</th>
<th style="text-align:center">Mname</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">学院-1</td>
<td style="text-align:center">院长-1</td>
</tr>
<tr>
<td style="text-align:center">学院-2</td>
<td style="text-align:center">院长-2</td>
</tr>
</tbody>
</table>
<h2 id="八er-图">八、ER 图</h2>
<p>Entity-Relationship，有三个组成部分：实体、属性、联系。</p>
<p>用来进行关系型数据库系统的概念设计。</p>
<h3 id="实体的三种联系">实体的三种联系</h3>
<p>包含一对一，一对多，多对多三种。</p>
<ul>
<li>如果 A 到 B 是一对多关系，那么画个带箭头的线段指向 B；</li>
<li>如果是一对一，画两个带箭头的线段；</li>
<li>如果是多对多，画两个不带箭头的线段。</li>
</ul>
<p>下图的 Course 和 Student 是一对多的关系。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/1d28ad05-39e5-49a2-a6a1-a6f496adba6a.png" width="380px"/> </div><br>
<h3 id="表示出现多次的关系">表示出现多次的关系</h3>
<p>一个实体在联系出现几次，就要用几条线连接。</p>
<p>下图表示一个课程的先修关系，先修关系出现两个 Course 实体，第一个是先修课程，后一个是后修课程，因此需要用两条线来表示这种关系。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/ac929ea3-daca-40ec-9e95-4b2fa6678243.png" width="250px"/> </div><br>
<h3 id="联系的多向性">联系的多向性</h3>
<p>虽然老师可以开设多门课，并且可以教授多名学生，但是对于特定的学生和课程，只有一个老师教授，这就构成了一个三元联系。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/5bb1b38a-527e-4802-a385-267dadbd30ba.png" width="350px"/> </div><br>
<h3 id="表示子类">表示子类</h3>
<p>用一个三角形和两条线来连接类和子类，与子类有关的属性和联系都连到子类上，而与父类和子类都有关的连到父类上。</p>
<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/14389ea4-8d96-4e96-9f76-564ca3324c1e.png" width="450px"/> </div><br>
<h2 id="参考资料">参考资料</h2>
<ul>
<li>AbrahamSilberschatz, HenryF.Korth, S.Sudarshan, 等. 数据库系统概念 [M]. 机械工业出版社, 2006.</li>
<li>施瓦茨. 高性能 MYSQL(第3版)[M]. 电子工业出版社, 2013.</li>
<li>史嘉权. 数据库系统概论[M]. 清华大学出版社有限公司, 2006.</li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-storage-engine.html">The InnoDB Storage Engine</a></li>
<li><a href="https://www.slideshare.net/ErnestoHernandezRodriguez/transaction-isolation-levels">Transaction isolation levels</a></li>
<li><a href="http://scanftree.com/dbms/2-phase-locking-protocol">Concurrency Control</a></li>
<li><a href="https://www.slideshare.net/brshristov/the-nightmare-of-locking-blocking-and-isolation-levels-46391666">The Nightmare of Locking, Blocking and Isolation Levels!</a></li>
<li><a href="https://aksakalli.github.io/2012/03/12/database-normalization-and-normal-forms-with-an-example.html">Database Normalization and Normal Forms with an Example</a></li>
<li><a href="https://blog.jcole.us/2014/04/16/the-basics-of-the-innodb-undo-logging-and-history-system/">The basics of the InnoDB undo logging and history system</a></li>
<li><a href="https://www.brightbox.com/blog/2013/10/31/on-mysql-locks/">MySQL locking for the busy web developer</a></li>
<li><a href="https://draveness.me/mysql-innodb">浅入浅出 MySQL 和 InnoDB</a></li>
<li><a href="https://tech.meituan.com/2014/08/20/innodb-lock.html">Innodb 中的事务隔离级别和锁的关系</a></li>
</ul>

        
        ]]>
      </description>
    </item>
    
    
    
    <item>
      <title>线性表</title>
      <link>/post/2021/12/16/linearlist/</link>
      <pubDate>Thu, 16 Dec 2021 12:43:02 +0800</pubDate>
      <author>罗泽勋</author>
      <guid>/post/2021/12/16/linearlist/</guid>
      <description>
        <![CDATA[
        <p>线性表是一种最基本、最简单的数据结构，数据元素之间仅具有单一的前驱和后继关系。</p>
<h3 id="一线性表的逻辑结构">一、线性表的逻辑结构</h3>
<p>定义：线性表简称表，是 n(n&gt;=0) 个具有<strong>相同类型</strong>的数据元素的<strong>有限序列</strong>。</p>
<h3 id="二线性表的顺序存储结构顺序表">二、线性表的顺序存储结构——顺序表</h3>
<p>顺序表是用一段<strong>地址连续</strong>的存储单元依次存储线性表的元素。通常使用数组实现。</p>
<p>用数组存储顺序表，意味着要分配固定长度的数组空间，因此，必须确定数组的长度。</p>
<p>顺序表中数据元素的地址是其序号的线性函数，只要确定了存储顺序表的起始地址（即基地址），计算任意一个元素的存储地址的时间是相等的，具有这一特点的存储结构称为<strong>随机存储结构</strong>。</p>
<p>顺序表具有以下缺点：</p>
<ul>
<li>插入和删除操作需要移动大量元素。在顺序表上做插入和删除操作，等概率情况下，平均要移动表中一半的元素。</li>
<li>表的容量难以确定。由于数组的长度必须事先确定，因为此，当线性表的长度变化较大时，难以确定合适的存储规模。</li>
<li>造成存储空间的“碎片”。数组要求占用连续的存储空间，即使存储单元数超过所需的数目，如果不连续也不能使用，造成存储空间的“碎片”现象。</li>
</ul>
<p>造成上述顺序表的缺点的根本原因是静态存储分配，为了克服顺序表的缺点，可以采用动态存储分配连存储线性表，也就是采用链接存储结构。</p>
<h3 id="三线性表的链接存储结构及实现">三、线性表的链接存储结构及实现</h3>
<h4 id="单链表">单链表</h4>
<p>单链表是用一组任意的存储单元存放线性表的元素，这组存储单元可以连续也可以不连续，甚至可以零散分布在内存中的任意位置。每个存储单元在存储数据元素的同时，还必须存储其后继元素所在的地址信息，这个地址信息称为指针。这两部分组成数据元素的存储映射，称为节点。</p>
<p>单链表只有一个指针域（next）。</p>
<p>头节点：无论单链表是否为空，头指针始终指向头节点，因此空表和非空表的处理统一了。</p>
<h4 id="循环链表">循环链表</h4>
<p>在单链表中，如果将终端节点的指针域由空指针改为指向头节点，形成一个环，这种头尾相接的单链表称为循环链表。</p>
<p>从循环链表中任一节点出发，可以扫描到其他节点，增加了链表操作的灵活性。</p>
<p>但由于循环链表没有明显的尾端，要格外注意循环条件。通常判断用作循环变量的工作指针是否等于头一个制定指针（头指针或尾指针）。</p>
<h4 id="双链表">双链表</h4>
<p>如果希望快速确定表中任一节点的前驱节点，可以在单链表的每个节点中再设置一个指向其前驱节点的指针域，这样就形成了双链表。</p>
<h3 id="顺序表和链表的比较">顺序表和链表的比较</h3>
<h4 id="时间性能比较">时间性能比较</h4>
<p>按位置随机访问某个元素，顺序表更快一些，时间性能为 O(1)；相比之下链表需要从头开始遍历扫描，所需要的平均时间为 O(n)。</p>
<p>在链表进行插入和删除操作不需要移动元素，在给出指向某个位置的指针后，进行插入和删除操作所需的时间仅为 O(1)；在顺序表中进行插入和删除操作需要移动表长一半的元素，平均时间为 O(n)。</p>
<p>一般规律，如果线性表需要频繁查找却很少进行插入和删除，或其操作和“数据元素在线性表中的位置密切相关时，宜采用顺序表作为存储结构；如果线性表需要频繁进行插入和删除操作，则宜采用链表作为存储结构。</p>
<h4 id="空间性能比较">空间性能比较</h4>
<p>作为一般规律，当线性表中元素个数变化较大或未知时，最好采用链表实现；如果事先知道线性表的大致长度，采用顺序表的空间效率会更高。</p>

        
        ]]>
      </description>
    </item>
    
    
    
    <item>
      <title>C&#43;&#43; 基础总结</title>
      <link>/post/2021/12/15/cppbase/</link>
      <pubDate>Wed, 15 Dec 2021 12:35:27 +0800</pubDate>
      <author>罗泽勋</author>
      <guid>/post/2021/12/15/cppbase/</guid>
      <description>
        <![CDATA[
        <h3 id="一语法基础">一、语法基础</h3>
<ul>
<li>指针和引用的概念</li>
<li>指针与内存关系</li>
<li>程序编译过程</li>
<li>static、const、#define的用法和区别</li>
<li>C和C++区别</li>
<li>内存模型</li>
<li>内存中的栈和堆分配</li>
</ul>
<h3 id="二面对对象基础">二、面对对象基础</h3>
<ul>
<li>
<p>面向对象理解</p>
</li>
<li>
<p>析构函数</p>
</li>
<li>
<p>构造函数</p>
</li>
<li>
<p>拷贝构造</p>
</li>
<li>
<p>多态</p>
</li>
<li>
<p>纯虚函数和虚函数</p>
</li>
<li>
<p>虚函数实现机制</p>
</li>
<li>
<p>虚函数表</p>
</li>
<li>
<p>访问限定符 public、private、protected</p>
</li>
<li>
<p>继承原理、虚继承、菱形继承</p>
</li>
<li>
<p>静态绑定和动态绑定</p>
</li>
<li>
<p>new/delete和malloc/free</p>
</li>
<li>
<p>重载、重写和隐藏</p>
</li>
</ul>
<h3 id="三语法进阶">三、语法进阶</h3>
<ul>
<li>智能指针</li>
<li>左值、右值引用和move语义</li>
<li>类型转换方式</li>
<li>常用的设计模式</li>
<li>线程安全的单例模式</li>
<li>内存溢出和内存泄漏</li>
<li>C++11新特性</li>
<li>静态链接库和动态链接库</li>
</ul>
<h3 id="四stl-标准模板库">四、STL 标准模板库</h3>
<ul>
<li>迭代器、空间配置器理解</li>
<li>常用容器特点、用法以及底层实现vector、list、deque、set、map、unorderedmap</li>
</ul>

        
        ]]>
      </description>
    </item>
    
    
    
    <item>
      <title>【转载】Qt6 绘制基础</title>
      <link>/post/2021/12/13/paintsystem/</link>
      <pubDate>Mon, 13 Dec 2021 21:28:59 +0800</pubDate>
      <author>罗泽勋</author>
      <guid>/post/2021/12/13/paintsystem/</guid>
      <description>
        <![CDATA[
        <h3 id="绘制系统">绘制系统</h3>
<p>Qt 的绘制系统可以使用相同的 API 在屏幕和打印设备上进行绘制，并且主要基于 QPainter 、 QPaintDevice 和 QPaintEngine 类。</p>
<p>QPainter 用于执行绘图操作， QPaintDevice 是二维空间的抽象，可以使用 进行绘制 QPainter ， QPaintEngine 提供了画家用来绘制不同类型设备的接口。 该 QPaintEngine 类是由在内部使用 了QPainter 和 的QPaintDevice ，除非他们创建自己的设备的种类从应用程序员隐藏。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2021-12-13/paintsystem.png" alt="paintsystem"></p>
<p>这种方法的主要好处是所有绘制都遵循相同的绘制管道，从而可以轻松添加对新功能的支持并为不受支持的功能提供默认实现。</p>
<h3 id="一绘图示例">一、绘图示例</h3>
<p>通常在 QWidget, QPixmap, QPixture, QPrinter 上面绘图。</p>
<h4 id="示例1-直接绘制">示例1 直接绘制：</h4>
<pre tabindex="0"><code>MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
{
    QLabel *label = new QLabel(this);
    label-&gt;resize(100, 100);

    QPixmap pixmap(100, 100);
    pixmap.fill(Qt::gray);

    QPainter painter(&amp;pixmap);
    painter.drawRect(10, 10, 80, 80);
    painter.drawText(20, 30, &quot;Hello World&quot;);

    label-&gt;setPixmap(pixmap);

    QVBoxLayout *layout = new QVBoxLayout();
    layout-&gt;addWidget(label);
    this-&gt;setLayout(layout);
    this-&gt;resize(200, 200);
}

</code></pre><p>运行结果：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2021-12-13/demo1.png" alt="demo1"></p>
<h4 id="示例2-painteventqpaintevent--函数中绘制">示例2 paintEvent(QPaintEvent *) 函数中绘制：</h4>
<pre tabindex="0"><code>void MainWindow::paintEvent(QPaintEvent *)
{
    QPainter painter(this);
    painter.setPen(Qt::gray);
    painter.setBrush(Qt::green);
    painter.drawRect(10, 10, 50, 50);
}
</code></pre><p>运行结果：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2021-12-13/demo2.png" alt="demo2"></p>
<h3 id="二坐标系">二、坐标系</h3>
<p>坐标系由 QPainter 类控制。绘图设备的默认坐标系的原点位于左上角。 该 X 值增加向右和 Y 值向下增加。 默认单位在基于像素的设备上是一个像素，在打印机上是一个点（1/72 英寸）。注意：原点在 Widget 的左上角而不是正中心，并且每个 Widget 都有自己独立的坐标系。</p>
<p>QPainter 的逻辑坐标到物理 QPaintDevice 坐标的映射由 QPainter 的转换矩阵、视口和“窗口”处理。 默认情况下，逻辑坐标系和物理坐标系是一致的。 QPainter 还支持坐标变换（例如旋转和缩放）。</p>
<h4 id="渲染-逻辑表示">渲染 逻辑表示</h4>
<p>图形基元的大小（宽度和高度）始终与其数学模型相对应，忽略绘制它的笔的宽度：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2021-12-13/coordsys.png" alt="Paint-Base-Draw-Methods"></p>
<h4 id="window-viewport-转换">Window-Viewport 转换</h4>
<p>使用 Window-Viewport 转换，您可以使逻辑坐标系适合您的偏好。 该机制还可用于使绘图代码独立于绘图设备。 例如，您可以通过调用 ，使逻辑坐标从 (-50, -50) 扩展到 (50, 50)，以 (0, 0) 为中心 QPainter::setWindow () 函数 ：</p>
<pre tabindex="0"><code>QPainter painter(this);
painter.setWindow(QRect(-50, -50, 100, 100));
</code></pre><p>现在，逻辑坐标 (-50,-50) 对应于绘制设备的物理坐标 (0, 0)。 独立于绘画设备，您的绘画代码将始终在指定的逻辑坐标上运行。</p>
<h3 id="三常用函数">三、常用函数</h3>
<p>下图来自《C++ GUI Programming with Qt 4》，列出了 QPainter 常用的画图方法。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2021-12-13/Paint-Base-Draw-Methods.png" alt="Paint-Base-Draw-Methods"></p>
<h4 id="线---drawline">线 - drawLine()</h4>
<h4 id="多线段---drawlines">多线段 - drawLines()</h4>
<h4 id="折线---drawpolyline">折线 - drawPolyline()</h4>
<h4 id="多边形---drawpolygon">多边形 - drawPolygon()</h4>
<h4 id="矩形---drawrect">矩形 - drawRect()</h4>
<h4 id="圆角矩形---drawroundrect--drawroundedrect">圆角矩形 - drawRoundRect() &amp; drawRoundedRect()</h4>
<h4 id="圆椭圆---drawellipse">圆、椭圆 - drawEllipse()</h4>
<h4 id="弧弦饼图---drawarcdrawchorddrawpie">弧、弦、饼图 - drawArc()、drawChord()、drawPie()</h4>
<h4 id="绘制-qpixmap---drawpixmap">绘制 QPixmap - drawPixmap()</h4>
<h4 id="绘制-qimage---drawimage">绘制 QImage - drawImage()</h4>

        
        ]]>
      </description>
    </item>
    
    
    
    <item>
      <title>【转载】Qt6 对象模型</title>
      <link>/post/2021/12/13/object/</link>
      <pubDate>Mon, 13 Dec 2021 08:08:17 +0800</pubDate>
      <author>罗泽勋</author>
      <guid>/post/2021/12/13/object/</guid>
      <description>
        <![CDATA[
        <h3 id="对象模型">对象模型</h3>
<p>标准的 C++ 对象模型为对象范例提供了非常有效的运行时支持。 但是它的静态特性在某些问题领域是不灵活的。 图形用户界面编程是一个需要运行时效率和高度灵活性的领域。 Qt 通过将 C++ 的速度与 Qt 对象模型的灵活性相结合来提供这一点。</p>
<p>Qt 将这些特性添加到 C++ 中：</p>
<blockquote>
<p>一种非常强大的无缝对象通信机制，称为 信号和槽
可查询和可设计的 对象属性
强大的 事件和事件过滤器
上下文 用于国际化的 字符串翻译
复杂的间隔驱动 计时器 ，可以在事件驱动的 GUI 中优雅地集成许多任务
分层和可查询 对象树 以自然方式组织对象所有权的
受保护的指针 ( QPointer ) 在引用的对象被销毁时自动设置为 0，这与普通的 C++ 指针不同，后者在对象被销毁时变成悬空指针
动态转换 跨库边界 。
支持 自定义类型 创建。</p>
</blockquote>
<p>许多 Qt 功能是使用标准 C++ 技术实现的，基于 继承 QObject 的 。 其他的，比如对象通信机制和动态属性系统，需要 的 元对象系统 Qt自己的 提供 元对象编译器（moc） 。</p>
<p>元对象系统是一个 C++ 扩展，使该语言更适合真正的组件 GUI 编程。</p>
<h3 id="重要类">重要类</h3>
<p>这些类构成了 Qt 对象模型的基础。</p>
<h3 id="qt-对象身份与价值">Qt 对象：身份与价值</h3>
<p>上面为 Qt 对象模型列出的一些附加功能要求我们将 Qt 对象视为身份，而不是值。 值被复制或分配； 身份被克隆。 克隆意味着创建一个新身份，而不是旧身份的精确副本。 例如，双胞胎有不同的身份。 它们可能看起来相同，但名称不同，位置不同，并且可能拥有完全不同的社交网络。</p>
<p>那么克隆身份是比复制或分配值更复杂的操作。 我们可以在 Qt 对象模型中看到这意味着什么。</p>
<p>一个 Qt 对象&hellip;</p>
<blockquote>
<p>可能有一个唯一的 QObject::objectName ()。 如果我们复制一个 Qt 对象，我们应该给副本起什么名字？
在 有一个位置 对象层次结构中 。 如果我们复制一个 Qt 对象，该副本应该位于何处？
可以连接到其他 Qt 对象以向它们发出信号或接收它们发出的信号。 如果我们复制一个 Qt 对象，我们应该如何将这些连接转移到副本？
可以 新属性 在运行时向其添加未在 C++ 类中声明的 。 如果我们复制一个 Qt 对象，该副本是否应该包括添加到原始对象的属性？</p>
</blockquote>
<p>由于这些原因，Qt 对象应该被视为身份，而不是值。 身份是克隆的，而不是复制或分配的，克隆身份是比复制或分配值更复杂的操作。 因此， QObject的 和所有子类 的QObject （直接或间接）有自己的 拷贝构造函数和赋值操作符 禁用。</p>

        
        ]]>
      </description>
    </item>
    
    
    
    <item>
      <title>【转载】Qt 6 核心内部结构</title>
      <link>/post/2021/12/13/qt-core/</link>
      <pubDate>Mon, 13 Dec 2021 08:00:25 +0800</pubDate>
      <author>罗泽勋</author>
      <guid>/post/2021/12/13/qt-core/</guid>
      <description>
        <![CDATA[
        <p>Qt 包含一组丰富的基础使能器，主要来自 Qt Core 模块。 Qt 使用这些促成因素来提供更高级别的 UI 和应用程序开发组件。 以下主题解释了最重要的促成因素，并展示了如何使用它们来实现 Qt 尚未提供的专门功能。</p>
<h3 id="对象属性和事件">对象、属性和事件</h3>
<p>该 QObject的 类构成Qt的对象模型的基础，是父类的许多Qt类的。 对象模型引入了许多机制，例如元对象系统，它允许运行时内省、操作和调用对象中的属性和方法。 它还作为 Qt 事件系统的基础，这是一种在 之间进行通信的低级方式 QObject 基于 的对象 。 Qt 的信号和槽机制提供了另一种高级通信形式。</p>
<p>另外， QObject 通过 提供了一个简单的计时机制 QObject::startTimer () 。 或者， QTimer 类为计时器提供高级接口。</p>
<blockquote>
<p>对象模型<br>
元对象系统<br>
物业系统<br>
事件系统<br>
信号和插槽<br>
—— 基于字符串和基于函子的连接之间的差异<br>
计时器</p>
</blockquote>
<h3 id="容器类">容器类</h3>
<p>容器 是一种数据结构，其实例是其他对象的集合。 容器的一些示例是：动态数组、队列、链表和关联数组。 Qt 提供了一组通用的、基于模板的容器类，用于在内存中构造数据。</p>
<p>有关 请参阅 的完整列表 容器类 更多详细信息， 。</p>
<h3 id="国际化">国际化</h3>
<p>Qt 使用 Unicode 来编码可显示的文本字符串。 Unicode 为世界上所有常用的书写系统提供支持，是跨平台开发的理想选择。 还可以使用 Qt 强大的国际化系统编写应用程序，以通过一个代码库支持任意数量的不同语言。</p>
<blockquote>
<p>Qt 中的 Unicode
Qt 国际化</p>
</blockquote>
<h3 id="进程间通信">进程间通信</h3>
<p>Qt 提供了几个类来支持进程之间的通信。 您还可以使用 启动和管理外部进程 QProcess 类 。</p>
<blockquote>
<p>Qt中的进程间通信</p>
</blockquote>
<h3 id="线程">线程</h3>
<p>Qt 提供了以安全且独立于平台的方式管理线程和并行代码的功能。</p>
<blockquote>
<p>线程基础
Qt 中的线程支持</p>
</blockquote>
<h3 id="平台支持">平台支持</h3>
<p>Qt 允许您编写独立于平台的代码，其中相同的代码库可以在不同平台上编译和部署，而无需任何更改。 如果您需要使用特定于平台的功能并与系统库集成，Qt 也为此提供了解决方案。</p>
<p>Qt 使用 Qt Platform Abstraction (QPA) 与目标平台上的窗口系统集成。 QPA 是窗口系统的抽象，它使得将 Qt 移植到新平台变得简单快捷。 其中一种系统是 Wayland 协议。 Qt 可以与 Wayland 一起用作嵌入式硬件上的轻量级窗口系统，以支持多进程图形用户界面。</p>
<p>Qt 平台抽象使用 Qt 的插件系统。 该插件系统提供 API 以在特定领域扩展 Qt（例如添加对新图像格式、数据库驱动程序等的支持）以及编写您自己的支持第三方插件的可扩展 Qt 应用程序。</p>
<blockquote>
<p>Qt平台抽象
实现原子操作 - 用于新架构
如何创建 Qt 插件
Endian Conversion Functions - 用于处理来自 QtEndian 头文件的字节序的函数</p>
</blockquote>

        
        ]]>
      </description>
    </item>
    
    
    
    <item>
      <title>【转载】Qt6 Qvariant 与自定义 Qt 类型</title>
      <link>/post/2021/12/13/qvariant/</link>
      <pubDate>Mon, 13 Dec 2021 07:29:55 +0800</pubDate>
      <author>罗泽勋</author>
      <guid>/post/2021/12/13/qvariant/</guid>
      <description>
        <![CDATA[
        <h3 id="概述">概述</h3>
<p>在本文档中，我们采用自定义类型并描述如何将其集成到 Qt 的对象模型中，以便可以像标准 Qt 类型一样存储它。 然后我们展示如何注册自定义类型以允许它在信号和插槽连接中使用。</p>
<h3 id="创建自定义类型">创建自定义类型</h3>
<p>在开始之前，我们需要确保我们正在创建的自定义类型满足 QMetaType 强加的所有要求。换言之，它必须提供：</p>
<blockquote>
<p>公共默认构造函数 <br>
公共复制构造函数<br>
公共析构函数</p>
</blockquote>
<p>下列 Message类定义包括以下成员：</p>
<pre tabindex="0"><code>class Message
{
public:
    Message() = default;
    ~Message() = default;
    Message(const Message &amp;) = default;
    Message &amp;operator=(const Message &amp;) = default;

    Message(const QString &amp;body, const QStringList &amp;headers);

    QStringView body() const;
    QStringList headers() const;

private:
    QString m_body;
    QStringList m_headers;
};
</code></pre><p>该类还提供了一个正常使用的构造函数和两个用于获取私有数据的公共成员函数。</p>
<h3 id="使用-qmetatype-声明类型">使用 QMetaType 声明类型</h3>
<p>这 Message类只需要一个合适的实现即可使用。 但是，如果没有一些帮助，Qt 的类型系统将无法理解如何存储、检索和序列化此类的实例。 例如，我们将无法存储 Message值 QVariant 中的 。</p>
<p>Qt 中负责自定义类型的类是 QMetaType 。 为了让这个类知道类型，我们在定义它的头文件中的类上 添加 Q_DECLARE_METATYPE() 宏：</p>
<pre tabindex="0"><code>Q_DECLARE_METATYPE(Message);
</code></pre><p>这使得现在有可能 Message要存储在 QVariant 对象中并稍后检索的值。 有关 请参阅 自定义类型示例 演示此内容的代码， 。</p>
<p>所述 Q_DECLARE_METATYPE （）宏还使得可以对这些值用作到信号，但是参数 只在直接信号槽连接 。 为了使自定义类型通常可用于信号和插槽机制，我们需要执行一些额外的工作。</p>
<h3 id="创建和销毁自定义对象">创建和销毁自定义对象</h3>
<p>尽管上一节中的声明使该类型可用于直接信号槽连接，但它不能用于排队的信号槽连接，例如在不同线程中的对象之间建立的连接。 这是因为元对象系统不知道如何在运行时处理自定义类型对象的创建和销毁。</p>
<p>要在运行时创建对象，请调用 qRegisterMetaType () 模板函数将其注册到元对象系统。 这也使得该类型可用于排队的信号槽通信，只要您在使用该类型的第一个连接之前调用它。</p>
<pre tabindex="0"><code>int main(int argc, char *argv[])
{
    QApplication app(argc, argv);
    ...
    qRegisterMetaType&lt;Block&gt;();
    ...
    return app.exec();
}
</code></pre><p>这种类型后来用于信号槽连接中 window.cpp文件：</p>
<pre tabindex="0"><code>Window::Window(QWidget *parent)
    : QWidget(parent), thread(new RenderThread(this))
{
    ...
    connect(thread, &amp;RenderThread::sendBlock,
            this, &amp;Window::addBlock);
    ...
    setWindowTitle(tr(&quot;Queued Custom Type&quot;));
}
</code></pre><p>如果一个类型在没有注册的情况下在排队连接中使用，控制台会打印警告； 例如：</p>
<pre tabindex="0"><code>QObject::connect: Cannot queue arguments of type 'Block'
(Make sure 'Block' is registered using qRegisterMetaType().)
</code></pre><h3 id="使类型可打印">使类型可打印</h3>
<p>为调试目的使自定义类型可打印通常非常有用，如下面的代码所示：</p>
<pre tabindex="0"><code>    Message message(body, headers);
    qDebug() &lt;&lt; &quot;Original:&quot; &lt;&lt; message;
</code></pre><p>这是通过为该类型创建一个流操作符来实现的，该操作符通常在该类型的头文件中定义：</p>
<pre tabindex="0"><code>QDebug operator&lt;&lt;(QDebug dbg, const Message &amp;message);
</code></pre><p>实现：</p>
<pre tabindex="0"><code>QDebug operator&lt;&lt;(QDebug dbg, const Message &amp;message)
{
    QList&lt;QStringView&gt; pieces = message.body().split(u&quot;\r\n&quot;, Qt::SkipEmptyParts);
    if (pieces.isEmpty())
        dbg.nospace() &lt;&lt; &quot;Message()&quot;;
    else if (pieces.size() == 1)
        dbg.nospace() &lt;&lt; &quot;Message(&quot; &lt;&lt; pieces.first() &lt;&lt; &quot;)&quot;;
    else
        dbg.nospace() &lt;&lt; &quot;Message(&quot; &lt;&lt; pieces.first() &lt;&lt; &quot; ...)&quot;;
    return dbg.maybeSpace();
}
</code></pre><p>当然，发送到调试流的输出可以根据您的喜好变得简单或复杂。 请注意，此函数返回的值是 QDebug 对象本身，尽管这通常是通过调用 获得的，该 QDebug 的 maySpace () 成员函数 函数 填充 用空格字符 流以使其更具可读性。</p>

        
        ]]>
      </description>
    </item>
    
    
    
    <item>
      <title>【转载】Qt6 顺序容器 QList</title>
      <link>/post/2021/12/02/qlist/</link>
      <pubDate>Thu, 02 Dec 2021 12:41:29 +0800</pubDate>
      <author>罗泽勋</author>
      <guid>/post/2021/12/02/qlist/</guid>
      <description>
        <![CDATA[
        <h3 id="介绍">介绍</h3>
<p>QList 类是提供动态数组的模板类。该类中的所有函数都是可重入的。另外两个常用的顺序容器 QStack 和 QQueue 继承自 Qlist。</p>
<h3 id="详细说明">详细说明</h3>
<p>QList<T> 是 Qt 的通用容器类之一。它将其项目存储在相邻的内存位置，并提供基于索引的快速访问。QVector <T> 在 Qt 5 中曾经是一个不同的类，但现在是 QList 的一个简单别名。</p>
<p>QList<T> 和QVarLengthArray <T> 提供类似的 API 和功能。它们通常可以互换，但会产生性能后果。以下是用例的概述：</p>
<ul>
<li>QList 应该是您的默认首选。</li>
<li>QVarLengthArray提供了一个在堆栈上保留空间的数组，但如果需要，可以动态地增长到堆上。用于通常较小的短寿命容器是很好的。</li>
<li>如果您需要一个真正的链表，它保证在列表中间插入恒定时间并使用迭代器到项目而不是索引，请使用 std::list。</li>
</ul>

        
        ]]>
      </description>
    </item>
    
    
    
    <item>
      <title>【转载】Qt6 隐式共享</title>
      <link>/post/2021/12/01/implicit-sharing/</link>
      <pubDate>Wed, 01 Dec 2021 22:48:45 +0800</pubDate>
      <author>罗泽勋</author>
      <guid>/post/2021/12/01/implicit-sharing/</guid>
      <description>
        <![CDATA[
        <p>Qt 中的许多 C++ 类使用隐式数据共享来最大化资源使用并最小化复制。当作为参数传递时，隐式共享类既安全又高效，因为只有一个指向数据的指针被传递，并且只有当函数写入数据时才会复制数据，即copy-on-write。</p>
<h3 id="概述">概述</h3>
<p>共享类由指向共享数据块的指针组成，该共享数据块包含引用计数和数据。</p>
<p>创建共享对象时，它将引用计数设置为 1。只要新对象引用共享数据，引用计数就会增加，而当对象取消引用共享数据时，引用计数会减少。当引用计数变为零时，共享数据将被删除。</p>
<p>在处理共享对象时，有两种方法可以复制对象。我们通常谈论深拷贝和浅拷贝。深拷贝意味着复制一个对象。浅拷贝是引用拷贝，即只是指向共享数据块的指针。就内存和 CPU 而言，进行深度复制的成本可能很高。制作浅拷贝非常快，因为它只涉及设置一个指针和增加引用计数。</p>
<p>隐式共享对象的对象分配（使用 operator=()）是使用浅拷贝实现的。</p>
<p>共享的好处是程序不需要不必要地复制数据，从而减少内存使用和数据复制。对象可以很容易地被赋值，作为函数参数发送，并从函数中返回。</p>
<p>隐式共享大多发生在幕后；程序员很少需要担心它。但是，Qt 的容器迭代器与 STL 的容器迭代器具有不同的行为。阅读隐式共享迭代器问题。</p>
<p>在多线程应用程序中，会发生隐式共享，如线程和隐式共享类中所述。</p>
<p>在实现您自己的隐式共享类时，请使用QSharedData和QSharedDataPointer类。</p>
<h3 id="详细的隐式共享">详细的隐式共享</h3>
<p>如果对象即将更改并且引用计数大于 1，则隐式共享会自动将对象从共享块中分离。（这通常称为 copy-on-write 或者 value semantics。）</p>
<p>隐式共享类可以控制其内部数据。在任何修改其数据的成员函数中，它会在修改数据之前自动分离。但是，请注意容器迭代器的特殊情况；请参阅隐式共享迭代器问题。</p>
<blockquote>
<p>警告：在使用STL 样式的迭代器时，请小心复制隐式共享容器（QMap、QList等）。请参阅隐式共享迭代器问题。</p>
</blockquote>
<h3 id="示例">示例</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++">QPixmap p1, p2;
p1.load(<span style="color:#e6db74">&#34;image.bmp&#34;</span>);
p2 <span style="color:#f92672">=</span> p1;                        <span style="color:#75715e">// p1 and p2 share data
</span><span style="color:#75715e"></span>
QPainter paint;
paint.begin(<span style="color:#f92672">&amp;</span>p2);               <span style="color:#75715e">// cuts p2 loose from p1
</span><span style="color:#75715e"></span>paint.drawText(<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">50</span>, <span style="color:#e6db74">&#34;Hi&#34;</span>);
paint.end();
</code></pre></div><p>在这个例子中，p1 和 p2 共享数据，直到了 p2 被 QPainter::begin() 调用，因为画像素图将修改它。</p>
<h3 id="所有隐式共享的类">所有隐式共享的类</h3>
<p>参见 <a href="https://doc.qt.io/qt-6/implicit-sharing.html">Qt 文档</a>。</p>

        
        ]]>
      </description>
    </item>
    
    
    
    <item>
      <title>【转载】Qt6 容器类-概述</title>
      <link>/post/2021/12/01/qt-containers/</link>
      <pubDate>Wed, 01 Dec 2021 22:05:26 +0800</pubDate>
      <author>罗泽勋</author>
      <guid>/post/2021/12/01/qt-containers/</guid>
      <description>
        <![CDATA[
        <h3 id="介绍">介绍</h3>
<p>Qt 库提供了一组通用的基于模板的容器类。这些类可用于存储制定类型的项。例如，您需要一个可调整大小的 QString 数组，请使用 QList<QString>。</p>
<p>这些容器类被设计为比 STL 容器更轻、更安全且更易于使用。如果您不熟悉 STL，或者更喜欢“Qt 方式”实现，您可以使用这些类而不是 STL 类。</p>
<p>容器类是 <a href="/post/2021/12/01/implicit-sharing/">隐式共享的</a>，它们是可重入的，并且它们针对速度、低内存消耗和最小的内联代码扩展进行了优化，从而产生更小的可执行文件。此外，在所有用于访问它们的线程将它们用作只读容器的情况下，它们是线程安全的。</p>
<p>容器提供了遍历的迭代器。STL 样式的迭代器是最有效的迭代器，可以与 Qt 和 STL 的通用算法一起使用。提供 Java 风格的迭代器是为了向后兼容。</p>
<h3 id="容器类">容器类</h3>
<p>Qt 提供以下顺序容器：QList、QStack 和 QQueue。对于大多数应用程序，QList 是最好的类型。它提供了非常快速的追加。如果您确实需要链表，请使用 std::list。QStack 和 QQueue 是提供 LIFO 和 FIFO 语义的便利类。QList和QVector在 Qt 6 中被统一。两者都使用来自QVector的数据模型。QVector现在是QList的别名。</p>
<p>Qt 还提供了这些关联容器：QMap、QMultiMap、QHash、QMultiHash和QSet。“Multi”容器方便地支持与单个键关联的多个值。“散列”容器通过使用散列函数而不是对排序集的二分搜索来提供更快的查找。</p>
<p>作为特殊情况，QCache 和 QContiguousCache 类在有限的缓存存储中提供了有效的对象散列查找。</p>
<table>
<thead>
<tr>
<th>类</th>
<th>简述</th>
</tr>
</thead>
<tbody>
<tr>
<td>QList <T></td>
<td>这是迄今为止最常用的容器类。它存储可以通过索引访问的给定类型 (T) 的值列表。在内部，它在内存中的相邻位置存储一组给定类型的值。在列表的前面或中间插入可能会很慢，因为它可能导致大量项目必须在内存中移动一个位置。</td>
</tr>
<tr>
<td>QVarLengthArray &lt;T, Prealloc &gt;</td>
<td>这提供了一个低级的可变长度数组。在速度特别重要的地方，它可以代替QList使用。</td>
</tr>
<tr>
<td>QStack <T></td>
<td>这是QList 的一个便利子类，提供“后进先出”(LIFO) 语义。它向QList 中已有的函数添加了以下函数：push ()、pop () 和top ()。</td>
</tr>
<tr>
<td>QQueue <T></td>
<td>这是QList的便利子类，提供“先进先出”(FIFO) 语义。它将以下函数添加到QList 中已经存在的函数中：enqueue ()、dequeue () 和head ()。</td>
</tr>
<tr>
<td>QSet <T></td>
<td>这提供了具有快速查找功能的单值数学集。</td>
</tr>
<tr>
<td>QMap &lt;Key, T&gt;</td>
<td>这提供了一个字典（关联数组），将 Key 类型的键映射到 T 类型的值。通常每个键都与单个值相关联。QMap以 Key 顺序存储其数据；如果顺序无关紧要QHash是一个更快的选择。</td>
</tr>
<tr>
<td>QMultiMap &lt;Key, T&gt;</td>
<td>这是QMap 的一个方便的子类，它为多值映射提供了一个很好的接口，即一个键可以与多个值相关联的映射。</td>
</tr>
<tr>
<td>QHash &lt;Key, T&gt;</td>
<td>这与QMap具有几乎相同的 API ，但提供了明显更快的查找。QHash以任意顺序存储其数据。</td>
</tr>
<tr>
<td>QMultiHash &lt;Key, T&gt;</td>
<td>这是QHash 的一个便利子类，它为多值散列提供了一个很好的接口。</td>
</tr>
</tbody>
</table>
<h3 id="算法复杂性">算法复杂性</h3>
<p>下表总结了顺序容器 QList 的算法复杂度。</p>
<table>
<thead>
<tr>
<th></th>
<th>索引查找</th>
<th>插入</th>
<th>前置</th>
<th>附加</th>
</tr>
</thead>
<tbody>
<tr>
<td>QList <T></td>
<td>O(1)</td>
<td>O(n)</td>
<td>O(n)</td>
<td>Amort.O(1)</td>
</tr>
</tbody>
</table>
<blockquote>
<p>在表中，“Amort.”代表“摊销行为”。例如，“Amort.O(1)”意味着如果你只调用一次函数，你可能会得到 O(n) 的行为，但如果你多次调用它（例如，n 次），平均行为将是 O(1)。</p>
</blockquote>
<p>下表总结了 Qt 的关联容器和集合的算法复杂度：</p>
<table>
<thead>
<tr>
<th></th>
<th>键查找-平均数</th>
<th>键查找-最差的情况</th>
<th>插入-平均数</th>
<th>插入-最差的情况</th>
</tr>
</thead>
<tbody>
<tr>
<td>QMap&lt;Key, T&gt;</td>
<td>O(log n )</td>
<td>O(log n )</td>
<td>O(log n )</td>
<td>O(log n )</td>
</tr>
<tr>
<td>QMultiMap&lt;Key, T&gt;</td>
<td>O(log n )</td>
<td>O(log n )</td>
<td>O(log n )</td>
<td>O(log n )</td>
</tr>
<tr>
<td>QHash&lt;Key, T&gt;</td>
<td>Amort.O(1)</td>
<td>O( n )</td>
<td>Amort.O(1)</td>
<td>O( n )</td>
</tr>
<tr>
<td>QSet<Key></td>
<td>Amort.O(1)</td>
<td>O( n )</td>
<td>Amort.O(1)</td>
<td>O( n )</td>
</tr>
</tbody>
</table>

        
        ]]>
      </description>
    </item>
    
    
    
    <item>
      <title>修改菜单栏和文章创作</title>
      <link>/post/2021/11/18/%E4%BF%AE%E6%94%B9%E8%8F%9C%E5%8D%95%E6%A0%8F%E5%92%8C%E6%96%87%E7%AB%A0%E5%88%9B%E4%BD%9C/</link>
      <pubDate>Thu, 18 Nov 2021 18:36:33 +0800</pubDate>
      <author>罗泽勋</author>
      <guid>/post/2021/11/18/%E4%BF%AE%E6%94%B9%E8%8F%9C%E5%8D%95%E6%A0%8F%E5%92%8C%E6%96%87%E7%AB%A0%E5%88%9B%E4%BD%9C/</guid>
      <description>
        <![CDATA[
        <h3 id="前情提要">前情提要</h3>
<p>完成前面的工作后，我们的网站是下图这样的，非常符合极简之美。不过空荡荡的网站不是我们想要的，接下来我们就开始最核心的部分：修改网站内容。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2021-11-18/0.png" alt="img"></p>
<h3 id="一准备文本编辑工具">一、准备文本编辑工具</h3>
<p>（1）下载文本编辑工具。创作当然离不开文本的编辑，那么一款高效好用的文本编辑工具就非常重要了。这里我强烈推荐一个常用的工具 Visual Studio Code，它可以多文件管理。点击 <a href="https://code.visualstudio.com/Download">https://code.visualstudio.com/Download</a> 可以直达官网下载。接下来的讲述会使用到 VSCode，如果你选择其他文本编辑器，也无妨，找到对应的文件修改即可。</p>
<p>（2）用 VSCode 打开 blog 文件夹。打开 VSCode 后，点击左上角文件菜单，然后点击打开文件夹，选择 D:/hugo/site/blog 文件夹。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2021-11-18/1.png" alt="img"></p>
<p>（3）我们需要关注 content 文件夹、public 文件夹和 config.yaml 文件即可。content 存放网站的所有内容，我们平时写文章会在里面创建；public 存放网站的源代码，我们使用 hugo 命令时它会自动生成，我们需要将它上传到 Github ；config.yaml 是网站的配置文件，我们网站的基本信息都会在里面配置。</p>
<h3 id="二网站预览">二、网站预览</h3>
<p>用命令窗口进入网站 blog 根目录，执行 <code>hugo server</code>。打开浏览器，访问 localhost:1313。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2021-11-17/11.png" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2021-11-17/12.png" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2021-11-17/10.png" alt="img"></p>
<h3 id="三创建菜单栏">三、创建菜单栏</h3>
<p>可以看到我们的网站现在有五个菜单，如果你前面在网站配置把菜单改成中文的话，那么将是[主页]、[关于]、[分类]、[标签]、[订阅]。[主页]不用多说了，[分类]、[标签]、[订阅]是自动管理的，如果不需要的话可以在网站目录的 config.yaml 里删掉，[关于]现在点击的话，是访问不了的，因为我们还没有创建对应的文件夹或文件。</p>
<p>（1）打开 themes/hugo-ivy/exampleSite 文件夹，这是 hugo-ivy 主题作者提供的示例网站。复制其中的 content 文件夹下的所有文件和文件夹，放到我们网站根目录下的 content文件夹下面。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2021-11-18/2.png" alt="img"></p>
<p>（2）修改 config.yaml 文件，添加文章和记录两个菜单。对应的文件夹是 post 和 note。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2021-11-18/3.png" alt="img"></p>
<p>（3）这样，再回到浏览器上看。因为我们把示例的文章也复制过来了，所以网站已经有文章显示了。而我们添加的[文章]和[记录]文章也完成了。如果你需要添加其他菜单，可以参考现有的：在 content 文件夹下新建文件夹，然后在 config.yaml 文件中添加修改。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2021-11-18/4.png" alt="img"></p>
<h3 id="四新建文章">四、新建文章</h3>
<p>我们可以复制 content/post 或者 content/note 下的文件，然后修改里面的标题、作者、日期、分类、标签等等，因为我们使用 hugo server 预览网站，所以可以在浏览器上 localhost:1313 实时查看修改后的效果。不过更常见的做法是通过命令的方式来创建，下面演示在[文章]菜单下创建一篇文章。</p>
<p>（1）同样，在重新打开一个 cmd 命令窗口，进入网站根目录（blog)。和之前的做法一样这里就不贴图片了。</p>
<p>(2)执行 <code>hugo new post/2021-11-18.md</code> 命令，post 是存放的目标文件夹，2021-11-18.md 是将要生成的文件，文件名可以随意，注意不要使用中文。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2021-11-18/5.png" alt="img"></p>
<p>(3)在 VSCode 里面修改文件内容。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2021-11-18/6.png" alt="img"></p>
<h3 id="五推送到-github-平台">五、推送到 Github 平台</h3>
<p>（1）在 cmd 窗口，在网站根目录（blog）下先执行 <code>hugo</code> 生成网站源代码到 public 目录，然后执行 <code>cd pulic</code> 进入 public 目录。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2021-11-18/7.png" alt="img"></p>
<p>（2）分别执行 <code>git add .</code> 和 <code>git commit -m &quot;update&quot;</code> 和 <code>git push</code>完成上传。</p>
<h3 id="六完成">六、完成</h3>
<p>上传成功后，等一小会就可以通过 “你的 github 用户名.github.io” 域名访问你的网站啦。到这里，最基本的流程已经走完了，现在可以开始自行探索了！当然，还有很多内容会在后续补充，本系列教程仍存在不足的地方，如果你遇到问题可以联系我。祝愉快~</p>

        
        ]]>
      </description>
    </item>
    
    
    
    <item>
      <title>搭建</title>
      <link>/post/2021/11/17/%E6%90%AD%E5%BB%BA/</link>
      <pubDate>Wed, 17 Nov 2021 19:38:06 +0800</pubDate>
      <author>罗泽勋</author>
      <guid>/post/2021/11/17/%E6%90%AD%E5%BB%BA/</guid>
      <description>
        <![CDATA[
        <h3 id="一在本地创建网站">一、在本地创建网站</h3>
<p>（1）使用 Hugo 建立网站。打开命令窗口，进入 D:\hugo\site 目录（便捷方法：在文件资源管理器中进入相应目录，单击地址栏右边空白地方，在最左边输入 <code>cmd </code> 加空格，回车。这样打开命令窗口的同时，进入了相应的目录），执行命令 <code>hugo new site blog</code> ，如出现 Congratulations! 提示则成功。（此时可在文件资源管理器中查看生成的文件，blog 是任意取的一个文件夹名字，但为了方便教程工作，请统一）</p>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2021-11-17/1.png" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2021-11-17/2.png" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2021-11-17/3.png" alt="img"></p>
<h3 id="二下载主题模板以-hugo-ivy-为例">二、下载主题模板（以 hugo-ivy ）为例</h3>
<p>（1）接着回到刚刚的命令窗口，输入执行 <code>cd blog\themes</code> 进入 themes 目录。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2021-11-17/4.png" alt="img"></p>
<p>（2）下载主题模板（ hugo-ivy ）。接上述步骤，在命令窗口中 执行 <code>git clone https://github.com/yihui/hugo-ivy.git</code> 来下载 hugo.386 主题。下载完成后，blog/themes 文件夹里面就可以看到下载好的主题了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2021-11-17/6.png" alt="img"></p>
<h3 id="三修改网站配置">三、修改网站配置</h3>
<p>将 themes/hugo-ivy/exampleSite 文件夹中的 config.yaml 文件复制到文件夹 blog 下，并删除原有的 config.toml 。用记事本或者其他文本编辑工具，根据需要修改相应的内容。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2021-11-17/7.png" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2021-11-17/8.png" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2021-11-17/9.png" alt="img"></p>
<h3 id="四网站本地预览">四、网站本地预览</h3>
<p>用命令窗口进入 blog 目录，先执行 <code>hugo</code> 生成网页文件，再执行 <code>hugo server</code> 开启预览。打开浏览器，访问 localhost:1313 。（注意，这个命令窗口需要保持到你不需要预览网站的时候，届时可以用两次 Ctrl + c 停止，或者直接关闭窗口）</p>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2021-11-17/11.png" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2021-11-17/12.png" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2021-11-17/10.png" alt="img"></p>
<h3 id="五将网站推送到-github-平台">五、将网站推送到 Github 平台</h3>
<p>（2）打开命令窗口，进入 blog\public 目录，分别执行</p>
<pre tabindex="0"><code>git init 
git add .
git commit -m &quot;first commit&quot;
git remote add origin https://github.com/你的Github名字/你的Github名字.github.io.git
git push --set-upstream origin master
</code></pre><p>输入 Github 账号名，密码，完成上传。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2021-11-17/13.png" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2021-11-17/14.png" alt="img"></p>
<p>（3）测试。访问 github.com 网站，在你之前创建的仓库可以看到刚刚上传的文件。访问提供的 <code>https://你的Github账户名.github.io</code> 访问你的网站，如果没有之前预览的网页，可以等待一会再刷新。</p>

        
        ]]>
      </description>
    </item>
    
    
    
    <item>
      <title>准备工作</title>
      <link>/post/2021/11/15/%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/</link>
      <pubDate>Mon, 15 Nov 2021 12:26:45 +0800</pubDate>
      <author>罗泽勋</author>
      <guid>/post/2021/11/15/%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/</guid>
      <description>
        <![CDATA[
        <h3 id="一注册-github-帐号">一、注册 Github 帐号</h3>
<p>（1）.前往 <a href="https://github.com/">github.com</a> 注册一个帐号。（注意：慎重考虑注册的用户名，如果你不购买别的域名，这个用户名将是你网站域名的一部分）</p>
<p>（2）在 Github 中创建一个名为 你的仓库名字.github.io 的仓库。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2021-11-15/-2.png" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2021-11-15/-1.png" alt="img"></p>
<h3 id="二安装-git">二、安装 Git</h3>
<p>（1）下载安装。前往 <a href="https://git-scm.com/download/win" target="_blank">这里</a> ，点击下载 Git-**-64-bit.exe。然后安装，不懂的话一直 next 。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2021-11-15/0.png" alt="img"></p>
<p>（2）配置。在 win10 搜索 cmd ，打开命令提示符，输入 <code>git config --global user.email &quot;你注册Github所用的邮箱&quot;</code> 回车执行，再输入 <code>git config --global user.name &quot;你的昵称&quot;</code> 回车执行。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2021-11-15/1.png" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2021-11-15/2.png" alt="img"></p>
<p>注意：这种方式打开命令窗口会默认进入 C 盘的用户目录。如果需要切换到其他目录，比如我们后面所用的 <code>D:/hugo/site/blog</code> 目录，则需要先执行 <code>D:</code> 切换盘符，然后执行 <code>cd hugo/site/blog</code>，其中 <code>cd</code> 就是进入目录的命令，后面是需要进入的文件夹，有时候我们需要返回上一层目录，则可以执行 <code>cd ..</code> 来完成。后面会有相关操作。</p>
<h3 id="三安装-hugo">三、安装 Hugo</h3>
<p>（1）首先在 D 盘创建一个新文件夹 hugo，然后在里面创建 bin 和 site 两个文件夹。bin 将用来放 Hugo 的可执行文件，site 将用来放你的网站的源代码。</p>
<p>（2）前往<a href="https://github.com/spf13/hugo/releases">https://github.com/spf13/hugo/releases</a>，找到并下载 hugo_<em><em>Windows-64bit.zip。解压，如果是一个 hugo</em></em>_windows_amd64.exe 文件，将它改名为 hugo.exe。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2021-11-15/3.png" alt="img"></p>
<p>（3）将这个 hugo.exe 文件移动到刚刚创建的 bin 文件夹里。</p>
<p>（4）配置环境变量。在 win10 搜索环境变量，进去找到系统变量中的 Path，双击编辑，在弹出的界面点新建，然后将 <code>D:\hugo\bin</code> 复制进去，最后连续确定。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2021-11-15/4.png" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2021-11-15/5.png" alt="img"></p>
<p>（5）验证。重新打开命令窗口（关闭上一步骤使用的），输入执行 <code>hugo help</code>，如果你能看到下图所示的 Hugo 帮助文档，就证明配置成功，否则重新执行上一步骤。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2021-11-15/6.png" alt="img"></p>

        
        ]]>
      </description>
    </item>
    
    
    
    <item>
      <title>基础概念</title>
      <link>/post/2021/11/14/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</link>
      <pubDate>Sun, 14 Nov 2021 20:57:13 +0800</pubDate>
      <author>罗泽勋</author>
      <guid>/post/2021/11/14/%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</guid>
      <description>
        <![CDATA[
        <p>教程开始前，先来介绍一下最终的成果，以便确认是否符合你的需求。本篇教程以 Hugo 和 Github Pages 为基础，创建一个静态的网站。这个过程仅需要一台联网的电脑，不需要其他花费（注意：如果你想自定义域名，则需要自行购买域名，后面会有相关介绍）。下文提到的概念理论只需要有一个模糊的认识就足够了，不需要理解透彻，因为在后续文章中会具体介绍其用法，届时就会有更直观的认识了。</p>
<p>Hugo 和 Github Pages 稍后会介绍，我们先来了解什么是静态网站。静态网站是由静态网页文件（也就是HTML文件)组成，它不需要服务器运行，也不需要数据库。我们将组成网站的这些网页文件上传到服务器上，别人就可以在互联网上通过这台服务器的地址或域名（例如 <a href="http://www.lzxqaq.com">www.lzxqaq.com</a>)访问这些网页文件，这就是静态网站的大致原理。</p>
<p>不过，这里所说的服务器并非我们日常所用的电脑，因为我们日常所用的电脑都是在局域网里，是不能让整个互联网的人都能访问到的。所以一般都要用所谓的云服务器，例如阿里云服务器、华为云服务器等等。不过现在有一些平台提供了免费的站点服务，我们就不需要购买昂贵的服务器了。例如本教程中使用的 Github Pages 服务，我们可以将网站托管到 Github 平台上，让平台帮我们把网站跑起来并在互联网上可以访问。</p>
<p>这里提到的 Github 是一个代码托管平台，也是全世界最大的开源社区。在本教程中，我们只需要知道，它是帮我们帮网站跑起来的就行了。我们在自己的电脑上创建网站，然后将这些网页文件上传到 Github 平台，而 Github 会帮我们运行网站，这样网站就可以访问了。另外，我们还需要在 Github 下载网站主题（这会在后续介绍）。如何将我们的网站文件上传到 Github 或者从 Github 下载东西呢？这里我们会用到 Git 这个工具。</p>
<p>那么如何建立网站呢？需要去学习网页技术吗？答案是不需要，我们将使用静态网站生成器来完成这项繁琐的工作。在本教程里，我们会使用 Hugo 这款出色的静态网站生成器。我们只需要挑选别人制作好的博客模板，根据某种规则去生成网站就好了（这里说的规则可以简单理解成约定好的文本格式，我们在约定好的文本格式下写文字，网站生成器会将这些文字翻译成网页文件）。所以我们只需要关注网站的文本，也就是展示的文章那些。（理想状态下，就类似我们写微博、发说说，编辑好文本发送出去就可以了）</p>
<p>简单来说，我们的工作流程是：在自己的电脑上，用一个静态网站生成器工具生成网页文件，然后将网站文件上传到某个平台上，这样别人就可以访问我们的网站了。如果修改网站（比如添加文章），也是重复上述步骤：重新生成网页文件，重新上传。</p>
<p>后续文章我会细述搭建网站的具体步骤，尽可能考虑新手建站的情况。如果你在这过程中遇到问题，欢迎在评论中指出或着与我联系。</p>

        
        ]]>
      </description>
    </item>
    
    
    
    <item>
      <title>开篇</title>
      <link>/post/2021/11/14/%E5%BC%80%E7%AF%87/</link>
      <pubDate>Sun, 14 Nov 2021 20:57:13 +0800</pubDate>
      <author>罗泽勋</author>
      <guid>/post/2021/11/14/%E5%BC%80%E7%AF%87/</guid>
      <description>
        <![CDATA[
        <p><img src="https://cdn.jsdelivr.net/gh/lzxqaq/jsdelivr@master/image/2021-11-14/0.jpg" alt="img"></p>
<p>回顾过去，我刚接触互联网时，还是 2G 时代，那时各类论坛博客和聊天室正蓬勃发展。这种跨越时空的交流方式让我感到非常新奇，看着屏幕吐出文字的时候，就感觉打开了一个新世界的大门。通过一根根网线，就可以将世界连起来，人们可以在其中感知世界并畅所欲言。有趣的是，当时还是小学生的我，已经在一款网页文字游戏中建立队伍，和几十位素不相识的伙伴一起在游戏江湖里打拼了……</p>
<p>不过随着QQ、微信和微博等便捷交流平台的发展，传统博客和论坛逐渐淡出人们的视线。然而人们在选择这些便捷的平台时，也被其束缚着。特别是在内容分发推荐和主流媒体导流的当下，人们获取信息的的渠道看似变多了，但是这过程已经从主动变成了被动，我不认为这是什么好事。</p>
<p>“I web, therefore I am a spiderman.”，这是 hugo-ivy 主题作者谢益辉在他 <a href="https://bookdown.org/yihui/blogdown/">blogdown</a>一书提到的个人网站的作用，我深以为然。在当下，个人网站用来交流分享、内容创造或者记录人生仍是一个非常棒的选择。</p>
<p>值得高兴的是，个人网站搭建技术从未停下发展的脚步，现在搭建一个个人网站已经是一件很容易的事了～如果你拥有了它，那么你便在这嘈杂的网络世界有了一方净土。这需要感谢开源，感谢前人的努力。因为他们的努力，让搭建网站这类技术活变得更简单，让这世界充满自由与奉献的星光。</p>
<p>但即便如此，为了更自由、更多元化的需求，搭建和管理网站仍需要足够的耐心，特别是对于不了解这方面的人。为了前人的付出让更多的人知晓，让自由的表达有更多选择，我在这里开启系列教程，将搭建个人网站的步骤一一讲述。虽然有很多人做过类似的工作，但我还是希望我能做得更详细、更简单，为有需要的朋友省下一番功夫。注意，本系列教程默认读者为零基础的读者，所以会涉及很多基础概念，有一定基础的读者建议去查找其他教程。同时，因为技术会不停地发展，本教程的一些信息可能已经过时，如果你发现任何问题或者有改进建议，请在评论（需要注册 Github 帐号）指出或者联系我，我会及时更新。在此，感谢支持。</p>
<blockquote>
<p>当你面对一个陌生领域的挑战时，最困难的往往是开始动手这个决定。</p>
</blockquote>

        
        ]]>
      </description>
    </item>
    
    
    
    <item>
      <title>Qt单元测试基础笔记</title>
      <link>/post/2021/10/13/qt%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Wed, 13 Oct 2021 07:01:19 +0800</pubDate>
      <author>罗泽勋</author>
      <guid>/post/2021/10/13/qt%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/</guid>
      <description>
        <![CDATA[
        <h3 id="一构建">一、构建</h3>
<p>构建时添加 <code>QT += testlib</code> 。</p>
<h3 id="二测试类">二、测试类</h3>
<p>测试类必须从 QObject 继承，头文件 <code>include &lt;QTest&gt;</code> ，并将测试函数声明 <code>private slot</code></p>
<h3 id="三qverifycondition-宏">三、QVERIFY(condition) 宏</h3>
<p>检查 condition（条件）是否为真。如果为真，则继续执行。如果没有，则测试日志中会记录失败，并且不会进一步执行测试。</p>
<p>如果需要在测试失败报告中加入附加信息，可以使用 QVERIFY2(condition, message)。</p>
<p>如果需要测试日志有更详细的输出，可以使用 QCOMPARE(actual, expected)。</p>
<h3 id="四qcompareactual-expected宏">四、QCOMPARE(actual, expected)宏</h3>
<p>使用相等运算符将 actual （实际值）与 expected （预期值）进行比较。如果实际和预期匹配，则继续执行。如果不是，则在测试日志中记录失败，并且测试函数返回而不尝试任何后续检查。</p>
<p>如果比较失败，QCOMPARE() 会尝试输出值的内容，因此可以从测试日志中看到比较失败的原因。</p>
<p>对于你自己的类，你可以使用 <code>QTest::toString ()</code> 来格式化输出到测试日志中的值。具体可参考 <a href="https://doc.qt.io/qt-6/qtest.html#QCOMPARE">Qt 文档</a>;</p>
<h3 id="五可执行文件">五、可执行文件</h3>
<p>如果需要将测试用例成为独立的可执行文件，需要添加以下两行：</p>
<pre tabindex="0"><code>QTEST_MAIN(YourClassName)
#include &quot;yourfilename.moc&quot;
</code></pre>
        
        ]]>
      </description>
    </item>
    
    
    
    <item>
      <title>【转载】Qt测试最佳实践</title>
      <link>/post/2021/10/13/%E8%BD%AC%E8%BD%BDqt%E6%B5%8B%E8%AF%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</link>
      <pubDate>Wed, 13 Oct 2021 07:01:19 +0800</pubDate>
      <author>罗泽勋</author>
      <guid>/post/2021/10/13/%E8%BD%AC%E8%BD%BDqt%E6%B5%8B%E8%AF%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</guid>
      <description>
        <![CDATA[
        <h2 id="qt-测试最佳实践">Qt 测试最佳实践</h2>
<p>我们建议您为错误修复和新功能添加 Qt 测试。在您尝试修复错误之前，添加一个回归测试（理想情况下是自动的），该测试在修复之前失败，表现出错误，并在修复之后通过。在开发新功能时，添加测试以验证它们是否按预期工作。</p>
<p>符合一组编码标准将使 Qt 自动测试更有可能在所有环境中可靠地工作。例如，有些测试需要从磁盘读取数据。如果没有为如何完成设置标准，则某些测试将无法移植。例如，假设其测试数据文件位于当前工作目录中的测试仅适用于源代码构建。在影子构建中（在源目录之外），测试将无法找到其数据。</p>
<p>以下章节包含了编写Qt测试的指南。</p>
<ul>
<li><a href="#%E4%B8%80%E8%88%AC%E5%8E%9F%E5%88%99">一般原则</a></li>
<li><a href="#%E7%BC%96%E5%86%99%E5%8F%AF%E9%9D%A0%E7%9A%84%E6%B5%8B%E8%AF%95">编写可靠的测试</a></li>
<li><a href="#%E6%94%B9%E8%BF%9B%E6%B5%8B%E8%AF%95%E8%BE%93%E5%87%BA">改进测试输出</a></li>
<li><a href="#%E7%BC%96%E5%86%99%E5%8F%AF%E6%B5%8B%E8%AF%95%E7%9A%84%E4%BB%A3%E7%A0%81">编写可测试的代码</a></li>
<li><a href="#%E8%AE%BE%E7%BD%AE%E6%B5%8B%E8%AF%95%E6%9C%BA">设置测试机</a></li>
</ul>
<h2 id="一般原则">一般原则</h2>
<p>下面的章节提供了编写单元测试的一般指南。</p>
<ul>
<li><a href="#%E9%AA%8C%E8%AF%81%E6%B5%8B%E8%AF%95">验证测试</a></li>
<li><a href="#%E8%B5%8B%E4%BA%88%E6%B5%8B%E8%AF%95%E5%87%BD%E6%95%B0%E6%8F%8F%E8%BF%B0%E6%80%A7%E7%9A%84%E5%90%8D%E7%A7%B0">赋予测试函数描述性的名称</a></li>
<li><a href="#%E7%BC%96%E5%86%99%E8%87%AA%E5%B8%A6%E7%9A%84%E6%B5%8B%E8%AF%95%E5%87%BD%E6%95%B0">编写自带的测试函数</a></li>
<li><a href="#%E6%B5%8B%E8%AF%95%E5%85%A8%E6%A0%88">测试全栈</a></li>
<li><a href="#%E8%AE%A9%E6%B5%8B%E8%AF%95%E5%BF%AB%E9%80%9F%E5%AE%8C%E6%88%90">让测试快速完成</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8%E7%9A%84%E6%B5%8B%E8%AF%95">使用数据驱动的测试</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8%E8%A6%86%E7%9B%96%E5%B7%A5%E5%85%B7">使用覆盖工具</a></li>
<li><a href="#%E9%80%89%E6%8B%A9%E9%80%82%E5%BD%93%E7%9A%84%E6%9C%BA%E5%88%B6%E6%9D%A5%E6%8E%92%E9%99%A4%E6%B5%8B%E8%AF%95">选择适当的机制来排除测试</a></li>
<li><a href="#%E9%81%BF%E5%85%8DQ_ASSERT">避免Q_ASSERT</a></li>
</ul>
<h3 id="验证测试">验证测试</h3>
<p>编写并提交你的测试以及你的修复或新功能到一个新的分支上。一旦你完成了,你可以检查出你的工作所基于的分支,然后把你的新测试的测试文件检查到这个分支。这可以让你验证测试是否在前一个分支上失败了,因此确实抓住了一个错误或测试了一个新功能。</p>
<p>例如，如果使用Git版本控制系统，则修复 QDateTime 类中的错误的工作流程可能如下所示：</p>
<blockquote>
<p>1.为您的修订和测试创建一个分支： git checkout -b fix-branch 5.14<br>
2.编写一个测试并修复错误。<br>
3.用修复版和新的测试版进行构建和测试,以验证新的测试版是否能通过修复版。<br>
4.将修复程序和测试添加到您的分支： git add tests/auto/corelib/time/qdatetime/tst_qdatetime.cpp src/corelib/time/qdatetime.cpp<br>
5.提交修复程序并测试您的分支机构： git commit -m &lsquo;Fix bug in QDateTime&rsquo;<br>
6.要验证测试是否确实捕获了需要您修复的内容，请检出您自己的分支所基于的分支： git checkout 5.14<br>
7.仅将测试文件检出到5.14分支： git checkout fix-branch &ndash; tests/auto/corelib/time/qdatetime/tst_qdatetime.cpp<br>
现在只有测试在fix-branch上。其余的源代码树仍在5.14上。<br>
8.构建并运行测试,以验证它在5.14上失败,因此确实抓住了一个错误。<br>
9.您现在可以返回到fix分支： git checkout fix-branch<br>
10.或者，您可以在5.14上将工作树恢复到干净状态： git checkout HEAD &ndash; tests/auto/corelib/time/qdatetime/tst_qdatetime.cpp</p>
</blockquote>
<p>当你在审查一个变更时,你可以调整这个工作流程,以检查该变更是否确实带有测试它确实修复的问题。</p>
<h3 id="为测试函数提供描述性名称">为测试函数提供描述性名称</h3>
<p>命名测试用例很重要。测试名称出现在测试运行的失败报告中。对于数据驱动的测试，数据行的名称也会出现在失败报告中。这些名字让阅读报告的人初步了解出了什么问题。</p>
<p>测试函数名称应该让函数试图测试的内容一目了然。不要简单地使用错误跟踪标识符，因为如果替换错误跟踪器，标识符就会过时。此外，并非所有用户都可以访问某些错误跟踪器。当测试代码的后续读者可能对错误报告感兴趣时，您可以在测试的相关部分旁边的评论中提及它。</p>
<p>同样，在编写数据驱动的测试时，为测试用例提供描述性名称，表明每个测试用例关注功能的哪个方面。不要简单地给测试用例编号，也不要使用错误跟踪标识符。阅读测试输出的人将不知道数字或标识符的含义。如果相关，您可以在提及错误跟踪标识符的测试行上添加注释。</p>
<h3 id="编写自包含的测试函数">编写自包含的测试函数</h3>
<p>在一个测试程序中，测试功能应该相互独立，并且它们不应该依赖于之前已经运行过的测试功能。您可以通过使用tst_foo testname.</p>
<p>不要在多个测试中重复使用被测类的实例。测试实例（例如小部件）不应该是测试的成员变量，但最好在堆栈上实例化，以确保即使测试失败也能进行适当的清理，这样测试不会相互干扰。</p>
<h3 id="测试全栈">测试全栈</h3>
<p>如果 API 是根据可插拔或特定于平台的后端来实现的，这些后端执行繁重的工作，请确保编写涵盖代码路径一直到后端的测试。使用模拟后端测试上层 API 部分是将 API 层中的错误与后端隔离的好方法，但它是对使用真实世界数据运行实际实现的测试的补充。</p>
<h3 id="使测试快速完成">使测试快速完成</h3>
<p>测试不应因不必要的重复、使用不当的大量测试数据或引入不必要的空闲时间而浪费时间。</p>
<p>对于单元测试尤其如此，其中每一秒额外的单元测试执行时间都会使跨多个目标的分支的 CI 测试花费更长的时间。请记住，单元测试与负载和可靠性测试是分开的，其中需要大量的测试数据和更长的测试运行时间。</p>
<p>基准测试通常会多次执行相同的测试，应位于单独的tests/benchmarks目录中，并且不应与功能单元测试混合使用。</p>
<h3 id="使用数据驱动测试">使用数据驱动测试</h3>
<p>数据驱动的测试可以更轻松地为后期错误报告中发现的边界条件添加新测试。</p>
<p>使用数据驱动的测试而不是在测试中按顺序测试多个项目可以节省非常相似的代码的重复，并确保即使较早的案例失败也能测试后续案例。它还鼓励系统和统一的测试，因为对每个数据样本应用相同的测试。</p>
<h3 id="使用覆盖工具">使用覆盖工具</h3>
<p>使用诸如Froglogic Coco Code Coverage或gcov 之类的覆盖工具来帮助编写测试，以覆盖被测试函数或类中尽可能多的语句、分支和条件。在新功能的开发周期中越早完成此操作，稍后在重构代码时就越容易捕获回归。</p>
<h3 id="选择适当的机制来排除测试">选择适当的机制来排除测试</h3>
<p>选择适当的机制来排除不适用的测试很重要：QSKIP ()，使用条件语句排除部分测试功能，或不为特定平台构建测试。</p>
<p>使用QSKIP () 来处理在运行时发现整个测试函数在当前测试环境中不适用的情况。当只跳过测试函数的一部分时，可以使用条件语句，可选择qDebug()调用以报告跳过不适用部分的原因。</p>
<p>数据驱动测试的测试功能或数据行可以限于特定平台，或使用#if. 但是，在使用跳过测试功能时要注意moc限制#if。该moc预处理器不具备访问所有builtin被经常用于编译器的特征检测编译器的宏。因此，moc预处理器条件的结果可能与其余代码看到的结果不同。这可能会导致moc为实际编译器跳过的测试槽生成元数据，或省略实际编译到类中的测试槽的元数据。在第一种情况下，测试将尝试运行未实现的插槽。在第二种情况下，即使应该尝试运行测试槽，测试也不会尝试。</p>
<p>如果整个测试程序不适用于特定平台或除非启用了特定功能，最好的方法是使用父目录的.pro文件来避免构建测试。例如，如果tests/auto/gui/someclass测试对 macOS 无效，请将以下行添加到tests/auto/gui.pro：</p>
<pre tabindex="0"><code>mac*: SUBDIRS -= someclass
</code></pre><h3 id="避免q_assert">避免Q_ASSERT</h3>
<p>该Q_ASSERT宏将导致程序中止时断言的情况false，但前提是软件始建于调试模式。在 release 和 debug-and-release 版本中，Q_ASSERT什么都不做。</p>
<p>Q_ASSERT 应该避免，因为它使测试的行为取决于是否正在测试调试版本，并且因为它会导致测试立即中止，跳过所有剩余的测试函数并返回不完整或格式错误的测试结果。</p>
<p>它还会跳过本应在测试结束时进行的任何拆卸或整理，因此可能会使工作区处于不整洁状态，这可能会导致进一步测试的复杂化。</p>
<p>应Q_ASSERT使用QCOMPARE () 或QVERIFY () 宏变体而不是 。它们使当前测试报告失败并终止，但允许执行剩余的测试功能和整个测试程序正常终止。QVERIFY2 () 甚至允许在测试日志中记录描述性错误消息。</p>
<h2 id="编写可靠的测试">编写可靠的测试</h2>
<p>以下部分提供了编写可靠测试的指南：</p>
<ul>
<li><a href="#%E9%81%BF%E5%85%8D%E9%AA%8C%E8%AF%81%E6%AD%A5%E9%AA%A4%E4%B8%AD%E7%9A%84%E5%89%AF%E4%BD%9C%E7%94%A8">避免验证步骤中的副作用</a></li>
<li><a href="#%E9%81%BF%E5%85%8D%E5%9B%BA%E5%AE%9A%E8%B6%85%E6%97%B6">避免固定超时</a></li>
<li><a href="#%E8%B0%A8%E9%98%B2%E4%BE%9D%E8%B5%96%E4%BA%8E%E6%97%B6%E9%97%B4%E7%9A%84%E8%A1%8C%E4%B8%BA">谨防依赖于时间的行为</a></li>
<li><a href="#%E9%81%BF%E5%85%8D%E4%BD%8D%E5%9B%BE%E6%8D%95%E8%8E%B7%E5%92%8C%E6%AF%94%E8%BE%83">避免位图捕获和比较</a></li>
</ul>
<h3 id="避免验证步骤中的副作用">避免验证步骤中的副作用</h3>
<p>在使用QCOMPARE ()、QVERIFY () 等执行自动测试中的验证步骤时，应避免副作用。验证步骤中的副作用会使测试难以理解。此外，当测试更改为使用QTRY_VERIFY ()、QTRY_COMPARE () 或QBENCHMARK ()时，他们可以很容易地以难以诊断的方式破坏测试。这些可以多次执行传递的表达式，从而重复任何副作用。</p>
<p>当副作用不可避免时，确保在测试函数结束时恢复先前的状态，即使测试失败。这通常需要使用在函数返回时恢复状态的 RAII（资源获取即初始化）类或cleanup()方法。不要简单地将恢复代码放在测试结束时。如果部分测试失败，此类代码将被跳过并且不会恢复之前的状态。</p>
<h3 id="避免固定超时">避免固定超时</h3>
<p>避免使用硬编码超时，例如QTest::qWait () 来等待某些条件变为真。考虑使用QSignalSpy类、QTRY_VERIFY () 或QTRY_COMPARE () 宏，或将QSignalSpy类与QTRY_宏变体结合使用。</p>
<p>该qWait()函数可用于在执行某些操作和等待该操作触发的某些异步行为完成之间设置一段固定时间的延迟。例如，更改小部件的状态，然后等待小部件重新绘制。但是，当在工作站上编写的测试在设备上执行时，此类超时通常会导致失败，在这种情况下，预期行为可能需要更长时间才能完成。在最慢的测试平台上将固定超时增加到比所需值大几倍的值并不是一个好的解决方案，因为它会减慢所有平台上的测试运行速度，特别是对于表驱动测试。</p>
<p>如果被测代码在异步行为完成时发出 Qt 信号，更好的方法是使用QSignalSpy类通知测试函数现在可以执行验证步骤。</p>
<p>如果没有 Qt 信号，请使用QTRY_COMPARE()和QTRY_VERIFY()宏，它会定期测试指定的条件，直到它变为真或达到某个最大超时。这些宏可防止测试花费比必要时间更长的时间，同时避免在工作站上编写测试并随后在嵌入式平台上执行时出现中断。</p>
<p>如果没有 Qt 信号，并且您正在编写测试作为开发新 API 的一部分，请考虑 API 是否可以从添加报告异步行为完成的信号中受益。</p>
<h3 id="谨防依赖于时间的行为">谨防依赖于时间的行为</h3>
<p>一些测试策略容易受到某些类的时间相关行为的影响，这可能导致测试仅在某些平台上失败或不返回一致的结果。</p>
<p>这方面的一个例子是文本输入小部件，它通常有一个闪烁的光标，可以根据捕获位图时光标的状态使捕获的位图的比较成功或失败。这又可能取决于执行测试的机器的速度。</p>
<p>在测试根据计时器事件更改其状态的类时，在执行验证步骤时需要考虑基于计时器的行为。由于依赖于时序的行为多种多样，因此没有针对此测试问题的单一通用解决方案。</p>
<p>对于文本输入小部件，潜在的解决方案包括禁用光标闪烁行为（如果 API 提供该功能），在捕获位图之前等待光标处于已知状态（例如，如果 API提供一个)，或者从位图比较中排除包含光标的区域。</p>
<h3 id="避免位图捕获和比较">避免位图捕获和比较</h3>
<p>虽然有时需要通过捕获和比较位图来验证测试结果，但它可能非常脆弱且需要大量劳动。</p>
<p>例如，特定小部件在不同平台上可能有不同的外观或具有不同的小部件样式，因此可能需要多次创建参考位图，然后在未来随着 Qt 支持的平台集的发展进行维护。因此，进行影响位图的更改意味着必须在每个支持的平台上重新创建预期的位图，这将需要访问每个平台。</p>
<p>位图比较也会受到测试机器的屏幕分辨率、位深度、活动主题、配色方案、小部件样式、活动区域设置（货币符号、文本方向等）、字体大小、透明度效果和选择等因素的影响的窗口管理器。</p>
<p>在可能的情况下，使用编程方式，例如验证对象和变量的属性，而不是捕获和比较位图。</p>
<h2 id="改进测试输出">改进测试输出</h2>
<p>以下部分提供了生成可读且有用的测试输出的指南：</p>
<ul>
<li><a href="#%E6%98%BE%E5%BC%8F%E5%BF%BD%E7%95%A5%E9%A2%84%E6%9C%9F%E8%AD%A6%E5%91%8A">显式忽略预期警告</a></li>
<li><a href="#%E6%98%BE%E5%BC%8F%E5%BF%BD%E7%95%A5%E9%A2%84%E6%9C%9F%E8%AD%A6%E5%91%8A">显式忽略预期警告</a></li>
<li><a href="#%E7%BC%96%E5%86%99%E7%BB%93%E6%9E%84%E8%89%AF%E5%A5%BD%E7%9A%84%E8%AF%8A%E6%96%AD%E4%BB%A3%E7%A0%81">编写结构良好的诊断代码</a></li>
</ul>
<h3 id="显式忽略预期警告">显式忽略预期警告</h3>
<p>如果预期测试会导致 Qt 在控制台上输出警告或调试消息，则应调用QTest::ignoreMessage () 将该消息从测试输出中过滤掉，如果没有输出消息，则测试失败。</p>
<p>如果只有在调试模式下构建 Qt 时才会输出这样的消息，请使用QLibraryInfo::isDebugBuild () 来确定 Qt 库是否是在调试模式下构建的。使用#ifdef QT_DEBUG是不够的，因为它只会告诉您测试是否是在调试模式下构建的，并且不能保证 Qt 库也是在调试模式下构建的。</p>
<h3 id="避免打印来自自动测试的调试消息">避免打印来自自动测试的调试消息</h3>
<p>自动测试不应产生任何未处理的警告或调试消息。这将允许 CI Gate 将新警告或调试消息视为测试失败。</p>
<p>在开发过程中添加调试消息很好，但是在签入测试之前应该禁用或删除这些消息。</p>
<h3 id="编写结构良好的诊断代码">编写结构良好的诊断代码</h3>
<p>如果测试失败，任何有用的诊断输出都应该是常规测试输出的一部分，而不是被注释掉、被预处理器指令禁用或仅在调试版本中启用。如果在持续集成期间测试失败，与启用诊断代码和再次测试相比，在 CI 日志中包含所有相关的诊断输出可以为您节省大量时间。特别是，如果故障发生在您的桌面上没有的平台上。</p>
<p>测试中的诊断消息应该使用 Qt 的输出机制，例如qDebug()and qWarning()，而不是stdio.horiostream.h输出机制。后者绕过 Qt 的消息处理并阻止-silent命令行选项抑制诊断消息。这可能会导致在大量调试输出中隐藏重要的失败消息。</p>
<h2 id="编写可测试的代码">编写可测试的代码</h2>
<p>以下部分提供了编写易于测试的代码的指南：</p>
<ul>
<li><a href="#%E6%89%93%E7%A0%B4%E4%BE%9D%E8%B5%96">打破依赖</a></li>
<li><a href="#%E5%B0%86%E6%89%80%E6%9C%89%E7%B1%BB%E7%BC%96%E8%AF%91%E5%88%B0%E5%BA%93%E4%B8%AD">将所有类编译到库中</a></li>
</ul>
<h3 id="打破依赖">打破依赖</h3>
<p>单元测试的想法是单独使用每个类。由于许多类实例化了其他类，因此不可能单独实例化一个类。因此，您应该使用一种称为依赖注入的技术，它将对象创建与对象使用分开。工厂负责构建对象树。其他对象通过抽象接口操作这些对象。</p>
<p>这种技术适用于数据驱动的应用程序。对于 GUI 应用程序，这种方法可能很困难，因为对象经常被创建和销毁。为了验证依赖于抽象接口的类的正确行为，可以使用模拟。例如，请参阅Googletest Mocking (gMock) 框架。</p>
<h3 id="将所有类编译到库中">将所有类编译到库中</h3>
<p>在中小型项目中，构建脚本通常会列出所有源文件，然后一次性编译可执行文件。这意味着测试的构建脚本必须再次列出所需的源文件。</p>
<p>在脚本中只列出一次源文件和头文件来构建静态库会更容易。然后该main()函数将链接到静态库以构建可执行文件，并且测试将链接到静态库。</p>
<p>对于在构建多个程序时使用相同源文件的项目，将共享类构建到每个程序（包括测试程序）可以在运行时加载的动态链接（或共享对象）库中可能更合适. 同样，将编译后的代码放在库中有助于避免重复描述组合哪些组件来制作各种程序。</p>
<h2 id="设置测试机">设置测试机</h2>
<p>以下部分讨论由测试机设置引起的常见问题：</p>
<ul>
<li><a href="#%E5%B1%8F%E5%B9%95%E4%BF%9D%E6%8A%A4%E7%A8%8B%E5%BA%8F">屏幕保护程序</a></li>
<li><a href="#%E7%B3%BB%E7%BB%9F%E5%AF%B9%E8%AF%9D%E6%A1%86">系统对话框</a></li>
<li><a href="#%E6%98%BE%E7%A4%BA%E4%BD%BF%E7%94%A8">显示使用</a></li>
<li><a href="#%E7%AA%97%E5%8F%A3%E7%AE%A1%E7%90%86%E5%99%A8">窗口管理器</a></li>
</ul>
<p>所有这些问题通常都可以通过明智地使用虚拟化来解决。</p>
<h3 id="屏幕保护程序">屏幕保护程序</h3>
<p>屏幕保护程序可能会干扰 GUI 类的某些测试，从而导致测试结果不可靠。应禁用屏幕保护程序以确保测试结果一致和可靠。</p>
<h3 id="系统对话框">系统对话框</h3>
<p>操作系统或其他正在运行的应用程序意外显示的对话框可能会从自动测试中涉及的小部件中窃取输入焦点，从而导致不可重现的故障。</p>
<p>典型问题的示例包括 macOS 上的在线更新通知对话框、病毒扫描程序的误报、病毒签名更新等计划任务、推送到工作站的软件更新以及在堆栈顶部弹出窗口的聊天程序。</p>
<h3 id="显示使用">显示使用</h3>
<p>某些测试使用测试机器的显示器、鼠标和键盘，因此如果机器同时用于其他用途或并行运行多个测试，则可能会失败。</p>
<p>CI 系统使用专用测试机来避免此问题，但如果您没有专用测试机，则可以通过在第二台显示器上运行测试来解决此问题。</p>
<p>在 Unix 上，还可以在嵌套或虚拟 X 服务器上运行测试，例如 Xephyr。例如，要在 Xephyr 上运行整套测试，请执行以下命令：</p>
<pre tabindex="0"><code>Xephyr :1 -ac -screen 1920x1200 &gt;/dev/null 2&gt;&amp;1 &amp;
sleep 5
DISPLAY=:1 icewm &gt;/dev/null 2&gt;&amp;1 &amp;
cd tests/auto
make
DISPLAY=:1 make -k -j1 check
</code></pre><p>NVIDIA 二进制驱动程序的用户应该注意 Xephyr 可能无法提供 GLX 扩展。强制 Mesa libGL 可能会有所帮助：</p>
<pre tabindex="0"><code>export LD_PRELOAD=/usr/lib/mesa-diverted/x86_64-linux-gnu/libGL.so.1
</code></pre><p>但是，当在 Xephyr 和具有不同 libGL 版本的真实 X 服务器上运行测试时，QML 磁盘缓存可能会使测试崩溃。为避免这种情况，请使用QML_DISABLE_DISK_CACHE=1.</p>
<p>或者，使用屏幕外插件：</p>
<pre tabindex="0"><code>TESTARGS=&quot;-platform offscreen&quot; make check -k -j1
</code></pre><h3 id="窗口管理器">窗口管理器</h3>
<p>在 Unix 上，至少有两个自动测试（tst_examples和tst_gestures）需要运行窗口管理器。因此，如果在嵌套的 X-server 下运行这些测试，您还必须在该 X-server 中运行窗口管理器。</p>
<p>您的窗口管理器必须配置为自动定位显示器上的所有窗口。一些窗口管理器，例如 Tab Window Manager (twm)，具有手动定位新窗口的模式，这会阻止测试套件在没有用户交互的情况下运行。</p>
<p>注意： Tab Window Manager 不适合运行完整的 Qt 自动测试套件，因为tst_gestures自动测试会导致它忘记其配置并恢复到手动窗口放置。</p>

        
        ]]>
      </description>
    </item>
    
    
    
    <item>
      <title>开发指南-未完待续</title>
      <link>/post/2021/07/16/%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97-%E6%9C%AA%E5%AE%8C%E5%BE%85%E7%BB%AD/</link>
      <pubDate>Fri, 16 Jul 2021 14:24:34 +0800</pubDate>
      <author>罗泽勋</author>
      <guid>/post/2021/07/16/%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97-%E6%9C%AA%E5%AE%8C%E5%BE%85%E7%BB%AD/</guid>
      <description>
        <![CDATA[
        <p>提高质量和生产率是软件工程要解决的核心问题。</p>
<p>软件开发：正确性、健壮性、可靠性、效率、易用性、可读性（可理解性）、可扩展性、可复用性、兼容性、可移植性等。</p>
<p>只记录实际目前为止比较困惑的。</p>
<h3 id="头文件的结构">头文件的结构</h3>
<p>1.为了防止头文件被重复引用，应当用 ifndef/define/endif 结构产生预处理块。</p>
<p>2.用 #include&lt;filename.h&gt;格式来引用非标准库的头文件（编译器将会从标准库目录开始搜索；用 #include&lt;Îy &ldquo;filename.h&rdquo; 格式来引用非标准库的头文件（编译器将从用户的工作目录开始搜索）。（注：一般将 &lt;&gt; 格式的放在前， &ldquo;&ldquo;格式的放在后，为了统一风格）</p>
<p>3.头文件只存放“声明”而不存放“定义”。（C++中，类的成员函数可以在声明的同时被定义，并且自动成为内联函数。但这样做会造成风格不一致，弊大于利！</p>
<p>4.不提倡使用全局变量，尽量不要在头文件中出现 extern int value 这类声明。</p>
<h3 id="头文件作用">头文件作用：</h3>
<ul>
<li>
<p>（1）通过头文件来调用库功能。在很多场合，源代码不便（或不准）向用户公布，只要向用户提供头文件和二进制的库即可。用户只需要按照头文件中的借口声明来调用库的功能，而不必关心接口怎么实现的。编译器会从库中提取相应的代码。</p>
</li>
<li>
<p>（2）头文件能加强类型安全检查。如果某个接口被实现或被使用时，其方式与头文件中的声明不一致，编译器就会指出错误，这一简单的规则能大大减轻程序员调试、改错的负担。</p>
</li>
</ul>
<h3 id="目录结构">目录结构</h3>
<p>如果一个软件的头文件数目比较多（如超过十个），通常应将头文件和定义文件分别保存于不同的目录，以便于维护。</p>
<p>例如可将头文件保存于 include 目录，将定义文件保存于 source 目录（可以是多级目录）。</p>
<p>如果某些头文件是私有的，它不会被用户的程序直接饮用，则没有必要公开其“声明”，可以把这些私有的头文件和定义文件存放于同一个目录。</p>
<h3 id="空行">空行</h3>
<p>1.类声明之后、函数定义结束之后要加空行。</p>
<p>2.在一个函数体内，逻辑上密切相关的语句之间不加空行，其他地方应加空行分割。</p>
<h3 id="代码行">代码行</h3>
<p>1.一行代码只做一件事情，如只定义一个变量，或只写一条语句。</p>
<p>2.if、for、while、do 等语句自占一行，执行语句不得紧跟其后。不论执行语句有多少都要加{}。这样可以防止书写失误。（注：也为了统一风格）</p>
<p>3.尽可能在定义变量的同时初始化该变量（就近原则）。（注：这样可以减少被野指针折磨的痛苦，强烈建议）</p>
<h3 id="代码行内的空格">代码行内的空格</h3>
<p>1.关键字之后要留一个空格。像 if、for、while 等关键字之后应留一个空格再跟左括号 &lsquo;('，以突出关键字。</p>
<p>2.函数名之后不要留空格，紧跟左括号&rsquo;('，以与关键字区别。</p>
<p>3.'(&lsquo;向后紧跟，')'、‘，’、‘；’向前紧跟，紧跟处不留空格。</p>
<p>4.&rsquo;,&lsquo;之后要留空格，如果&rsquo;;&lsquo;不是一行的结束符号，其后要留空格，如for(initialization; condition; update)。</p>
<p>5.【建议】对于表达式比较长的 for 语句和 if 语句，为了紧凑起见可以适当地去掉一些空格。（注：如果真的长到影响阅读，可以考虑）</p>
<h3 id="对齐">对齐</h3>
<p>1.‘{{’h和‘}}’应独占一行并且位于同一列，同时与引用它们的语句左对齐。</p>
<h3 id="长行拆分">长行拆分</h3>
<p>1.代码行最大长度应控制在 70 至 80 个字符以内。</p>
<p>2.【强烈】长表达式要在低优先级操作符处拆分成新行，操作符放在新行之首。</p>

        
        ]]>
      </description>
    </item>
    
    
    
    <item>
      <title>vim 操作备忘</title>
      <link>/post/2021/07/10/vim-%E6%93%8D%E4%BD%9C%E5%A4%87%E5%BF%98/</link>
      <pubDate>Sat, 10 Jul 2021 10:35:46 +0800</pubDate>
      
      <guid>/post/2021/07/10/vim-%E6%93%8D%E4%BD%9C%E5%A4%87%E5%BF%98/</guid>
      <description>
        <![CDATA[
        <h3 id="一存活">一、存活</h3>
<table>
<thead>
<tr>
<th style="text-align:left">操作</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">i</td>
<td style="text-align:left">Insert 模式，按 ESC 回到 Normal 模式。</td>
</tr>
<tr>
<td style="text-align:left">x</td>
<td style="text-align:left">删除当前光标所在的一个字符。</td>
</tr>
<tr>
<td style="text-align:left">:wq</td>
<td style="text-align:left">保存退出</td>
</tr>
<tr>
<td style="text-align:left">dd</td>
<td style="text-align:left">删除当前行，并存到剪切板</td>
</tr>
<tr>
<td style="text-align:left">p</td>
<td style="text-align:left">粘贴剪切板</td>
</tr>
<tr>
<td style="text-align:left">hjkl</td>
<td style="text-align:left">左下上右</td>
</tr>
<tr>
<td style="text-align:left">:help <command></td>
<td style="text-align:left">显示相关命令的帮助</td>
</tr>
</tbody>
</table>
<h3 id="二感觉良好">二、感觉良好</h3>
<p>1.各种插入模式</p>
<table>
<thead>
<tr>
<th style="text-align:left">操作</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">a</td>
<td style="text-align:left">在光标后插入</td>
</tr>
<tr>
<td style="text-align:left">o</td>
<td style="text-align:left">在当前行后插入一个新行</td>
</tr>
<tr>
<td style="text-align:left">O</td>
<td style="text-align:left">在当前行前插入一个新行</td>
</tr>
<tr>
<td style="text-align:left">cw</td>
<td style="text-align:left">替换从光标所在位置到一个单词结尾的字符</td>
</tr>
</tbody>
</table>
<p>2.简单的光标移动</p>
<table>
<thead>
<tr>
<th style="text-align:left">操作</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">0</td>
<td style="text-align:left">数字零，到行头</td>
</tr>
<tr>
<td style="text-align:left">^</td>
<td style="text-align:left">到本行第一个不是 blank 字符的位置（blank 字符就是空格、tab、换行、回车等）</td>
</tr>
<tr>
<td style="text-align:left">$</td>
<td style="text-align:left">到本行行尾</td>
</tr>
<tr>
<td style="text-align:left">g_</td>
<td style="text-align:left">到本行最后一个不是 blank 字符的位置</td>
</tr>
<tr>
<td style="text-align:left">/pattern</td>
<td style="text-align:left">搜索 pattern 的字符串（多个匹配时，按 n 到下一个）</td>
</tr>
</tbody>
</table>
<p>3.拷贝/粘贴</p>
<table>
<thead>
<tr>
<th style="text-align:left">操作</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">p</td>
<td style="text-align:left">粘贴</td>
</tr>
<tr>
<td style="text-align:left">yy</td>
<td style="text-align:left">拷贝当前行</td>
</tr>
</tbody>
</table>
<p>4.撤销反撤销</p>
<table>
<thead>
<tr>
<th style="text-align:left">操作</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">u</td>
<td style="text-align:left">撤销</td>
</tr>
<tr>
<td style="text-align:left">ctrl-r</td>
<td style="text-align:left">反撤销</td>
</tr>
</tbody>
</table>
<p>5.打开/保存/退出/改变文件（Buffer)</p>
<table>
<thead>
<tr>
<th style="text-align:left">操作</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">:e &lt;path/to/file&gt;</td>
<td style="text-align:left">打开一个文件</td>
</tr>
<tr>
<td style="text-align:left">:w</td>
<td style="text-align:left">保存</td>
</tr>
<tr>
<td style="text-align:left">:saveas &lt;path/to/file&gt;</td>
<td style="text-align:left">另存为</td>
</tr>
<tr>
<td style="text-align:left">:x, ZZ 或 :wq</td>
<td style="text-align:left">保存并退出(:x仅在需要时保存)</td>
</tr>
<tr>
<td style="text-align:left">:q!</td>
<td style="text-align:left">退出不保存</td>
</tr>
<tr>
<td style="text-align:left">:qa!</td>
<td style="text-align:left">强行退出所有正在编辑的文件</td>
</tr>
<tr>
<td style="text-align:left">:n， :bn</td>
<td style="text-align:left">下一个文件</td>
</tr>
<tr>
<td style="text-align:left">:bp</td>
<td style="text-align:left">上一个文件</td>
</tr>
</tbody>
</table>
<h3 id="三更好更强更快">三、更好、更强、更快</h3>
<h3 id="未完待续">未完待续</h3>

        
        ]]>
      </description>
    </item>
    
    
    
    <item>
      <title>从零开始搭建个人网站——小白篇</title>
      <link>/post/2021/06/01/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99%E5%B0%8F%E7%99%BD%E7%AF%87/</link>
      <pubDate>Tue, 01 Jun 2021 06:16:32 +0800</pubDate>
      <author>罗泽勋</author>
      <guid>/post/2021/06/01/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99%E5%B0%8F%E7%99%BD%E7%AF%87/</guid>
      <description>
        <![CDATA[
        <h3 id="前言">前言</h3>
<p>小白篇和前面<a href="../2021-2-18-2/">正经篇</a>的区别是，懒人篇专门针对基础更浅（或者更懒的）朋友而设计，在这里不会新建一个网站，而是下载我预先准备好的<a href="https://gitee.com/lzxqaq/demosite.git">示例网站</a>，在这个示例上面做扩展。这样也是为了避免新手成功创建网站时，面对空荡荡的网站不知所措的尴尬。</p>
<h3 id="准备工作与前篇一致">准备工作（与前篇一致）</h3>
<p>1.注册 Github 帐号。前往 <a href="https://github.com/" target="_blank">github.com</a> 注册一个 Github 帐号。（友情提示：认真考虑注册时的用户名，它将是你网站网址的一部分）</p>
<p>补充：Github 是一个代码托管平台（远程仓库），你可以将网站的源代码放在上面，Github Pages 是一个免费的静态网站服务，你将网站的源文件放在上面，它会提供一个链接，使互联网上的人都能访问你的网站。</p>
<p>2.准备Git。</p>
<p>（1）下载安装。前往 <a href="https://git-scm.com/download/win" target="_blank">这里</a> ，点击下载 Git-**-64-bit.exe。然后安装，不懂的话一直 next 。</p>
<p>（2）配置。在 win10 搜索 cmd ，打开命令提示符，输入 <code>git config --global user.email &quot;你注册Github所用的邮箱&quot;</code> 回车执行，再输入 <code>git config --global user.name &quot;你的昵称&quot;</code> 回车执行。</p>
<p>3.安装 Hugo。（官方教程可看<a href="https://www.gohugo.org/doc/tutorials/installing-on-windows/" target="_blank">这里</a>)</p>
<p>（1）首先在 D 盘创建一个新文件夹 Hugo，然后在里面创建 bin 和 sites两个文件夹。bin 将用来放 Hugo 的可执行文件，sites 将用来放你的网站的源代码。</p>
<p>（2）前往<a href="https://github.com/spf13/hugo/releases" target="_blank">这里</a>，找到并下载 hugo_<em><em>Windows-64bit.zip。解压，如果是一个 hugo</em></em>_windows_amd64.exe 文件，将它改名为 hugo.exe。</p>
<p>（3）将这个 hugo.exe 文件移动到刚刚创建的 bin 文件夹里。</p>
<p>（4）配置环境变量。方法1:在 win10 搜索 cmd，右键<strong>以管理员身份打开</strong>命令提示符，将 <code>setx &quot;Path&quot; &quot;%PATH%;D:\Hugo\bin&quot; /m </code>复制粘贴上去，回车（输入命令后需回车执行，后文不再赘述）。 方法2：在 win10 搜索环境变量，进去找到系统变量中的 Path，-&gt;编辑-&gt;新建，然后将 <code>D:\Hugo\bin</code> 复制进去，确定。</p>
<p>（5）验证。重新打开命令提示符（关闭上一步骤使用的），输入执行 <code>hugo help</code>，如果你能看到 hugo 的帮助文档，就验证成功，否则检查上述步骤是否出错。</p>
<h3 id="开始">开始</h3>
<p>1.建立博客网站</p>
<p>（1）下载示例网站。打开命令提示符，执行 <code>D:</code> 切换 D 盘，然后执行 <code>cd D:\Hugo\sites</code> 进入 D:\Hugo\sites 目录（便捷方法：在文件资源管理器中进入相应目录，单击地址栏右边空白地方，在文本最左输入 <code>cmd </code> 加空格，回车），执行命令 <code>git clone https://gitee.com/lzxqaq/demosite.git</code> ，如最后出现 <code>** 100% ** 完成</code> 则成功。（此时可在文件资源管理器中查看下载的文件夹 <code>demosite</code>）</p>
<p>（2）预览。紧接上一步，在命令提示符中执行 <code>cd demosite</code> 进入 demosite 目录，先执行 <code>hugo</code> ，再执行 <code>hugo server</code>。打开浏览器，输入网址访问 localhost:1313。</p>
<p>2.将网站展示文件存放到 Github 远程仓库。</p>
<p>（1）在 Github 中创建一个名为 你的仓库名字.github.io 的仓库，在设置中检查 Github Pages。</p>
<p>（2）打开命令提示符，进入 demosite\public 目录，分别执行</p>
<pre tabindex="0"><code>git init 
git add .
git commit -m &quot;first commit&quot;
git remote add origin https://github.com/你的Github名字/你的Github名字.github.io.git
git push --set-upstream origin master
</code></pre><p>输入账号名，密码，完成上传。</p>
<p>（3）测试。访问 github.com 网站，在你之前创建的仓库可以看到刚刚上传的文件。随后检查 Github Pages 设置，打开网址 <code>https://你的Github账户名.github.io</code> 访问你的网站，如果没有之前预览的网页，可以等待一会再刷新。</p>
<p>3.自定义域名（可选、需要一定的时间）</p>
<p>（1）购买域名。在华为云、阿里云等服务商购买域名。注意：国内购买域名需要实名认证。</p>
<p>（2）配置。访问 github.com 网站，进入你的仓库，在 setting 中找到 Github Pages，在 Custom domain 输入框中输入你的域名，保存。</p>
<p>（3）测试。访问你的域名。</p>

        
        ]]>
      </description>
    </item>
    
    
    
    <item>
      <title>【规约】 C&#43;&#43; 编程篇</title>
      <link>/post/2021/05/28/%E8%A7%84%E7%BA%A6-c-%E7%BC%96%E7%A8%8B%E7%AF%87/</link>
      <pubDate>Fri, 28 May 2021 11:46:44 +0800</pubDate>
      
      <guid>/post/2021/05/28/%E8%A7%84%E7%BA%A6-c-%E7%BC%96%E7%A8%8B%E7%AF%87/</guid>
      <description>
        <![CDATA[
        <h3 id="前言">前言</h3>
<p>“码出高效，码出质量”。本文整理了比较常见的 C++ 编程规范，主要来源于华为《软件编程规范总则》。</p>
<h3 id="一排版">（一）排版</h3>
<p>1.程序块要采用缩进风格编写，缩进的空格数位 4 个。对齐只用空格键，不适用tab键。<br>
2.相对独立的程序块之间、变量说明之后必须加空行。<br>
3.较长的语句（&gt;80 字符）要分成多行书写，长表达式要在低优先级操作符划分新行，操作符放在新行之首。<br>
4.if、for、do、while、case、switch、default 等语句自占一行，且执行语句部分无论多少都要加括号 {}。</p>
<h3 id="二注释">（二）注释</h3>
<p>1.一般情况下，源程序有效注释量必须在 20% 以上。<br>
2.说明性文件（如头文件 .h 文件、.inc 文件、.def 文件等）头部应进行注释，注释必须列出：版权说明、版本号、生成日期、作者、内容、功能、与其他头文件关系、修改日志等，头文件注释中还应有函数功能简要说明。<br>
3.源文件头部应进行注释，列出：版权说明、版本号、生成日期、作者、模块目的/功能、主要函数及其功能、修改日志等。<br>
4.函数头部应进行注释，列出：函数的目的/功能、输入参数、输出参数、返回值、调用关系（函数、表）等。<br>
5.边写代码边注释，修改代码同时修改响应的注释。不再有用的注释 要删除。<br>
6.注释格式尽量统一，建议使用“/<em>…………</em>/”。<br>
7.注释应考虑程序易读性，建议使用中文。</p>
<h3 id="三标识符命名">（三）标识符命名</h3>
<p>1.命名规范必须与所使用的系统风格保持一致，并在同一项目中统一，比如采用 UNIX 的全小写加下划线风格或大小写混排的方式，不要将两种方式混合使用。用作特殊标识如标识成员变量或全局变量的 m_ 和 g_，其后加上大小写混排的方式是允许的。<br>
示例：Add_User 不允许，add_user、AddUser、m_AddUser允许。</p>
<p>2.用正确的反义词组命名具有互斥意义的变量或相反动作的函数等。<br>
说明：以下是一些在软件中常用的反义词组。<br>
add / remove    begin / end    create / destroy<br>
insert /delete    first / last    get / release<br>
increment / decrement    put / get<br>
add /delete    lock unlock    open /close<br>
min / max    old /new     stat / stop<br>
next /previous    source / target    show / hide<br>
send / receive    source / destination <br>
cut /paste    up / down<br>
示例：<br>
int min_sum;<br>
int max_sum;<br>
int add_user( BYTE *user_name );<br>
int delete_user( BYTE *user_name);</p>
<h3 id="四可测性">（四）可测性</h3>
<p>1.使用断言来发现软件问题，提高代码可测性。</p>
<h3 id="五程序效率">（五）程序效率</h3>
<p>1.多重循环中，应将最忙的循环放在最内层。<br>
2.尽量减少循环嵌套层次。<br>
3.尽量使用乘法或其他方法代替除法特别是浮点运算中的除法（占用较多 CPU 资源）。</p>
<h3 id="六质量保证">（六）质量保证</h3>
<p>1.防止引用已经释放的内存空间。<br>
2.过程/函数中分配的内存，在过程/函数退出之前要释放。<br>
3.过程/函数中申请的（为打开文件而使用的）文件句柄，在过程/函数退出之前要关闭。<br>
4.防止内存操作越界。<br>
5.编程时，要防止差 1 错误。（&lt;=、&lt;等注意）<br>
6.if 语句尽量加上 else 分支，switch 语句必须有 default 分支。<br>
7.Unix 下，多线程的子线程退出必需采用主动退出的方式，即子线程应 return 出口。<br>
8.时刻注意表达式是否会上溢、下溢。使用变量时要注意其边界值的情况。</p>

        
        ]]>
      </description>
    </item>
    
    
    
    <item>
      <title>【规约】 Java 编程篇</title>
      <link>/post/2021/05/28/%E8%A7%84%E7%BA%A6-java-%E7%BC%96%E7%A8%8B%E7%AF%87/</link>
      <pubDate>Fri, 28 May 2021 10:36:40 +0800</pubDate>
      
      <guid>/post/2021/05/28/%E8%A7%84%E7%BA%A6-java-%E7%BC%96%E7%A8%8B%E7%AF%87/</guid>
      <description>
        <![CDATA[
        <h3 id="前言">前言</h3>
<p>“码出高效，码出质量”。本文整理了比较常见的 Java 编程规范，主要来源于《阿里巴巴 Java 开发手册》。</p>
<h3 id="一命名风格">（一）命名风格</h3>
<p>1.【强制】类名使用 UpperCamelCase风格，但以下情形例外：DO  /  BO  /  DTO  /  VO  /  AO  /  PO  /  UID等。
正例：MarcoPolo  /  UserDO  /  XmlService  /  TcpUdpDeal  /TaPromotion</p>
<p>2.【强制】方法名、参数名、成员变量、局部变量都统一使用 lowerCamelCase 风格，必须遵从驼峰形式。<br>
正例：localValue  /  getHttpMessage()  /  inputUserId</p>
<p>3.【强制】常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。<br>
正例：MAX_STOCK_COUNT</p>
<p>4.【强制】抽象类命名使用 Abstract 或 Base 开头；异常类命名使用 Exception 结尾；测试类命名以它要测试的类的名称开始，以 Test 结尾。</p>
<p>5.【强制】类型与中括号紧挨起来表示数组。<br>
正例：int[] arrayDemo;</p>
<p>6.【强制】POJO 类中布尔类型的变量，都不要加 is 前缀。</p>
<p>7.【强制】包名统一使用小写，点分隔符之间有且只有一个自然语义的英语单词。包名统一使用单数形式，但是类名如果有复数含义，类名可以使用复数形式。<br>
正例：应用工具类包名为 com.alibaba.ai.util、类名为 MessageUtils。</p>
<p>8.【强制】杜绝完全不规范的缩写，任何自定义编程元素在命名时，使用尽量完整的单词组合来表达其意。</p>
<p>9.【推荐】如果模块、接口、类、方法使用了设计模式，在命名时需体系那具体模式。</p>
<p>10.【推荐】接口类的方法和属性不要加任何修饰符号（public 也不要加），保持代码整洁，并加上有效的 Javadoc 注释。</p>
<p>11.【强制】对于 Service 和 DAO 类，基于 SOA 的理念，暴露出来的一定时接口，内部的实现类用 Impl 的后缀与接口区别。<br>
正例：CacheServiceImpl 实现 CacheService。</p>
<p>12.【参考】各层命名规约：
A）Service/DAO 层方法命名规约<br>
1）获取单个对象的方法用 get 做前缀。<br>
2）获取多个对象的方法用 list 做前缀，复数形式结尾如： listObjects。<br>
3）获取统计值的方法用 count 做前缀。<br>
4）插入的方法用 save/insert 做前缀<br>
5）删除的方法用 remove/delete 做前缀<br>
6）修改的方法用 update 做前缀<br>
B）领域模型命名规约<br>
1）数据对象：xxxDO，xxx 即为数据表名。<br>
2）数据传输对象：xxxDTO，xxx 为业务领域相关的名称。<br>
3）展示对象：xxxVO，xxx 一般为网页名称。<br>
4) POJO 是 DO/DTO/BO/VO 的统称，禁止命名为 xxxPOJO。</p>
<p>13.【强制】不允许任何魔法值（即未经预先i当以的常量）出现在代码中。<br>
反例：String key = &ldquo;ID#taobao_&rdquo; + tradeId;</p>
<p>14.【强制】代码格式，具体见下面正例。
正例：</p>
<pre tabindex="0"><code>    public static void main(String[] args) {
        // 缩进4个空格，注释内空1格
        String say = &quot;hello&quot;;
        // 运算符左右必须有一个空格
        int flag = 0;
        // 关键词 if 与括号之间必须有一个空格
        if (flag == 0) {
            System.out.println(say);
        }

        // 左大括号前加空格且不换行，左大括号后换行。
        if (flag == 0) {
            System.out.println(&quot;world&quot;);
        //  右大括号前换行，右大括号后有 else，不用换行、
        }
        else {
            System.out.printLn(&quot;ok&quot;);
        }
    }</code></pre>
        
        ]]>
      </description>
    </item>
    
    
    
    <item>
      <title>【规约】 MySQL 数据库篇</title>
      <link>/post/2021/05/28/%E8%A7%84%E7%BA%A6-mysql-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AF%87/</link>
      <pubDate>Fri, 28 May 2021 09:03:51 +0800</pubDate>
      
      <guid>/post/2021/05/28/%E8%A7%84%E7%BA%A6-mysql-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AF%87/</guid>
      <description>
        <![CDATA[
        <h3 id="前言">前言</h3>
<p>“码出高效，码出质量”。本文整理了比较常见的 MySQL 数据库编程规范，主要来源于《阿里巴巴 Java 开发手册》。</p>
<h3 id="一建表规约">(一)建表规约</h3>
<p>1.【强制】表达是与否概念的字段，必须使用 is_xxx 的方式命名，数据类型是 unsigned tinying(1 表示是，0 表示否)。<br>
说明：任何字段如果为非负数，必须是 unsigned。<br>
注意：POJO 类中任何布尔类型的变量，都不要加 is 前缀，所以，需要在 <resultMap> 设置从 is_xxx 到 Xxx 的映射关系。数据库表示是与否的值，使用 tinyint 类型，坚持 is_xxx 的命名方式是为了明确其取值含义与范围。<br>
正例：表达逻辑删除的字段名 is_deleted，1 表示删除，0 表示未删除。</p>
<p>2.【强制】表名、字段名必须使用小写字母或数字，禁止出现数字开头，禁止两个下划线中间只出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。<br>
说明:MySQL 在 Windows 下不区分大小写，但在 Linux 下默认是区分大小写。因此，数据库名、表名、字段名，都不允许出现任何大小写字母，避免节外生枝。<br>
正例：aliyun_admin, rdc_config, level3_name
反例：AliyunAdmin, rdcConfig, level_3_name</p>
<p>3.【强制】表明不使用复数名词。
说明：表名应该仅仅表示表里面的实体内容，不应该表示实体数量，对应于 DO 类名也是单数形式，符合表达习惯。</p>
<p>4.【强制】主键索引名为 pk_字段名；唯一索引名为 uk_字段名；普通索引名则为 idx_字段名。<br>
说明：pk_ 即 primary key；uk_ 即 unique key；idx_ 即 index 的简称。</p>
<p>5.【小数类型】为 decimal，禁止使用 float 和 double。<br>
说明：float 和 double 在存储的时候，存在精度损失的问题，很可能在值的比较时，得不到正确的结果。如果存储的数据范围超 decimal 的范围，建议将数据拆成整数和小数分开存储。</p>
<p>6.【强制】如果存储的字符串长度几乎相等，使用 char 定长字符串类型。</p>
<p>7.【强制】varchar 是可变字符串，不与先分配存储控件，长度不要超过 5000，如果存储长度大于此值，定义字段类型为 text,独立出来一张表，用主键来对应，避免影响其他字段索引效率。</p>
<p>8.【强制】表必备三字段：id, gmt_create, gmt_modified。<br>
说明：其中 id 必为主键，类型为 bigint unsigned、单表自增、步长为 1。gmt_create，gmt_modified 的类型均为 datetime 类型，前者现在时表示主动创建，后者过去分词表示被动更新。</p>
<p>9.【推荐】表的命名最好是加上”业务名称_表的作用“。<br>
正例：alipay_task   /   force_project   /   trade_config</p>
<p>10.【推荐】库名与应用名称尽量一致。</p>
<p>11.【推荐】字段允许适当冗余，以提高查询性能，但必须考虑数据一致。冗余字段应遵循：<br>
1）不是频繁修改的字段。<br>
2）不是 varchar 超长字段，更不能是 text 字段。<br>
正例：商品类目名称使用频率高，字段长度短，名称基本一成不变，可在相关联的表中冗余存储类目名称，避免关联查询。</p>
<p>12.【参考】合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检索速度。<br>
正例：  人  150岁之内   tinyint unsigned    1字节   无符号值：0 到 255<br>
龟  数百岁  smallint unsigned   2字节   无符号值：0 到65535</p>
<h3 id="二索引规约">（二）索引规约</h3>
<p>1.【强制】业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引。<br>
说明：不要以为唯一索引影响了 insert 速度，这个速度的损耗可以忽略，但提高查找速度是明显的；另外，只要没有唯一索引，必定有脏数据产生（墨菲定律）。</p>
<p>2.【强制】超过三个表禁止 join。需要 join 的字段，数据类型必须绝对一致；多表关联查询时，保证被关联的字段有索引。<br>
说明：join 需要注意表索引、SQL 性能。</p>
<p>3.【强制】在 varchar 字段上建立索引时，必须根据文本区分度指定索引长度。</p>
<p>4.【强制】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。<br>
说明：索引文件具有 B-Tree 的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。</p>
<p>5.【推荐】利用覆盖索引来进行查询操作，避免回表。</p>
<p>6.【参考】创建索引时避免有如下极端误解：<br>
1）宁滥勿缺。认为一个查询就需要建一个索引。<br>
2）宁缺毋滥。认为索引会消耗空间、严重拖慢更新和新增速度。<br>
3）抵制唯一索引。认为业务的唯一性一律需要在应用层通过”先查后插“方式解决。</p>
<h3 id="三sql-语句">（三）SQL 语句</h3>
<p>1.【强制】不要使用 count(列名) 或 count(常量) 来替代 count(*)。</p>
<p>2.【强制】使用 ISNULL() 来判断是否为 NULL 值。</p>
<p>3.【强制】不得使用外键和级联，一切外键概念不必在应用层解决。
说明：外键与级联更新使用于单机低并发，不适合分布式、高并发集群；级联更新时强阻塞，存在数据库过呢更新风暴的风险；外键影响数据库的插入速度。</p>
<p>4.【推荐】尽量避免 in 操作，若使用也需评估 in 后边的集合元素数量，控制在 1000 个之内。</p>

        
        ]]>
      </description>
    </item>
    
    
    
    <item>
      <title>[做点有趣的]C&#43;&#43;做一个哈夫曼压缩软件</title>
      <link>/post/2021/05/25/%E5%81%9A%E7%82%B9%E6%9C%89%E8%B6%A3%E7%9A%84c-%E5%81%9A%E4%B8%80%E4%B8%AA%E5%93%88%E5%A4%AB%E6%9B%BC%E5%8E%8B%E7%BC%A9%E8%BD%AF%E4%BB%B6/</link>
      <pubDate>Tue, 25 May 2021 07:12:32 +0800</pubDate>
      
      <guid>/post/2021/05/25/%E5%81%9A%E7%82%B9%E6%9C%89%E8%B6%A3%E7%9A%84c-%E5%81%9A%E4%B8%80%E4%B8%AA%E5%93%88%E5%A4%AB%E6%9B%BC%E5%8E%8B%E7%BC%A9%E8%BD%AF%E4%BB%B6/</guid>
      <description>
        <![CDATA[
        <h3 id="前言">前言</h3>
<p>这是以前的一个实训周作业，核心是哈夫曼编码和解码，软件界面由 QT 实现。代码量很小，比较简单。</p>
<p>源代码： <a href="https://gitee.com/lzxqaq/zxhan.git">https://gitee.com/lzxqaq/zxhan.git</a></p>
<p>介绍：<a href="https://lzxqaq.com/post/zxhan/">https://lzxqaq.com/post/zxhan/</a></p>
<p>算法参考：<a href="https://blog.csdn.net/small_hacker/article/details/52843738">Huffman压缩真正的C++实现</a></p>
<p>运行环境：Linux 系统（Windows系统下运行尚有 bug ),开发环境为 QT Creator。</p>
<p>运行截图：</p>
<div  align="center">    
 <img src="https://cdn.jsdelivr.net/gh/lzxqaq/zxhan@master/images/zxhan.png" width = "500" height = "200" alt="图片名称" align=center /></div>
<!-- ![img](https://cdn.jsdelivr.net/gh/lzxqaq/zxhan@master/images/zxhan.png) -->
<h3 id="核心实现">核心实现</h3>
<pre tabindex="0"><code>void create_node_array();//构造包含字符及其频率的数组
void create_pq();//构造优先级队列
void create_huffman_tree();//构造哈夫曼树
void create_map_table(Node* node,bool);//根据哈夫曼树建立哈夫曼映射表
bool calculate_huffman_codes();//计算哈夫曼编码
bool do_compress();//开始压缩
bool rebuid_huffman_tree();//从哈夫曼编码文件中重构哈夫曼树
void decode_huffman();//根据重构的哈夫曼树解码文件

</code></pre><h3 id="后续">后续</h3>
<p>该项目仍有许多不足之处，如果你对该项目有任何意见或建议，欢迎<a href="https://lzxqaq.com/about/">联系我</a>。如有任何问题，亦可与我一同探讨。</p>

        
        ]]>
      </description>
    </item>
    
    
    
    <item>
      <title>[做点有趣的]Java开发泡泡堂游戏（MVC架构）</title>
      <link>/post/2021/05/08/%E5%81%9A%E7%82%B9%E6%9C%89%E8%B6%A3%E7%9A%84java%E5%BC%80%E5%8F%91%E6%B3%A1%E6%B3%A1%E5%A0%82%E6%B8%B8%E6%88%8Fmvc%E6%9E%B6%E6%9E%84/</link>
      <pubDate>Sat, 08 May 2021 11:09:51 +0800</pubDate>
      
      <guid>/post/2021/05/08/%E5%81%9A%E7%82%B9%E6%9C%89%E8%B6%A3%E7%9A%84java%E5%BC%80%E5%8F%91%E6%B3%A1%E6%B3%A1%E5%A0%82%E6%B8%B8%E6%88%8Fmvc%E6%9E%B6%E6%9E%84/</guid>
      <description>
        <![CDATA[
        <h3 id="介绍">介绍</h3>
<p>本项目是一个很久以前的实训周项目，由我和我的组员 ljr 共同实现。整个项目思路清晰，整体难度不大，但是很多细节需要花功夫。本项目仍存在一些不足的地方，后续可能会进行优化，现在我将项目源代码和一些实现思路开源公布。</p>
<p>源代码：<a href="https://gitee.com/lzxqaq/CrazyArcade">https://gitee.com/lzxqaq/CrazyArcade</a></p>
<p>文章介绍：<a href="https://lzxqaq.com/post/java/paopaotang/">https://lzxqaq.com/post/java/paopaotang/</a></p>
<p>程序运行： 在终端下进入执行程序所在目录，执行 <code>java -jar CrazyArcade.jar</code> 或者双击 <code>CrazyArcade.jar</code>，或者在开发环境中打开源代码，运行 <code>GameStart.java</code>的 <code>main</code> 方法。</p>
<p>运行环境：Linux、Windows均可。开发环境：IDEA。</p>
<p>演示视频：</p>
<p>运行截图：</p>
<div  align="center">    
 <img src="https://cdn.jsdelivr.net/gh/lzxqaq/CrazyArcade@master/images/CrazyArcade.png" width = "500" height = "200" alt="图片1" align=center />
 <br/>
  <img src="https://cdn.jsdelivr.net/gh/lzxqaq/CrazyArcade/images/2.png" width = "500" height = "200" alt="图片2" align=center />
 </div>
<h3 id="功能">功能</h3>
<p>本项目实现的功能如下：</p>
<ul>
<li>绘制游戏启动界面、结束界面、地图、主角、道具</li>
<li>实现泡泡爆炸</li>
<li>实现双主角PK（积分制）</li>
<li>实现道具掉落和相应属性加成</li>
<li>实现游戏音效和背景音乐</li>
</ul>
<p>其中我们对游戏玩法做了调整，大致如下:</p>
<p>我们把游戏设计为双人pk积分赛模式，在这个模式里面，玩家只要率先达到一定分数既可以赢得比赛。玩家可以通过炸箱子可以得到少量的分数，也可以通过炸掉对手然后戳破包围对手的水泡得到大量分数。而玩家如果被泡泡爆炸击中，会被泡泡包裹一段时间，在这段时间内不可以移动和放泡泡，需要等时间过去或者被对手戳破水泡才能获得自由。但如果玩家被自己放的泡泡炸中，会扣一定的分数。</p>
<h3 id="思路和架构">思路和架构</h3>
<p>整个项目采用 MVC 架构，将项目整体分为数据模型层（M）、视图层（V）、控制层（C）。M层负责元素的创建、存储、管理，V层负责所有元素的显示（24帧/秒），C层负责交互（监听用户的操作），同时负责控制游戏的进程。</p>
<p>选择MVC架构最主要的原因是让这个游戏项目具有良好的可扩展性和更新功能，当然了，一个好的游戏也需要良好的交互功能，漂亮的UI设计。</p>
<p>架构设计图：</p>
<div  align="center">    
 <img src="https://cdn.jsdelivr.net/gh/lzxqaq/CrazyArcade@master/images/design.png" width = "500" height = "200" alt="图片名称" align=center /></div>
<h3 id="包结构">包结构</h3>
<p>未完待续……</p>
<h3 id="核心实现">核心实现</h3>
<p>未完待续……</p>
<h3 id="后续">后续</h3>
<p>该项目仍有许多不足之处，如果你对该项目有任何意见或建议，欢迎<a href="https://lzxqaq.com/about/">联系我</a>。如有任何问题，亦可与我一同探讨。</p>

        
        ]]>
      </description>
    </item>
    
    
    
    <item>
      <title>从零开始搭建个人网站（win10,Github,Hugo）</title>
      <link>/post/2021/02/18/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99win10githubhugo/</link>
      <pubDate>Thu, 18 Feb 2021 09:03:38 +0800</pubDate>
      <author>罗泽勋</author>
      <guid>/post/2021/02/18/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99win10githubhugo/</guid>
      <description>
        <![CDATA[
        <h3 id="准备工作">准备工作</h3>
<p>1.注册 Github 帐号。前往 <a href="https://github.com/" target="_blank">github.com</a> 注册一个 Github 帐号。（友情提示：认真考虑注册时的用户名，它将是网址的一部分）</p>
<p>补充：Github 是一个代码托管平台（远程仓库），你可以将网站的源代码放在上面，Github Pages 是一个免费的静态网站服务，你将网站的源文件放在上面，它会提供一个链接，使互联网上的人都能访问你的网站。</p>
<p>2.准备Git。</p>
<p>（1）下载安装。前往 <a href="https://git-scm.com/download/win" target="_blank">这里</a> ，点击下载 Git-**-64-bit.exe。然后安装，不懂的话一直 next 。</p>
<p>（2）配置。在 win10 搜索 cmd ，打开命令提示符，输入 <code>git config --global user.email &quot;你注册Github所用的邮箱&quot;</code> 回车执行，再输入 <code>git config --global user.name &quot;你的昵称&quot;</code> 回车执行。</p>
<p>3.安装 Hugo。（官方教程可看<a href="https://www.gohugo.org/doc/tutorials/installing-on-windows/" target="_blank">这里</a>)</p>
<p>（1）首先在 D 盘创建一个新文件夹 Hugo，然后在里面创建 bin 和 sites两个文件夹。bin 将用来放 Hugo 的可执行文件，sites 将用来放你的网站的源代码。</p>
<p>（2）前往<a href="https://github.com/spf13/hugo/releases" target="_blank">这里</a>，找到并下载 hugo_<em><em>Windows-64bit.zip。解压，如果是一个 hugo</em></em>_windows_amd64.exe 文件，将它改名为 hugo.exe。</p>
<p>（3）将这个 hugo.exe 文件移动到刚刚创建的 bin 文件夹里。</p>
<p>（4）配置环境变量。方法1:在 win10 搜索 cmd，右键<strong>以管理员身份打开</strong>命令提示符，将 <code>setx &quot;Path&quot; &quot;%PATH%;D:\Hugo\bin&quot; /m </code>复制粘贴上去，回车（输入命令后需回车执行，后文不再赘述）。 方法2：在 win10 搜索环境变量，进去找到系统变量中的 Path，-&gt;编辑-&gt;新建，然后将 <code>D:\Hugo\bin</code> 复制进去，确定。</p>
<p>（5）验证。重新打开命令提示符（关闭上一步骤使用的），输入执行 <code>hugo help</code>，如果你能看到 hugo 的帮助文档，就验证成功，否则检查上述步骤是否出错。</p>
<h3 id="开始">开始</h3>
<p>1.建立博客网站</p>
<p>（1）使用 Hugo 建立网站。打开命令提示符，执行 <code>D:</code> 切换 D 盘，然后执行 <code>cd D:\Hugo\sites</code> 进入 D:\Hugo\sites 目录（便捷方法：在文件资源管理器中进入相应目录，单击地址栏右边空白地方，在最左边输入 <code>cmd </code> 加空格，回车），执行命令 <code>hugo new site blog</code> ，如出现 Congratulations! 提示则成功。（此时可在文件资源管理器中查看生成的文件）</p>
<p>（2）下载主题模板（以 Hugo.386 为例）。接上述步骤，在命令提示符中 执行 <code>git clone https://gitlab.com/maxlefou/hugo.386 themes/hugo.386 </code>来下载 hugo.386 主题。</p>
<p>（3）配置。将 hugo.386\exampleSite 文件夹中的 theme.toml 文件复制到文件夹 blog 中，替换原本的。根据需要修改其中的内容。</p>
<p>（4）预览。命令提示符进入 blog 目录，先执行 <code>hugo</code> ，再执行 <code>hugo server</code>。打开浏览器，访问 localhost:1313。</p>
<p>2.将网站展示文件存放到 Github 远程仓库。</p>
<p>（1）在 Github 中创建一个名为 你的仓库名字.github.io 的仓库，在设置 setting 中检查 Github Pages。</p>
<p>（2）打开命令提示符，进入 blog\public 目录，分别执行</p>
<pre tabindex="0"><code>git init 
git add .
git commit -m &quot;first commit&quot;
git remote add origin https://github.com/你的Github名字/你的Github名字.github.io.git
git push --set-upstream origin master
</code></pre><p>输入账号名，密码，完成上传。</p>
<p>（3）测试。访问 github.com 网站，在你之前创建的仓库可以看到刚刚上传的文件。随后检查 Github Pages 设置，访问提供的 <code>https://你的Github账户名.github.io</code> 访问你的网站，如果没有之前预览的网页，可以等待一会再刷新。</p>
<p>3.自定义域名（可选、需要一定的时间）</p>
<p>（1）购买域名。在华为云、阿里云等服务商购买域名。注意：国内购买域名需要实名认证。</p>
<p>（2）配置。访问 github.com 网站，进入你的仓库，在 setting 中找到 Github Pages，在 Custom domain 输入框中输入你的域名，保存。</p>
<p>（3）测试。访问你的域名。</p>

        
        ]]>
      </description>
    </item>
    
    
    
    <item>
      <title>Java I/O</title>
      <link>/post/2021/01/12/java-i/o/</link>
      <pubDate>Tue, 12 Jan 2021 08:46:08 +0800</pubDate>
      <author>罗泽勋</author>
      <guid>/post/2021/01/12/java-i/o/</guid>
      <description>
        <![CDATA[
        <h3 id="一概览">一、概览</h3>
<p>Java 的 I/O 大概可以分成以下几类：</p>
<ul>
<li>磁盘操作：File</li>
<li>字节操作：InputStream 和 OutputStream</li>
<li>对象操作：Serializable</li>
<li>网络操作：Socket</li>
<li>新的输入/输出：NIO</li>
</ul>
<h3 id="二磁盘操作">二、磁盘操作</h3>
<p>File 类可以用于表示文件和目录的信息，但是它不表示文件的内容。
递归地列出一个目录的所有文件：</p>
<pre tabindex="0"><code>public static void listAllFiles(File dir){
    if(dir == null || !dir.exists()){
        return ;
    }
    if(dir.isFile()) {
        System.out.println(dir.getName());
        return ;
    }
    for (File:file : dir.listFiles()) {
        listAllFiles(file);
    }
}
</code></pre><p>从 Java 7 开始，可以使用 Paths 和 Files 代替 File。</p>
<h3 id="三字节操作">三、字节操作</h3>
<h4 id="实现文件复制">实现文件复制</h4>
<pre tabindex="0"><code>public static void copuFile(String src, String dist) throws IOException {
    FileInputStream in = new FileInputStream(src);
    FileOutputStream out = new FileOutStream(dist);

    byte[] buffer = new byte[20 * 1024];
    int cnt;
    // read() 最多读 buffer.length 个字节
    // 返回的是实际读取的个数
    // 返回 -1 的时候表示读到 eof,即文件结尾
    while ((cnt = in.read(buffer, 0, buffer.length)) != -1) {
        out.write(buffer, 0, cnt);
    }

    in.close();
    out.close();
}
</code></pre><h4 id="装饰者模式">装饰者模式</h4>
<p>Java I/O 使用了装饰者模式来实现。</p>
<p>实例化一个具有缓存功能的字节流对象时，只需要在 FileInputStream 对象上再套一层 BufferedInputStream 对象即可。</p>
<h3 id="七nio">七、NIO</h3>
<p>新的输入/输出（NIO）库是在 JDK1.4中引入的，弥补了原来的 I/O 的不足，提供了高速的、面向块的 I/O。</p>

        
        ]]>
      </description>
    </item>
    
    
    
    <item>
      <title>Java 并发</title>
      <link>/post/2021/01/09/java-%E5%B9%B6%E5%8F%91/</link>
      <pubDate>Sat, 09 Jan 2021 10:50:16 +0800</pubDate>
      <author>罗泽勋</author>
      <guid>/post/2021/01/09/java-%E5%B9%B6%E5%8F%91/</guid>
      <description>
        <![CDATA[
        <h3 id="一使用线程">一、使用线程</h3>
<p>有三种使用线程的方法：</p>
<ul>
<li>实现 Runnable 接口；</li>
<li>实现 Callable接口；</li>
<li>继承 Tread 类；</li>
</ul>
<h4 id="实现-runnable-接口">实现 Runnable 接口</h4>
<p>需要实现接口中的 run() 方法。</p>
<pre tabindex="0"><code>public class MyRunnable implements Runnable {
    @Override
    public void run(){
        // ...
    }
}
</code></pre><p>使用 Runnable 实例再创建一个 Thread 实例，然后调用 Thread 实例的 start() 方法来启动线程。</p>
<pre tabindex="0"><code>public static void main(String[] args){
    MyRunnable instance = new MyRunnable();
    Thread thread = new Thread(instance);
    thread.start();
}
</code></pre><h4 id="实现-callable-接口">实现 Callable 接口</h4>
<p>与 Runnable 相比，Callable 可以有返回值，返回值通过 FutureTask 进行封装。</p>
<pre tabindex="0"><code>public class MyCallable implements Callable&lt;Integer&gt; {
    public Integer call(){
        return 123;
    }
}
</code></pre><pre tabindex="0"><code>public static void main(String[] args) throws ExecutionException,InterruptedException {
    MyCallable mc = new MyCallble();
    FutureTask&lt;Integer&gt; ft = new FutureTask&lt;&gt;(mc);
    Thread thread = new Thread(ft);
    thread.start();
    System.out.println(ft.get());
}
</code></pre><h3 id="继承-thread-类">继承 Thread 类</h3>
<p>同样也是需要实现 run() 方法，因为 Thread 类也实现了 Runnable 接口。</p>
<p>当调用 start() 方法启动一个线程时，虚拟机会将该线程放入就绪队列中等待被调度，当一个线程被调度时会执行该线程的 run() 方法。</p>
<pre tabindex="0"><code>public class MyThread extends Thread {
    public void run() {
        // ...
    }
}
</code></pre><pre tabindex="0"><code>public static void main(String[] args) {
    MyThread mt = new MyThread();
    mt.start();
}
</code></pre><h3 id="实现接口-vs-继承-thread">实现接口 VS 继承 Thread</h3>
<p>实现接口会更好一些，因为：</p>
<ul>
<li>Java 不支持多重继承，可以实现多个接口。</li>
<li>继承整个 Thread 类开销过大。</li>
</ul>
<h3 id="四互斥同步">四、互斥同步</h3>
<p>Java 提供了两种锁机制来控制多个线程对共享资源的互斥访问，第一个是 JVM 实现的 synchronized，而另一个是 JDK 实现的 ReentrantLock。</p>
<h4 id="synchronized">synchronized</h4>
<h5 id="1同步一个代码块">1.同步一个代码块</h5>
<pre tabindex="0"><code>public void func() {
    synchronized (this) {
        // ...
    }
}
</code></pre><p>它只作用于同一个对象，如果调用两个对象上的同步代码块，就不会进行同步。</p>
<p>对于以下代码，使用 ExecutorService 执行了两个线程，由于调用的是同一个对象的同步代码块，因此这两个线程会进行同步，当一个线程进入同步语句块时，另一个线程就必须等待。</p>
<pre tabindex="0"><code>public class SynchronizedExample {

    public void func1() {
        synchronized (this) {
            for (int i = 0; i &lt; 10; i++) {
                System.out.print(i + &quot; &quot;);
            }
        }
    }
}
</code></pre><pre tabindex="0"><code>public static void main(String[] args) {
    SynchronizedExample e1 = new SynchronizedExample();
    ExecutorService executorService = Executors.newCachedThreadPool();
    executorService.execute(() -&gt; e1.func1());
    executorService.execute(() -&gt; e1.func1());
}
</code></pre><pre tabindex="0"><code>0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9
</code></pre><p>对于以下代码，两个线程调用了不同对象的同步代码块，因此这两个线程就不需要同步。从输出结果可以看出，两个线程交叉执行。</p>
<pre tabindex="0"><code>public static void main(String[] args) {
    SynchronizedExample e1 = new SynchronizedExample();
    SynchronizedExample e2 = new SynchronizedExample();
    ExecutorService executorService = Executors.newCachedThreadPool();
    executorService.execute(() -&gt; e1.func1());
    executorService.execute(() -&gt; e2.func1());
}
</code></pre><pre tabindex="0"><code>0 0 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9
</code></pre><h5 id="2同步一个方法">2.同步一个方法</h5>
<pre tabindex="0"><code>public synchronized void func() {
    // ...
}
</code></pre><p>它和同步代码块一样，作用于同一个对象</p>
<h5 id="3同步一个类">3.同步一个类</h5>
<pre tabindex="0"><code>public void func() {
    synchronized (SynchronizedExample.class) {
        // ...
    }
}
</code></pre><p>作用于整个类，也就是说两个线程调用同一个类的不同对象上的这种同步语句块，也会进行同步。</p>
<pre tabindex="0"><code>public class SynchronizedExample {

    public void func2() {
        synchronized (SynchronizedExample.class) {
            for (int i = 0; i &lt; 10; i++) {
                System.out.print(i + &quot; &quot;);
            }
        }
    }
}
</code></pre><pre tabindex="0"><code>public static void main(String[] args) {
    SynchronizedExample e1 = new SynchronizedExample();
    SynchronizedExample e2 = new SynchronizedExample();
    ExecutorService executorService = Executors.newCachedThreadPool();
    executorService.execute(() -&gt; e1.func2());
    executorService.execute(() -&gt; e2.func2());
}
</code></pre><pre tabindex="0"><code>0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9
</code></pre><h5 id="4同步一个静态方法">4.同步一个静态方法</h5>
<pre tabindex="0"><code>public synchronized static void fun() {
    // ...
}
</code></pre><p>作用于整个类。</p>
<h4 id="reentrantlock">ReentrantLock</h4>
<p>ReentrantLock 是 java.util.concurrent（J.U.C)包中的锁。</p>
<pre tabindex="0"><code>public class LockExample {

    private Lock lock = new ReentrantLock();

    public void func() {
        lock.lock();
        try {
            for (int i = 0; i &lt; 10; i++) {
                System.out.print(i + &quot; &quot;);
            }
        } finally {
            lock.unlock(); // 确保释放锁，从而避免发生死锁。
        }
    }
}

</code></pre><pre tabindex="0"><code>public static void main(String[] args) {
    LockExample lockExample = new LockExample();
    ExecutorService executorService = Executors.newCachedThreadPool();
    executorService.execute(() -&gt; lockExample.func());
    executorService.execute(() -&gt; lockExample.func());
}
</code></pre><pre tabindex="0"><code>0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9
</code></pre><h5 id="使用选择">使用选择</h5>
<p>除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized。这是因为 synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。并且使用 synchronized 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放。</p>
<h3 id="六线程状态">六、线程状态</h3>
<h4 id="新建">新建</h4>
<h4 id="可运行">可运行</h4>
<h4 id="阻塞">阻塞</h4>
<h4 id="无限期等待">无限期等待</h4>
<h4 id="死亡">死亡</h4>

        
        ]]>
      </description>
    </item>
    
    
    
    <item>
      <title>SQL 语法</title>
      <link>/post/2020/12/31/sql-%E8%AF%AD%E6%B3%95/</link>
      <pubDate>Thu, 31 Dec 2020 10:12:40 +0800</pubDate>
      <author>罗泽勋</author>
      <guid>/post/2020/12/31/sql-%E8%AF%AD%E6%B3%95/</guid>
      <description>
        <![CDATA[
        <ul>
<li><a href="#1">一、基础</a></li>
<li><a href="#2">二、创建表</a></li>
<li><a href="#3">三、修改表</a></li>
<li><a href="#4">四、插入</a></li>
<li><a href="#5">五、更新</a></li>
<li><a href="#6">六、删除</a></li>
<li><a href="#7">七、查询</a>
<ul>
<li><a href="#7.1">DISTINCT</a></li>
<li><a href="#7.2">LIMIT</a></li>
</ul>
</li>
<li><a href="#8">八、排序</a></li>
<li><a href="#9">九、过滤</a></li>
<li><a href="#10">十、通配符</a></li>
<li><a href="#11">十一、计算字段</a></li>
<li><a href="#12">十二、函数</a>
<ul>
<li><a href="#12.1">汇总</a></li>
<li><a href="#12.2">文本处理</a></li>
<li><a href="#12.3">日期和时间处理</a></li>
<li><a href="#12.4">数值处理</a></li>
</ul>
</li>
<li><a href="#13">十三、分组</a></li>
<li><a href="#14">十四、子查询</a></li>
<li><a href="#15">十五、连接</a>
<ul>
<li><a href="#15.1">内连接</a></li>
<li><a href="#15.2">自连接</a></li>
<li><a href="#15.3">自然连接</a></li>
<li><a href="#15.4">外连接</a></li>
</ul>
</li>
<li><a href="#16">十六、组合查询</a></li>
<li><a href="#17">十七、视图</a></li>
<li><a href="#18">十八、存储过程</a></li>
<li><a href="#19">十九、游标</a></li>
<li><a href="#20">二十、触发器</a></li>
<li><a href="#21">二十一、事务管理</a></li>
<li><a href="#22">二十二、字符集</a></li>
<li><a href="#23">二十三、权限管理</a></li>
</ul>
<h3 id="一基础a-name1a">一、基础<a name="1"></a></h3>
<p>模式定义了数据如何存储、存储怎么样的数据以及数据如何分解等信息，数据库和表都有模式。</p>
<p>主键的值不允许修改，也不允许复用（不能将已经删除的主键值赋给新数据行的主键）。</p>
<p>SQL，（Structred Query Language)，标准 SQL 由 ANSI 标准委员会管理，从而被称为 ANSI SQL。各个 DBMS 都有自己的实现，如 PL/SQL、Transact-SQL 等。</p>
<p>SQL 语句不区分大小写，但是数据库表名、列名和值是否区分依赖于具体的 DBMS 以及配置。</p>
<p>SQL 支持以下三种注释：</p>
<pre tabindex="0"><code>### 注释
SELECT * FROM mytable; -- 注释
/* 注释1
   注释2 */

</code></pre><p>数据库创建与使用：</p>
<pre tabindex="0"><code>CREATE DATABASE test;
USE test;
</code></pre><h3 id="二创建表a-name2a">二、创建表<a name="2"></a></h3>
<pre tabindex="0"><code>CREATE TABLE mytable (
    # int 类型，不为空，自增
    id INT NOT NULL AUTO_INCREMENT,
    # int 类型，不可为空，默认值为1，不为空
    col1 INT NOT NULL DEFAULT 1,
    # 变长字符串类型，最常为 45 个字符，可以为空
    col2 VARCHAR(45) NULL,
    # 日期类型，可为空
    col3 DATE NULL,
    # 设置主健为 id
    PRIMARY KEY (`id`)
);
</code></pre><h3 id="三修改表">三、修改表</h3>
<p>添加列</p>
<pre tabindex="0"><code>ALTER TABLE mytable
ADD col CHAR(20);
</code></pre><p>删除列</p>
<pre tabindex="0"><code>ALTER TABLE mytable
DROP COLUMN col;
</code></pre><p>删除表</p>
<pre tabindex="0"><code>DROP TABLE mytable;
</code></pre><h3 id="四插入">四、插入</h3>
<p>普通插入</p>
<pre tabindex="0"><code>INSERT INTO mytable(col1, col2)
VALUES(val1,val2);
</code></pre><p>插入检索出来的数据</p>
<pre tabindex="0"><code>INSERT INTO mytable1(col1, col2)
SELECT col1, col2
FROM mytable2;
</code></pre><p>将一个表的内容插入到一个新表</p>
<pre tabindex="0"><code>CREATE TABLE newtable AS 
SELECT * FROM mytable;
</code></pre><h3 id="五更新">五、更新</h3>
<pre tabindex="0"><code>UPDATE mytable
SET col = val 
WHERE id = 1;
</code></pre><h3 id="六删除">六、删除</h3>
<pre tabindex="0"><code>DELETE FROM mytable
WHERE id = 1;
</code></pre><p>TRUNCATE TABLE table 可以清空表，也就是删除所有行。</p>
<pre tabindex="0"><code>TRUNCATE TABLE mytable;
</code></pre><p>使用更新和删除操作时一定要用 WHERE 字句，不然会把整张表的数据都损坏。用 SELECT 语句进行测试，防止错误删除。</p>
<h3 id="七查询">七、查询</h3>
<p>DISTINCT
相同值只会出现一次。它作用与所有列，也就是说所有列的值都想同时才算相同。</p>
<pre tabindex="0"><code>SELECT DISTINCT col1, col2
FROM mytable;
</code></pre><p>LIMIT
限制返回的行数。可以有两个参数，第一个参数为起始行，从 0 开始；第二个参数为返回的总行数。<br>
返回前五行：</p>
<pre tabindex="0"><code>SELECT * 
FROM mytable
LIMIT 5;
</code></pre><pre tabindex="0"><code>SELECT *
FROM mytable
LIMIT 0, 5;
</code></pre><p>返回第3～5行：</p>
<pre tabindex="0"><code>SELECT *
FROM mytable
LIMIT 2, 3;
</code></pre><h3 id="八排序">八、排序</h3>
<ul>
<li>ASC：升序（默认）</li>
<li>DESC：降序
可以按多个列进行排序，并且为每个列指定不同的排序方式：</li>
</ul>
<pre tabindex="0"><code>SELECT *
FROM mytable
ORDER BY col1 DESC, col2 ASC;
</code></pre><h3 id="九过滤">九、过滤</h3>
<p>不进行过滤的数据非常大，导致通过网络传输了多余的数据，从而浪费了网络带宽。因此尽量使用 SQL 语句来过滤不必要的数据，而不是传输所有的数据到客户端中然后由客户端进行过滤。</p>
<pre tabindex="0"><code>SELECT * 
FROM mytable
WHERE col IS NULL;
</code></pre><p>下表显示了 WHERE 字句可用的操作符。</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>=</td>
<td>等于</td>
</tr>
<tr>
<td>&lt;</td>
<td>小于</td>
</tr>
<tr>
<td>&gt;</td>
<td>大于</td>
</tr>
<tr>
<td>&lt;&gt;!=</td>
<td>不等于</td>
</tr>
<tr>
<td>&lt;=!&gt;</td>
<td>小于等于</td>
</tr>
<tr>
<td>&gt;=!=</td>
<td>大于等于</td>
</tr>
<tr>
<td>BETWEEN</td>
<td>在两个值之间</td>
</tr>
<tr>
<td>IS NULL</td>
<td>为 NULL 值</td>
</tr>
</tbody>
</table>
<p>应该注意到，NULL 和 0、空字符串都不同。</p>
<p>AND 和 OR 用于连接多个过滤条件。优先处理 AND，当一个过滤表达式涉及到多个 AND 和 OR 时，可以使用（）来决定优先级，时的优先级关系更清晰。</p>
<p>IN 操作符用于匹配一组值，其后也可以接一个 SELECT 子句，从而匹配子查询得到的一组值。</p>
<p>NOT 操作符用于否定一个条件。</p>
<h3 id="十通配符">十、通配符</h3>
<p>通配符也是用在过滤语句中，但它只能用于文本字段。</p>
<ul>
<li>% 匹配 &gt;=0 个任意字符；</li>
<li>_ 匹配 ==1 个任意字符；</li>
<li>[] 可以匹配集合内的字符，例如 [ab]将匹配字符 a 或者 b。用脱字符 ^ 可以对其进行否定，也就是不匹配集合内的字符。<br>
使用 LIKE 来进行通配符匹配。</li>
</ul>
<pre tabindex="0"><code>SELECT *
FROM mytable
WHERE col LIKE '[^AB]%'; -- 不以 A 和 B 开头的任意文本
</code></pre><p>不要滥用通配符，通配符位于开头处匹配会非常慢。</p>
<h3 id="十一计算字段">十一、计算字段</h3>
<p>在数据库服务器上完成数据的转换和格式化的工作往往比客户端上快得多，并且转换和格式化后的数据量更少的话可以减少网络通信量。</p>
<p>计算字段通常需要使用 AS 来取别名，否则输出的时候字段名为计算表达式。</p>
<pre tabindex="0"><code>SELECT col1 * col2 AS alias
FROM mytable;
</code></pre><p>CONCAT() 用于连接两个字段。许多数据库会使用空格把一个值填充为列宽，因此连接的结果会出现一些不必要的空格，使用 TRIM() 可以去除首尾空格。</p>
<pre tabindex="0"><code>SELECT CONCAT(TRIM(col1), '(', TRIM(col2), ')') AS concat_col
FROM mytable;
</code></pre><h3 id="十二函数">十二、函数</h3>
<p>各个 DBMS 的函数都是不相同的，因此不可移植，以下主要是 MySQL 的函数。</p>
<h4 id="汇总">汇总</h4>
<p>AVG()	返回某列的平均值<br>
COUNT()	返回某列的行数<br>
MAX()	返回某列的最大值<br>
MIN()	返回某列的最小值<br>
SUM()	返回某列值之和</p>
<p>AVG() 会忽略 NULL 行。</p>
<p>使用 DISTINCT 可以汇总不同的值。</p>
<pre tabindex="0"><code>SELECT AVG(DISTINCT col1) AS avg_col
FROM mytable;
</code></pre><h4 id="文本处理">文本处理</h4>
<p>LEFT()	左边的字符<br>
RIGHT()	右边的字符<br>
LOWER()	转换为小写字符<br>
UPPER()	转换为大写字符<br>
LTRIM()	去除左边的空格<br>
RTRIM()	去除右边的空格<br>
LENGTH()	长度<br>
SOUNDEX()	转换为语音值</p>
<p>其中， SOUNDEX() 可以将一个字符串转换为描述其语音表示的字母数字模式。</p>
<pre tabindex="0"><code>SELECT *
FROM mytable
WHERE SOUNDEX(col1) = SOUNDEX('apple')
</code></pre><h4 id="日期和时间处理">日期和时间处理</h4>
<ul>
<li>日期格式：YYYY-MM-DD</li>
<li>时间格式：HH:<zero-width space>MM:SS</li>
</ul>
<p>ADDDATE()	增加一个日期（天、周等）<br>
ADDTIME()	增加一个时间（时、分等）<br>
CURDATE()	返回当前日期<br>
CURTIME()	返回当前时间<br>
DATE()	返回日期时间的日期部分<br>
DATEDIFF()	计算两个日期之差<br>
DATE_ADD()	高度灵活的日期运算函数<br>
DATE_FORMAT()	返回一个格式化的日期或时间串<br>
DAY()	返回一个日期的天数部分<br>
DAYOFWEEK()	对于一个日期，返回对应的星期几<br>
HOUR()	返回一个时间的小时部分<br>
MINUTE()	返回一个时间的分钟部分<br>
MONTH()	返回一个日期的月份部分<br>
NOW()	返回当前日期和时间<br>
SECOND()	返回一个时间的秒部分<br>
TIME()	返回一个日期时间的时间部分<br>
YEAR()	返回一个日期的年份部分</p>
<pre tabindex="0"><code>mysql&gt; SELECT NOW();
2018-4-14 20:25:11
</code></pre><h4 id="数值处理">数值处理</h4>
<p>SIN()	正弦
COS()	余弦
TAN()	正切
ABS()	绝对值
SQRT()	平方根
MOD()	余数
EXP()	指数
PI()	圆周率
RAND()	随机数</p>
<h3 id="十三分组">十三、分组</h3>
<p>把具有相同的数据值的行放在同一组中。</p>
<p>可以对同一分组数据使用汇总函数进行处理，例如求分组数据的平均值等。</p>
<p>指定的分组字段除了能按该字段进行分组，也会自动按该字段进行排序。</p>
<pre tabindex="0"><code>SELECT col, COUNT(*) AS num
FROM mytable
GROUP BY col;
</code></pre><p>GROUP BY 自动按分组字段进行排序，ORDER BY 也可以按汇总字段来进行排序。</p>
<pre tabindex="0"><code>SELECT col, COUNT(*) AS num
FROM mytable
GROUP BY col
ORDER BY num;
</code></pre><p>分组规定：</p>
<ul>
<li>GROUP BY 子句出现在 WHERE 子句之后，ORDER BY 子句之前；</li>
<li>除了汇总字段外，SELECT 语句中的每一字段都必须在 GROUP BY 子句中给出；</li>
<li>NULL 的行会单独分为一组；</li>
<li>大多数 SQL 实现不支持 GROUP BY 列具有可变长度的数据类型。</li>
</ul>
<h3 id="十四子查询">十四、子查询</h3>
<p>子查询中只能返回一个字段的数据。</p>
<p>可以将子查询的结果作为 WHRER 语句的过滤条件：</p>
<pre tabindex="0"><code>SELECT *
FROM mytable1
WHERE col1 IN (SELECT col2 FROM mytable2);
</code></pre><p>下面的语句可以检索出客户的订单数量，子查询语句会对第一个查询检索出的每个客户执行一次：</p>
<pre tabindex="0"><code>SELECT cust_name, (SELECT COUNT(*)
                   FROM Orders
                   WHERE Orders.cust_id = Customers.cust_id)
                   AS orders_num
FROM Customers
ORDER BY cust_name;
</code></pre><h3 id="十五连接">十五、连接</h3>
<p>连接用于连接多个表，使用 JOIN 关键字，并且条件语句使用 ON 而不是 WHERE。</p>
<p>连接可以替换子查询，并且比子查询的效率一般会更快。</p>
<p>可以用 AS 给列名、计算字段和表名取别名，给表名取别名是为了简化 SQL 语句以及连接相同表。</p>
<h4 id="内连接">内连接</h4>
<p>内连接又称等值连接，使用 INNER JOIN 关键字。</p>
<pre tabindex="0"><code>SELECT A.value, B.value
FROM tablea AS A INNER JOIN tableb AS B
ON A.key = B.key;
</code></pre><p>可以不明确使用 INNER JOIN，而使用普通查询并在 WHERE 中将两个表中要连接的列用等值方法连接起来。</p>
<pre tabindex="0"><code>SELECT A.value, B.value
FROM tablea AS A, tableb AS B
WHERE A.key = B.key;
</code></pre><h3 id="自连接">自连接</h3>
<p>自连接可以看成内连接的一种，只是连接的表是自身而已。</p>
<p>一张员工表，包含员工姓名和员工所属部门，要找出与 Jim 处在同一部门的所有员工姓名。</p>
<p>子查询版本</p>
<pre tabindex="0"><code>SELECT name
FROM employee
WHERE department = (
      SELECT department
      FROM employee
      WHERE name = &quot;Jim&quot;);
</code></pre><p>自连接版本</p>
<pre tabindex="0"><code>SELECT e1.name
FROM employee AS e1 INNER JOIN employee AS e2
ON e1.department = e2.department
      AND e2.name = &quot;Jim&quot;;
</code></pre><h4 id="自然连接">自然连接</h4>
<p>自然连接是把同名列通过等值测试连接起来的，同名列可以有多个。</p>
<p>内连接和自然连接的区别：内连接提供连接的列，而自然连接自动连接所有同名列。</p>
<pre tabindex="0"><code>SELECT A.value, B.value
FROM tablea AS A NATURAL JOIN tableb AS B;
</code></pre><h4 id="外连接">外连接</h4>
<p>外连接保留了没有关联的那些行。分为左外连接，右外连接以及全外连接，左外连接就是保留左表没有关联的行。</p>
<h3 id="十六组合查询">十六、组合查询</h3>
<p>使用 UNION 来组合两个查询，如果第一个查询返回 M 行，第二个查询返回 N 行，那么组合查询的结果一般为 M+N 行。</p>
<p>每个查询必须包含相同的列、表达式和聚集函数。</p>
<p>默认会去除相同行，如果需要保留相同行，使用 UNION ALL。</p>
<p>只能包含一个 ORDER BY 子句，并且必须位于语句的最后。</p>
<pre tabindex="0"><code>SELECT col
FROM mytable
WHERE col = 1
UNION
SELECT col
FROM mytable
WHERE col =2;
</code></pre><h3 id="十七视图">十七、视图</h3>
<p>视图是虚拟的表，本身不包含数据，也就不能对其进行索引操作。</p>
<p>对视图的操作和对普通表的操作一样。</p>
<p>视图具有如下好处：</p>
<ul>
<li>简化复杂的 SQL 操作，比如复杂的连接；</li>
<li>只使用实际表的一部分数据；</li>
<li>通过只给用户访问视图的权限，保证数据的安全性；</li>
<li>更改数据格式和表示。</li>
</ul>
<pre tabindex="0"><code>CREATE VIEW myview AS
SELECT Concat(col1, col2) AS concat_col, col3*col4 AS compute_col
FROM mytable
WHERE col5 = val;
</code></pre><h3 id="十八存储过程">十八、存储过程</h3>
<p>存储过程可以看成是对一系列 SQL 操作的批处理。</p>
<p>使用存储过程的好处：</p>
<ul>
<li>代码封装，保证了一定的安全性；</li>
<li>代码复用；</li>
<li>由于是预先编译，因此具有很高的性能。
命令行中创建存储过程需要自定义分隔符，因为命令行是以 ; 为结束符，而存储过程中也包含了分号，因此会错误把这部分分号当成是结束符，造成语法错误。</li>
</ul>
<p>包含 in、out 和 inout 三种参数。</p>
<p>给变量赋值都需要用 select into 语句。</p>
<p>每次只能给一个变量赋值，不支持集合的操作。</p>
<pre tabindex="0"><code>delimiter //

create procedure myprocedure( out ret int )
    begin
        declare y int;
        select sum(col1)
        from mytable
        into y;
        select y*y into ret;
    end //

delimiter ;
</code></pre><pre tabindex="0"><code>call myprocedure(@ret);
select @ret;
</code></pre><h3 id="十九游标">十九、游标</h3>
<p>在存储过程中使用游标可以对一个结果集进行移动遍历。</p>
<p>游标主要用于交互式应用，其中用户需要对数据集中的任意行进行浏览和修改。</p>
<p>使用游标的四个步骤：</p>
<ul>
<li>声明游标，这个过程没有实际检索出数据；</li>
<li>打开游标；</li>
<li>取出数据；</li>
<li>关闭游标；</li>
</ul>
<pre tabindex="0"><code>delimiter //
create procedure myprocedure(out ret int)
    begin
        declare done boolean default 0;

        declare mycursor cursor for
        select col1 from mytable;
        # 定义了一个 continue handler，当 sqlstate '02000' 这个条件出现时，会执行 set done = 1
        declare continue handler for sqlstate '02000' set done = 1;

        open mycursor;

        repeat
            fetch mycursor into ret;
            select ret;
        until done end repeat;

        close mycursor;
    end //
 delimiter ;
</code></pre><h3 id="二十触发器">二十、触发器</h3>
<p>触发器会在某个表执行以下语句时而自动执行：DELETE、INSERT、UPDATE。</p>
<p>触发器必须指定在语句执行之前还是之后自动执行，之前执行使用 BEFORE 关键字，之后执行使用 AFTER 关键字。BEFORE 用于数据验证和净化，AFTER 用于审计跟踪，将修改记录到另外一张表中。</p>
<p>INSERT 触发器包含一个名为 NEW 的虚拟表。</p>
<pre tabindex="0"><code>CREATE TRIGGER mytrigger AFTER INSERT ON mytable
FOR EACH ROW SELECT NEW.col into @result;

SELECT @result; -- 获取结果
</code></pre><p>DELETE 触发器包含一个名为 OLD 的虚拟表，并且是只读的。</p>
<p>UPDATE 触发器包含一个名为 NEW 和一个名为 OLD 的虚拟表，其中 NEW 是可以被修改的，而 OLD 是只读的。</p>
<p>MySQL 不允许在触发器中使用 CALL 语句，也就是不能调用存储过程。</p>
<h3 id="二十一事务管理">二十一、事务管理</h3>
<p>基本术语：</p>
<ul>
<li>事务（transaction）指一组 SQL 语句；</li>
<li>回退（rollback）指撤销指定 SQL 语句的过程；</li>
<li>提交（commit）指将未存储的 SQL 语句结果写入数据库表；</li>
<li>保留点（savepoint）指事务处理中设置的临时占位符（placeholder），你可* 以对它发布回退（与回退整个事务处理不同）。</li>
</ul>
<p>不能回退 SELECT 语句，回退 SELECT 语句也没意义；也不能回退 CREATE 和 DROP 语句。</p>
<p>MySQL 的事务提交默认是隐式提交，每执行一条语句就把这条语句当成一个事务然后进行提交。当出现 START TRANSACTION 语句时，会关闭隐式提交；当 COMMIT 或 ROLLBACK 语句执行后，事务会自动关闭，重新恢复隐式提交。</p>
<p>设置 autocommit 为 0 可以取消自动提交；autocommit 标记是针对每个连接而不是针对服务器的。</p>
<p>如果没有设置保留点，ROLLBACK 会回退到 START TRANSACTION 语句处；如果设置了保留点，并且在 ROLLBACK 中指定该保留点，则会回退到该保留点。</p>
<pre tabindex="0"><code>START TRANSACTION
// ...
SAVEPOINT delete1
// ...
ROLLBACK TO delete1
// ...
COMMIT
</code></pre><h3 id="二十二字符集">二十二、字符集</h3>
<p>基本术语：</p>
<ul>
<li>字符集为字母和符号的集合；</li>
<li>编码为某个字符集成员的内部表示；</li>
<li>校对字符指定如何比较，主要用于排序和分组。</li>
</ul>
<p>除了给表指定字符集和校对外，也可以给列指定：</p>
<pre tabindex="0"><code>CREATE TABLE mytable
(col VARCHAR(10) CHARACTER SET latin COLLATE latin1_general_ci )
DEFAULT CHARACTER SET hebrew COLLATE hebrew_general_ci;
</code></pre><p>可以在排序、分组时指定校对：</p>
<pre tabindex="0"><code>SELECT *
FROM mytable
ORDER BY col COLLATE latin1_general_ci;
</code></pre><h3 id="二十三权限管理">二十三、权限管理</h3>
<p>MySQL 的账户信息保存在 mysql 这个数据库中。</p>
<pre tabindex="0"><code>USE mysql;
SELECT user FROM user;
</code></pre><p>创建账户</p>
<p>新创建的账户没有任何权限。</p>
<pre tabindex="0"><code>CREATE USER myuser IDENTIFIED BY 'mypassword';
</code></pre><p>修改账户名</p>
<pre tabindex="0"><code>RENAME USER myuser TO newuser;
</code></pre><p>删除账户</p>
<pre tabindex="0"><code>DROP USER myuser;
</code></pre><p>查看权限</p>
<pre tabindex="0"><code>SHOW GRANTS FOR myuser;
</code></pre><p>授予权限</p>
<p>账户用 username@host 的形式定义，username@% 使用的是默认主机名。</p>
<pre tabindex="0"><code>GRANT SELECT, INSERT ON mydatabase.* TO myuser;
</code></pre><p>删除权限</p>
<p>GRANT 和 REVOKE 可在几个层次上控制访问权限：</p>
<ul>
<li>整个服务器，使用 GRANT ALL 和 REVOKE ALL；</li>
<li>整个数据库，使用 ON database.*；</li>
<li>特定的表，使用 ON database.table；</li>
<li>特定的列；</li>
<li>特定的存储过程。</li>
</ul>
<pre tabindex="0"><code>REVOKE SELECT, INSERT ON mydatabase.* FROM myuser;
</code></pre><p>更改密码</p>
<p>必须使用 Password() 函数进行加密。</p>
<pre tabindex="0"><code>SET PASSWROD FOR myuser = Password('new_password');
</code></pre>
        
        ]]>
      </description>
    </item>
    
    
    
    <item>
      <title>Linux 不同发行版的选择</title>
      <link>/post/2020/12/26/linux-%E4%B8%8D%E5%90%8C%E5%8F%91%E8%A1%8C%E7%89%88%E7%9A%84%E9%80%89%E6%8B%A9/</link>
      <pubDate>Sat, 26 Dec 2020 22:33:13 +0800</pubDate>
      <author>罗泽勋</author>
      <guid>/post/2020/12/26/linux-%E4%B8%8D%E5%90%8C%E5%8F%91%E8%A1%8C%E7%89%88%E7%9A%84%E9%80%89%E6%8B%A9/</guid>
      <description>
        <![CDATA[
        <p>如果你对 Linux 感兴趣但还不了解，想知道 Linux 的不同发行版之间的区别，我的这些经历应该对你有帮助。</p>
<p>我最初使用的是 Ubuntu，它以前经常被推荐为 Linux 入门选择。用了很长一段时间，它给我最大的感受是不稳定和笨重。会经常收到系统内部崩溃的通知，而且另一个问题是装其他显卡驱动时很艰难（做深度学习、玩游戏等等会用到），令我几度崩溃 T_T 。所以，我认为 Ubuntu 对新手非常不友好；</p>
<p>后来我开始尝试 Deepin 系统，这是一款由国内深之度公司推出的发行版，预装软件最符合国人习惯，而且上手简单，系统不需要怎么配置就能拥有漂亮的界面。但是很快我就不能忍受它的软件源的落后。软件获取、维护便捷本该是 Linux 系统的一大优点，它可以为很多工作带来便利。</p>
<p>接着我来到 Arch 的世界。遗憾的是 Arch Linux 我在尝试的中途便放弃了。它确实很棒，从零开始定制操作系统很诱人，但是因为时间关系，我需要的是能快速上手，成为主力的操作系统。</p>
<p>最后，我接触到了很多人推荐的 Manjaro，它是为了让用户更方便使用的 Arch 衍生版。安装之后确实让我很惊喜，它完美符合我对操作系统的需求：上手简单、使用高效、美。而且尝试过后我才知道 Arch 系的软件仓库 AUR 有多强大。AUR 是一个社区维护的软件包仓库，有了它，你可以轻易获取到很多想要的软件。因此我很推荐使用 Manjaro。</p>
<p>（顺便提一下最稳定发行版之一的 CentOS。当我想在服务器上尝试它时，它就被官宣抛弃了……）</p>

        
        ]]>
      </description>
    </item>
    
    
    
    <item>
      <title>Java 虚拟机</title>
      <link>/post/2020/12/25/java-%E8%99%9A%E6%8B%9F%E6%9C%BA/</link>
      <pubDate>Fri, 25 Dec 2020 15:06:19 +0800</pubDate>
      <author>罗泽勋</author>
      <guid>/post/2020/12/25/java-%E8%99%9A%E6%8B%9F%E6%9C%BA/</guid>
      <description>
        <![CDATA[
        <p>参考自 <a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md">CyC2018/CS-Notes</a></p>
<ul>
<li><a href="#1">一、运行时数据区域</a>
<ul>
<li><a href="#1.1">程序计数器</a></li>
<li><a href="#1.2">Java 虚拟机栈</a></li>
<li><a href="#1.3">本地方法栈</a></li>
<li><a href="#1.4">堆</a></li>
<li><a href="#1.5">方法区</a></li>
<li><a href="#1.6">运行时常量池</a></li>
<li><a href="#1.7">直接内存</a></li>
</ul>
</li>
<li><a href="#2">二、垃圾收集</a>
<ul>
<li><a href="#2.1">判断一个对象是否可被回收</a></li>
<li><a href="#2.2">引用类型</a></li>
<li><a href="#2.3">垃圾收集算法</a></li>
<li><a href="#2.4">垃圾收集器</a></li>
</ul>
</li>
<li><a href="#3">三、内存分配和回收策略</a>
<ul>
<li><a href="#3.1">Minor Gc 和 Full Gc</a></li>
<li><a href="#3.2">内存分配策略</a></li>
<li><a href="#3.3">Full GC 的触发条件</a></li>
</ul>
</li>
<li><a href="#4">四、类加载机制</a>
<ul>
<li><a href="#4.1">类的生命周期</a></li>
<li><a href="#4.2">类加载过程</a></li>
<li><a href="#4.3">类初始化时机</a></li>
<li><a href="#4.4">类与类加载器</a></li>
<li><a href="#4.5">类加载器分类</a></li>
<li><a href="#4.6">双亲委派模型</a></li>
<li><a href="#4.7">自定义类加载器实现</a></li>
</ul>
</li>
</ul>
<h3 id="一运行时数据区域-a-name1a">一、运行时数据区域 <a name="1"></a></h3>
<h4 id="程序计数器-a-name11a">程序计数器 <a name="1.1"></a></h4>
<p>记录正在执行的虚拟机字节码指令的地址（如果正在执行的是本地方法则为空）。</p>
<h4 id="java-虚拟机栈-a-name12a">Java 虚拟机栈 <a name="1.2"></a></h4>
<p>每个 Java方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</p>
<p>可以通过 -Xss 这个虚拟机参数来指定每个线程的 Java 虚拟机栈内存大小，在 JDK 1.4 中默认为 256K，而在 JDK1.5+ 默认为 1M：</p>
<pre tabindex="0"><code>java -Xss2M HaskTheJava
</code></pre><p>该区域可能抛出以下异常：</p>
<ul>
<li>当线程请求的栈深度超过最大值，会抛出 StackOverflowError 异常；</li>
<li>栈进行动态扩展的时如果无法申请到足够的内存，会抛出 OutofMemoryError 异常。</li>
</ul>
<h4 id="本地方法栈a-name13a">本地方法栈<a name="1.3"></a></h4>
<p>本地方法栈与 Java 虚拟机栈类似，他们之间的区别只不过是本地方法栈为本地方法服务。<br>
本地方法一般是用其他语言（C、C++或汇编语言等等）编写的，并且被编译为基于本机硬件和操作系统的程序，对待这些方法需要特别处理。</p>
<h4 id="堆-a-name14a">堆 <a name="1.4"></a></h4>
<p>所有对象都在这里分配内存，是垃圾收集的主要区域（&ldquo;GC堆&rdquo;）。<br>
现代的垃圾收集器基本都是采用分代收集算法，其主要的思想是针对不同类型的对象采用不同的垃圾回收算法。可以将堆分成两块：</p>
<ul>
<li>新生代</li>
<li>老年代</li>
</ul>
<p>堆不需要连续内存，并且可以动态增加其内存，增加失败会抛出 OutOfMemoryError 异常。</p>
<p>可以通过 -Xms 和 -Xmx 这两个虚拟机参数来指定一个程序的堆内存大小，第一个参数设置初始值，第二个参数设置最大值。</p>
<pre tabindex="0"><code>java -Xms1M -Xmx2M HackTheJava
</code></pre><h4 id="方法区a-name15a">方法区<a name="1.5"></a></h4>
<p>用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
<p>和堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出 OutOfMemoryError 异常。</p>
<p>对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载，但是一般比较难实现。</p>
<p>HotSpot 虚拟机把它当成永久代来进行垃圾回收。但很难确定永久代的大小，因为它受到很多因素影响，并且每次 Full GC 之后永久代的大小都会改变，所以经常会抛出 OutOfMemoryError 异常。为了更容易管理方法区，从 JDK 1.8 开始，移除永久代，并把方法区移至元空间，它位于本地内存，而不是虚拟机内存。<br>
方法区是一个 JVM 规范，永久代与元空间都是其一种实现方式。在 JDK 1.8 之后，原来永久代的数据被分到了堆和元空间中。元空间存储类的元信息，静态变量和常量池等放入堆中。</p>
<h4 id="运行时常量池a-name16a">运行时常量池<a name="1.6"></a></h4>
<p>运行时常量池是方法区的一部分。</p>
<p>Class 文件中的常量池（编译器生成的字面量和符号引用）会在类加载后被放入这个区域。</p>
<p>除了在编译期生成的常量，还允许动态生成，例如 String 类的 intern()。</p>
<h4 id="直接内存a-name17a">直接内存<a name="1.7"></a></h4>
<p>在 JDK 1.4 中新引入了 NIO 类，它可以使用 Native 函数库直接分配堆外内存。</p>
<h3 id="二垃圾回收a-name2a">二、垃圾回收<a name="2"></a></h3>
<p>垃圾收集主要是针对堆和方法区进行。程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期，线程结束之后就会消失，因此不需要对这三个区域进行垃圾回收。</p>
<h4 id="判断一个对象是否可被回收a-name21a">判断一个对象是否可被回收<a name="2.1"></a></h4>
<h5 id="1引用技术算法">1.引用技术算法</h5>
<p>（相互引用时，两个对象都无法被回收）</p>
<h5 id="2可达性分析">2.可达性分析</h5>
<p>以 GC Roots为起始点进行搜索，可达的对象都是存活的，不可达的对象可被回收。
Java 虚拟机使用该算法来判断对象是否可被回收，GC Roots 一般包含以下内容：</p>
<ul>
<li>虚拟机栈中局部变量表中引用的对象</li>
<li>本地方法栈 JNI 中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中的常量引用的对象</li>
</ul>
<h5 id="3方法区的回收">3.方法区的回收</h5>
<p>因为方法区主要存放永久代对象，而永久代对象的回收率比新生代低很多，所有在方法区上进行回收性价比不高。</p>
<p>主要是对常量池的回收和对类的卸载。</p>
<h5 id="4finalize">4.finalize()</h5>
<p>类似 C++ 的析构函数，用于关闭外部资源。最好别用，用try-finally等。</p>
<h4 id="引用类型a-name22a">引用类型<a name="2.2"></a></h4>
<h5 id="1强引用">1.强引用</h5>
<p>被强引用关联的对象不会被回收。</p>
<p>使用 new 一个新对象来创建强引用。</p>
<h5 id="2软引用">2.软引用</h5>
<h5 id="3弱引用">3.弱引用</h5>
<h5 id="4虚引用">4.虚引用</h5>
<h4 id="垃圾收集算法a-name23a">垃圾收集算法<a name="2.3"></a></h4>
<h5 id="1标记-清除">1.标记-清除</h5>
<h5 id="2标记-整理">2.标记-整理</h5>
<h5 id="3复制">3.复制</h5>
<h5 id="4分代收集">4.分代收集</h5>
<p>根据对象存活周期将内存划分为几块，不痛块采用适当的收集算法。</p>
<p>一般将堆分为新生代和老生代。</p>
<ul>
<li>新生代使用：复制算法</li>
<li>老生代使用：标记-清除 或者 标记-整理 算法</li>
</ul>
<h3 id="四类加载机制a-name4a">四、类加载机制<a name="4"></a></h3>
<p>类是在运行期间第一次使用时动态加载的，而不是一次性加载所有类。因为如果一次性加载，那么会占用很多的内存。</p>
<h4 id="类的生命周期a-name41a">类的生命周期<a name="4.1"></a></h4>
<p>包括以下阶段：</p>
<ul>
<li>加载</li>
<li>验证</li>
<li>准备</li>
<li>解析</li>
<li>初始化</li>
<li>使用</li>
<li>卸载</li>
</ul>

        
        ]]>
      </description>
    </item>
    
    
    
    <item>
      <title>Java 容器</title>
      <link>/post/2020/12/24/java-%E5%AE%B9%E5%99%A8/</link>
      <pubDate>Thu, 24 Dec 2020 16:47:24 +0800</pubDate>
      <author>罗泽勋</author>
      <guid>/post/2020/12/24/java-%E5%AE%B9%E5%99%A8/</guid>
      <description>
        <![CDATA[
        <p>参考自 <a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%AE%B9%E5%99%A8.md">CyC2018/CS-Notes</a></p>
<ul>
<li><a href="#1">一、概览</a>
<ul>
<li><a href="#1.1">Collection</a></li>
<li><a href="#1.2">Map</a></li>
</ul>
</li>
</ul>
<!-- * [二、容器中的设计模式]
    * [迭代器模式](#2.1)
    * [适配器模式](#2.2)
* [三、源码分析](#3)
    * [ArrayList](#3.1)
    * [Vector](#3.2)
    * [CopyOnWriteArrayList](#3.3)
    * [LinkedList](#3.4)
    * [HashMap](#3.5)
    * [ConcurrentHashMap](#3.6)
    * [LinkedHashMap](#3.7)
    * [WeakHashMap](#3.8) -->
<h3 id="一概览-a-name1a">一、概览 <a name="1"></a></h3>
<p>容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map存储着键值对（两个对象）的映射表。</p>
<h4 id="collection-a-name11a">Collection <a name="1.1"></a></h4>
<p><strong>1.Set</strong></p>
<ul>
<li>TreeSet: 基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet, HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。</li>
<li>HashSet: 基于哈希表的实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。</li>
<li>LinkedHashSet: 具有 HashSet 的查找效率，并且内部使用双向链表维护元素的插入顺序。</li>
</ul>
<p><strong>2.List</strong></p>
<ul>
<li>ArrayList： 基于动态数组实现，支持随机访问。</li>
<li>Vector： 和 ArrayList 类似，但它是线程安全的。</li>
<li>LinkedList： 基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用做栈、队列和双向队列。</li>
</ul>
<p><strong>3.Queue</strong></p>
<ul>
<li>LinkedList：可以用它来实现双向队列。</li>
<li>PriorityQueue：基于堆结构实现，可以用它来实现优先队列。</li>
</ul>
<h4 id="map-a-name12a">Map <a name="1.2"></a></h4>
<ul>
<li>TreeMap：基于红黑树实现</li>
<li>HashMap：基于哈希表实现</li>
<li>hashTable：和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程同时写入 HashTable 不会导致数据不一致。它是遗留类，不应该去使用它，而是使用 ConcurrentHashMap 来支持线程安全，ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。</li>
<li>LinkedHashMap：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。</li>
</ul>

        
        ]]>
      </description>
    </item>
    
    
    
    <item>
      <title>String 类真的不可以改变吗？</title>
      <link>/post/2020/12/15/string-%E7%B1%BB%E7%9C%9F%E7%9A%84%E4%B8%8D%E5%8F%AF%E4%BB%A5%E6%94%B9%E5%8F%98%E5%90%97/</link>
      <pubDate>Tue, 15 Dec 2020 15:05:27 +0800</pubDate>
      <author>罗泽勋</author>
      <guid>/post/2020/12/15/string-%E7%B1%BB%E7%9C%9F%E7%9A%84%E4%B8%8D%E5%8F%AF%E4%BB%A5%E6%94%B9%E5%8F%98%E5%90%97/</guid>
      <description>
        <![CDATA[
        <p>对于 java.lang.String 类，我相信很多人印象里都是它不能被改变。通过查看源码，可以知道 String 有一个 final char 数组的变量，这个变量初始化之后便不能重新赋值。虽然这个变量引用的 char 数组的值虽然可以改变，但是String 类中并没有主动修改 这个 char 数组的方法。这就是通常所说 String 类不可变的依据。</p>
<p>然而在学习反射的时候，我产生了一个疑问：我们不可以通过反射修改 String 内部的 char 数组的值吗？答案是可以的，了解 Java 反射的人很容易就做到这点。那为什么还说 String 不可变呢？在思考过后，我得出一个答案：String 的不可变说的是一种约束规范。换句话说，String 的不可变是有好处的。在实际工作中，代码是自己写来用的，没有人会费劲给自己找麻烦，而没有任何益处。</p>
<p>事情到这里就完了？不，最近我再去了解 String 、String Pool（字符串常量池）的时候，又有了一些疑惑，于是亲手操刀给String 来了一次手术。最后也是加深了对 String 的理解，也验证了上面的观点。先上代码（如果你对任一实验结果感到疑惑，没关系，请带着疑惑来看后面的对照实验）：</p>
<pre tabindex="0"><code>    //实验1
    String s1 = &quot;1&quot;;
    Field valueField = String.class.getDeclaredField(&quot;value&quot;);
    valueField.setAccessible(true);
    char[] value = (char[]) valueField.get(s1);
    value[0] = '2';
    System.out.println(s1);                 //2
    System.out.println((s1 == &quot;1&quot;));        //true
</code></pre><p>上述实验 1 做的事情就是：用 <code>s1 = &quot;1&quot; </code> 的方式创建字符串，用反射修改它的值为 <code>&quot;2&quot;</code>,最后用它与 <code>&quot;1&quot;</code> 比较，结果是 <code>true</code> 。琢磨琢磨，再看下一段代码：</p>
<pre tabindex="0"><code>    //实验2
    String s2 = new String(&quot;1&quot;);
    Field valueField = String.class.getDeclaredField(&quot;value&quot;);
    valueField.setAccessible(true);
    char[] value2 = (char[]) valueField.get(s2);
    value2[0] = '2';
    System.out.println(s2);                //2
    System.out.println((s2 == &quot;1&quot;));       //false
</code></pre><p>上述实验 2 和实验 1 唯一的区别是字符串创建方式，实验2是通过 <code>new String(&quot;1&quot;)</code> 方式创建，实验1是通过 <code>= &quot;1&quot;</code> 的方式创建。而实验2的结果： <code>s2 == &quot;1&quot;</code> 是 <code>false</code> 。</p>
<p>到这里，可以停一会了。很多技术文章中都做过类似上面的实验（通过比较创建方式的区别、反射修改等)，来分析 String 、String Pool 的原理和设计理念。但我总觉得以此说明最终的结论还不够严谨、或者说还不够直观。接下来请看——魔鬼实验：</p>
<pre tabindex="0"><code>    //实验3 
    String s1 = &quot;1&quot;;
    Field valueField = String.class.getDeclaredField(&quot;value&quot;);
    valueField.setAccessible(true);
    char[] value = (char[]) valueField.get(s1);
    value[0] = '2';
    System.out.println(s1);                 //2
    System.out.println((s1 == &quot;1&quot;));        //true
    System.out.println(&quot;1&quot;);                //2
</code></pre><p>不难发现，实验3仅仅只是在实验1的基础上输出了 <code>&quot;1&quot;</code> 的值。然而 <code>&quot;1&quot;</code> 输出的值为 2，这样的结果，也许有人会困惑，没关系,看完几个对比实验，相信你会对相关理论（String 、String Pool 等）有了更直观的认识。接下来，请看终极实验：</p>
<pre tabindex="0"><code>    //实验4
    String s2 = new String(&quot;1&quot;);
    Field valueField = String.class.getDeclaredField(&quot;value&quot;);
    valueField.setAccessible(true);
    char[] value2 = (char[]) valueField.get(s2);
    value2[0] = '2';
    System.out.println(s2);                 //2
    System.out.println((s2 == &quot;1&quot;));        //false
    System.out.println(&quot;1&quot;);                //2
</code></pre><p>同样的，上述实验 4 只是在实验 2 的基础上输出了 <code>&quot;1&quot;</code> 的值。结果 <code>&quot;1&quot;</code> 的值还是 2。</p>
<p><strong>结论：</strong><br>
基于对 String 类和字符串常量池（String Pool） 的了解，我对以上实验作出解释（详细理论下回贴出）:</p>
<p>实验 3 中 字符串 <code>s1</code> 通过直接赋值字符串常量 <code>&quot;1&quot;</code> 的方式创建，因此 <strong><code>s1</code> 会直接引用字符串常量池中 <code>&quot;1&quot;</code> 对应的对象</strong>。对 <code>s1</code> 的修改，也就是对常量池中 <code>&quot;1&quot;</code> 对象的修改，因此 <code>s1</code> 和 <code>&quot;1&quot;</code> 的值都是修改后的 2，而 <code>s1 == &quot;1&quot;</code> 也是 <code>true</code>,因为它们是同一个对象的引用。</p>
<p>实验 4 中 字符串 <code>s2</code> 通过 <code>new String(&quot;1&quot;)</code>的方式创建，因此，<strong><code>s2</code> 会被新建在堆中，并且，<code>s2</code> 的 <code>char</code> 数组变量会直接引用字符串常量池中 &ldquo;1&quot;对象的 <code>char</code> 数组</strong>，也就是说虽然 <code>s2</code> 是新创建的对象，但是 <code>s2</code> 里存储字符的 <code>char</code> 数组是创建时传进来的字符串常量 <code>&quot;1&quot;</code> 的 <code>char</code> 数组。因此，<code>s2</code> 修改 <code>char</code> 数组,<code>&quot;1&quot;</code> 的也会变。<code>s2</code> 和 <code>&quot;1&quot;</code> 的值都是修改后的 2 。而 <code>s2 == &quot;1&quot;</code> 是 <code>false</code> 的，因为它们引用的不是同一个对象。</p>
<p>最终结论，String 类真的是“不可以”变的！因为这不仅仅是它的特点，更是它的设计初衷。（<del>任何想通过反射修改它的人都应该被拉去祭天</del>)</p>
<p>如果你发现任何问题，请<a href="/about">联系</a>我。</p>

        
        ]]>
      </description>
    </item>
    
    
    
    <item>
      <title>Java 基础</title>
      <link>/post/2020/12/15/java-%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Tue, 15 Dec 2020 08:32:26 +0800</pubDate>
      <author>罗泽勋</author>
      <guid>/post/2020/12/15/java-%E5%9F%BA%E7%A1%80/</guid>
      <description>
        <![CDATA[
        <p>参考自 <a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E5%9F%BA%E7%A1%80.md">CyC2018/CS-Notes</a></p>
<ul>
<li><a href="#1">一、数据类型</a>
<ul>
<li><a href="#1.1">基本类型</a></li>
<li><a href="#1.2">包装类型</a></li>
<li><a href="#1.3">缓存池</a></li>
</ul>
</li>
<li><a href="#2">二、String</a>
<ul>
<li><a href="#2.1">概述</a></li>
<li><a href="#2.2">不可变的好处</a></li>
<li><a href="#2.3">String,StringBuffer and StringBuilder</a></li>
<li><a href="#2.4">StringPoll</a></li>
<li><a href="#2.5">new String(&ldquo;abc&rdquo;)</a></li>
</ul>
</li>
<li><a href="#3">三、运算</a>
<ul>
<li><a href="#3.1">参数传递</a></li>
<li><a href="#3.2">float与double</a></li>
<li><a href="#3.3">隐式类型转换</a></li>
<li><a href="#3.4">switch</a></li>
</ul>
</li>
<li><a href="#4">四、关键字</a>
<ul>
<li><a href="#4.1">final</a></li>
<li><a href="#4.2">static</a></li>
</ul>
</li>
<li><a href="#5">五、Object通用方法</a>
<ul>
<li><a href="#5.1">概览</a></li>
<li><a href="#5.2">equals()</a></li>
<li><a href="#5.3">hashCode()</a></li>
<li><a href="#5.4">toString()</a></li>
<li><a href="#5.5">clone()</a></li>
</ul>
</li>
<li><a href="#6">六、继承</a>
<ul>
<li><a href="#6.1">访问权限</a></li>
<li><a href="#6.2">抽象类和接口</a></li>
<li><a href="#6.3">super</a></li>
<li><a href="#6.4">重载和重写</a></li>
</ul>
</li>
<li><a href="#7">七、反射</a></li>
<li><a href="#8">八、异常</a></li>
<li><a href="#9">九、泛型</a></li>
<li><a href="#10">十、注解</a></li>
<li><a href="#11">十一、特性</a></li>
</ul>
<h3 id="一数据类型-a-name1a">一、数据类型 <a name="1"></a></h3>
<h4 id="基本类型-a-name11a">基本类型 <a name="1.1"></a></h4>
<ul>
<li>byte/8</li>
<li>char/16</li>
<li>short/16</li>
<li>int/32</li>
<li>float/32</li>
<li>long/64</li>
<li>double/64</li>
<li>boolean/~</li>
</ul>
<p>boolean 只有两个值：true、flase,可以使用 1 bit 来存储，但是具体大小没有明确规定。JVM 会在编译时期将 boolean 类型的数据转换为 int，使用 1 来表示 true， 0 表示 false。JVM 支持 boolean 数组，但是是通过读写 byte 数组来实现的。</p>
<h4 id="包装类型-a-name12a">包装类型 <a name="1.2"></a></h4>
<p>基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱和拆箱完成。</p>
<pre tabindex="0"><code>Integer x = 2;  //装箱 调用了 Integer.valueOf(2)
int y = x;  //  拆箱 调用了 x.intValue()
</code></pre><h4 id="缓存池-a-name13a">缓存池 <a name="1.3"></a></h4>
<p>new Integer(123) 与 Integer.valueOf(123)的区别在于：</p>
<ul>
<li>new Integer(123) 每次都会创建一个对象；</li>
<li>Integer.valueOf(123) 会使用缓存池中的对象，调用会取得同一个对象的引用。</li>
</ul>
<pre tabindex="0"><code>Integer x = new Integer(123);
Integer y = new Integer(123);
System.out.println(x == y);     //false
Integer z = Integer.valueOf(123);
Integer k = Integer.valueOf(123);
System.out.println(z == k);     //true
</code></pre><p>valueOf() 方法的实现，就是先判断值是否存在缓存池中，如果在的话就直接返回缓存池的内容。</p>
<pre tabindex="0"><code>public static Integer valueOf(int i){
    if(i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high){
        return IntegerCache.cache[i + (-IntegerCache.low)];
        return new Integer(i);
    }
}
</code></pre><p>在 Java 8 中，Integer 缓存池的大小默认为 -128~127。</p>
<p>编译器会在自动装箱过程中调用 valueOf()方法，因此多个值相同且值在缓存池范围内的 Integer 实例使用自动装箱来创建，那么就会引用相同的对象。</p>
<pre tabindex="0"><code>Integer m = 123;
Integer n = 123;
System.out.priintln(m == n);    //true
</code></pre><p>基本类型对应的缓冲池如下：</p>
<ul>
<li>boolean values true and false</li>
<li>all byte values</li>
<li>short values between -128 and 127</li>
<li>int values between -128 and 127</li>
<li>char in the range \u0000 to \u007F</li>
</ul>
<p>在使用这些基本类型对应的包装类型时，如果该数值范围在缓冲范围内，就可以直接使用缓冲池中的对象。<br>
在 JDK 1.8 所有的数值类型缓冲池中，Integer 的缓冲池 IntegerCache 很特殊，这个缓冲池的下界是 -128，上界默认是 127，但是这个上界是可以调的，在启动 JVM 的时候，通过 <code>-XX:AutoBoxCacheMax=&lt;size&gt;</code> 来指定 IntegerCache 的大小，该选项在 JVM 初始化的时候会设定一个名为 <code>java.lang.IntegerCache.high</code> 系统属性，然后 IntegerCache 初始化的时候就会读取该系统属性来决定上界。</p>
<h3 id="二string-a-name2a">二、String <a name="2"></a></h3>
<h4 id="概览a-name21a">概览<a name="2.1"></a></h4>
<p>String 被声明为 final,因此不可被继承。(Integer 等包装类也不能被继承)<br>
在 Java 8 中，String 内部使用 char 数组存储数据。</p>
<pre tabindex="0"><code>public final class String 
    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence {
    private final char value[];   
}
</code></pre><p>在 Java 9 之后，String 类的实现改用 byte 数组存储字符串，同时使用 <code>coder</code> 来标识使用的编码。</p>
<pre tabindex="0"><code>public final class String
    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence {
        private final byte[] value;
        private final byte coder;
    }
</code></pre><p>value 数组被声明为 final，这意味着 value 数组初始化之后就不能在引用其他数组，并且 String 内部没有改变 value 数组的方法。这些表明 String 不能更改的约束规范。实际上可以通过反射来修改 String 内部 value 数组的值，但是这样的做法毫无意义，而且会引发错误。</p>
<h4 id="不可变的好处a-name22a">不可变的好处<a name="2.2"></a></h4>
<p>1.可以缓存 hash 值</p>
<p>因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性使得 hash 值也不可变，因此只需要进行一次计算。</p>
<p>2.String Pool 的需要</p>
<p>如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。</p>
<p>3.安全性</p>
<p>String 经常作为参数，String 不可变性可以保证参数不可变。</p>
<p>4.线程安全</p>
<p>String 不可变性天生具备线程安全，可以在多个线程中安全使用。</p>
<h4 id="stringstringbufferand-stringbuildera-name23a">String,StringBuffer,and StringBuilder<a name="2.3"></a></h4>
<p>1.可变性</p>
<ul>
<li>String 不可变</li>
<li>StringBuffer 和 StringBuilder 可变</li>
</ul>
<p>2.线程安全</p>
<ul>
<li>String 不可变，因此是线程安全的</li>
<li>StringBuilder 不是线程安全的</li>
<li>StringBuffer 是线程安全的，内部使用 synchronized 进行同步</li>
</ul>
<h4 id="string-poola-name24a">String Pool<a name="2.4"></a></h4>
<p>字符串常量池(String Pool) 保存着所有字符串字面量(literal strings) ,这些字面量在编译时期就确定。不仅如此，还可以使用 String 的 intern() 方法在运行过程将字符串添加到 String Pool中。<br>
当一个字符串调用 intern() 方法时，如果 String Pool 中已存在一个字符串和该字符串相等(使用 equals() 方法进行确定)，那么就会返回 String Pool 中字符串的引用；否则，就会在 String Poll 中添加一个新的字符串，并返回这个新字符串的引用。</p>
<pre tabindex="0"><code>String s1 = new String(&quot;aaa&quot;);
String s2 = new String(&quot;aaa&quot;);
System.out.println(s1 == s2);    //false
String s3 = s1.intern();
String s4 = s2.intern();
System.out.println(s3 == s4);   //true
</code></pre><p>如果是采用 &ldquo;bbb&rdquo; 这种字面量的形式创建字符串，会自动将字符串放入 String Pool 中。</p>
<pre tabindex="0"><code>String s5 = &quot;bbb&quot;;
String s6 = &quot;bbb&quot;;
System.out.println(s5 == s6);   //true
</code></pre><p>在 Java 7 之前，String Pool被放在运行时常量池中，它属于永久代。而在 Java 7 ，String Pool 被移到堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误。</p>
<h4 id="new-stringabca-name25a">new String(&ldquo;abc&rdquo;)<a name="2.5"></a></h4>
<p>使用这种方式一共会创建两个字符串对象（前提是 String Pool  中还没有 &ldquo;abc&rdquo; 字符串对象）。</p>
<ul>
<li>&ldquo;abc&rdquo; 属于字符串字面量，因此在编译时期会在 String Pool 中创建一个字符串对象，指向这个 &ldquo;abc&rdquo; 字符串字面量。</li>
<li>而使用 new 的方式会在堆中创建一个字符串对象。<br>
创建一个测试类，其 main 方法中使用这种方式来创建字符串对象。</li>
</ul>
<pre tabindex="0"><code>    public class NewStringTest {
        public static void main(String[] args){
            String s = new String(&quot;abc&quot;);
        }
    }
</code></pre><p>使用 javap -verbose 进行反编译，得到以下内容：</p>
<pre tabindex="0"><code>// ...
Constant pool:
// ...
   #2 = Class              #18            // java/lang/String
   #3 = String             #19            // abc
// ...
  #18 = Utf8               java/lang/String
  #19 = Utf8               abc
// ...
  public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=3, locals=2, args_size=1
         0: new           #2                  // class java/lang/String
         3: dup
         4: ldc           #3                  // String abc
         6: invokespecial #4                  // Method java/lang/String.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V
         9: astore_1
// ...

</code></pre><p>在 Constant Pool 中，#19 存储这字符串字面量 &ldquo;abc&rdquo;, #3 是 String Pool 的字符串对象，它指向 #19 这个字符串字面量。在 main 方法中， 0: 行使用 new #2 在堆中创建一个字符串对象，并且使用 ldc #3 将 String Pool 中的字符串对象作为 String 构造函数的参数。</p>
<p>以下是 String 构造函数的源码，可以看到，在将一个字符串对象作为另一个字符串对象的构造函数参数时，并不会完全复制 value 数组内容，而是都会指向同一个 value 数组。</p>
<pre tabindex="0"><code>public String(String original){
    this.value = original.value;
    this.hash = original.hash;
}
</code></pre><h3 id="三运算a-name3a">三、运算<a name="3"></a></h3>
<h4 id="参数传递a-name31a">参数传递<a name="3.1"></a></h4>
<p>以下代码中 Dog dog 的dog是一个指针，存储的是对象的地址。在将一个参数传入一个方法时，本质上是将对象的地址以值得方式传递到形参中。</p>
<pre tabindex="0"><code>public class Dog {
    
    String name;

    Dog(String name) {
        this.name = name;
    }

    String getName() {
        return this.name;
    }

    String getObjectAddress() {
        return super.toString();
    }
}
</code></pre><p>在方法中改变对象的字段值会改变原对象该字段值，因为引用的是同一个对象。</p>
<pre tabindex="0"><code>class PassByValueExample {
    public static void main(String[] args) {
        Dog dog = new Dog(&quot;A&quot;);
        func(dog);
        System.out.println(dog.getName());      // B
    }

    private static void func(Dog dog) {
        dog.setName(&quot;B&quot;);
    }
}
</code></pre><p>但是在方法中将指针引用了其它对象，那么此时方法里和方法外的两个指针指向了不同的对象，在一个指针改变其所指向对象的内容对另一个指针所指向的对象没有影响。</p>
<pre tabindex="0"><code>public class PassByValueExample {
    public static void main(String[] args) {
        Dog dog = new Dog(&quot;A&quot;);
        System.out.println(dog.getObjectAddress()); // Dog@4554617c
        func(dog);
        System.out.println(dog.getObjectAddress()); // Dog@4554617c
        System.out.println(dog.getName());          // A
    }

    private static void func(Dog dog) {
        System.out.println(dog.getObjectAddress()); // Dog@4554617c
        dog = new Dog(&quot;B&quot;);
        System.out.println(dog.getObjectAddress()); // Dog@74a14482
        System.out.println(dog.getName());          // B
    }
}
</code></pre><h4 id="float-与-doublea-name32a">float 与 double<a name="3.2"></a></h4>
<p>Java 不能隐式执行向下转型，因为这会使得精度降低。</p>
<p>1.1 字面量属于 double 类型，不能直接将 1.1 直接赋值给 float 变量，因为这是向下转型。</p>
<pre tabindex="0"><code>// float f = 1.1;
</code></pre><p>1.1f 字面量才是 float 类型。</p>
<pre tabindex="0"><code>float f = 1.1f;
</code></pre><h4 id="隐式类型转换a-name33a">隐式类型转换<a name="3.3"></a></h4>
<p>因为字面量 1 是 int 类型，它比 short 类型精度要高，因此不能隐式地将 int 类型向下转型为 short 类型。</p>
<pre tabindex="0"><code>short s1 = 1;
//s1 = s1 + 1;
</code></pre><p>但是使用 += 或者 ++ 运算符会执行隐式类型转换。</p>
<pre tabindex="0"><code>s1 += 1;
s1++;
</code></pre><p>上面的语句相当于将 s1 + 1 的计算结果进行了向下转型：</p>
<pre tabindex="0"><code>s1 = (short)(s1 + 1);
</code></pre><h4 id="switcha-name34a">switch<a name="3.4"></a></h4>
<p>从 Java 7 开始，可以在 switch 条件判断语句中使用 String 对象。<br>
switch 不支持 long、float、double，是因为 switch 的设计初衷是对那些只有少数几个值的类型进行等值判断，如果值过于复杂，那么还是用 if 比较合适。</p>
<h3 id="四关键字a-name4a">四、关键字<a name="4"></a></h3>
<h4 id="finala-name41a">final<a name="4.1"></a></h4>
<p>1.<strong>数据</strong></p>
<p>声明数据为常量，可以是编译时的常量，也可以是在运行时被初始化后不能被改变的常量。</p>
<ul>
<li>对于基本类型，final 使数值不变；</li>
<li>对于引用类型，final 使引用不变，也就不能引用其他对象，但是被引用的对象本身是可以修改的。</li>
</ul>
<pre tabindex="0"><code>final int x = 1;
//x = 3;    // cannot assign value to final variable 'x'
final A y = new A();
y.a = 1;
</code></pre><p>2.<strong>方法</strong></p>
<p>声明方法不能被子类重写。<br>
private 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法。</p>
<p>3.<strong>类</strong>
声明类不允许被继承。</p>
<h4 id="statica-name42a">static<a name="4.2"></a></h4>
<p>1.<strong>静态变量</strong></p>
<ul>
<li>静态变量： 又被称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，可以直接通过类名来访问它。静态变量在内存中只存在一份。</li>
<li>实例变量： 每创建一个实例就会产生一个实例变量，它与该实例同生共死。</li>
</ul>
<pre tabindex="0"><code>public class A {
    private int x;          // 实例变量
    private static int y;   // 静态变量

    public static void main(String[] args) {
        // int x = A.x;     // Non-static field 'x' cannot be referenced from a static context 
        A a = new A();
        int x = a.x;
        int y = A.y;
    }
}
</code></pre><p>2.<strong>静态方法</strong></p>
<p>静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法。</p>
<pre tabindex="0"><code>public  abstract class A {
    public static void func1(){}
}
</code></pre><p>只能访问所属类的静态字段和静态方法，方法中不能有 this 和 super 关键字，因为这两个关键字与具体对象关联。</p>
<pre tabindex="0"><code>public class A {
    private static int x;
    private int y;

    public static void func1(){
        int a = x;
        // int b = y;       // Non-static field 'y' cannot be referenced from a static context
        // int b = this.y;  //'A.this' cannot be referenced from a static context
    }
}
</code></pre><p><strong>3.静态语句块</strong><br>
静态语句块在类初始化时运行一次。</p>
<pre tabindex="0"><code>public class A {
    static {
        System.out.println(&quot;123&quot;);
    }

    public static void main(String[] args) {
        A a1 = new A();
        A a2 = new A();
    }
}
</code></pre><pre tabindex="0"><code>123
</code></pre><p><strong>4.静态内部类</strong><br>
非静态内部类依赖于外部类的实例，也就是说需要先创建外部类的实例，才能用这个实例去创建非静态内部类。而静态内部类不需要。</p>
<pre tabindex="0"><code>public class OuterClass {
    class InnerClass {
    }
    static class StaticInnerClass {
    }
    public static void main(String[] args) {
        //InnerClass innerClass = new InnerClass();     //  'OuterClass.this' cannot be referenced from a static context
        OuterClass  outerClass = new OuterClass();
        InnerClass innerClass = outerClass.new InnerClass();
        StaticInnerClass staticInnerClass = new StaticInnerClass(); 
    }
}
</code></pre><p>静态内部类不能访问外部类的非静态的变量和方法。</p>
<p><strong>5.静态导包</strong>
在使用静态变量和方法时不用再指明 ClassName,从而简化代码，但可读性大大降低。</p>
<p><strong>6.初始化顺序</strong><br>
静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。</p>
<pre tabindex="0"><code>public static String staticField = &quot;静态变量&quot;;
</code></pre><pre tabindex="0"><code>static {
    System.out.println(&quot;静态语句块&quot;);
}
</code></pre><pre tabindex="0"><code>public String field = &quot;实例变量&quot;;
</code></pre><pre tabindex="0"><code>{
    System.out.println(&quot;普通语句块&quot;);
}
</code></pre><p>最后才是构造函数的初始化。</p>
<pre tabindex="0"><code>public InitialOrderTest(){
    System.out.println(&quot;构造函数&quot;);
}
</code></pre><p>存在继承的情况下，初始化顺序为：</p>
<ul>
<li>父类（静态变量、静态语句块）</li>
<li>子类（静态变量、静态语句块）</li>
<li>父类（实例变量、普通语句块）</li>
<li>父类（构造函数）</li>
<li>子类（实例变量、普通语句块）</li>
<li>子类（构造函数）</li>
</ul>
<h3 id="五object-通用方法a-name5a">五、Object 通用方法<a name="5"></a></h3>
<h4 id="概述a-name51a">概述<a name="5.1"></a></h4>
<pre tabindex="0"><code>public native int hashCode()

public boolean equals(Object obj)

protected native Object clone() throws CloneNotSupportedException

public String toString()

public final native Class&lt;?&gt; getClass()

protected void finalize() throws Throwable

public final native void notify()

public final native void notifyAll()

public final native void wait(long timeout) throws InterruptedException

public final void wait(long timeout, int nanos) throws InterruptedException

public final void wait() throws InterruptedException

</code></pre><h4 id="equalsa-name52a">equals()<a name="5.2"></a></h4>
<p><strong>1.等价关系</strong><br>
两个对象具有等价关系，需要满足以下五个条件：自反性、对称性、传递性、一致性、与 null 的比较（对任何不是 null 的对象 x 调用 x.equals(null) 结果都为flase)</p>
<p><strong>2.等价于相等</strong></p>
<ul>
<li>对于基本类型，== 判断两个值是否相等，基本类型没有 equals() 方法。</li>
<li>对于引用类型，== 判断两个变量是否引用同一个对象，而 equals() 判断引用的对象是否等价。</li>
</ul>
<pre tabindex="0"><code>Integer x = new Integer(1);
Integer y = new Integer(1);
System.out.println(x.equals(y));    // true
System.out.println(x == y);         // false
</code></pre><p><strong>3.实现</strong></p>
<ul>
<li>检查是否为同一个对象的引用，如果是直接返回 true；</li>
<li>检查是否是同一个类型，如果不是，直接返回 false；</li>
<li>将 Object 对象进行转型；</li>
<li>判断每个关键域是否相等</li>
</ul>
<pre tabindex="0"><code>public class EqualExample {
    private int x;
    private int y;
    private int z;

    public EqualExample(int x, int y, int z){
        this.x = x;
        this.y = y;
        this.z = z;
    }

    @Override
    public boolean equals(Object o){
        if(this == o) return true;
        if(o == null || getClass() != o.getClass()) return false;

        EqualExample that = (EqualExample) o;
        
        if(x != that.x) return false;
        if(y != that.y) return false;
        return z == that.z;
    }
}
</code></pre><h4 id="hashcodea-name53a">hashCode()<a name="5.3"></a></h4>
<p>hashCode() 返回哈希值，而 equals() 是用来判断两个对象是否等价。等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价，这是因为计算哈希值具有随机性，两个值不同的对象可能计算出相同的哈希值。<br>
在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，保证等价的两个对象哈希值也相等。<br>
HashSet 和 HashMap 等集合类使用了 hashCode() 方法来计算对象应该存储的位置，因此要将对象添加到这些集合类中，需要让对应的类实现 hashCode() 方法。<br>
下面的代码中，新建了两个等价的对象，并将它们添加到 HashSet 中，我们希望将两个对象当成一样的，只在集合中添加一个对象。但是 EqualExample 没有实现 hashCode() 方法，因此两个对象的哈希值是不同的，最终导致集合添加了两个等价的对象。</p>
<pre tabindex="0"><code>EqualExample e1 = new EqualExample(1,1,1);
EqualExample e2 = new EqualExample(1,1,1);
System.out.println(eq.equal(e2));   // true
HashSet&lt;EqualExample&gt; set  = new HashSet&lt;&gt;();
set.add(e1);
set.add(e2);
System.out.println(set.size());     // 2
</code></pre><p>理想的哈希函数应当具有均匀性 ，即不相等的对象应当均匀分布到所有可能的哈希值上。这就要求了哈希函数要把所有域的值都考虑进来。可以将每个域都当成 R 进制的某一位，然后组成一个 R 进制的整数。</p>
<p>R 一般取 31，它是一个奇素数。</p>
<h4 id="tostringa-name54a">toString()<a name="5.4"></a></h4>
<p>默认返回 类名@十六进制数 这种形式，其中 @ 后面的数值为散列码的无符号十六进制表示。</p>
<h4 id="clonea-name55a">clone()<a name="5.5"></a></h4>
<h5 id="1cloneable">1.cloneable</h5>
<p>clone() 是 Object 的 protected 方法，它不是 public，一个类不显式去重写 clone()，其他类就不能直接去调用该类实例的 clone() 方法。</p>
<h5 id="2浅拷贝">2.浅拷贝</h5>
<p>拷贝对象和原始对象的引用类型引用同一个对象。</p>
<h5 id="3深拷贝">3.深拷贝</h5>
<p>拷贝对象和原始对象的引用类型引用不同的对象。</p>
<h5 id="4clone的替代方案">4.clone的替代方案</h5>
<p>使用 clone() 方法既复杂又有风险，最好别用，使用拷贝构造函数或拷贝工厂来拷贝一个对象。</p>
<h3 id="六继承-a-name6a">六、继承 <a name="6"></a></h3>
<h4 id="访问权限-a-name61a">访问权限 <a name="6.1"></a></h4>
<p>Java 中有三个访问权限修饰符：private、protected 以及 public，如果不加访问修饰符，表示包级可见。</p>
<h4 id="抽象类与接口-a-name62a">抽象类与接口 <a name="6.2"></a></h4>
<h5 id="1抽象类">1.抽象类</h5>
<p>抽象类和抽象方法都使用 abstract 关键字进行声明。如果一个类中包含抽象方法，那么该类必须声明为抽象类。</p>
<p>抽象类不能被实例化，只能被继承。</p>
<h5 id="2接口">2.接口</h5>
<p>接口是抽象类的延伸，在 Java 8 之前，它可以看成是一个完全抽象的类，也就是说它不能有任何的方法实现。</p>
<p>从 Java 8开始，接口也可以拥有默认的方法实现，这是因为不支持默认方法的接口的维护成本太高了。</p>
<p>接口的成员（字段+方法）默认都是 public的，并且不允许定义为 private 或 protected。从 Java 9 开始，允许将方法定义为 private，这样就能定义某些复用的代码又不会把方法暴露出去。</p>
<p>接口的字段默认都是 static 和 final 的。</p>
<h5 id="3抽象类与接口比较">3.抽象类与接口比较</h5>
<ul>
<li>从设计层面上看，抽象类提供一种 IS-A 关系，而接口更像一种 LIKE-A 关系。</li>
<li>从使用上看，一个类可以实现多个接口，但是不能继承多个抽象类。</li>
<li>接口的字段只能是 static 和 final 类型的，而抽象类的字段没有这种限制。</li>
<li>接口的成员只能是 public 的，而抽象类的成员可以有多种访问权限。</li>
</ul>
<p>在很多情况下，接口优先于抽象类。因为接口没有抽象类严格的类层次结构要求，可以灵活地为一个类添加行为。并且从 Java 8 开始，接口也可以有默认的方法实现，使得接口的成本也变得很低。</p>
<h4 id="supera-name63a">super<a name="6.3"></a></h4>
<ul>
<li>访问父类的构造函数。super()。</li>
<li>访问父类的成员。</li>
</ul>
<h4 id="重写与重载-a-name64a">重写与重载 <a name="6.4"></a></h4>
<h5 id="1重写">1.重写</h5>
<p>存在于继承体系中，指子类实现了一个与父类在方法声明上完全相同的一个方法。</p>
<h5 id="2重载">2.重载</h5>
<p>存在于一个类中，指一个方法与已经存在的方法名称上相同，但是参数类型、个数、顺序至少有一个不同。</p>
<p>应该注意的是，返回值不同，其他都相同不算是重载。</p>
<h3 id="七反射a-name7a">七、反射<a name="7"></a></h3>
<p>每个类都有一个 Class 对象，包含了与类有关的信息。当编译一个新类时，会产生一个同名的 .class 文件，该文件内容保存着 Class 对象。</p>
<p>类加载相当于 Class 对象的加载，类在第一次使用时才动态加载到 JVM 中。也可以使用 Class.forname(&ldquo;com.mysql.jdbc.Driver&rdquo;) 这种方式来控制类的加载，该方法会返回一个 Class 对象。</p>
<p>反射可以提供运行时的类信息，并且这个类可以在运行时才加载进来，甚至在编译时期该类的.class不存在也可以加载进来。</p>
<p>反射的优点：</p>
<ul>
<li>可扩展性</li>
<li>可视化开发环境： 如IDE,从反射中可用的类型信息中受益，帮助程序员编写正确的代码。</li>
<li>调试器和测试工具</li>
</ul>
<p>反射的缺点：</p>
<ul>
<li>性能开销</li>
<li>安全限制</li>
<li>内部暴露</li>
</ul>
<h3 id="八异常a-name8a">八、异常<a name="8"></a></h3>
<h3 id="九泛型a-name9a">九、泛型<a name="9"></a></h3>
<h3 id="十注解a-name10a">十、注解<a name="10"></a></h3>
<h3 id="十一特性a-name11a">十一、特性<a name="11"></a></h3>

        
        ]]>
      </description>
    </item>
    
    
  </channel>
</rss>
