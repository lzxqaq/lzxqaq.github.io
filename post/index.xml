<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>技术文章 on (๑•̀ㅂ•́) ✧ 罗泽勋</title>
    <link>/post/</link>
    <description>Recent content in 技术文章 on (๑•̀ㅂ•́) ✧ 罗泽勋</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Wed, 13 Oct 2021 07:01:19 +0800</lastBuildDate>
    <atom:link href="/post/" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Qt单元测试基础笔记</title>
      <link>/post/2021-10-13-1/</link>
      <pubDate>Wed, 13 Oct 2021 07:01:19 +0800</pubDate>
      <author>罗泽勋</author>
      <guid>/post/2021-10-13-1/</guid>
      <description>
        <![CDATA[
        <h3 id="一构建">一、构建</h3>
<p>构建时添加 <code>QT += testlib</code> 。</p>
<h3 id="二测试类">二、测试类</h3>
<p>测试类必须从 QObject 继承，头文件 <code>include &lt;QTest&gt;</code> ，并将测试函数声明 <code>private slot</code></p>
<h3 id="三qverifycondition-宏">三、QVERIFY(condition) 宏</h3>
<p>检查 condition（条件）是否为真。如果为真，则继续执行。如果没有，则测试日志中会记录失败，并且不会进一步执行测试。</p>
<p>如果需要在测试失败报告中加入附加信息，可以使用 QVERIFY2(condition, message)。</p>
<p>如果需要测试日志有更详细的输出，可以使用 QCOMPARE(actual, expected)。</p>
<h3 id="四qcompareactual-expected宏">四、QCOMPARE(actual, expected)宏</h3>
<p>使用相等运算符将 actual （实际值）与 expected （预期值）进行比较。如果实际和预期匹配，则继续执行。如果不是，则在测试日志中记录失败，并且测试函数返回而不尝试任何后续检查。</p>
<p>如果比较失败，QCOMPARE() 会尝试输出值的内容，因此可以从测试日志中看到比较失败的原因。</p>
<p>对于你自己的类，你可以使用 <code>QTest::toString ()</code> 来格式化输出到测试日志中的值。具体可参考 <a href="https://doc.qt.io/qt-6/qtest.html#QCOMPARE">Qt 文档</a>;</p>
<h3 id="五可执行文件">五、可执行文件</h3>
<p>如果需要将测试用例成为独立的可执行文件，需要添加以下两行：</p>
<pre tabindex="0"><code>QTEST_MAIN(YourClassName)
#include &quot;yourfilename.moc&quot;
</code></pre>
        
        ]]>
      </description>
    </item>
    
    
    
    <item>
      <title>Qt测试最佳实践（Qt文档）</title>
      <link>/post/2021-10-13-2/</link>
      <pubDate>Wed, 13 Oct 2021 07:01:19 +0800</pubDate>
      <author>罗泽勋</author>
      <guid>/post/2021-10-13-2/</guid>
      <description>
        <![CDATA[
        <h2 id="qt-测试最佳实践">Qt 测试最佳实践</h2>
<p>我们建议您为错误修复和新功能添加 Qt 测试。在您尝试修复错误之前，添加一个回归测试（理想情况下是自动的），该测试在修复之前失败，表现出错误，并在修复之后通过。在开发新功能时，添加测试以验证它们是否按预期工作。</p>
<p>符合一组编码标准将使 Qt 自动测试更有可能在所有环境中可靠地工作。例如，有些测试需要从磁盘读取数据。如果没有为如何完成设置标准，则某些测试将无法移植。例如，假设其测试数据文件位于当前工作目录中的测试仅适用于源代码构建。在影子构建中（在源目录之外），测试将无法找到其数据。</p>
<p>以下章节包含了编写Qt测试的指南。</p>
<ul>
<li><a href="#%E4%B8%80%E8%88%AC%E5%8E%9F%E5%88%99">一般原则</a></li>
<li><a href="#%E7%BC%96%E5%86%99%E5%8F%AF%E9%9D%A0%E7%9A%84%E6%B5%8B%E8%AF%95">编写可靠的测试</a></li>
<li><a href="#%E6%94%B9%E8%BF%9B%E6%B5%8B%E8%AF%95%E8%BE%93%E5%87%BA">改进测试输出</a></li>
<li><a href="#%E7%BC%96%E5%86%99%E5%8F%AF%E6%B5%8B%E8%AF%95%E7%9A%84%E4%BB%A3%E7%A0%81">编写可测试的代码</a></li>
<li><a href="#%E8%AE%BE%E7%BD%AE%E6%B5%8B%E8%AF%95%E6%9C%BA">设置测试机</a></li>
</ul>
<h2 id="一般原则">一般原则</h2>
<p>下面的章节提供了编写单元测试的一般指南。</p>
<ul>
<li><a href="#%E9%AA%8C%E8%AF%81%E6%B5%8B%E8%AF%95">验证测试</a></li>
<li><a href="#%E8%B5%8B%E4%BA%88%E6%B5%8B%E8%AF%95%E5%87%BD%E6%95%B0%E6%8F%8F%E8%BF%B0%E6%80%A7%E7%9A%84%E5%90%8D%E7%A7%B0">赋予测试函数描述性的名称</a></li>
<li><a href="#%E7%BC%96%E5%86%99%E8%87%AA%E5%B8%A6%E7%9A%84%E6%B5%8B%E8%AF%95%E5%87%BD%E6%95%B0">编写自带的测试函数</a></li>
<li><a href="#%E6%B5%8B%E8%AF%95%E5%85%A8%E6%A0%88">测试全栈</a></li>
<li><a href="#%E8%AE%A9%E6%B5%8B%E8%AF%95%E5%BF%AB%E9%80%9F%E5%AE%8C%E6%88%90">让测试快速完成</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8%E7%9A%84%E6%B5%8B%E8%AF%95">使用数据驱动的测试</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8%E8%A6%86%E7%9B%96%E5%B7%A5%E5%85%B7">使用覆盖工具</a></li>
<li><a href="#%E9%80%89%E6%8B%A9%E9%80%82%E5%BD%93%E7%9A%84%E6%9C%BA%E5%88%B6%E6%9D%A5%E6%8E%92%E9%99%A4%E6%B5%8B%E8%AF%95">选择适当的机制来排除测试</a></li>
<li><a href="#%E9%81%BF%E5%85%8DQ_ASSERT">避免Q_ASSERT</a></li>
</ul>
<h3 id="验证测试">验证测试</h3>
<p>编写并提交你的测试以及你的修复或新功能到一个新的分支上。一旦你完成了,你可以检查出你的工作所基于的分支,然后把你的新测试的测试文件检查到这个分支。这可以让你验证测试是否在前一个分支上失败了,因此确实抓住了一个错误或测试了一个新功能。</p>
<p>例如，如果使用Git版本控制系统，则修复 QDateTime 类中的错误的工作流程可能如下所示：</p>
<blockquote>
<p>1.为您的修订和测试创建一个分支： git checkout -b fix-branch 5.14<br>
2.编写一个测试并修复错误。<br>
3.用修复版和新的测试版进行构建和测试,以验证新的测试版是否能通过修复版。<br>
4.将修复程序和测试添加到您的分支： git add tests/auto/corelib/time/qdatetime/tst_qdatetime.cpp src/corelib/time/qdatetime.cpp<br>
5.提交修复程序并测试您的分支机构： git commit -m &lsquo;Fix bug in QDateTime&rsquo;<br>
6.要验证测试是否确实捕获了需要您修复的内容，请检出您自己的分支所基于的分支： git checkout 5.14<br>
7.仅将测试文件检出到5.14分支： git checkout fix-branch &ndash; tests/auto/corelib/time/qdatetime/tst_qdatetime.cpp<br>
现在只有测试在fix-branch上。其余的源代码树仍在5.14上。<br>
8.构建并运行测试,以验证它在5.14上失败,因此确实抓住了一个错误。<br>
9.您现在可以返回到fix分支： git checkout fix-branch<br>
10.或者，您可以在5.14上将工作树恢复到干净状态： git checkout HEAD &ndash; tests/auto/corelib/time/qdatetime/tst_qdatetime.cpp</p>
</blockquote>
<p>当你在审查一个变更时,你可以调整这个工作流程,以检查该变更是否确实带有测试它确实修复的问题。</p>
<h3 id="为测试函数提供描述性名称">为测试函数提供描述性名称</h3>
<p>命名测试用例很重要。测试名称出现在测试运行的失败报告中。对于数据驱动的测试，数据行的名称也会出现在失败报告中。这些名字让阅读报告的人初步了解出了什么问题。</p>
<p>测试函数名称应该让函数试图测试的内容一目了然。不要简单地使用错误跟踪标识符，因为如果替换错误跟踪器，标识符就会过时。此外，并非所有用户都可以访问某些错误跟踪器。当测试代码的后续读者可能对错误报告感兴趣时，您可以在测试的相关部分旁边的评论中提及它。</p>
<p>同样，在编写数据驱动的测试时，为测试用例提供描述性名称，表明每个测试用例关注功能的哪个方面。不要简单地给测试用例编号，也不要使用错误跟踪标识符。阅读测试输出的人将不知道数字或标识符的含义。如果相关，您可以在提及错误跟踪标识符的测试行上添加注释。</p>
<h3 id="编写自包含的测试函数">编写自包含的测试函数</h3>
<p>在一个测试程序中，测试功能应该相互独立，并且它们不应该依赖于之前已经运行过的测试功能。您可以通过使用tst_foo testname.</p>
<p>不要在多个测试中重复使用被测类的实例。测试实例（例如小部件）不应该是测试的成员变量，但最好在堆栈上实例化，以确保即使测试失败也能进行适当的清理，这样测试不会相互干扰。</p>
<h3 id="测试全栈">测试全栈</h3>
<p>如果 API 是根据可插拔或特定于平台的后端来实现的，这些后端执行繁重的工作，请确保编写涵盖代码路径一直到后端的测试。使用模拟后端测试上层 API 部分是将 API 层中的错误与后端隔离的好方法，但它是对使用真实世界数据运行实际实现的测试的补充。</p>
<h3 id="使测试快速完成">使测试快速完成</h3>
<p>测试不应因不必要的重复、使用不当的大量测试数据或引入不必要的空闲时间而浪费时间。</p>
<p>对于单元测试尤其如此，其中每一秒额外的单元测试执行时间都会使跨多个目标的分支的 CI 测试花费更长的时间。请记住，单元测试与负载和可靠性测试是分开的，其中需要大量的测试数据和更长的测试运行时间。</p>
<p>基准测试通常会多次执行相同的测试，应位于单独的tests/benchmarks目录中，并且不应与功能单元测试混合使用。</p>
<h3 id="使用数据驱动测试">使用数据驱动测试</h3>
<p>数据驱动的测试可以更轻松地为后期错误报告中发现的边界条件添加新测试。</p>
<p>使用数据驱动的测试而不是在测试中按顺序测试多个项目可以节省非常相似的代码的重复，并确保即使较早的案例失败也能测试后续案例。它还鼓励系统和统一的测试，因为对每个数据样本应用相同的测试。</p>
<h3 id="使用覆盖工具">使用覆盖工具</h3>
<p>使用诸如Froglogic Coco Code Coverage或gcov 之类的覆盖工具来帮助编写测试，以覆盖被测试函数或类中尽可能多的语句、分支和条件。在新功能的开发周期中越早完成此操作，稍后在重构代码时就越容易捕获回归。</p>
<h3 id="选择适当的机制来排除测试">选择适当的机制来排除测试</h3>
<p>选择适当的机制来排除不适用的测试很重要：QSKIP ()，使用条件语句排除部分测试功能，或不为特定平台构建测试。</p>
<p>使用QSKIP () 来处理在运行时发现整个测试函数在当前测试环境中不适用的情况。当只跳过测试函数的一部分时，可以使用条件语句，可选择qDebug()调用以报告跳过不适用部分的原因。</p>
<p>数据驱动测试的测试功能或数据行可以限于特定平台，或使用#if. 但是，在使用跳过测试功能时要注意moc限制#if。该moc预处理器不具备访问所有builtin被经常用于编译器的特征检测编译器的宏。因此，moc预处理器条件的结果可能与其余代码看到的结果不同。这可能会导致moc为实际编译器跳过的测试槽生成元数据，或省略实际编译到类中的测试槽的元数据。在第一种情况下，测试将尝试运行未实现的插槽。在第二种情况下，即使应该尝试运行测试槽，测试也不会尝试。</p>
<p>如果整个测试程序不适用于特定平台或除非启用了特定功能，最好的方法是使用父目录的.pro文件来避免构建测试。例如，如果tests/auto/gui/someclass测试对 macOS 无效，请将以下行添加到tests/auto/gui.pro：</p>
<pre tabindex="0"><code>mac*: SUBDIRS -= someclass
</code></pre><h3 id="避免q_assert">避免Q_ASSERT</h3>
<p>该Q_ASSERT宏将导致程序中止时断言的情况false，但前提是软件始建于调试模式。在 release 和 debug-and-release 版本中，Q_ASSERT什么都不做。</p>
<p>Q_ASSERT 应该避免，因为它使测试的行为取决于是否正在测试调试版本，并且因为它会导致测试立即中止，跳过所有剩余的测试函数并返回不完整或格式错误的测试结果。</p>
<p>它还会跳过本应在测试结束时进行的任何拆卸或整理，因此可能会使工作区处于不整洁状态，这可能会导致进一步测试的复杂化。</p>
<p>应Q_ASSERT使用QCOMPARE () 或QVERIFY () 宏变体而不是 。它们使当前测试报告失败并终止，但允许执行剩余的测试功能和整个测试程序正常终止。QVERIFY2 () 甚至允许在测试日志中记录描述性错误消息。</p>
<h2 id="编写可靠的测试">编写可靠的测试</h2>
<p>以下部分提供了编写可靠测试的指南：</p>
<ul>
<li><a href="#%E9%81%BF%E5%85%8D%E9%AA%8C%E8%AF%81%E6%AD%A5%E9%AA%A4%E4%B8%AD%E7%9A%84%E5%89%AF%E4%BD%9C%E7%94%A8">避免验证步骤中的副作用</a></li>
<li><a href="#%E9%81%BF%E5%85%8D%E5%9B%BA%E5%AE%9A%E8%B6%85%E6%97%B6">避免固定超时</a></li>
<li><a href="#%E8%B0%A8%E9%98%B2%E4%BE%9D%E8%B5%96%E4%BA%8E%E6%97%B6%E9%97%B4%E7%9A%84%E8%A1%8C%E4%B8%BA">谨防依赖于时间的行为</a></li>
<li><a href="#%E9%81%BF%E5%85%8D%E4%BD%8D%E5%9B%BE%E6%8D%95%E8%8E%B7%E5%92%8C%E6%AF%94%E8%BE%83">避免位图捕获和比较</a></li>
</ul>
<h3 id="避免验证步骤中的副作用">避免验证步骤中的副作用</h3>
<p>在使用QCOMPARE ()、QVERIFY () 等执行自动测试中的验证步骤时，应避免副作用。验证步骤中的副作用会使测试难以理解。此外，当测试更改为使用QTRY_VERIFY ()、QTRY_COMPARE () 或QBENCHMARK ()时，他们可以很容易地以难以诊断的方式破坏测试。这些可以多次执行传递的表达式，从而重复任何副作用。</p>
<p>当副作用不可避免时，确保在测试函数结束时恢复先前的状态，即使测试失败。这通常需要使用在函数返回时恢复状态的 RAII（资源获取即初始化）类或cleanup()方法。不要简单地将恢复代码放在测试结束时。如果部分测试失败，此类代码将被跳过并且不会恢复之前的状态。</p>
<h3 id="避免固定超时">避免固定超时</h3>
<p>避免使用硬编码超时，例如QTest::qWait () 来等待某些条件变为真。考虑使用QSignalSpy类、QTRY_VERIFY () 或QTRY_COMPARE () 宏，或将QSignalSpy类与QTRY_宏变体结合使用。</p>
<p>该qWait()函数可用于在执行某些操作和等待该操作触发的某些异步行为完成之间设置一段固定时间的延迟。例如，更改小部件的状态，然后等待小部件重新绘制。但是，当在工作站上编写的测试在设备上执行时，此类超时通常会导致失败，在这种情况下，预期行为可能需要更长时间才能完成。在最慢的测试平台上将固定超时增加到比所需值大几倍的值并不是一个好的解决方案，因为它会减慢所有平台上的测试运行速度，特别是对于表驱动测试。</p>
<p>如果被测代码在异步行为完成时发出 Qt 信号，更好的方法是使用QSignalSpy类通知测试函数现在可以执行验证步骤。</p>
<p>如果没有 Qt 信号，请使用QTRY_COMPARE()和QTRY_VERIFY()宏，它会定期测试指定的条件，直到它变为真或达到某个最大超时。这些宏可防止测试花费比必要时间更长的时间，同时避免在工作站上编写测试并随后在嵌入式平台上执行时出现中断。</p>
<p>如果没有 Qt 信号，并且您正在编写测试作为开发新 API 的一部分，请考虑 API 是否可以从添加报告异步行为完成的信号中受益。</p>
<h3 id="谨防依赖于时间的行为">谨防依赖于时间的行为</h3>
<p>一些测试策略容易受到某些类的时间相关行为的影响，这可能导致测试仅在某些平台上失败或不返回一致的结果。</p>
<p>这方面的一个例子是文本输入小部件，它通常有一个闪烁的光标，可以根据捕获位图时光标的状态使捕获的位图的比较成功或失败。这又可能取决于执行测试的机器的速度。</p>
<p>在测试根据计时器事件更改其状态的类时，在执行验证步骤时需要考虑基于计时器的行为。由于依赖于时序的行为多种多样，因此没有针对此测试问题的单一通用解决方案。</p>
<p>对于文本输入小部件，潜在的解决方案包括禁用光标闪烁行为（如果 API 提供该功能），在捕获位图之前等待光标处于已知状态（例如，如果 API提供一个)，或者从位图比较中排除包含光标的区域。</p>
<h3 id="避免位图捕获和比较">避免位图捕获和比较</h3>
<p>虽然有时需要通过捕获和比较位图来验证测试结果，但它可能非常脆弱且需要大量劳动。</p>
<p>例如，特定小部件在不同平台上可能有不同的外观或具有不同的小部件样式，因此可能需要多次创建参考位图，然后在未来随着 Qt 支持的平台集的发展进行维护。因此，进行影响位图的更改意味着必须在每个支持的平台上重新创建预期的位图，这将需要访问每个平台。</p>
<p>位图比较也会受到测试机器的屏幕分辨率、位深度、活动主题、配色方案、小部件样式、活动区域设置（货币符号、文本方向等）、字体大小、透明度效果和选择等因素的影响的窗口管理器。</p>
<p>在可能的情况下，使用编程方式，例如验证对象和变量的属性，而不是捕获和比较位图。</p>
<h2 id="改进测试输出">改进测试输出</h2>
<p>以下部分提供了生成可读且有用的测试输出的指南：</p>
<ul>
<li><a href="#%E6%98%BE%E5%BC%8F%E5%BF%BD%E7%95%A5%E9%A2%84%E6%9C%9F%E8%AD%A6%E5%91%8A">显式忽略预期警告</a></li>
<li><a href="#%E6%98%BE%E5%BC%8F%E5%BF%BD%E7%95%A5%E9%A2%84%E6%9C%9F%E8%AD%A6%E5%91%8A">显式忽略预期警告</a></li>
<li><a href="#%E7%BC%96%E5%86%99%E7%BB%93%E6%9E%84%E8%89%AF%E5%A5%BD%E7%9A%84%E8%AF%8A%E6%96%AD%E4%BB%A3%E7%A0%81">编写结构良好的诊断代码</a></li>
</ul>
<h3 id="显式忽略预期警告">显式忽略预期警告</h3>
<p>如果预期测试会导致 Qt 在控制台上输出警告或调试消息，则应调用QTest::ignoreMessage () 将该消息从测试输出中过滤掉，如果没有输出消息，则测试失败。</p>
<p>如果只有在调试模式下构建 Qt 时才会输出这样的消息，请使用QLibraryInfo::isDebugBuild () 来确定 Qt 库是否是在调试模式下构建的。使用#ifdef QT_DEBUG是不够的，因为它只会告诉您测试是否是在调试模式下构建的，并且不能保证 Qt 库也是在调试模式下构建的。</p>
<h3 id="避免打印来自自动测试的调试消息">避免打印来自自动测试的调试消息</h3>
<p>自动测试不应产生任何未处理的警告或调试消息。这将允许 CI Gate 将新警告或调试消息视为测试失败。</p>
<p>在开发过程中添加调试消息很好，但是在签入测试之前应该禁用或删除这些消息。</p>
<h3 id="编写结构良好的诊断代码">编写结构良好的诊断代码</h3>
<p>如果测试失败，任何有用的诊断输出都应该是常规测试输出的一部分，而不是被注释掉、被预处理器指令禁用或仅在调试版本中启用。如果在持续集成期间测试失败，与启用诊断代码和再次测试相比，在 CI 日志中包含所有相关的诊断输出可以为您节省大量时间。特别是，如果故障发生在您的桌面上没有的平台上。</p>
<p>测试中的诊断消息应该使用 Qt 的输出机制，例如qDebug()and qWarning()，而不是stdio.horiostream.h输出机制。后者绕过 Qt 的消息处理并阻止-silent命令行选项抑制诊断消息。这可能会导致在大量调试输出中隐藏重要的失败消息。</p>
<h2 id="编写可测试的代码">编写可测试的代码</h2>
<p>以下部分提供了编写易于测试的代码的指南：</p>
<ul>
<li><a href="#%E6%89%93%E7%A0%B4%E4%BE%9D%E8%B5%96">打破依赖</a></li>
<li><a href="#%E5%B0%86%E6%89%80%E6%9C%89%E7%B1%BB%E7%BC%96%E8%AF%91%E5%88%B0%E5%BA%93%E4%B8%AD">将所有类编译到库中</a></li>
</ul>
<h3 id="打破依赖">打破依赖</h3>
<p>单元测试的想法是单独使用每个类。由于许多类实例化了其他类，因此不可能单独实例化一个类。因此，您应该使用一种称为依赖注入的技术，它将对象创建与对象使用分开。工厂负责构建对象树。其他对象通过抽象接口操作这些对象。</p>
<p>这种技术适用于数据驱动的应用程序。对于 GUI 应用程序，这种方法可能很困难，因为对象经常被创建和销毁。为了验证依赖于抽象接口的类的正确行为，可以使用模拟。例如，请参阅Googletest Mocking (gMock) 框架。</p>
<h3 id="将所有类编译到库中">将所有类编译到库中</h3>
<p>在中小型项目中，构建脚本通常会列出所有源文件，然后一次性编译可执行文件。这意味着测试的构建脚本必须再次列出所需的源文件。</p>
<p>在脚本中只列出一次源文件和头文件来构建静态库会更容易。然后该main()函数将链接到静态库以构建可执行文件，并且测试将链接到静态库。</p>
<p>对于在构建多个程序时使用相同源文件的项目，将共享类构建到每个程序（包括测试程序）可以在运行时加载的动态链接（或共享对象）库中可能更合适. 同样，将编译后的代码放在库中有助于避免重复描述组合哪些组件来制作各种程序。</p>
<h2 id="设置测试机">设置测试机</h2>
<p>以下部分讨论由测试机设置引起的常见问题：</p>
<ul>
<li><a href="#%E5%B1%8F%E5%B9%95%E4%BF%9D%E6%8A%A4%E7%A8%8B%E5%BA%8F">屏幕保护程序</a></li>
<li><a href="#%E7%B3%BB%E7%BB%9F%E5%AF%B9%E8%AF%9D%E6%A1%86">系统对话框</a></li>
<li><a href="#%E6%98%BE%E7%A4%BA%E4%BD%BF%E7%94%A8">显示使用</a></li>
<li><a href="#%E7%AA%97%E5%8F%A3%E7%AE%A1%E7%90%86%E5%99%A8">窗口管理器</a></li>
</ul>
<p>所有这些问题通常都可以通过明智地使用虚拟化来解决。</p>
<h3 id="屏幕保护程序">屏幕保护程序</h3>
<p>屏幕保护程序可能会干扰 GUI 类的某些测试，从而导致测试结果不可靠。应禁用屏幕保护程序以确保测试结果一致和可靠。</p>
<h3 id="系统对话框">系统对话框</h3>
<p>操作系统或其他正在运行的应用程序意外显示的对话框可能会从自动测试中涉及的小部件中窃取输入焦点，从而导致不可重现的故障。</p>
<p>典型问题的示例包括 macOS 上的在线更新通知对话框、病毒扫描程序的误报、病毒签名更新等计划任务、推送到工作站的软件更新以及在堆栈顶部弹出窗口的聊天程序。</p>
<h3 id="显示使用">显示使用</h3>
<p>某些测试使用测试机器的显示器、鼠标和键盘，因此如果机器同时用于其他用途或并行运行多个测试，则可能会失败。</p>
<p>CI 系统使用专用测试机来避免此问题，但如果您没有专用测试机，则可以通过在第二台显示器上运行测试来解决此问题。</p>
<p>在 Unix 上，还可以在嵌套或虚拟 X 服务器上运行测试，例如 Xephyr。例如，要在 Xephyr 上运行整套测试，请执行以下命令：</p>
<pre tabindex="0"><code>Xephyr :1 -ac -screen 1920x1200 &gt;/dev/null 2&gt;&amp;1 &amp;
sleep 5
DISPLAY=:1 icewm &gt;/dev/null 2&gt;&amp;1 &amp;
cd tests/auto
make
DISPLAY=:1 make -k -j1 check
</code></pre><p>NVIDIA 二进制驱动程序的用户应该注意 Xephyr 可能无法提供 GLX 扩展。强制 Mesa libGL 可能会有所帮助：</p>
<pre tabindex="0"><code>export LD_PRELOAD=/usr/lib/mesa-diverted/x86_64-linux-gnu/libGL.so.1
</code></pre><p>但是，当在 Xephyr 和具有不同 libGL 版本的真实 X 服务器上运行测试时，QML 磁盘缓存可能会使测试崩溃。为避免这种情况，请使用QML_DISABLE_DISK_CACHE=1.</p>
<p>或者，使用屏幕外插件：</p>
<pre tabindex="0"><code>TESTARGS=&quot;-platform offscreen&quot; make check -k -j1
</code></pre><h3 id="窗口管理器">窗口管理器</h3>
<p>在 Unix 上，至少有两个自动测试（tst_examples和tst_gestures）需要运行窗口管理器。因此，如果在嵌套的 X-server 下运行这些测试，您还必须在该 X-server 中运行窗口管理器。</p>
<p>您的窗口管理器必须配置为自动定位显示器上的所有窗口。一些窗口管理器，例如 Tab Window Manager (twm)，具有手动定位新窗口的模式，这会阻止测试套件在没有用户交互的情况下运行。</p>
<p>注意： Tab Window Manager 不适合运行完整的 Qt 自动测试套件，因为tst_gestures自动测试会导致它忘记其配置并恢复到手动窗口放置。</p>

        
        ]]>
      </description>
    </item>
    
    
    
    <item>
      <title>开发指南-未完待续</title>
      <link>/post/2021-7-16/</link>
      <pubDate>Fri, 16 Jul 2021 14:24:34 +0800</pubDate>
      <author>罗泽勋</author>
      <guid>/post/2021-7-16/</guid>
      <description>
        <![CDATA[
        <p>提高质量和生产率是软件工程要解决的核心问题。</p>
<p>软件开发：正确性、健壮性、可靠性、效率、易用性、可读性（可理解性）、可扩展性、可复用性、兼容性、可移植性等。</p>
<p>只记录实际目前为止比较困惑的。</p>
<h3 id="头文件的结构">头文件的结构</h3>
<p>1.为了防止头文件被重复引用，应当用 ifndef/define/endif 结构产生预处理块。</p>
<p>2.用 #include&lt;filename.h&gt;格式来引用非标准库的头文件（编译器将会从标准库目录开始搜索；用 #include&lt;Îy &ldquo;filename.h&rdquo; 格式来引用非标准库的头文件（编译器将从用户的工作目录开始搜索）。（注：一般将 &lt;&gt; 格式的放在前， &ldquo;&ldquo;格式的放在后，为了统一风格）</p>
<p>3.头文件只存放“声明”而不存放“定义”。（C++中，类的成员函数可以在声明的同时被定义，并且自动成为内联函数。但这样做会造成风格不一致，弊大于利！</p>
<p>4.不提倡使用全局变量，尽量不要在头文件中出现 extern int value 这类声明。</p>
<h3 id="头文件作用">头文件作用：</h3>
<ul>
<li>
<p>（1）通过头文件来调用库功能。在很多场合，源代码不便（或不准）向用户公布，只要向用户提供头文件和二进制的库即可。用户只需要按照头文件中的借口声明来调用库的功能，而不必关心接口怎么实现的。编译器会从库中提取相应的代码。</p>
</li>
<li>
<p>（2）头文件能加强类型安全检查。如果某个接口被实现或被使用时，其方式与头文件中的声明不一致，编译器就会指出错误，这一简单的规则能大大减轻程序员调试、改错的负担。</p>
</li>
</ul>
<h3 id="目录结构">目录结构</h3>
<p>如果一个软件的头文件数目比较多（如超过十个），通常应将头文件和定义文件分别保存于不同的目录，以便于维护。</p>
<p>例如可将头文件保存于 include 目录，将定义文件保存于 source 目录（可以是多级目录）。</p>
<p>如果某些头文件是私有的，它不会被用户的程序直接饮用，则没有必要公开其“声明”，可以把这些私有的头文件和定义文件存放于同一个目录。</p>
<h3 id="空行">空行</h3>
<p>1.类声明之后、函数定义结束之后要加空行。</p>
<p>2.在一个函数体内，逻辑上密切相关的语句之间不加空行，其他地方应加空行分割。</p>
<h3 id="代码行">代码行</h3>
<p>1.一行代码只做一件事情，如只定义一个变量，或只写一条语句。</p>
<p>2.if、for、while、do 等语句自占一行，执行语句不得紧跟其后。不论执行语句有多少都要加{}。这样可以防止书写失误。（注：也为了统一风格）</p>
<p>3.尽可能在定义变量的同时初始化该变量（就近原则）。（注：这样可以减少被野指针折磨的痛苦，强烈建议）</p>
<h3 id="代码行内的空格">代码行内的空格</h3>
<p>1.关键字之后要留一个空格。像 if、for、while 等关键字之后应留一个空格再跟左括号 &lsquo;('，以突出关键字。</p>
<p>2.函数名之后不要留空格，紧跟左括号&rsquo;('，以与关键字区别。</p>
<p>3.'(&lsquo;向后紧跟，')'、‘，’、‘；’向前紧跟，紧跟处不留空格。</p>
<p>4.&rsquo;,&lsquo;之后要留空格，如果&rsquo;;&lsquo;不是一行的结束符号，其后要留空格，如for(initialization; condition; update)。</p>
<p>5.【建议】对于表达式比较长的 for 语句和 if 语句，为了紧凑起见可以适当地去掉一些空格。（注：如果真的长到影响阅读，可以考虑）</p>
<h3 id="对齐">对齐</h3>
<p>1.‘{{’h和‘}}’应独占一行并且位于同一列，同时与引用它们的语句左对齐。</p>
<h3 id="长行拆分">长行拆分</h3>
<p>1.代码行最大长度应控制在 70 至 80 个字符以内。</p>
<p>2.【强烈】长表达式要在低优先级操作符处拆分成新行，操作符放在新行之首。</p>

        
        ]]>
      </description>
    </item>
    
    
    
    <item>
      <title>vim 操作备忘</title>
      <link>/post/2021-7-10/</link>
      <pubDate>Sat, 10 Jul 2021 10:35:46 +0800</pubDate>
      
      <guid>/post/2021-7-10/</guid>
      <description>
        <![CDATA[
        <h3 id="一存活">一、存活</h3>
<table>
<thead>
<tr>
<th style="text-align:left">操作</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">i</td>
<td style="text-align:left">Insert 模式，按 ESC 回到 Normal 模式。</td>
</tr>
<tr>
<td style="text-align:left">x</td>
<td style="text-align:left">删除当前光标所在的一个字符。</td>
</tr>
<tr>
<td style="text-align:left">:wq</td>
<td style="text-align:left">保存退出</td>
</tr>
<tr>
<td style="text-align:left">dd</td>
<td style="text-align:left">删除当前行，并存到剪切板</td>
</tr>
<tr>
<td style="text-align:left">p</td>
<td style="text-align:left">粘贴剪切板</td>
</tr>
<tr>
<td style="text-align:left">hjkl</td>
<td style="text-align:left">左下上右</td>
</tr>
<tr>
<td style="text-align:left">:help <command></td>
<td style="text-align:left">显示相关命令的帮助</td>
</tr>
</tbody>
</table>
<h3 id="二感觉良好">二、感觉良好</h3>
<p>1.各种插入模式</p>
<table>
<thead>
<tr>
<th style="text-align:left">操作</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">a</td>
<td style="text-align:left">在光标后插入</td>
</tr>
<tr>
<td style="text-align:left">o</td>
<td style="text-align:left">在当前行后插入一个新行</td>
</tr>
<tr>
<td style="text-align:left">O</td>
<td style="text-align:left">在当前行前插入一个新行</td>
</tr>
<tr>
<td style="text-align:left">cw</td>
<td style="text-align:left">替换从光标所在位置到一个单词结尾的字符</td>
</tr>
</tbody>
</table>
<p>2.简单的光标移动</p>
<table>
<thead>
<tr>
<th style="text-align:left">操作</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">0</td>
<td style="text-align:left">数字零，到行头</td>
</tr>
<tr>
<td style="text-align:left">^</td>
<td style="text-align:left">到本行第一个不是 blank 字符的位置（blank 字符就是空格、tab、换行、回车等）</td>
</tr>
<tr>
<td style="text-align:left">$</td>
<td style="text-align:left">到本行行尾</td>
</tr>
<tr>
<td style="text-align:left">g_</td>
<td style="text-align:left">到本行最后一个不是 blank 字符的位置</td>
</tr>
<tr>
<td style="text-align:left">/pattern</td>
<td style="text-align:left">搜索 pattern 的字符串（多个匹配时，按 n 到下一个）</td>
</tr>
</tbody>
</table>
<p>3.拷贝/粘贴</p>
<table>
<thead>
<tr>
<th style="text-align:left">操作</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">p</td>
<td style="text-align:left">粘贴</td>
</tr>
<tr>
<td style="text-align:left">yy</td>
<td style="text-align:left">拷贝当前行</td>
</tr>
</tbody>
</table>
<p>4.撤销反撤销</p>
<table>
<thead>
<tr>
<th style="text-align:left">操作</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">u</td>
<td style="text-align:left">撤销</td>
</tr>
<tr>
<td style="text-align:left">ctrl-r</td>
<td style="text-align:left">反撤销</td>
</tr>
</tbody>
</table>
<p>5.打开/保存/退出/改变文件（Buffer)</p>
<table>
<thead>
<tr>
<th style="text-align:left">操作</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">:e &lt;path/to/file&gt;</td>
<td style="text-align:left">打开一个文件</td>
</tr>
<tr>
<td style="text-align:left">:w</td>
<td style="text-align:left">保存</td>
</tr>
<tr>
<td style="text-align:left">:saveas &lt;path/to/file&gt;</td>
<td style="text-align:left">另存为</td>
</tr>
<tr>
<td style="text-align:left">:x, ZZ 或 :wq</td>
<td style="text-align:left">保存并退出(:x仅在需要时保存)</td>
</tr>
<tr>
<td style="text-align:left">:q!</td>
<td style="text-align:left">退出不保存</td>
</tr>
<tr>
<td style="text-align:left">:qa!</td>
<td style="text-align:left">强行退出所有正在编辑的文件</td>
</tr>
<tr>
<td style="text-align:left">:n， :bn</td>
<td style="text-align:left">下一个文件</td>
</tr>
<tr>
<td style="text-align:left">:bp</td>
<td style="text-align:left">上一个文件</td>
</tr>
</tbody>
</table>
<h3 id="三更好更强更快">三、更好、更强、更快</h3>
<h3 id="未完待续">未完待续</h3>

        
        ]]>
      </description>
    </item>
    
    
    
    <item>
      <title>从零开始搭建个人网站——小白篇</title>
      <link>/post/2021-6-1/</link>
      <pubDate>Tue, 01 Jun 2021 06:16:32 +0800</pubDate>
      <author>罗泽勋</author>
      <guid>/post/2021-6-1/</guid>
      <description>
        <![CDATA[
        <h3 id="前言">前言</h3>
<p>小白篇和前面<a href="../2021-2-18-2/">正经篇</a>的区别是，懒人篇专门针对基础更浅（或者更懒的）朋友而设计，在这里不会新建一个网站，而是下载我预先准备好的<a href="https://gitee.com/lzxqaq/demosite.git">示例网站</a>，在这个示例上面做扩展。这样也是为了避免新手成功创建网站时，面对空荡荡的网站不知所措的尴尬。</p>
<h3 id="准备工作与前篇一致">准备工作（与前篇一致）</h3>
<p>1.注册 Github 帐号。前往 <a href="https://github.com/" target="_blank">github.com</a> 注册一个 Github 帐号。（友情提示：认真考虑注册时的用户名，它将是你网站网址的一部分）</p>
<p>补充：Github 是一个代码托管平台（远程仓库），你可以将网站的源代码放在上面，Github Pages 是一个免费的静态网站服务，你将网站的源文件放在上面，它会提供一个链接，使互联网上的人都能访问你的网站。</p>
<p>2.准备Git。</p>
<p>（1）下载安装。前往 <a href="https://git-scm.com/download/win" target="_blank">这里</a> ，点击下载 Git-**-64-bit.exe。然后安装，不懂的话一直 next 。</p>
<p>（2）配置。在 win10 搜索 cmd ，打开命令提示符，输入 <code>git config --global user.email &quot;你注册Github所用的邮箱&quot;</code> 回车执行，再输入 <code>git config --global user.name &quot;你的昵称&quot;</code> 回车执行。</p>
<p>3.安装 Hugo。（官方教程可看<a href="https://www.gohugo.org/doc/tutorials/installing-on-windows/" target="_blank">这里</a>)</p>
<p>（1）首先在 D 盘创建一个新文件夹 Hugo，然后在里面创建 bin 和 sites两个文件夹。bin 将用来放 Hugo 的可执行文件，sites 将用来放你的网站的源代码。</p>
<p>（2）前往<a href="https://github.com/spf13/hugo/releases" target="_blank">这里</a>，找到并下载 hugo_*_Windows-64bit.zip。解压，如果是一个 hugo_*_windows_amd64.exe 文件，将它改名为 hugo.exe。</p>
<p>（3）将这个 hugo.exe 文件移动到刚刚创建的 bin 文件夹里。</p>
<p>（4）配置环境变量。方法1:在 win10 搜索 cmd，右键<strong>以管理员身份打开</strong>命令提示符，将 <code>setx &quot;Path&quot; &quot;%PATH%;D:\Hugo\bin&quot; /m </code>复制粘贴上去，回车（输入命令后需回车执行，后文不再赘述）。 方法2：在 win10 搜索环境变量，进去找到系统变量中的 Path，-&gt;编辑-&gt;新建，然后将 <code>D:\Hugo\bin</code> 复制进去，确定。</p>
<p>（5）验证。重新打开命令提示符（关闭上一步骤使用的），输入执行 <code>hugo help</code>，如果你能看到 hugo 的帮助文档，就验证成功，否则检查上述步骤是否出错。</p>
<h3 id="开始">开始</h3>
<p>1.建立博客网站</p>
<p>（1）下载示例网站。打开命令提示符，执行 <code>D:</code> 切换 D 盘，然后执行 <code>cd D:\Hugo\sites</code> 进入 D:\Hugo\sites 目录（便捷方法：在文件资源管理器中进入相应目录，单击地址栏右边空白地方，在文本最左输入 <code>cmd </code> 加空格，回车），执行命令 <code>git clone https://gitee.com/lzxqaq/demosite.git</code> ，如最后出现 <code>** 100% ** 完成</code> 则成功。（此时可在文件资源管理器中查看下载的文件夹 <code>demosite</code>）</p>
<p>（2）预览。紧接上一步，在命令提示符中执行 <code>cd demosite</code> 进入 demosite 目录，先执行 <code>hugo</code> ，再执行 <code>hugo server</code>。打开浏览器，输入网址访问 localhost:1313。</p>
<p>2.将网站展示文件存放到 Github 远程仓库。</p>
<p>（1）在 Github 中创建一个名为 你的仓库名字.github.io 的仓库，在设置中检查 Github Pages。</p>
<p>（2）打开命令提示符，进入 demosite\public 目录，分别执行</p>
<pre tabindex="0"><code>git init 
git add .
git commit -m &quot;first commit&quot;
git remote add origin https://github.com/你的Github名字/你的Github名字.github.io.git
git push --set-upstream origin master
</code></pre><p>输入账号名，密码，完成上传。</p>
<p>（3）测试。访问 github.com 网站，在你之前创建的仓库可以看到刚刚上传的文件。随后检查 Github Pages 设置，打开网址 <code>https://你的Github账户名.github.io</code> 访问你的网站，如果没有之前预览的网页，可以等待一会再刷新。</p>
<p>3.自定义域名（可选、需要一定的时间）</p>
<p>（1）购买域名。在华为云、阿里云等服务商购买域名。注意：国内购买域名需要实名认证。</p>
<p>（2）配置。访问 github.com 网站，进入你的仓库，在 setting 中找到 Github Pages，在 Custom domain 输入框中输入你的域名，保存。</p>
<p>（3）测试。访问你的域名。</p>

        
        ]]>
      </description>
    </item>
    
    
    
    <item>
      <title>【规约】 C&#43;&#43; 编程篇</title>
      <link>/post/c&#43;&#43;codingguidelines/</link>
      <pubDate>Fri, 28 May 2021 11:46:44 +0800</pubDate>
      
      <guid>/post/c&#43;&#43;codingguidelines/</guid>
      <description>
        <![CDATA[
        <h3 id="前言">前言</h3>
<p>“码出高效，码出质量”。本文整理了比较常见的 C++ 编程规范，主要来源于华为《软件编程规范总则》。</p>
<h3 id="一排版">（一）排版</h3>
<p>1.程序块要采用缩进风格编写，缩进的空格数位 4 个。对齐只用空格键，不适用tab键。<br>
2.相对独立的程序块之间、变量说明之后必须加空行。<br>
3.较长的语句（&gt;80 字符）要分成多行书写，长表达式要在低优先级操作符划分新行，操作符放在新行之首。<br>
4.if、for、do、while、case、switch、default 等语句自占一行，且执行语句部分无论多少都要加括号 {}。</p>
<h3 id="二注释">（二）注释</h3>
<p>1.一般情况下，源程序有效注释量必须在 20% 以上。<br>
2.说明性文件（如头文件 .h 文件、.inc 文件、.def 文件等）头部应进行注释，注释必须列出：版权说明、版本号、生成日期、作者、内容、功能、与其他头文件关系、修改日志等，头文件注释中还应有函数功能简要说明。<br>
3.源文件头部应进行注释，列出：版权说明、版本号、生成日期、作者、模块目的/功能、主要函数及其功能、修改日志等。<br>
4.函数头部应进行注释，列出：函数的目的/功能、输入参数、输出参数、返回值、调用关系（函数、表）等。<br>
5.边写代码边注释，修改代码同时修改响应的注释。不再有用的注释 要删除。<br>
6.注释格式尽量统一，建议使用“/<em>…………</em>/”。<br>
7.注释应考虑程序易读性，建议使用中文。</p>
<h3 id="三标识符命名">（三）标识符命名</h3>
<p>1.命名规范必须与所使用的系统风格保持一致，并在同一项目中统一，比如采用 UNIX 的全小写加下划线风格或大小写混排的方式，不要将两种方式混合使用。用作特殊标识如标识成员变量或全局变量的 m_ 和 g_，其后加上大小写混排的方式是允许的。<br>
示例：Add_User 不允许，add_user、AddUser、m_AddUser允许。</p>
<p>2.用正确的反义词组命名具有互斥意义的变量或相反动作的函数等。<br>
说明：以下是一些在软件中常用的反义词组。<br>
add / remove    begin / end    create / destroy<br>
insert /delete    first / last    get / release<br>
increment / decrement    put / get<br>
add /delete    lock unlock    open /close<br>
min / max    old /new     stat / stop<br>
next /previous    source / target    show / hide<br>
send / receive    source / destination <br>
cut /paste    up / down<br>
示例：<br>
int min_sum;<br>
int max_sum;<br>
int add_user( BYTE *user_name );<br>
int delete_user( BYTE *user_name);</p>
<h3 id="四可测性">（四）可测性</h3>
<p>1.使用断言来发现软件问题，提高代码可测性。</p>
<h3 id="五程序效率">（五）程序效率</h3>
<p>1.多重循环中，应将最忙的循环放在最内层。<br>
2.尽量减少循环嵌套层次。<br>
3.尽量使用乘法或其他方法代替除法特别是浮点运算中的除法（占用较多 CPU 资源）。</p>
<h3 id="六质量保证">（六）质量保证</h3>
<p>1.防止引用已经释放的内存空间。<br>
2.过程/函数中分配的内存，在过程/函数退出之前要释放。<br>
3.过程/函数中申请的（为打开文件而使用的）文件句柄，在过程/函数退出之前要关闭。<br>
4.防止内存操作越界。<br>
5.编程时，要防止差 1 错误。（&lt;=、&lt;等注意）<br>
6.if 语句尽量加上 else 分支，switch 语句必须有 default 分支。<br>
7.Unix 下，多线程的子线程退出必需采用主动退出的方式，即子线程应 return 出口。<br>
8.时刻注意表达式是否会上溢、下溢。使用变量时要注意其边界值的情况。</p>

        
        ]]>
      </description>
    </item>
    
    
    
    <item>
      <title>【规约】 Java 编程篇</title>
      <link>/post/javacodingguidelines/</link>
      <pubDate>Fri, 28 May 2021 10:36:40 +0800</pubDate>
      
      <guid>/post/javacodingguidelines/</guid>
      <description>
        <![CDATA[
        <h3 id="前言">前言</h3>
<p>“码出高效，码出质量”。本文整理了比较常见的 Java 编程规范，主要来源于《阿里巴巴 Java 开发手册》。</p>
<h3 id="一命名风格">（一）命名风格</h3>
<p>1.【强制】类名使用 UpperCamelCase风格，但以下情形例外：DO  /  BO  /  DTO  /  VO  /  AO  /  PO  /  UID等。
正例：MarcoPolo  /  UserDO  /  XmlService  /  TcpUdpDeal  /TaPromotion</p>
<p>2.【强制】方法名、参数名、成员变量、局部变量都统一使用 lowerCamelCase 风格，必须遵从驼峰形式。<br>
正例：localValue  /  getHttpMessage()  /  inputUserId</p>
<p>3.【强制】常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。<br>
正例：MAX_STOCK_COUNT</p>
<p>4.【强制】抽象类命名使用 Abstract 或 Base 开头；异常类命名使用 Exception 结尾；测试类命名以它要测试的类的名称开始，以 Test 结尾。</p>
<p>5.【强制】类型与中括号紧挨起来表示数组。<br>
正例：int[] arrayDemo;</p>
<p>6.【强制】POJO 类中布尔类型的变量，都不要加 is 前缀。</p>
<p>7.【强制】包名统一使用小写，点分隔符之间有且只有一个自然语义的英语单词。包名统一使用单数形式，但是类名如果有复数含义，类名可以使用复数形式。<br>
正例：应用工具类包名为 com.alibaba.ai.util、类名为 MessageUtils。</p>
<p>8.【强制】杜绝完全不规范的缩写，任何自定义编程元素在命名时，使用尽量完整的单词组合来表达其意。</p>
<p>9.【推荐】如果模块、接口、类、方法使用了设计模式，在命名时需体系那具体模式。</p>
<p>10.【推荐】接口类的方法和属性不要加任何修饰符号（public 也不要加），保持代码整洁，并加上有效的 Javadoc 注释。</p>
<p>11.【强制】对于 Service 和 DAO 类，基于 SOA 的理念，暴露出来的一定时接口，内部的实现类用 Impl 的后缀与接口区别。<br>
正例：CacheServiceImpl 实现 CacheService。</p>
<p>12.【参考】各层命名规约：
A）Service/DAO 层方法命名规约<br>
1）获取单个对象的方法用 get 做前缀。<br>
2）获取多个对象的方法用 list 做前缀，复数形式结尾如： listObjects。<br>
3）获取统计值的方法用 count 做前缀。<br>
4）插入的方法用 save/insert 做前缀<br>
5）删除的方法用 remove/delete 做前缀<br>
6）修改的方法用 update 做前缀<br>
B）领域模型命名规约<br>
1）数据对象：xxxDO，xxx 即为数据表名。<br>
2）数据传输对象：xxxDTO，xxx 为业务领域相关的名称。<br>
3）展示对象：xxxVO，xxx 一般为网页名称。<br>
4) POJO 是 DO/DTO/BO/VO 的统称，禁止命名为 xxxPOJO。</p>
<p>13.【强制】不允许任何魔法值（即未经预先i当以的常量）出现在代码中。<br>
反例：String key = &ldquo;ID#taobao_&rdquo; + tradeId;</p>
<p>14.【强制】代码格式，具体见下面正例。
正例：</p>
<pre tabindex="0"><code>    public static void main(String[] args) {
        // 缩进4个空格，注释内空1格
        String say = &quot;hello&quot;;
        // 运算符左右必须有一个空格
        int flag = 0;
        // 关键词 if 与括号之间必须有一个空格
        if (flag == 0) {
            System.out.println(say);
        }

        // 左大括号前加空格且不换行，左大括号后换行。
        if (flag == 0) {
            System.out.println(&quot;world&quot;);
        //  右大括号前换行，右大括号后有 else，不用换行、
        }
        else {
            System.out.printLn(&quot;ok&quot;);
        }
    }</code></pre>
        
        ]]>
      </description>
    </item>
    
    
    
    <item>
      <title>【规约】 MySQL 数据库篇</title>
      <link>/post/databaseguidelines/</link>
      <pubDate>Fri, 28 May 2021 09:03:51 +0800</pubDate>
      
      <guid>/post/databaseguidelines/</guid>
      <description>
        <![CDATA[
        <h3 id="前言">前言</h3>
<p>“码出高效，码出质量”。本文整理了比较常见的 MySQL 数据库编程规范，主要来源于《阿里巴巴 Java 开发手册》。</p>
<h3 id="一建表规约">(一)建表规约</h3>
<p>1.【强制】表达是与否概念的字段，必须使用 is_xxx 的方式命名，数据类型是 unsigned tinying(1 表示是，0 表示否)。<br>
说明：任何字段如果为非负数，必须是 unsigned。<br>
注意：POJO 类中任何布尔类型的变量，都不要加 is 前缀，所以，需要在 <resultMap> 设置从 is_xxx 到 Xxx 的映射关系。数据库表示是与否的值，使用 tinyint 类型，坚持 is_xxx 的命名方式是为了明确其取值含义与范围。<br>
正例：表达逻辑删除的字段名 is_deleted，1 表示删除，0 表示未删除。</p>
<p>2.【强制】表名、字段名必须使用小写字母或数字，禁止出现数字开头，禁止两个下划线中间只出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。<br>
说明:MySQL 在 Windows 下不区分大小写，但在 Linux 下默认是区分大小写。因此，数据库名、表名、字段名，都不允许出现任何大小写字母，避免节外生枝。<br>
正例：aliyun_admin, rdc_config, level3_name
反例：AliyunAdmin, rdcConfig, level_3_name</p>
<p>3.【强制】表明不使用复数名词。
说明：表名应该仅仅表示表里面的实体内容，不应该表示实体数量，对应于 DO 类名也是单数形式，符合表达习惯。</p>
<p>4.【强制】主键索引名为 pk_字段名；唯一索引名为 uk_字段名；普通索引名则为 idx_字段名。<br>
说明：pk_ 即 primary key；uk_ 即 unique key；idx_ 即 index 的简称。</p>
<p>5.【小数类型】为 decimal，禁止使用 float 和 double。<br>
说明：float 和 double 在存储的时候，存在精度损失的问题，很可能在值的比较时，得不到正确的结果。如果存储的数据范围超 decimal 的范围，建议将数据拆成整数和小数分开存储。</p>
<p>6.【强制】如果存储的字符串长度几乎相等，使用 char 定长字符串类型。</p>
<p>7.【强制】varchar 是可变字符串，不与先分配存储控件，长度不要超过 5000，如果存储长度大于此值，定义字段类型为 text,独立出来一张表，用主键来对应，避免影响其他字段索引效率。</p>
<p>8.【强制】表必备三字段：id, gmt_create, gmt_modified。<br>
说明：其中 id 必为主键，类型为 bigint unsigned、单表自增、步长为 1。gmt_create，gmt_modified 的类型均为 datetime 类型，前者现在时表示主动创建，后者过去分词表示被动更新。</p>
<p>9.【推荐】表的命名最好是加上”业务名称_表的作用“。<br>
正例：alipay_task   /   force_project   /   trade_config</p>
<p>10.【推荐】库名与应用名称尽量一致。</p>
<p>11.【推荐】字段允许适当冗余，以提高查询性能，但必须考虑数据一致。冗余字段应遵循：<br>
1）不是频繁修改的字段。<br>
2）不是 varchar 超长字段，更不能是 text 字段。<br>
正例：商品类目名称使用频率高，字段长度短，名称基本一成不变，可在相关联的表中冗余存储类目名称，避免关联查询。</p>
<p>12.【参考】合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检索速度。<br>
正例：  人  150岁之内   tinyint unsigned    1字节   无符号值：0 到 255<br>
龟  数百岁  smallint unsigned   2字节   无符号值：0 到65535</p>
<h3 id="二索引规约">（二）索引规约</h3>
<p>1.【强制】业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引。<br>
说明：不要以为唯一索引影响了 insert 速度，这个速度的损耗可以忽略，但提高查找速度是明显的；另外，只要没有唯一索引，必定有脏数据产生（墨菲定律）。</p>
<p>2.【强制】超过三个表禁止 join。需要 join 的字段，数据类型必须绝对一致；多表关联查询时，保证被关联的字段有索引。<br>
说明：join 需要注意表索引、SQL 性能。</p>
<p>3.【强制】在 varchar 字段上建立索引时，必须根据文本区分度指定索引长度。</p>
<p>4.【强制】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。<br>
说明：索引文件具有 B-Tree 的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。</p>
<p>5.【推荐】利用覆盖索引来进行查询操作，避免回表。</p>
<p>6.【参考】创建索引时避免有如下极端误解：<br>
1）宁滥勿缺。认为一个查询就需要建一个索引。<br>
2）宁缺毋滥。认为索引会消耗空间、严重拖慢更新和新增速度。<br>
3）抵制唯一索引。认为业务的唯一性一律需要在应用层通过”先查后插“方式解决。</p>
<h3 id="三sql-语句">（三）SQL 语句</h3>
<p>1.【强制】不要使用 count(列名) 或 count(常量) 来替代 count(*)。</p>
<p>2.【强制】使用 ISNULL() 来判断是否为 NULL 值。</p>
<p>3.【强制】不得使用外键和级联，一切外键概念不必在应用层解决。
说明：外键与级联更新使用于单机低并发，不适合分布式、高并发集群；级联更新时强阻塞，存在数据库过呢更新风暴的风险；外键影响数据库的插入速度。</p>
<p>4.【推荐】尽量避免 in 操作，若使用也需评估 in 后边的集合元素数量，控制在 1000 个之内。</p>

        
        ]]>
      </description>
    </item>
    
    
    
    <item>
      <title>[做点有趣的]C&#43;&#43;做一个哈夫曼压缩软件</title>
      <link>/post/zxhan/</link>
      <pubDate>Tue, 25 May 2021 07:12:32 +0800</pubDate>
      
      <guid>/post/zxhan/</guid>
      <description>
        <![CDATA[
        <h3 id="前言">前言</h3>
<p>这是以前的一个实训周作业，核心是哈夫曼编码和解码，软件界面由 QT 实现。代码量很小，比较简单。</p>
<p>源代码： <a href="https://gitee.com/lzxqaq/zxhan.git">https://gitee.com/lzxqaq/zxhan.git</a></p>
<p>介绍：<a href="https://lzxqaq.com/post/zxhan/">https://lzxqaq.com/post/zxhan/</a></p>
<p>算法参考：<a href="https://blog.csdn.net/small_hacker/article/details/52843738">Huffman压缩真正的C++实现</a></p>
<p>运行环境：Linux 系统（Windows系统下运行尚有 bug ),开发环境为 QT Creator。</p>
<p>运行截图：</p>
<div  align="center">    
 <img src="https://cdn.jsdelivr.net/gh/lzxqaq/zxhan@master/images/zxhan.png" width = "500" height = "200" alt="图片名称" align=center /></div>
<!-- ![img](https://cdn.jsdelivr.net/gh/lzxqaq/zxhan@master/images/zxhan.png) -->
<h3 id="核心实现">核心实现</h3>
<pre tabindex="0"><code>void create_node_array();//构造包含字符及其频率的数组
void create_pq();//构造优先级队列
void create_huffman_tree();//构造哈夫曼树
void create_map_table(Node* node,bool);//根据哈夫曼树建立哈夫曼映射表
bool calculate_huffman_codes();//计算哈夫曼编码
bool do_compress();//开始压缩
bool rebuid_huffman_tree();//从哈夫曼编码文件中重构哈夫曼树
void decode_huffman();//根据重构的哈夫曼树解码文件

</code></pre><h3 id="后续">后续</h3>
<p>该项目仍有许多不足之处，如果你对该项目有任何意见或建议，欢迎<a href="https://lzxqaq.com/about/">联系我</a>。如有任何问题，亦可与我一同探讨。</p>

        
        ]]>
      </description>
    </item>
    
    
    
    <item>
      <title>[做点有趣的]Java开发泡泡堂游戏（MVC架构）</title>
      <link>/post/paopaotang/</link>
      <pubDate>Sat, 08 May 2021 11:09:51 +0800</pubDate>
      
      <guid>/post/paopaotang/</guid>
      <description>
        <![CDATA[
        <h3 id="介绍">介绍</h3>
<p>本项目是一个很久以前的实训周项目，当时花费了两天左右时间，由我和我的组员 ljr 共同实现。整个项目思路清晰，整体难度不大，但是很多细节需要花功夫。本项目仍存在一些不足的地方，后续可能会进行优化，现在我将项目源代码和一些实现思路开源公布。</p>
<p>源代码：<a href="https://gitee.com/lzxqaq/CrazyArcade">https://gitee.com/lzxqaq/CrazyArcade</a></p>
<p>文章介绍：<a href="https://lzxqaq.com/post/java/paopaotang/">https://lzxqaq.com/post/java/paopaotang/</a></p>
<p>程序运行： 在终端下进入执行程序所在目录，执行 <code>java -jar CrazyArcade.jar</code> 或者双击 <code>CrazyArcade.jar</code>，或者在开发环境中打开源代码，运行 <code>GameStart.java</code>的 <code>main</code> 方法。</p>
<p>运行环境：Linux、Windows均可。开发环境：IDEA。</p>
<p>演示视频：</p>
<p>运行截图：</p>
<div  align="center">    
 <img src="https://cdn.jsdelivr.net/gh/lzxqaq/CrazyArcade@master/images/CrazyArcade.png" width = "500" height = "200" alt="图片1" align=center />
 <br/>
  <img src="https://cdn.jsdelivr.net/gh/lzxqaq/CrazyArcade/images/2.png" width = "500" height = "200" alt="图片2" align=center />
 </div>
<h3 id="功能">功能</h3>
<p>本项目实现的功能如下：</p>
<ul>
<li>绘制游戏启动界面、结束界面、地图、主角、道具</li>
<li>实现泡泡爆炸</li>
<li>实现双主角PK（积分制）</li>
<li>实现道具掉落和相应属性加成</li>
<li>实现游戏音效和背景音乐</li>
</ul>
<p>其中我们对游戏玩法做了调整，大致如下:</p>
<p>我们把游戏设计为双人pk积分赛模式，在这个模式里面，玩家只要率先达到一定分数既可以赢得比赛。玩家可以通过炸箱子可以得到少量的分数，也可以通过炸掉对手然后戳破包围对手的水泡得到大量分数。而玩家如果被泡泡爆炸击中，会被泡泡包裹一段时间，在这段时间内不可以移动和放泡泡，需要等时间过去或者被对手戳破水泡才能获得自由。但如果玩家被自己放的泡泡炸中，会扣一定的分数。</p>
<h3 id="思路和架构">思路和架构</h3>
<p>整个项目采用 MVC 架构，将项目整体分为数据模型层（M）、视图层（V）、控制层（C）。M层负责元素的创建、存储、管理，V层负责所有元素的显示（24帧/秒），C层负责交互（监听用户的操作），同时负责控制游戏的进程。</p>
<p>选择MVC架构最主要的原因是让这个游戏项目具有良好的可扩展性和更新功能，当然了，一个好的游戏也需要良好的交互功能，漂亮的UI设计。</p>
<p>架构设计图：</p>
<div  align="center">    
 <img src="https://cdn.jsdelivr.net/gh/lzxqaq/CrazyArcade@master/images/design.png" width = "500" height = "200" alt="图片名称" align=center /></div>
<h3 id="包结构">包结构</h3>
<p>未完待续……</p>
<h3 id="核心实现">核心实现</h3>
<p>未完待续……</p>
<h3 id="后续">后续</h3>
<p>该项目仍有许多不足之处，如果你对该项目有任何意见或建议，欢迎<a href="https://lzxqaq.com/about/">联系我</a>。如有任何问题，亦可与我一同探讨。</p>

        
        ]]>
      </description>
    </item>
    
    
    
    <item>
      <title>从零开始搭建个人网站（win10,Github,Hugo）</title>
      <link>/post/2021-2-18-2/</link>
      <pubDate>Thu, 18 Feb 2021 09:03:38 +0800</pubDate>
      <author>罗泽勋</author>
      <guid>/post/2021-2-18-2/</guid>
      <description>
        <![CDATA[
        <h3 id="准备工作">准备工作</h3>
<p>1.注册 Github 帐号。前往 <a href="https://github.com/" target="_blank">github.com</a> 注册一个 Github 帐号。（友情提示：认真考虑注册时的用户名，它将是网址的一部分）</p>
<p>补充：Github 是一个代码托管平台（远程仓库），你可以将网站的源代码放在上面，Github Pages 是一个免费的静态网站服务，你将网站的源文件放在上面，它会提供一个链接，使互联网上的人都能访问你的网站。</p>
<p>2.准备Git。</p>
<p>（1）下载安装。前往 <a href="https://git-scm.com/download/win" target="_blank">这里</a> ，点击下载 Git-**-64-bit.exe。然后安装，不懂的话一直 next 。</p>
<p>（2）配置。在 win10 搜索 cmd ，打开命令提示符，输入 <code>git config --global user.email &quot;你注册Github所用的邮箱&quot;</code> 回车执行，再输入 <code>git config --global user.name &quot;你的昵称&quot;</code> 回车执行。</p>
<p>3.安装 Hugo。（官方教程可看<a href="https://www.gohugo.org/doc/tutorials/installing-on-windows/" target="_blank">这里</a>)</p>
<p>（1）首先在 D 盘创建一个新文件夹 Hugo，然后在里面创建 bin 和 sites两个文件夹。bin 将用来放 Hugo 的可执行文件，sites 将用来放你的网站的源代码。</p>
<p>（2）前往<a href="https://github.com/spf13/hugo/releases" target="_blank">这里</a>，找到并下载 hugo_*_Windows-64bit.zip。解压，如果是一个 hugo_*_windows_amd64.exe 文件，将它改名为 hugo.exe。</p>
<p>（3）将这个 hugo.exe 文件移动到刚刚创建的 bin 文件夹里。</p>
<p>（4）配置环境变量。方法1:在 win10 搜索 cmd，右键<strong>以管理员身份打开</strong>命令提示符，将 <code>setx &quot;Path&quot; &quot;%PATH%;D:\Hugo\bin&quot; /m </code>复制粘贴上去，回车（输入命令后需回车执行，后文不再赘述）。 方法2：在 win10 搜索环境变量，进去找到系统变量中的 Path，-&gt;编辑-&gt;新建，然后将 <code>D:\Hugo\bin</code> 复制进去，确定。</p>
<p>（5）验证。重新打开命令提示符（关闭上一步骤使用的），输入执行 <code>hugo help</code>，如果你能看到 hugo 的帮助文档，就验证成功，否则检查上述步骤是否出错。</p>
<h3 id="开始">开始</h3>
<p>1.建立博客网站</p>
<p>（1）使用 Hugo 建立网站。打开命令提示符，执行 <code>D:</code> 切换 D 盘，然后执行 <code>cd D:\Hugo\sites</code> 进入 D:\Hugo\sites 目录（便捷方法：在文件资源管理器中进入相应目录，单击地址栏右边空白地方，在最左边输入 <code>cmd </code> 加空格，回车），执行命令 <code>hugo new site blog</code> ，如出现 Congratulations! 提示则成功。（此时可在文件资源管理器中查看生成的文件）</p>
<p>（2）下载主题模板（以 Hugo.386 为例）。接上述步骤，在命令提示符中 执行 <code>git clone https://gitlab.com/maxlefou/hugo.386 themes/hugo.386 </code>来下载 hugo.386 主题。</p>
<p>（3）配置。将 hugo.386\exampleSite 文件夹中的 theme.toml 文件复制到文件夹 blog 中，替换原本的。根据需要修改其中的内容。</p>
<p>（4）预览。命令提示符进入 blog 目录，先执行 <code>hugo</code> ，再执行 <code>hugo server</code>。打开浏览器，访问 localhost:1313。</p>
<p>2.将网站展示文件存放到 Github 远程仓库。</p>
<p>（1）在 Github 中创建一个名为 你的仓库名字.github.io 的仓库，在设置 setting 中检查 Github Pages。</p>
<p>（2）打开命令提示符，进入 blog\public 目录，分别执行</p>
<pre tabindex="0"><code>git init 
git add .
git commit -m &quot;first commit&quot;
git remote add origin https://github.com/你的Github名字/你的Github名字.github.io.git
git push --set-upstream origin master
</code></pre><p>输入账号名，密码，完成上传。</p>
<p>（3）测试。访问 github.com 网站，在你之前创建的仓库可以看到刚刚上传的文件。随后检查 Github Pages 设置，访问提供的 <code>https://你的Github账户名.github.io</code> 访问你的网站，如果没有之前预览的网页，可以等待一会再刷新。</p>
<p>3.自定义域名（可选、需要一定的时间）</p>
<p>（1）购买域名。在华为云、阿里云等服务商购买域名。注意：国内购买域名需要实名认证。</p>
<p>（2）配置。访问 github.com 网站，进入你的仓库，在 setting 中找到 Github Pages，在 Custom domain 输入框中输入你的域名，保存。</p>
<p>（3）测试。访问你的域名。</p>

        
        ]]>
      </description>
    </item>
    
    
    
    <item>
      <title>Linux 不同发行版的选择</title>
      <link>/post/2020-12-26/</link>
      <pubDate>Sat, 26 Dec 2020 22:33:13 +0800</pubDate>
      <author>罗泽勋</author>
      <guid>/post/2020-12-26/</guid>
      <description>
        <![CDATA[
        <p>如果你对 Linux 感兴趣但还不了解，想知道 Linux 的不同发行版之间的区别，我的这些经历应该对你有帮助。</p>
<p>我最初使用的是 Ubuntu，它以前经常被推荐为 Linux 入门选择。用了很长一段时间，它给我最大的感受是不稳定和笨重。会经常收到系统内部崩溃的通知，而且另一个问题是装其他显卡驱动时很艰难（做深度学习、玩游戏等等会用到），令我几度崩溃 T_T 。所以，我认为 Ubuntu 对新手非常不友好；</p>
<p>后来我开始尝试 Deepin 系统，这是一款由国内深之度公司推出的发行版，预装软件最符合国人习惯，而且上手简单，系统不需要怎么配置就能拥有漂亮的界面。但是很快我就不能忍受它的软件源的落后。软件获取、维护便捷本该是 Linux 系统的一大优点，它可以为很多工作带来便利。</p>
<p>接着我来到 Arch 的世界。遗憾的是 Arch Linux 我在尝试的中途便放弃了。它确实很棒，从零开始定制操作系统很诱人，但是因为时间关系，我需要的是能快速上手，成为主力的操作系统。</p>
<p>最后，我接触到了很多人推荐的 Manjaro，它是为了让用户更方便使用的 Arch 衍生版。安装之后确实让我很惊喜，它完美符合我对操作系统的需求：上手简单、使用高效、美。而且尝试过后我才知道 Arch 系的软件仓库 AUR 有多强大。AUR 是一个社区维护的软件包仓库，有了它，你可以轻易获取到很多想要的软件。因此我很推荐使用 Manjaro。</p>
<p>（顺便提一下最稳定发行版之一的 CentOS。当我想在服务器上尝试它时，它就被官宣抛弃了……）</p>

        
        ]]>
      </description>
    </item>
    
    
    
    <item>
      <title>String 类真的不可以改变吗？</title>
      <link>/post/2020-12-15-2/</link>
      <pubDate>Tue, 15 Dec 2020 15:05:27 +0800</pubDate>
      <author>罗泽勋</author>
      <guid>/post/2020-12-15-2/</guid>
      <description>
        <![CDATA[
        <p>对于 java.lang.String 类，我相信很多人印象里都是它不能被改变。通过查看源码，可以知道 String 有一个 final char 数组的变量，这个变量初始化之后便不能重新赋值。虽然这个变量引用的 char 数组的值虽然可以改变，但是String 类中并没有主动修改 这个 char 数组的方法。这就是通常所说 String 类不可变的依据。</p>
<p>然而在学习反射的时候，我产生了一个疑问：我们不可以通过反射修改 String 内部的 char 数组的值吗？答案是可以的，了解 Java 反射的人很容易就做到这点。那为什么还说 String 不可变呢？在思考过后，我得出一个答案：String 的不可变说的是一种约束规范。换句话说，String 的不可变是有好处的。在实际工作中，代码是自己写来用的，没有人会费劲给自己找麻烦，而没有任何益处。</p>
<p>事情到这里就完了？不，最近我再去了解 String 、String Pool（字符串常量池）的时候，又有了一些疑惑，于是亲手操刀给String 来了一次手术。最后也是加深了对 String 的理解，也验证了上面的观点。先上代码（如果你对任一实验结果感到疑惑，没关系，请带着疑惑来看后面的对照实验）：</p>
<pre tabindex="0"><code>    //实验1
    String s1 = &quot;1&quot;;
    Field valueField = String.class.getDeclaredField(&quot;value&quot;);
    valueField.setAccessible(true);
    char[] value = (char[]) valueField.get(s1);
    value[0] = '2';
    System.out.println(s1);                 //2
    System.out.println((s1 == &quot;1&quot;));        //true
</code></pre><p>上述实验 1 做的事情就是：用 <code>s1 = &quot;1&quot; </code> 的方式创建字符串，用反射修改它的值为 <code>&quot;2&quot;</code>,最后用它与 <code>&quot;1&quot;</code> 比较，结果是 <code>true</code> 。琢磨琢磨，再看下一段代码：</p>
<pre tabindex="0"><code>    //实验2
    String s2 = new String(&quot;1&quot;);
    Field valueField = String.class.getDeclaredField(&quot;value&quot;);
    valueField.setAccessible(true);
    char[] value2 = (char[]) valueField.get(s2);
    value2[0] = '2';
    System.out.println(s2);                //2
    System.out.println((s2 == &quot;1&quot;));       //false
</code></pre><p>上述实验 2 和实验 1 唯一的区别是字符串创建方式，实验2是通过 <code>new String(&quot;1&quot;)</code> 方式创建，实验1是通过 <code>= &quot;1&quot;</code> 的方式创建。而实验2的结果： <code>s2 == &quot;1&quot;</code> 是 <code>false</code> 。</p>
<p>到这里，可以停一会了。很多技术文章中都做过类似上面的实验（通过比较创建方式的区别、反射修改等)，来分析 String 、String Pool 的原理和设计理念。但我总觉得以此说明最终的结论还不够严谨、或者说还不够直观。接下来请看——魔鬼实验：</p>
<pre tabindex="0"><code>    //实验3 
    String s1 = &quot;1&quot;;
    Field valueField = String.class.getDeclaredField(&quot;value&quot;);
    valueField.setAccessible(true);
    char[] value = (char[]) valueField.get(s1);
    value[0] = '2';
    System.out.println(s1);                 //2
    System.out.println((s1 == &quot;1&quot;));        //true
    System.out.println(&quot;1&quot;);                //2
</code></pre><p>不难发现，实验3仅仅只是在实验1的基础上输出了 <code>&quot;1&quot;</code> 的值。然而 <code>&quot;1&quot;</code> 输出的值为 2，这样的结果，也许有人会困惑，没关系,看完几个对比实验，相信你会对相关理论（String 、String Pool 等）有了更直观的认识。接下来，请看终极实验：</p>
<pre tabindex="0"><code>    //实验4
    String s2 = new String(&quot;1&quot;);
    Field valueField = String.class.getDeclaredField(&quot;value&quot;);
    valueField.setAccessible(true);
    char[] value2 = (char[]) valueField.get(s2);
    value2[0] = '2';
    System.out.println(s2);                 //2
    System.out.println((s2 == &quot;1&quot;));        //false
    System.out.println(&quot;1&quot;);                //2
</code></pre><p>同样的，上述实验 4 只是在实验 2 的基础上输出了 <code>&quot;1&quot;</code> 的值。结果 <code>&quot;1&quot;</code> 的值还是 2。</p>
<p><strong>结论：</strong><br>
基于对 String 类和字符串常量池（String Pool） 的了解，我对以上实验作出解释（详细理论下回贴出）:</p>
<p>实验 3 中 字符串 <code>s1</code> 通过直接赋值字符串常量 <code>&quot;1&quot;</code> 的方式创建，因此 <strong><code>s1</code> 会直接引用字符串常量池中 <code>&quot;1&quot;</code> 对应的对象</strong>。对 <code>s1</code> 的修改，也就是对常量池中 <code>&quot;1&quot;</code> 对象的修改，因此 <code>s1</code> 和 <code>&quot;1&quot;</code> 的值都是修改后的 2，而 <code>s1 == &quot;1&quot;</code> 也是 <code>true</code>,因为它们是同一个对象的引用。</p>
<p>实验 4 中 字符串 <code>s2</code> 通过 <code>new String(&quot;1&quot;)</code>的方式创建，因此，<strong><code>s2</code> 会被新建在堆中，并且，<code>s2</code> 的 <code>char</code> 数组变量会直接引用字符串常量池中 &ldquo;1&quot;对象的 <code>char</code> 数组</strong>，也就是说虽然 <code>s2</code> 是新创建的对象，但是 <code>s2</code> 里存储字符的 <code>char</code> 数组是创建时传进来的字符串常量 <code>&quot;1&quot;</code> 的 <code>char</code> 数组。因此，<code>s2</code> 修改 <code>char</code> 数组,<code>&quot;1&quot;</code> 的也会变。<code>s2</code> 和 <code>&quot;1&quot;</code> 的值都是修改后的 2 。而 <code>s2 == &quot;1&quot;</code> 是 <code>false</code> 的，因为它们引用的不是同一个对象。</p>
<p>最终结论，String 类真的是“不可以”变的！因为这不仅仅是它的特点，更是它的设计初衷。（<del>任何想通过反射修改它的人都应该被拉去祭天</del>)</p>
<p>如果你发现任何问题，请<a href="/about">联系</a>我。</p>

        
        ]]>
      </description>
    </item>
    
    
  </channel>
</rss>
