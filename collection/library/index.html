<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>【转载】C&#43;&#43; 开发必备之链接装载库 | 罗泽勋</title>
<meta name="keywords" content="">
<meta name="description" content="转载自https://github.com/huihut/interview 本节部分知识点来自《程序员的自我修养——链接装载库》 内存、栈、堆">
<meta name="author" content="">
<link rel="canonical" href="/collection/library/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.48a18943c2fc15c38a372b8dde1f5e5dc0bc64fa6cb90f5a817d2f8c76b7f3ae.css" integrity="sha256-SKGJQ8L8FcOKNyuN3h9eXcC8ZPpsuQ9agX0vjHa3864=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.4dcb3c4f38462f66c6b6137227726f5543cb934cca9788f041c087e374491df2.js" integrity="sha256-Tcs8TzhGL2bGthNyJ3JvVUPLk0zKl4jwQcCH43RJHfI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="/collection/library/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-KDTTBGMLCQ"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-KDTTBGMLCQ', { 'anonymize_ip': false });
}
</script>
<meta property="og:title" content="【转载】C&#43;&#43; 开发必备之链接装载库" />
<meta property="og:description" content="转载自https://github.com/huihut/interview 本节部分知识点来自《程序员的自我修养——链接装载库》 内存、栈、堆" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/collection/library/" /><meta property="article:section" content="collection" />
<meta property="article:published_time" content="2022-01-15T08:10:50&#43;08:00" />
<meta property="article:modified_time" content="2022-01-15T08:10:50&#43;08:00" />


<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="【转载】C&#43;&#43; 开发必备之链接装载库"/>
<meta name="twitter:description" content="转载自https://github.com/huihut/interview 本节部分知识点来自《程序员的自我修养——链接装载库》 内存、栈、堆"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "收录文章",
      "item": "/collection/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "【转载】C++ 开发必备之链接装载库",
      "item": "/collection/library/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "【转载】C++ 开发必备之链接装载库",
  "name": "【转载】C\u002b\u002b 开发必备之链接装载库",
  "description": "转载自https://github.com/huihut/interview 本节部分知识点来自《程序员的自我修养——链接装载库》 内存、栈、堆",
  "keywords": [
    
  ],
  "articleBody": "转载自https://github.com/huihut/interview\n 本节部分知识点来自《程序员的自我修养——链接装载库》\n 内存、栈、堆 一般应用程序内存空间有如下区域：\n 栈：由操作系统自动分配释放，存放函数的参数值、局部变量等的值，用于维护函数调用的上下文 堆：一般由程序员分配释放，若程序员不释放，程序结束时可能由操作系统回收，用来容纳应用程序动态分配的内存区域 可执行文件映像：存储着可执行文件在内存中的映像，由装载器装载是将可执行文件的内存读取或映射到这里 保留区：保留区并不是一个单一的内存区域，而是对内存中受到保护而禁止访问的内存区域的总称，如通常 C 语言讲无效指针赋值为 0（NULL），因此 0 地址正常情况下不可能有效的访问数据  栈 栈保存了一个函数调用所需要的维护信息，常被称为堆栈帧（Stack Frame）或活动记录（Activate Record），一般包含以下几方面：\n 函数的返回地址和参数 临时变量：包括函数的非静态局部变量以及编译器自动生成的其他临时变量 保存上下文：包括函数调用前后需要保持不变的寄存器  堆 堆分配算法：\n 空闲链表（Free List） 位图（Bitmap） 对象池  “段错误（segment fault）” 或 “非法操作，该内存地址不能 read/write” 典型的非法指针解引用造成的错误。当指针指向一个不允许读写的内存地址，而程序却试图利用指针来读或写该地址时，会出现这个错误。\n普遍原因：\n 将指针初始化为 NULL，之后没有给它一个合理的值就开始使用指针 没用初始化栈中的指针，指针的值一般会是随机数，之后就直接开始使用指针  编译链接 各平台文件格式    平台 可执行文件 目标文件 动态库/共享对象 静态库     Windows exe obj dll lib   Unix/Linux ELF、out o so a   Mac Mach-O o dylib、tbd、framework a、framework    编译链接过程  预编译（预编译器处理如 #include、#define 等预编译指令，生成 .i 或 .ii 文件） 编译（编译器进行词法分析、语法分析、语义分析、中间代码生成、目标代码生成、优化，生成 .s 文件） 汇编（汇编器把汇编码翻译成机器码，生成 .o 文件） 链接（连接器进行地址和空间分配、符号决议、重定位，生成 .out 文件）   现在版本 GCC 把预编译和编译合成一步，预编译编译程序 cc1、汇编器 as、连接器 ld\n  MSVC 编译环境，编译器 cl、连接器 link、可执行文件查看器 dumpbin\n 目标文件 编译器编译源代码后生成的文件叫做目标文件。目标文件从结构上讲，它是已经编译后的可执行文件格式，只是还没有经过链接的过程，其中可能有些符号或有些地址还没有被调整。\n 可执行文件（Windows 的 .exe 和 Linux 的 ELF）、动态链接库（Windows 的 .dll 和 Linux 的 .so）、静态链接库（Windows 的 .lib 和 Linux 的 .a）都是按照可执行文件格式存储（Windows 按照 PE-COFF，Linux 按照 ELF）\n 目标文件格式  Windows 的 PE（Portable Executable），或称为 PE-COFF，.obj 格式 Linux 的 ELF（Executable Linkable Format），.o 格式 Intel/Microsoft 的 OMF（Object Module Format） Unix 的 a.out 格式 MS-DOS 的 .COM 格式   PE 和 ELF 都是 COFF（Common File Format）的变种\n 目标文件存储结构    段 功能     File Header 文件头，描述整个文件的文件属性（包括文件是否可执行、是静态链接或动态连接及入口地址、目标硬件、目标操作系统等）   .text section 代码段，执行语句编译成的机器代码   .data section 数据段，已初始化的全局变量和局部静态变量   .bss section BSS 段（Block Started by Symbol），未初始化的全局变量和局部静态变量（因为默认值为 0，所以只是在此预留位置，不占空间）   .rodata section 只读数据段，存放只读数据，一般是程序里面的只读变量（如 const 修饰的变量）和字符串常量   .comment section 注释信息段，存放编译器版本信息   .note.GNU-stack section 堆栈提示段     其他段略\n 链接的接口————符号 在链接中，目标文件之间相互拼合实际上是目标文件之间对地址的引用，即对函数和变量的地址的引用。我们将函数和变量统称为符号（Symbol），函数名或变量名就是符号名（Symbol Name）。\n如下符号表（Symbol Table）：\n   Symbol（符号名） Symbol Value （地址）     main 0x100   Add 0x123   … …    Linux 的共享库（Shared Library） Linux 下的共享库就是普通的 ELF 共享对象。\n共享库版本更新应该保证二进制接口 ABI（Application Binary Interface）的兼容\n命名 libname.so.x.y.z\n x：主版本号，不同主版本号的库之间不兼容，需要重新编译 y：次版本号，高版本号向后兼容低版本号 z：发布版本号，不对接口进行更改，完全兼容  路径 大部分包括 Linux 在内的开源系统遵循 FHS（File Hierarchy Standard）的标准，这标准规定了系统文件如何存放，包括各个目录结构、组织和作用。\n /lib：存放系统最关键和最基础的共享库，如动态链接器、C 语言运行库、数学库等 /usr/lib：存放非系统运行时所需要的关键性的库，主要是开发库 /usr/local/lib：存放跟操作系统本身并不十分相关的库，主要是一些第三方应用程序的库   动态链接器会在 /lib、/usr/lib 和由 /etc/ld.so.conf 配置文件指定的，目录中查找共享库\n 环境变量  LD_LIBRARY_PATH：临时改变某个应用程序的共享库查找路径，而不会影响其他应用程序 LD_PRELOAD：指定预先装载的一些共享库甚至是目标文件 LD_DEBUG：打开动态链接器的调试功能  so 共享库的编写 使用 CLion 编写共享库\n创建一个名为 MySharedLib 的共享库\nCMakeLists.txt\ncmake_minimum_required(VERSION 3.10)project(MySharedLib)set(CMAKE_CXX_STANDARD 11)add_library(MySharedLib SHARED library.cpp library.h)library.h\n#ifndef MYSHAREDLIB_LIBRARY_H #define MYSHAREDLIB_LIBRARY_H  // 打印 Hello World! void hello(); // 使用可变模版参数求和 template typename T T sum(T t) { return t; } template typename T, typename ...Types T sum(T first, Types ... rest) { return first + sumT(rest...); } #endif library.cpp\n#include #include \"library.h\" void hello() { std::cout  \"Hello, World!\"  std::endl; } so 共享库的使用（被可执行项目调用） 使用 CLion 调用共享库\n创建一个名为 TestSharedLib 的可执行项目\nCMakeLists.txt\ncmake_minimum_required(VERSION 3.10)project(TestSharedLib)# C++11 编译 set(CMAKE_CXX_STANDARD 11)# 头文件路径 set(INC_DIR /home/xx/code/clion/MySharedLib)# 库文件路径 set(LIB_DIR /home/xx/code/clion/MySharedLib/cmake-build-debug)include_directories(${INC_DIR})link_directories(${LIB_DIR})link_libraries(MySharedLib)add_executable(TestSharedLib main.cpp)# 链接 MySharedLib 库 target_link_libraries(TestSharedLib MySharedLib)main.cpp\n#include #include \"library.h\"using std::cout; using std::endl; int main() { hello(); cout  \"1 + 2 = \"  sum(1,2)  endl; cout  \"1 + 2 + 3 = \"  sum(1,2,3)  endl; return 0; } 执行结果\nHello, World! 1 + 2 = 3 1 + 2 + 3 = 6 Windows 应用程序入口函数  GUI（Graphical User Interface）应用，链接器选项：/SUBSYSTEM:WINDOWS CUI（Console User Interface）应用，链接器选项：/SUBSYSTEM:CONSOLE  _tWinMain 与 _tmain 函数声明\nInt WINAPI _tWinMain( HINSTANCE hInstanceExe, HINSTANCE, PTSTR pszCmdLine, int nCmdShow); int _tmain( int argc, TCHAR *argv[], TCHAR *envp[]);    应用程序类型 入口点函数 嵌入可执行文件的启动函数     处理ANSI字符（串）的GUI应用程序 _tWinMain(WinMain) WinMainCRTSartup   处理Unicode字符（串）的GUI应用程序 _tWinMain(wWinMain) wWinMainCRTSartup   处理ANSI字符（串）的CUI应用程序 _tmain(Main) mainCRTSartup   处理Unicode字符（串）的CUI应用程序 _tmain(wMain) wmainCRTSartup   动态链接库（Dynamic-Link Library） DllMain _DllMainCRTStartup    Windows 的动态链接库（Dynamic-Link Library）  部分知识点来自《Windows 核心编程（第五版）》\n 用处  扩展了应用程序的特性 简化了项目管理 有助于节省内存 促进了资源的共享 促进了本地化 有助于解决平台间的差异 可以用于特殊目的  注意  创建 DLL，事实上是在创建可供一个可执行模块调用的函数 当一个模块提供一个内存分配函数（malloc、new）的时候，它必须同时提供另一个内存释放函数（free、delete） 在使用 C 和 C++ 混编的时候，要使用 extern “C” 修饰符 一个 DLL 可以导出函数、变量（避免导出）、C++ 类（导出导入需要同编译器，否则避免导出） DLL 模块：cpp 文件中的 __declspec(dllexport) 写在 include 头文件之前 调用 DLL 的可执行模块：cpp 文件的 __declspec(dllimport) 之前不应该定义 MYLIBAPI  加载 Windows 程序的搜索顺序  包含可执行文件的目录 Windows 的系统目录，可以通过 GetSystemDirectory 得到 16 位的系统目录，即 Windows 目录中的 System 子目录 Windows 目录，可以通过 GetWindowsDirectory 得到 进程的当前目录 PATH 环境变量中所列出的目录  DLL 入口函数 DllMain 函数\nBOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved) { switch(fdwReason) { case DLL_PROCESS_ATTACH: // 第一次将一个DLL映射到进程地址空间时调用  // The DLL is being mapped into the process' address space.  break; case DLL_THREAD_ATTACH: // 当进程创建一个线程的时候，用于告诉DLL执行与线程相关的初始化（非主线程执行）  // A thread is bing created.  break; case DLL_THREAD_DETACH: // 系统调用 ExitThread 线程退出前，即将终止的线程通过告诉DLL执行与线程相关的清理  // A thread is exiting cleanly.  break; case DLL_PROCESS_DETACH: // 将一个DLL从进程的地址空间时调用  // The DLL is being unmapped from the process' address space.  break; } return (TRUE); // Used only for DLL_PROCESS_ATTACH } 载入卸载库 LoadLibrary、LoadLibraryExA、LoadPackagedLibrary、FreeLibrary、FreeLibraryAndExitThread 函数声明\n// 载入库 HMODULE WINAPI LoadLibrary( _In_ LPCTSTR lpFileName ); HMODULE LoadLibraryExA( LPCSTR lpLibFileName, HANDLE hFile, DWORD dwFlags ); // 若要在通用 Windows 平台（UWP）应用中加载 Win32 DLL，需要调用 LoadPackagedLibrary，而不是 LoadLibrary 或 LoadLibraryEx HMODULE LoadPackagedLibrary( LPCWSTR lpwLibFileName, DWORD Reserved ); // 卸载库 BOOL WINAPI FreeLibrary( _In_ HMODULE hModule ); // 卸载库和退出线程 VOID WINAPI FreeLibraryAndExitThread( _In_ HMODULE hModule, _In_ DWORD dwExitCode ); 显示地链接到导出符号 GetProcAddress 函数声明\nFARPROC GetProcAddress( HMODULE hInstDll, PCSTR pszSymbolName // 只能接受 ANSI 字符串，不能是 Unicode ); DumpBin.exe 查看 DLL 信息 在 VS 的开发人员命令提示符 使用 DumpBin.exe 可查看 DLL 库的导出段（导出的变量、函数、类名的符号）、相对虚拟地址（RVA，relative virtual address）。如：\nDUMPBIN -exports D:\\mydll.dll LoadLibrary 与 FreeLibrary 流程图 LoadLibrary 与 FreeLibrary 流程图\nLoadLibrary FreeLibrary DLL 库的编写（导出一个 DLL 模块） DLL 库的编写（导出一个 DLL 模块） DLL 头文件\n// MyLib.h  #ifdef MYLIBAPI  // MYLIBAPI 应该在全部 DLL 源文件的 include \"Mylib.h\" 之前被定义 // 全部函数/变量正在被导出  #else  // 这个头文件被一个exe源代码模块包含，意味着全部函数/变量被导入 #define MYLIBAPI extern \"C\" __declspec(dllimport)  #endif  // 这里定义任何的数据结构和符号  // 定义导出的变量（避免导出变量） MYLIBAPI int g_nResult; // 定义导出函数原型 MYLIBAPI int Add(int nLeft, int nRight); DLL 源文件\n// MyLibFile1.cpp  // 包含标准Windows和C运行时头文件 #include  // DLL源码文件导出的函数和变量 #define MYLIBAPI extern \"C\" __declspec(dllexport)  // 包含导出的数据结构、符号、函数、变量 #include \"MyLib.h\" // 将此DLL源代码文件的代码放在此处 int g_nResult; int Add(int nLeft, int nRight) { g_nResult = nLeft + nRight; return g_nResult; } DLL 库的使用（运行时动态链接 DLL） DLL 库的使用（运行时动态链接 DLL）\n// A simple program that uses LoadLibrary and // GetProcAddress to access myPuts from Myputs.dll.  #include  #include   typedef int (__cdecl *MYPROC)(LPWSTR); int main( void ) { HINSTANCE hinstLib; MYPROC ProcAdd; BOOL fFreeResult, fRunTimeLinkSuccess = FALSE; // Get a handle to the DLL module.  hinstLib = LoadLibrary(TEXT(\"MyPuts.dll\")); // If the handle is valid, try to get the function address.  if (hinstLib != NULL) { ProcAdd = (MYPROC) GetProcAddress(hinstLib, \"myPuts\"); // If the function address is valid, call the function.  if (NULL != ProcAdd) { fRunTimeLinkSuccess = TRUE; (ProcAdd) (L\"Message sent to the DLL function\\n\"); } // Free the DLL module.  fFreeResult = FreeLibrary(hinstLib); } // If unable to call the DLL function, use an alternative.  if (! fRunTimeLinkSuccess) printf(\"Message printed from executable\\n\"); return 0; } 运行库（Runtime Library） 典型程序运行步骤  操作系统创建进程，把控制权交给程序的入口（往往是运行库中的某个入口函数） 入口函数对运行库和程序运行环境进行初始化（包括堆、I/O、线程、全局变量构造等等）。 入口函数初始化后，调用 main 函数，正式开始执行程序主体部分。 main 函数执行完毕后，返回到入口函数进行清理工作（包括全局变量析构、堆销毁、关闭I/O等），然后进行系统调用结束进程。   一个程序的 I/O 指代程序与外界的交互，包括文件、管程、网络、命令行、信号等。更广义地讲，I/O 指代操作系统理解为 “文件” 的事物。\n glibc 入口 _start - __libc_start_main - exit - _exit\n其中 main(argc, argv, __environ) 函数在 __libc_start_main 里执行。\nMSVC CRT 入口 int mainCRTStartup(void)\n执行如下操作：\n 初始化和 OS 版本有关的全局变量。 初始化堆。 初始化 I/O。 获取命令行参数和环境变量。 初始化 C 库的一些数据。 调用 main 并记录返回值。 检查错误并将 main 的返回值返回。  C 语言运行库（CRT） 大致包含如下功能：\n 启动与退出：包括入口函数及入口函数所依赖的其他函数等。 标准函数：有 C 语言标准规定的C语言标准库所拥有的函数实现。 I/O：I/O 功能的封装和实现。 堆：堆的封装和实现。 语言实现：语言中一些特殊功能的实现。 调试：实现调试功能的代码。  C语言标准库（ANSI C） 包含：\n 标准输入输出（stdio.h） 文件操作（stdio.h） 字符操作（ctype.h） 字符串操作（string.h） 数学函数（math.h） 资源管理（stdlib.h） 格式转换（stdlib.h） 时间/日期（time.h） 断言（assert.h） 各种类型上的常数（limits.h \u0026 float.h） 变长参数（stdarg.h） 非局部跳转（setjmp.h）  ",
  "wordCount" : "4669",
  "inLanguage": "en",
  "datePublished": "2022-01-15T08:10:50+08:00",
  "dateModified": "2022-01-15T08:10:50+08:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/collection/library/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "罗泽勋",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="罗泽勋 (Alt + H)">罗泽勋</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                    <li>
                        <a href="/cn/" title="中文"
                            aria-label="中文">Cn</a>
                    </li>
                </ul>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/blog/" title="Blog">
                    <span>Blog</span>
                </a>
            </li>
            <li>
                <a href="/about" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Program">
                    <span>Program</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      【转载】C&#43;&#43; 开发必备之链接装载库
    </h1>
    <div class="post-meta"><span title='2022-01-15 08:10:50 +0800 CST'>January 15, 2022</span>

</div>
  </header> 
  <div class="post-content"><p>转载自<a href="https://github.com/huihut/interview">https://github.com/huihut/interview</a></p>
<blockquote>
<p>本节部分知识点来自《程序员的自我修养——链接装载库》</p>
</blockquote>
<h3 id="内存栈堆">内存、栈、堆<a hidden class="anchor" aria-hidden="true" href="#内存栈堆">#</a></h3>
<p>一般应用程序内存空间有如下区域：</p>
<ul>
<li>栈：由操作系统自动分配释放，存放函数的参数值、局部变量等的值，用于维护函数调用的上下文</li>
<li>堆：一般由程序员分配释放，若程序员不释放，程序结束时可能由操作系统回收，用来容纳应用程序动态分配的内存区域</li>
<li>可执行文件映像：存储着可执行文件在内存中的映像，由装载器装载是将可执行文件的内存读取或映射到这里</li>
<li>保留区：保留区并不是一个单一的内存区域，而是对内存中受到保护而禁止访问的内存区域的总称，如通常 C 语言讲无效指针赋值为 0（NULL），因此 0 地址正常情况下不可能有效的访问数据</li>
</ul>
<h4 id="栈">栈<a hidden class="anchor" aria-hidden="true" href="#栈">#</a></h4>
<p>栈保存了一个函数调用所需要的维护信息，常被称为堆栈帧（Stack Frame）或活动记录（Activate Record），一般包含以下几方面：</p>
<ul>
<li>函数的返回地址和参数</li>
<li>临时变量：包括函数的非静态局部变量以及编译器自动生成的其他临时变量</li>
<li>保存上下文：包括函数调用前后需要保持不变的寄存器</li>
</ul>
<h4 id="堆">堆<a hidden class="anchor" aria-hidden="true" href="#堆">#</a></h4>
<p>堆分配算法：</p>
<ul>
<li>空闲链表（Free List）</li>
<li>位图（Bitmap）</li>
<li>对象池</li>
</ul>
<h4 id="段错误segment-fault-或-非法操作该内存地址不能-readwrite">“段错误（segment fault）” 或 “非法操作，该内存地址不能 read/write”<a hidden class="anchor" aria-hidden="true" href="#段错误segment-fault-或-非法操作该内存地址不能-readwrite">#</a></h4>
<p>典型的非法指针解引用造成的错误。当指针指向一个不允许读写的内存地址，而程序却试图利用指针来读或写该地址时，会出现这个错误。</p>
<p>普遍原因：</p>
<ul>
<li>将指针初始化为 NULL，之后没有给它一个合理的值就开始使用指针</li>
<li>没用初始化栈中的指针，指针的值一般会是随机数，之后就直接开始使用指针</li>
</ul>
<h3 id="编译链接">编译链接<a hidden class="anchor" aria-hidden="true" href="#编译链接">#</a></h3>
<h4 id="各平台文件格式">各平台文件格式<a hidden class="anchor" aria-hidden="true" href="#各平台文件格式">#</a></h4>
<table>
<thead>
<tr>
<th>平台</th>
<th>可执行文件</th>
<th>目标文件</th>
<th>动态库/共享对象</th>
<th>静态库</th>
</tr>
</thead>
<tbody>
<tr>
<td>Windows</td>
<td>exe</td>
<td>obj</td>
<td>dll</td>
<td>lib</td>
</tr>
<tr>
<td>Unix/Linux</td>
<td>ELF、out</td>
<td>o</td>
<td>so</td>
<td>a</td>
</tr>
<tr>
<td>Mac</td>
<td>Mach-O</td>
<td>o</td>
<td>dylib、tbd、framework</td>
<td>a、framework</td>
</tr>
</tbody>
</table>
<h4 id="编译链接过程">编译链接过程<a hidden class="anchor" aria-hidden="true" href="#编译链接过程">#</a></h4>
<ol>
<li>预编译（预编译器处理如 <code>#include</code>、<code>#define</code> 等预编译指令，生成 <code>.i</code> 或 <code>.ii</code> 文件）</li>
<li>编译（编译器进行词法分析、语法分析、语义分析、中间代码生成、目标代码生成、优化，生成 <code>.s</code> 文件）</li>
<li>汇编（汇编器把汇编码翻译成机器码，生成 <code>.o</code> 文件）</li>
<li>链接（连接器进行地址和空间分配、符号决议、重定位，生成 <code>.out</code> 文件）</li>
</ol>
<blockquote>
<p>现在版本 GCC 把预编译和编译合成一步，预编译编译程序 cc1、汇编器 as、连接器 ld</p>
</blockquote>
<blockquote>
<p>MSVC 编译环境，编译器 cl、连接器 link、可执行文件查看器 dumpbin</p>
</blockquote>
<h4 id="目标文件">目标文件<a hidden class="anchor" aria-hidden="true" href="#目标文件">#</a></h4>
<p>编译器编译源代码后生成的文件叫做目标文件。目标文件从结构上讲，它是已经编译后的可执行文件格式，只是还没有经过链接的过程，其中可能有些符号或有些地址还没有被调整。</p>
<blockquote>
<p>可执行文件（Windows 的 <code>.exe</code> 和 Linux 的 <code>ELF</code>）、动态链接库（Windows 的 <code>.dll</code> 和 Linux 的 <code>.so</code>）、静态链接库（Windows 的 <code>.lib</code> 和 Linux 的 <code>.a</code>）都是按照可执行文件格式存储（Windows 按照 PE-COFF，Linux 按照 ELF）</p>
</blockquote>
<h5 id="目标文件格式">目标文件格式<a hidden class="anchor" aria-hidden="true" href="#目标文件格式">#</a></h5>
<ul>
<li>Windows 的 PE（Portable Executable），或称为 PE-COFF，<code>.obj</code> 格式</li>
<li>Linux 的 ELF（Executable Linkable Format），<code>.o</code> 格式</li>
<li>Intel/Microsoft 的 OMF（Object Module Format）</li>
<li>Unix 的 <code>a.out</code> 格式</li>
<li>MS-DOS 的 <code>.COM</code> 格式</li>
</ul>
<blockquote>
<p>PE 和 ELF 都是 COFF（Common File Format）的变种</p>
</blockquote>
<h5 id="目标文件存储结构">目标文件存储结构<a hidden class="anchor" aria-hidden="true" href="#目标文件存储结构">#</a></h5>
<table>
<thead>
<tr>
<th>段</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>File Header</td>
<td>文件头，描述整个文件的文件属性（包括文件是否可执行、是静态链接或动态连接及入口地址、目标硬件、目标操作系统等）</td>
</tr>
<tr>
<td>.text section</td>
<td>代码段，执行语句编译成的机器代码</td>
</tr>
<tr>
<td>.data section</td>
<td>数据段，已初始化的全局变量和局部静态变量</td>
</tr>
<tr>
<td>.bss section</td>
<td>BSS 段（Block Started by Symbol），未初始化的全局变量和局部静态变量（因为默认值为 0，所以只是在此预留位置，不占空间）</td>
</tr>
<tr>
<td>.rodata section</td>
<td>只读数据段，存放只读数据，一般是程序里面的只读变量（如 const 修饰的变量）和字符串常量</td>
</tr>
<tr>
<td>.comment section</td>
<td>注释信息段，存放编译器版本信息</td>
</tr>
<tr>
<td>.note.GNU-stack section</td>
<td>堆栈提示段</td>
</tr>
</tbody>
</table>
<blockquote>
<p>其他段略</p>
</blockquote>
<h4 id="链接的接口符号">链接的接口————符号<a hidden class="anchor" aria-hidden="true" href="#链接的接口符号">#</a></h4>
<p>在链接中，目标文件之间相互拼合实际上是目标文件之间对地址的引用，即对函数和变量的地址的引用。我们将函数和变量统称为符号（Symbol），函数名或变量名就是符号名（Symbol Name）。</p>
<p>如下符号表（Symbol Table）：</p>
<table>
<thead>
<tr>
<th>Symbol（符号名）</th>
<th>Symbol Value （地址）</th>
</tr>
</thead>
<tbody>
<tr>
<td>main</td>
<td>0x100</td>
</tr>
<tr>
<td>Add</td>
<td>0x123</td>
</tr>
<tr>
<td>&hellip;</td>
<td>&hellip;</td>
</tr>
</tbody>
</table>
<h3 id="linux-的共享库shared-library">Linux 的共享库（Shared Library）<a hidden class="anchor" aria-hidden="true" href="#linux-的共享库shared-library">#</a></h3>
<p>Linux 下的共享库就是普通的 ELF 共享对象。</p>
<p>共享库版本更新应该保证二进制接口 ABI（Application Binary Interface）的兼容</p>
<h4 id="命名">命名<a hidden class="anchor" aria-hidden="true" href="#命名">#</a></h4>
<p><code>libname.so.x.y.z</code></p>
<ul>
<li>x：主版本号，不同主版本号的库之间不兼容，需要重新编译</li>
<li>y：次版本号，高版本号向后兼容低版本号</li>
<li>z：发布版本号，不对接口进行更改，完全兼容</li>
</ul>
<h4 id="路径">路径<a hidden class="anchor" aria-hidden="true" href="#路径">#</a></h4>
<p>大部分包括 Linux 在内的开源系统遵循 FHS（File Hierarchy Standard）的标准，这标准规定了系统文件如何存放，包括各个目录结构、组织和作用。</p>
<ul>
<li><code>/lib</code>：存放系统最关键和最基础的共享库，如动态链接器、C 语言运行库、数学库等</li>
<li><code>/usr/lib</code>：存放非系统运行时所需要的关键性的库，主要是开发库</li>
<li><code>/usr/local/lib</code>：存放跟操作系统本身并不十分相关的库，主要是一些第三方应用程序的库</li>
</ul>
<blockquote>
<p>动态链接器会在 <code>/lib</code>、<code>/usr/lib</code> 和由 <code>/etc/ld.so.conf</code> 配置文件指定的，目录中查找共享库</p>
</blockquote>
<h4 id="环境变量">环境变量<a hidden class="anchor" aria-hidden="true" href="#环境变量">#</a></h4>
<ul>
<li><code>LD_LIBRARY_PATH</code>：临时改变某个应用程序的共享库查找路径，而不会影响其他应用程序</li>
<li><code>LD_PRELOAD</code>：指定预先装载的一些共享库甚至是目标文件</li>
<li><code>LD_DEBUG</code>：打开动态链接器的调试功能</li>
</ul>
<h4 id="so-共享库的编写">so 共享库的编写<a hidden class="anchor" aria-hidden="true" href="#so-共享库的编写">#</a></h4>
<p>使用 CLion 编写共享库</p>
<p>创建一个名为 MySharedLib 的共享库</p>
<p>CMakeLists.txt</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cmake" data-lang="cmake"><span class="line"><span class="cl"><span class="nb">cmake_minimum_required</span><span class="p">(</span><span class="s">VERSION</span> <span class="s">3.10</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">project</span><span class="p">(</span><span class="s">MySharedLib</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">set</span><span class="p">(</span><span class="s">CMAKE_CXX_STANDARD</span> <span class="s">11</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">add_library</span><span class="p">(</span><span class="s">MySharedLib</span> <span class="s">SHARED</span> <span class="s">library.cpp</span> <span class="s">library.h</span><span class="p">)</span><span class="err">
</span></span></span></code></pre></div><p>library.h</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#ifndef MYSHAREDLIB_LIBRARY_H
</span></span></span><span class="line"><span class="cl"><span class="cp">#define MYSHAREDLIB_LIBRARY_H
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 打印 Hello World!
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">hello</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 使用可变模版参数求和
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">T</span> <span class="n">sum</span><span class="p">(</span><span class="n">T</span> <span class="n">t</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">t</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="p">...</span><span class="n">Types</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">T</span> <span class="n">sum</span><span class="p">(</span><span class="n">T</span> <span class="n">first</span><span class="p">,</span> <span class="n">Types</span> <span class="p">...</span> <span class="n">rest</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">first</span> <span class="o">+</span> <span class="n">sum</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">rest</span><span class="p">...);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cp">#endif
</span></span></span></code></pre></div><p>library.cpp</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;library.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">hello</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;Hello, World!&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="so-共享库的使用被可执行项目调用">so 共享库的使用（被可执行项目调用）<a hidden class="anchor" aria-hidden="true" href="#so-共享库的使用被可执行项目调用">#</a></h4>
<p>使用 CLion 调用共享库</p>
<p>创建一个名为 TestSharedLib 的可执行项目</p>
<p>CMakeLists.txt</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cmake" data-lang="cmake"><span class="line"><span class="cl"><span class="nb">cmake_minimum_required</span><span class="p">(</span><span class="s">VERSION</span> <span class="s">3.10</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">project</span><span class="p">(</span><span class="s">TestSharedLib</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># C++11 编译
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">set</span><span class="p">(</span><span class="s">CMAKE_CXX_STANDARD</span> <span class="s">11</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 头文件路径
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">set</span><span class="p">(</span><span class="s">INC_DIR</span> <span class="s">/home/xx/code/clion/MySharedLib</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 库文件路径
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">set</span><span class="p">(</span><span class="s">LIB_DIR</span> <span class="s">/home/xx/code/clion/MySharedLib/cmake-build-debug</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">include_directories</span><span class="p">(</span><span class="o">${</span><span class="nv">INC_DIR</span><span class="o">}</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">link_directories</span><span class="p">(</span><span class="o">${</span><span class="nv">LIB_DIR</span><span class="o">}</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">link_libraries</span><span class="p">(</span><span class="s">MySharedLib</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nb">add_executable</span><span class="p">(</span><span class="s">TestSharedLib</span> <span class="s">main.cpp</span><span class="p">)</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="c"># 链接 MySharedLib 库
</span></span></span><span class="line"><span class="cl"><span class="c"></span><span class="nb">target_link_libraries</span><span class="p">(</span><span class="s">TestSharedLib</span> <span class="s">MySharedLib</span><span class="p">)</span><span class="err">
</span></span></span></code></pre></div><p>main.cpp</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;library.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">hello</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;1 + 2 = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;1 + 2 + 3 = &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>执行结果</p>
<pre tabindex="0"><code>Hello, World!
1 + 2 = 3
1 + 2 + 3 = 6
</code></pre><h3 id="windows-应用程序入口函数">Windows 应用程序入口函数<a hidden class="anchor" aria-hidden="true" href="#windows-应用程序入口函数">#</a></h3>
<ul>
<li>GUI（Graphical User Interface）应用，链接器选项：<code>/SUBSYSTEM:WINDOWS</code></li>
<li>CUI（Console User Interface）应用，链接器选项：<code>/SUBSYSTEM:CONSOLE</code></li>
</ul>
<p>_tWinMain 与 _tmain 函数声明</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">Int</span> <span class="n">WINAPI</span> <span class="nf">_tWinMain</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="n">HINSTANCE</span> <span class="n">hInstanceExe</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">HINSTANCE</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">PTSTR</span> <span class="n">pszCmdLine</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">nCmdShow</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">_tmain</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">argc</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">TCHAR</span> <span class="o">*</span><span class="n">argv</span><span class="p">[],</span>
</span></span><span class="line"><span class="cl">    <span class="n">TCHAR</span> <span class="o">*</span><span class="n">envp</span><span class="p">[]);</span>
</span></span></code></pre></div><table>
<thead>
<tr>
<th>应用程序类型</th>
<th>入口点函数</th>
<th>嵌入可执行文件的启动函数</th>
</tr>
</thead>
<tbody>
<tr>
<td>处理ANSI字符（串）的GUI应用程序</td>
<td>_tWinMain(WinMain)</td>
<td>WinMainCRTSartup</td>
</tr>
<tr>
<td>处理Unicode字符（串）的GUI应用程序</td>
<td>_tWinMain(wWinMain)</td>
<td>wWinMainCRTSartup</td>
</tr>
<tr>
<td>处理ANSI字符（串）的CUI应用程序</td>
<td>_tmain(Main)</td>
<td>mainCRTSartup</td>
</tr>
<tr>
<td>处理Unicode字符（串）的CUI应用程序</td>
<td>_tmain(wMain)</td>
<td>wmainCRTSartup</td>
</tr>
<tr>
<td>动态链接库（Dynamic-Link Library）</td>
<td>DllMain</td>
<td>_DllMainCRTStartup</td>
</tr>
</tbody>
</table>
<h3 id="windows-的动态链接库dynamic-link-library">Windows 的动态链接库（Dynamic-Link Library）<a hidden class="anchor" aria-hidden="true" href="#windows-的动态链接库dynamic-link-library">#</a></h3>
<blockquote>
<p>部分知识点来自《Windows 核心编程（第五版）》</p>
</blockquote>
<h4 id="用处">用处<a hidden class="anchor" aria-hidden="true" href="#用处">#</a></h4>
<ul>
<li>扩展了应用程序的特性</li>
<li>简化了项目管理</li>
<li>有助于节省内存</li>
<li>促进了资源的共享</li>
<li>促进了本地化</li>
<li>有助于解决平台间的差异</li>
<li>可以用于特殊目的</li>
</ul>
<h4 id="注意">注意<a hidden class="anchor" aria-hidden="true" href="#注意">#</a></h4>
<ul>
<li>创建 DLL，事实上是在创建可供一个可执行模块调用的函数</li>
<li>当一个模块提供一个内存分配函数（malloc、new）的时候，它必须同时提供另一个内存释放函数（free、delete）</li>
<li>在使用 C 和 C++ 混编的时候，要使用 extern &ldquo;C&rdquo; 修饰符</li>
<li>一个 DLL 可以导出函数、变量（避免导出）、C++ 类（导出导入需要同编译器，否则避免导出）</li>
<li>DLL 模块：cpp 文件中的 __declspec(dllexport) 写在 include 头文件之前</li>
<li>调用 DLL 的可执行模块：cpp 文件的 __declspec(dllimport) 之前不应该定义 MYLIBAPI</li>
</ul>
<h4 id="加载-windows-程序的搜索顺序">加载 Windows 程序的搜索顺序<a hidden class="anchor" aria-hidden="true" href="#加载-windows-程序的搜索顺序">#</a></h4>
<ol>
<li>包含可执行文件的目录</li>
<li>Windows 的系统目录，可以通过 GetSystemDirectory 得到</li>
<li>16 位的系统目录，即 Windows 目录中的 System 子目录</li>
<li>Windows 目录，可以通过 GetWindowsDirectory 得到</li>
<li>进程的当前目录</li>
<li>PATH 环境变量中所列出的目录</li>
</ol>
<h4 id="dll-入口函数">DLL 入口函数<a hidden class="anchor" aria-hidden="true" href="#dll-入口函数">#</a></h4>
<p>DllMain 函数</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">BOOL</span> <span class="n">WINAPI</span> <span class="nf">DllMain</span><span class="p">(</span><span class="n">HINSTANCE</span> <span class="n">hinstDLL</span><span class="p">,</span> <span class="n">DWORD</span> <span class="n">fdwReason</span><span class="p">,</span> <span class="n">LPVOID</span> <span class="n">lpvReserved</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">switch</span><span class="p">(</span><span class="n">fdwReason</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nl">DLL_PROCESS_ATTACH</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 第一次将一个DLL映射到进程地址空间时调用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// The DLL is being mapped into the process&#39; address space.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nl">DLL_THREAD_ATTACH</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 当进程创建一个线程的时候，用于告诉DLL执行与线程相关的初始化（非主线程执行）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// A thread is bing created.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nl">DLL_THREAD_DETACH</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 系统调用 ExitThread 线程退出前，即将终止的线程通过告诉DLL执行与线程相关的清理
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// A thread is exiting cleanly.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">case</span> <span class="nl">DLL_PROCESS_DETACH</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 将一个DLL从进程的地址空间时调用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="c1">// The DLL is being unmapped from the process&#39; address space.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">(</span><span class="n">TRUE</span><span class="p">);</span> <span class="c1">// Used only for DLL_PROCESS_ATTACH
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><h4 id="载入卸载库">载入卸载库<a hidden class="anchor" aria-hidden="true" href="#载入卸载库">#</a></h4>
<p>LoadLibrary、LoadLibraryExA、LoadPackagedLibrary、FreeLibrary、FreeLibraryAndExitThread 函数声明</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// 载入库
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">HMODULE</span> <span class="n">WINAPI</span> <span class="nf">LoadLibrary</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="n">_In_</span> <span class="n">LPCTSTR</span> <span class="n">lpFileName</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">HMODULE</span> <span class="nf">LoadLibraryExA</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="n">LPCSTR</span> <span class="n">lpLibFileName</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="n">HANDLE</span> <span class="n">hFile</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="n">DWORD</span>  <span class="n">dwFlags</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 若要在通用 Windows 平台（UWP）应用中加载 Win32 DLL，需要调用 LoadPackagedLibrary，而不是 LoadLibrary 或 LoadLibraryEx
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">HMODULE</span> <span class="nf">LoadPackagedLibrary</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="n">LPCWSTR</span> <span class="n">lpwLibFileName</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="n">DWORD</span>   <span class="n">Reserved</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 卸载库
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">BOOL</span> <span class="n">WINAPI</span> <span class="nf">FreeLibrary</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="n">_In_</span> <span class="n">HMODULE</span> <span class="n">hModule</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 卸载库和退出线程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">VOID</span> <span class="n">WINAPI</span> <span class="nf">FreeLibraryAndExitThread</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="n">_In_</span> <span class="n">HMODULE</span> <span class="n">hModule</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="n">_In_</span> <span class="n">DWORD</span>   <span class="n">dwExitCode</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span>
</span></span></code></pre></div><h4 id="显示地链接到导出符号">显示地链接到导出符号<a hidden class="anchor" aria-hidden="true" href="#显示地链接到导出符号">#</a></h4>
<p>GetProcAddress 函数声明</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">FARPROC</span> <span class="nf">GetProcAddress</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">  <span class="n">HMODULE</span> <span class="n">hInstDll</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="n">PCSTR</span> <span class="n">pszSymbolName</span>  <span class="c1">// 只能接受 ANSI 字符串，不能是 Unicode
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">);</span>
</span></span></code></pre></div><h4 id="dumpbinexe-查看-dll-信息">DumpBin.exe 查看 DLL 信息<a hidden class="anchor" aria-hidden="true" href="#dumpbinexe-查看-dll-信息">#</a></h4>
<p>在 <code>VS 的开发人员命令提示符</code> 使用 <code>DumpBin.exe</code> 可查看 DLL 库的导出段（导出的变量、函数、类名的符号）、相对虚拟地址（RVA，relative virtual address）。如：</p>
<pre tabindex="0"><code>DUMPBIN -exports D:\mydll.dll
</code></pre><h4 id="loadlibrary-与-freelibrary-流程图">LoadLibrary 与 FreeLibrary 流程图<a hidden class="anchor" aria-hidden="true" href="#loadlibrary-与-freelibrary-流程图">#</a></h4>
<p>LoadLibrary 与 FreeLibrary 流程图</p>
<h5 id="loadlibrary">LoadLibrary<a hidden class="anchor" aria-hidden="true" href="#loadlibrary">#</a></h5>
<p><img loading="lazy" src="https://gitee.com/huihut/interview/raw/master/images/WindowsLoadLibrary.png" alt="WindowsLoadLibrary"  />
</p>
<h5 id="freelibrary">FreeLibrary<a hidden class="anchor" aria-hidden="true" href="#freelibrary">#</a></h5>
<p><img loading="lazy" src="https://gitee.com/huihut/interview/raw/master/images/WindowsFreeLibrary.png" alt="WindowsFreeLibrary"  />
</p>
<h4 id="dll-库的编写导出一个-dll-模块">DLL 库的编写（导出一个 DLL 模块）<a hidden class="anchor" aria-hidden="true" href="#dll-库的编写导出一个-dll-模块">#</a></h4>
<p>DLL 库的编写（导出一个 DLL 模块）
DLL 头文件</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// MyLib.h
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#ifdef MYLIBAPI
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// MYLIBAPI 应该在全部 DLL 源文件的 include &#34;Mylib.h&#34; 之前被定义
</span></span></span><span class="line"><span class="cl"><span class="c1">// 全部函数/变量正在被导出
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#else
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 这个头文件被一个exe源代码模块包含，意味着全部函数/变量被导入
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#define MYLIBAPI extern &#34;C&#34; __declspec(dllimport)
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 这里定义任何的数据结构和符号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 定义导出的变量（避免导出变量）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">MYLIBAPI</span> <span class="kt">int</span> <span class="n">g_nResult</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 定义导出函数原型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">MYLIBAPI</span> <span class="kt">int</span> <span class="nf">Add</span><span class="p">(</span><span class="kt">int</span> <span class="n">nLeft</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nRight</span><span class="p">);</span>
</span></span></code></pre></div><p>DLL 源文件</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// MyLibFile1.cpp
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 包含标准Windows和C运行时头文件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;windows.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// DLL源码文件导出的函数和变量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#define MYLIBAPI extern &#34;C&#34; __declspec(dllexport)
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 包含导出的数据结构、符号、函数、变量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&#34;MyLib.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 将此DLL源代码文件的代码放在此处
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">g_nResult</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">Add</span><span class="p">(</span><span class="kt">int</span> <span class="n">nLeft</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nRight</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">g_nResult</span> <span class="o">=</span> <span class="n">nLeft</span> <span class="o">+</span> <span class="n">nRight</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">g_nResult</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="dll-库的使用运行时动态链接-dll">DLL 库的使用（运行时动态链接 DLL）<a hidden class="anchor" aria-hidden="true" href="#dll-库的使用运行时动态链接-dll">#</a></h4>
<p>DLL 库的使用（运行时动态链接 DLL）</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// A simple program that uses LoadLibrary and 
</span></span></span><span class="line"><span class="cl"><span class="c1">// GetProcAddress to access myPuts from Myputs.dll. 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> 
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;windows.h&gt; </span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt; </span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span> 
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="nf">int</span> <span class="p">(</span><span class="kr">__cdecl</span> <span class="o">*</span><span class="n">MYPROC</span><span class="p">)(</span><span class="n">LPWSTR</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span> <span class="kt">void</span> <span class="p">)</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span> 
</span></span><span class="line"><span class="cl">    <span class="n">HINSTANCE</span> <span class="n">hinstLib</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="n">MYPROC</span> <span class="n">ProcAdd</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">    <span class="n">BOOL</span> <span class="n">fFreeResult</span><span class="p">,</span> <span class="n">fRunTimeLinkSuccess</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">    <span class="c1">// Get a handle to the DLL module.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> 
</span></span><span class="line"><span class="cl">    <span class="n">hinstLib</span> <span class="o">=</span> <span class="n">LoadLibrary</span><span class="p">(</span><span class="n">TEXT</span><span class="p">(</span><span class="s">&#34;MyPuts.dll&#34;</span><span class="p">));</span> 
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">    <span class="c1">// If the handle is valid, try to get the function address.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> 
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">hinstLib</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span> 
</span></span><span class="line"><span class="cl">        <span class="n">ProcAdd</span> <span class="o">=</span> <span class="p">(</span><span class="n">MYPROC</span><span class="p">)</span> <span class="n">GetProcAddress</span><span class="p">(</span><span class="n">hinstLib</span><span class="p">,</span> <span class="s">&#34;myPuts&#34;</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">        <span class="c1">// If the function address is valid, call the function.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> 
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">!=</span> <span class="n">ProcAdd</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">fRunTimeLinkSuccess</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">(</span><span class="n">ProcAdd</span><span class="p">)</span> <span class="p">(</span><span class="sa">L</span><span class="s">&#34;Message sent to the DLL function</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// Free the DLL module.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> 
</span></span><span class="line"><span class="cl">        <span class="n">fFreeResult</span> <span class="o">=</span> <span class="n">FreeLibrary</span><span class="p">(</span><span class="n">hinstLib</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// If unable to call the DLL function, use an alternative.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">fRunTimeLinkSuccess</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Message printed from executable</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="运行库runtime-library">运行库（Runtime Library）<a hidden class="anchor" aria-hidden="true" href="#运行库runtime-library">#</a></h3>
<h4 id="典型程序运行步骤">典型程序运行步骤<a hidden class="anchor" aria-hidden="true" href="#典型程序运行步骤">#</a></h4>
<ol>
<li>操作系统创建进程，把控制权交给程序的入口（往往是运行库中的某个入口函数）</li>
<li>入口函数对运行库和程序运行环境进行初始化（包括堆、I/O、线程、全局变量构造等等）。</li>
<li>入口函数初始化后，调用 main 函数，正式开始执行程序主体部分。</li>
<li>main 函数执行完毕后，返回到入口函数进行清理工作（包括全局变量析构、堆销毁、关闭I/O等），然后进行系统调用结束进程。</li>
</ol>
<blockquote>
<p>一个程序的 I/O 指代程序与外界的交互，包括文件、管程、网络、命令行、信号等。更广义地讲，I/O 指代操作系统理解为 “文件” 的事物。</p>
</blockquote>
<h4 id="glibc-入口">glibc 入口<a hidden class="anchor" aria-hidden="true" href="#glibc-入口">#</a></h4>
<p><code>_start -&gt; __libc_start_main -&gt; exit -&gt; _exit</code></p>
<p>其中 <code>main(argc, argv, __environ)</code> 函数在 <code>__libc_start_main</code> 里执行。</p>
<h4 id="msvc-crt-入口">MSVC CRT 入口<a hidden class="anchor" aria-hidden="true" href="#msvc-crt-入口">#</a></h4>
<p><code>int mainCRTStartup(void)</code></p>
<p>执行如下操作：</p>
<ol>
<li>初始化和 OS 版本有关的全局变量。</li>
<li>初始化堆。</li>
<li>初始化 I/O。</li>
<li>获取命令行参数和环境变量。</li>
<li>初始化 C 库的一些数据。</li>
<li>调用 main 并记录返回值。</li>
<li>检查错误并将 main 的返回值返回。</li>
</ol>
<h4 id="c-语言运行库crt">C 语言运行库（CRT）<a hidden class="anchor" aria-hidden="true" href="#c-语言运行库crt">#</a></h4>
<p>大致包含如下功能：</p>
<ul>
<li>启动与退出：包括入口函数及入口函数所依赖的其他函数等。</li>
<li>标准函数：有 C 语言标准规定的C语言标准库所拥有的函数实现。</li>
<li>I/O：I/O 功能的封装和实现。</li>
<li>堆：堆的封装和实现。</li>
<li>语言实现：语言中一些特殊功能的实现。</li>
<li>调试：实现调试功能的代码。</li>
</ul>
<h4 id="c语言标准库ansi-c">C语言标准库（ANSI C）<a hidden class="anchor" aria-hidden="true" href="#c语言标准库ansi-c">#</a></h4>
<p>包含：</p>
<ul>
<li>标准输入输出（stdio.h）</li>
<li>文件操作（stdio.h）</li>
<li>字符操作（ctype.h）</li>
<li>字符串操作（string.h）</li>
<li>数学函数（math.h）</li>
<li>资源管理（stdlib.h）</li>
<li>格式转换（stdlib.h）</li>
<li>时间/日期（time.h）</li>
<li>断言（assert.h）</li>
<li>各种类型上的常数（limits.h &amp; float.h）</li>
<li>变长参数（stdarg.h）</li>
<li>非局部跳转（setjmp.h）</li>
</ul>


  </div>

  <footer class="post-footer">
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2022 <a href="/">罗泽勋</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
