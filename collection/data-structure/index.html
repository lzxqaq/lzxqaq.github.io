<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>【转载】C&#43;&#43; 开发必备之数据结构 | 罗泽勋</title>
<meta name="keywords" content="">
<meta name="description" content="转载自https://github.com/huihut/interview 顺序结构 顺序栈（Sequence Stack） SqStack.cpp 顺序栈数据结构和图">
<meta name="author" content="">
<link rel="canonical" href="/collection/data-structure/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.48a18943c2fc15c38a372b8dde1f5e5dc0bc64fa6cb90f5a817d2f8c76b7f3ae.css" integrity="sha256-SKGJQ8L8FcOKNyuN3h9eXcC8ZPpsuQ9agX0vjHa3864=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.4dcb3c4f38462f66c6b6137227726f5543cb934cca9788f041c087e374491df2.js" integrity="sha256-Tcs8TzhGL2bGthNyJ3JvVUPLk0zKl4jwQcCH43RJHfI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="mask-icon" href="/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="/collection/data-structure/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-KDTTBGMLCQ"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-KDTTBGMLCQ', { 'anonymize_ip': false });
}
</script>
<meta property="og:title" content="【转载】C&#43;&#43; 开发必备之数据结构" />
<meta property="og:description" content="转载自https://github.com/huihut/interview 顺序结构 顺序栈（Sequence Stack） SqStack.cpp 顺序栈数据结构和图" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/collection/data-structure/" /><meta property="article:section" content="collection" />
<meta property="article:published_time" content="2022-01-14T20:28:54&#43;08:00" />
<meta property="article:modified_time" content="2022-01-14T20:28:54&#43;08:00" />


<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="【转载】C&#43;&#43; 开发必备之数据结构"/>
<meta name="twitter:description" content="转载自https://github.com/huihut/interview 顺序结构 顺序栈（Sequence Stack） SqStack.cpp 顺序栈数据结构和图"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "收录文章",
      "item": "/collection/"
    }
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "【转载】C++ 开发必备之数据结构",
      "item": "/collection/data-structure/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "【转载】C++ 开发必备之数据结构",
  "name": "【转载】C\u002b\u002b 开发必备之数据结构",
  "description": "转载自https://github.com/huihut/interview 顺序结构 顺序栈（Sequence Stack） SqStack.cpp 顺序栈数据结构和图",
  "keywords": [
    
  ],
  "articleBody": "转载自https://github.com/huihut/interview\n顺序结构 顺序栈（Sequence Stack） SqStack.cpp\n顺序栈数据结构和图片\ntypedef struct { ElemType *elem; int top; int size; int increment; } SqStack; 队列（Sequence Queue） 队列数据结构\ntypedef struct { ElemType * elem; int front; int rear; int maxSize; }SqQueue; 非循环队列 非循环队列图片\nSqQueue.rear++\n循环队列 循环队列图片\nSqQueue.rear = (SqQueue.rear + 1) % SqQueue.maxSize\n顺序表（Sequence List） SqList.cpp\n顺序表数据结构和图片\ntypedef struct { ElemType *elem; int length; int size; int increment; } SqList; 链式结构 LinkList.cpp\nLinkList_with_head.cpp\n链式数据结构\ntypedef struct LNode { ElemType data; struct LNode *next; } LNode, *LinkList; 链队列（Link Queue） 链队列图片\n线性表的链式表示 单链表（Link List） 单链表图片\n双向链表（Du-Link-List） 双向链表图片\n循环链表（Cir-Link-List） 循环链表图片\n哈希表 HashTable.cpp\n概念 哈希函数：H(key): K - D , key ∈ K\n构造方法  直接定址法 除留余数法 数字分析法 折叠法 平方取中法  冲突处理方法  链地址法：key 相同的用单链表链接 开放定址法  线性探测法：key 相同 - 放到 key 的下一个位置，Hi = (H(key) + i) % m 二次探测法：key 相同 - 放到 Di = 1^2, -1^2, ..., ±（k)^2,(k 随机探测法：H = (H(key) + 伪随机数) % m    线性探测的哈希表数据结构 线性探测的哈希表数据结构和图片\ntypedef char KeyType; typedef struct { KeyType key; }RcdType; typedef struct { RcdType *rcd; int size; int count; bool *tag; }HashTable; 递归 概念 函数直接或间接地调用自身\n递归与分治  分治法  问题的分解 问题规模的分解   折半查找（递归） 归并排序（递归） 快速排序（递归）  递归与迭代  迭代：反复利用变量旧值推出新值 折半查找（迭代） 归并排序（迭代）  广义表 头尾链表存储表示 广义表的头尾链表存储表示和图片\n// 广义表的头尾链表存储表示 typedef enum {ATOM, LIST} ElemTag; // ATOM==0：原子，LIST==1：子表 typedef struct GLNode { ElemTag tag; // 公共部分，用于区分原子结点和表结点  union { // 原子结点和表结点的联合部分  AtomType atom; // atom 是原子结点的值域，AtomType 由用户定义  struct { struct GLNode *hp, *tp; } ptr; // ptr 是表结点的指针域，prt.hp 和 ptr.tp 分别指向表头和表尾  } a; } *GList, GLNode; 扩展线性链表存储表示 扩展线性链表存储表示和图片\n// 广义表的扩展线性链表存储表示 typedef enum {ATOM, LIST} ElemTag; // ATOM==0：原子，LIST==1：子表 typedef struct GLNode1 { ElemTag tag; // 公共部分，用于区分原子结点和表结点  union { // 原子结点和表结点的联合部分  AtomType atom; // 原子结点的值域  struct GLNode1 *hp; // 表结点的表头指针  } a; struct GLNode1 *tp; // 相当于线性链表的 next，指向下一个元素结点 } *GList1, GLNode1; 二叉树 BinaryTree.cpp\n性质  非空二叉树第 i 层最多 2(i-1) 个结点 （i = 1） 深度为 k 的二叉树最多 2k - 1 个结点 （k = 1） 度为 0 的结点数为 n0，度为 2 的结点数为 n2，则 n0 = n2 + 1 有 n 个结点的完全二叉树深度 k = ⌊ log2(n) ⌋ + 1 对于含 n 个结点的完全二叉树中编号为 i （1 若 i = 1，为根，否则双亲为 ⌊ i / 2 ⌋ 若 2i  n，则 i 结点没有左孩子，否则孩子编号为 2i 若 2i + 1  n，则 i 结点没有右孩子，否则孩子编号为 2i + 1    存储结构 二叉树数据结构\ntypedef struct BiTNode { TElemType data; struct BiTNode *lchild, *rchild; }BiTNode, *BiTree; 顺序存储 二叉树顺序存储图片\n链式存储 二叉树链式存储图片\n遍历方式  先序遍历 中序遍历 后续遍历 层次遍历  分类  满二叉树 完全二叉树（堆）  大顶堆：根 = 左 \u0026\u0026 根 = 右 小顶堆：根   二叉查找树（二叉排序树）：左 平衡二叉树（AVL树）：| 左子树树高 - 右子树树高 | 最小失衡树：平衡二叉树插入新结点导致失衡的子树：调整：  LL型：根的左孩子右旋 RR型：根的右孩子左旋 LR型：根的左孩子左旋，再右旋 RL型：右孩子的左子树，先右旋，再左旋    其他树及森林 树的存储结构  双亲表示法 双亲孩子表示法 孩子兄弟表示法  并查集 一种不相交的子集所构成的集合 S = {S1, S2, …, Sn}\n平衡二叉树（AVL树） 性质  | 左子树树高 - 右子树树高 | 平衡二叉树必定是二叉搜索树，反之则不一定 最小二叉平衡树的节点的公式：F(n)=F(n-1)+F(n-2)+1 （1 是根节点，F(n-1) 是左子树的节点数量，F(n-2) 是右子树的节点数量）  平衡二叉树图片\n最小失衡树 平衡二叉树插入新结点导致失衡的子树\n调整：\n LL 型：根的左孩子右旋 RR 型：根的右孩子左旋 LR 型：根的左孩子左旋，再右旋 RL 型：右孩子的左子树，先右旋，再左旋  红黑树 RedBlackTree.cpp\n红黑树的特征是什么？  节点是红色或黑色。 根是黑色。 所有叶子都是黑色（叶子是 NIL 节点）。 每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）（新增节点的父节点必须相同） 从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。（新增节点必须为红）  调整  变色 左旋 右旋  应用  关联数组：如 STL 中的 map、set  红黑树、B 树、B+ 树的区别？  红黑树的深度比较大，而 B 树和 B+ 树的深度则相对要小一些 B+ 树则将数据都保存在叶子节点，同时通过链表的形式将他们连接在一起。  B 树（B-tree）、B+ 树（B+-tree） B 树、B+ 树图片\n特点  一般化的二叉查找树（binary search tree） “矮胖”，内部（非叶子）节点可以拥有可变数量的子节点（数量范围预先定义好）  应用  大部分文件系统、数据库系统都采用B树、B+树作为索引结构  区别  B+树中只有叶子节点会带有指向记录的指针（ROWID），而B树则所有节点都带有，在内部节点出现的索引项不会再出现在叶子节点中。 B+树中所有叶子节点都是通过指针连接在一起，而B树不会。  B树的优点 对于在内部节点的数据，可直接得到，不必根据叶子节点来定位。\nB+树的优点  非叶子节点不会带上 ROWID，这样，一个块中可以容纳更多的索引项，一是可以降低树的高度。二是一个内部节点可以定位更多的叶子节点。 叶子节点之间通过指针来连接，范围扫描将十分简单，而对于B树来说，则需要在叶子节点和内部节点不停的往返移动。   B 树、B+ 树区别来自：differences-between-b-trees-and-b-trees、B树和B+树的区别\n 八叉树 八叉树图片\n八叉树（octree），或称八元树，是一种用于描述三维空间（划分空间）的树状数据结构。八叉树的每个节点表示一个正方体的体积元素，每个节点有八个子节点，这八个子节点所表示的体积元素加在一起就等于父节点的体积。一般中心点作为节点的分叉中心。\n用途  三维计算机图形 最邻近搜索  ",
  "wordCount" : "2447",
  "inLanguage": "en",
  "datePublished": "2022-01-14T20:28:54+08:00",
  "dateModified": "2022-01-14T20:28:54+08:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/collection/data-structure/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "罗泽勋",
    "logo": {
      "@type": "ImageObject",
      "url": "/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="/" accesskey="h" title="罗泽勋 (Alt + H)">罗泽勋</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                    <li>
                        <a href="/cn/" title="中文"
                            aria-label="中文">Cn</a>
                    </li>
                </ul>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="/blog/" title="Blog">
                    <span>Blog</span>
                </a>
            </li>
            <li>
                <a href="/about" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="/post/" title="Program">
                    <span>Program</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      【转载】C&#43;&#43; 开发必备之数据结构
    </h1>
    <div class="post-meta"><span title='2022-01-14 20:28:54 +0800 CST'>January 14, 2022</span>

</div>
  </header> 
  <div class="post-content"><p>转载自<a href="https://github.com/huihut/interview">https://github.com/huihut/interview</a></p>
<h3 id="顺序结构">顺序结构<a hidden class="anchor" aria-hidden="true" href="#顺序结构">#</a></h3>
<h4 id="顺序栈sequence-stack">顺序栈（Sequence Stack）<a hidden class="anchor" aria-hidden="true" href="#顺序栈sequence-stack">#</a></h4>
<p><a href="https://github.com/huihut/interview/blob/master/DataStructure/SqStack.cpp">SqStack.cpp</a></p>
<p>顺序栈数据结构和图片</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">ElemType</span> <span class="o">*</span><span class="n">elem</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">top</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">increment</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">SqStack</span><span class="p">;</span>
</span></span></code></pre></div><p><img loading="lazy" src="https://gitee.com/huihut/interview/raw/master/images/SqStack.png" alt=""  />
</p>
<h4 id="队列sequence-queue">队列（Sequence Queue）<a hidden class="anchor" aria-hidden="true" href="#队列sequence-queue">#</a></h4>
<p>队列数据结构</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">ElemType</span> <span class="o">*</span> <span class="n">elem</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">front</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">rear</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">maxSize</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span><span class="n">SqQueue</span><span class="p">;</span>
</span></span></code></pre></div><h5 id="非循环队列">非循环队列<a hidden class="anchor" aria-hidden="true" href="#非循环队列">#</a></h5>
<p>非循环队列图片</p>
<p><img loading="lazy" src="https://gitee.com/huihut/interview/raw/master/images/SqQueue.png" alt=""  />
</p>
<p><code>SqQueue.rear++</code></p>
<h5 id="循环队列">循环队列<a hidden class="anchor" aria-hidden="true" href="#循环队列">#</a></h5>
<p>循环队列图片</p>
<p><img loading="lazy" src="https://gitee.com/huihut/interview/raw/master/images/SqLoopStack.png" alt=""  />
</p>
<p><code>SqQueue.rear = (SqQueue.rear + 1) % SqQueue.maxSize</code></p>
<h4 id="顺序表sequence-list">顺序表（Sequence List）<a hidden class="anchor" aria-hidden="true" href="#顺序表sequence-list">#</a></h4>
<p><a href="https://github.com/huihut/interview/blob/master/DataStructure/SqList.cpp">SqList.cpp</a></p>
<p>顺序表数据结构和图片</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">ElemType</span> <span class="o">*</span><span class="n">elem</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">length</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">increment</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">SqList</span><span class="p">;</span>
</span></span></code></pre></div><p><img loading="lazy" src="https://gitee.com/huihut/interview/raw/master/images/SqList.png" alt=""  />
</p>
<h3 id="链式结构">链式结构<a hidden class="anchor" aria-hidden="true" href="#链式结构">#</a></h3>
<p><a href="https://github.com/huihut/interview/blob/master/DataStructure/LinkList.cpp">LinkList.cpp</a></p>
<p><a href="https://github.com/huihut/interview/blob/master/DataStructure/LinkList_with_head.cpp">LinkList_with_head.cpp</a></p>
<p>链式数据结构</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">LNode</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">ElemType</span> <span class="n">data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="nc">LNode</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">LNode</span><span class="p">,</span> <span class="o">*</span><span class="n">LinkList</span><span class="p">;</span> 
</span></span></code></pre></div><h4 id="链队列link-queue">链队列（Link Queue）<a hidden class="anchor" aria-hidden="true" href="#链队列link-queue">#</a></h4>
<p>链队列图片</p>
<p><img loading="lazy" src="https://gitee.com/huihut/interview/raw/master/images/LinkQueue.png" alt=""  />
</p>
<h4 id="线性表的链式表示">线性表的链式表示<a hidden class="anchor" aria-hidden="true" href="#线性表的链式表示">#</a></h4>
<h5 id="单链表link-list">单链表（Link List）<a hidden class="anchor" aria-hidden="true" href="#单链表link-list">#</a></h5>
<p>单链表图片</p>
<p><img loading="lazy" src="https://gitee.com/huihut/interview/raw/master/images/LinkList.png" alt=""  />
</p>
<h5 id="双向链表du-link-list">双向链表（Du-Link-List）<a hidden class="anchor" aria-hidden="true" href="#双向链表du-link-list">#</a></h5>
<p>双向链表图片</p>
<p><img loading="lazy" src="https://gitee.com/huihut/interview/raw/master/images/DuLinkList.png" alt=""  />
</p>
<h5 id="循环链表cir-link-list">循环链表（Cir-Link-List）<a hidden class="anchor" aria-hidden="true" href="#循环链表cir-link-list">#</a></h5>
<p>循环链表图片</p>
<p><img loading="lazy" src="https://gitee.com/huihut/interview/raw/master/images/CirLinkList.png" alt=""  />
</p>
<h3 id="哈希表">哈希表<a hidden class="anchor" aria-hidden="true" href="#哈希表">#</a></h3>
<p><a href="https://github.com/huihut/interview/blob/master/DataStructure/HashTable.cpp">HashTable.cpp</a></p>
<h4 id="概念">概念<a hidden class="anchor" aria-hidden="true" href="#概念">#</a></h4>
<p>哈希函数：<code>H(key): K -&gt; D , key ∈ K</code></p>
<h4 id="构造方法">构造方法<a hidden class="anchor" aria-hidden="true" href="#构造方法">#</a></h4>
<ul>
<li>直接定址法</li>
<li>除留余数法</li>
<li>数字分析法</li>
<li>折叠法</li>
<li>平方取中法</li>
</ul>
<h4 id="冲突处理方法">冲突处理方法<a hidden class="anchor" aria-hidden="true" href="#冲突处理方法">#</a></h4>
<ul>
<li>链地址法：key 相同的用单链表链接</li>
<li>开放定址法
<ul>
<li>线性探测法：key 相同 -&gt; 放到 key 的下一个位置，<code>Hi = (H(key) + i) % m</code></li>
<li>二次探测法：key 相同 -&gt; 放到 <code>Di = 1^2, -1^2, ..., ±（k)^2,(k&lt;=m/2）</code></li>
<li>随机探测法：<code>H = (H(key) + 伪随机数) % m</code></li>
</ul>
</li>
</ul>
<h4 id="线性探测的哈希表数据结构">线性探测的哈希表数据结构<a hidden class="anchor" aria-hidden="true" href="#线性探测的哈希表数据结构">#</a></h4>
<p>线性探测的哈希表数据结构和图片</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="kt">char</span> <span class="n">KeyType</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">KeyType</span> <span class="n">key</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span><span class="n">RcdType</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">RcdType</span> <span class="o">*</span><span class="n">rcd</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">bool</span> <span class="o">*</span><span class="n">tag</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span><span class="n">HashTable</span><span class="p">;</span>
</span></span></code></pre></div><p><img loading="lazy" src="https://gitee.com/huihut/interview/raw/master/images/HashTable.png" alt=""  />
</p>
<h3 id="递归">递归<a hidden class="anchor" aria-hidden="true" href="#递归">#</a></h3>
<h4 id="概念-1">概念<a hidden class="anchor" aria-hidden="true" href="#概念-1">#</a></h4>
<p>函数直接或间接地调用自身</p>
<h4 id="递归与分治">递归与分治<a hidden class="anchor" aria-hidden="true" href="#递归与分治">#</a></h4>
<ul>
<li>分治法
<ul>
<li>问题的分解</li>
<li>问题规模的分解</li>
</ul>
</li>
<li>折半查找（递归）</li>
<li>归并排序（递归）</li>
<li>快速排序（递归）</li>
</ul>
<h4 id="递归与迭代">递归与迭代<a hidden class="anchor" aria-hidden="true" href="#递归与迭代">#</a></h4>
<ul>
<li>迭代：反复利用变量旧值推出新值</li>
<li>折半查找（迭代）</li>
<li>归并排序（迭代）</li>
</ul>
<h4 id="广义表">广义表<a hidden class="anchor" aria-hidden="true" href="#广义表">#</a></h4>
<h5 id="头尾链表存储表示">头尾链表存储表示<a hidden class="anchor" aria-hidden="true" href="#头尾链表存储表示">#</a></h5>
<p>广义表的头尾链表存储表示和图片</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// 广义表的头尾链表存储表示
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span><span class="n">ATOM</span><span class="p">,</span> <span class="n">LIST</span><span class="p">}</span> <span class="n">ElemTag</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// ATOM==0：原子，LIST==1：子表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">GLNode</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">ElemTag</span> <span class="n">tag</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 公共部分，用于区分原子结点和表结点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">union</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 原子结点和表结点的联合部分
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">AtomType</span> <span class="n">atom</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// atom 是原子结点的值域，AtomType 由用户定义
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">struct</span> <span class="nc">GLNode</span> <span class="o">*</span><span class="n">hp</span><span class="p">,</span> <span class="o">*</span><span class="n">tp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="n">ptr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// ptr 是表结点的指针域，prt.hp 和 ptr.tp 分别指向表头和表尾
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="o">*</span><span class="n">GList</span><span class="p">,</span> <span class="n">GLNode</span><span class="p">;</span>
</span></span></code></pre></div><p><img loading="lazy" src="https://gitee.com/huihut/interview/raw/master/images/GeneralizedList1.png" alt=""  />
</p>
<h5 id="扩展线性链表存储表示">扩展线性链表存储表示<a hidden class="anchor" aria-hidden="true" href="#扩展线性链表存储表示">#</a></h5>
<p>扩展线性链表存储表示和图片</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// 广义表的扩展线性链表存储表示
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span><span class="n">ATOM</span><span class="p">,</span> <span class="n">LIST</span><span class="p">}</span> <span class="n">ElemTag</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// ATOM==0：原子，LIST==1：子表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">GLNode1</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">ElemTag</span> <span class="n">tag</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 公共部分，用于区分原子结点和表结点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">union</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 原子结点和表结点的联合部分
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">AtomType</span> <span class="n">atom</span><span class="p">;</span> <span class="c1">// 原子结点的值域
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">struct</span> <span class="nc">GLNode1</span> <span class="o">*</span><span class="n">hp</span><span class="p">;</span> <span class="c1">// 表结点的表头指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="nc">GLNode1</span> <span class="o">*</span><span class="n">tp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 相当于线性链表的 next，指向下一个元素结点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span> <span class="o">*</span><span class="n">GList1</span><span class="p">,</span> <span class="n">GLNode1</span><span class="p">;</span>
</span></span></code></pre></div><p><img loading="lazy" src="https://gitee.com/huihut/interview/raw/master/images/GeneralizedList2.png" alt=""  />
</p>
<h3 id="二叉树">二叉树<a hidden class="anchor" aria-hidden="true" href="#二叉树">#</a></h3>
<p><a href="https://github.com/huihut/interview/blob/master/DataStructure/BinaryTree.cpp">BinaryTree.cpp</a></p>
<h4 id="性质">性质<a hidden class="anchor" aria-hidden="true" href="#性质">#</a></h4>
<ol>
<li>非空二叉树第 i 层最多 2<sup>(i-1)</sup> 个结点 （i &gt;= 1）</li>
<li>深度为 k 的二叉树最多 2<sup>k</sup> - 1 个结点 （k &gt;= 1）</li>
<li>度为 0 的结点数为 n<sub>0</sub>，度为 2 的结点数为 n<sub>2</sub>，则 n<sub>0</sub> = n<sub>2</sub> + 1</li>
<li>有 n 个结点的完全二叉树深度 k = ⌊ log<sub>2</sub>(n) ⌋ + 1</li>
<li>对于含 n 个结点的完全二叉树中编号为 i （1 &lt;= i &lt;= n） 的结点
<ol>
<li>若 i = 1，为根，否则双亲为 ⌊ i / 2 ⌋</li>
<li>若 2i &gt; n，则 i 结点没有左孩子，否则孩子编号为 2i</li>
<li>若 2i + 1 &gt; n，则 i 结点没有右孩子，否则孩子编号为 2i + 1</li>
</ol>
</li>
</ol>
<h4 id="存储结构">存储结构<a hidden class="anchor" aria-hidden="true" href="#存储结构">#</a></h4>
<p>二叉树数据结构</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">BiTNode</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">TElemType</span> <span class="n">data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="nc">BiTNode</span> <span class="o">*</span><span class="n">lchild</span><span class="p">,</span> <span class="o">*</span><span class="n">rchild</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span><span class="n">BiTNode</span><span class="p">,</span> <span class="o">*</span><span class="n">BiTree</span><span class="p">;</span>
</span></span></code></pre></div><h5 id="顺序存储">顺序存储<a hidden class="anchor" aria-hidden="true" href="#顺序存储">#</a></h5>
<p>二叉树顺序存储图片</p>
<p><img loading="lazy" src="https://gitee.com/huihut/interview/raw/master/images/SqBinaryTree.png" alt=""  />
</p>
<h5 id="链式存储">链式存储<a hidden class="anchor" aria-hidden="true" href="#链式存储">#</a></h5>
<p>二叉树链式存储图片</p>
<p><img loading="lazy" src="https://gitee.com/huihut/interview/raw/master/images/LinkBinaryTree.png" alt=""  />
</p>
<h4 id="遍历方式">遍历方式<a hidden class="anchor" aria-hidden="true" href="#遍历方式">#</a></h4>
<ul>
<li>先序遍历</li>
<li>中序遍历</li>
<li>后续遍历</li>
<li>层次遍历</li>
</ul>
<h4 id="分类">分类<a hidden class="anchor" aria-hidden="true" href="#分类">#</a></h4>
<ul>
<li>满二叉树</li>
<li>完全二叉树（堆）
<ul>
<li>大顶堆：根 &gt;= 左 &amp;&amp; 根 &gt;= 右</li>
<li>小顶堆：根 &lt;= 左 &amp;&amp; 根 &lt;= 右</li>
</ul>
</li>
<li>二叉查找树（二叉排序树）：左 &lt; 根 &lt; 右</li>
<li>平衡二叉树（AVL树）：| 左子树树高 - 右子树树高 | &lt;= 1</li>
<li>最小失衡树：平衡二叉树插入新结点导致失衡的子树：调整：
<ul>
<li>LL型：根的左孩子右旋</li>
<li>RR型：根的右孩子左旋</li>
<li>LR型：根的左孩子左旋，再右旋</li>
<li>RL型：右孩子的左子树，先右旋，再左旋</li>
</ul>
</li>
</ul>
<h3 id="其他树及森林">其他树及森林<a hidden class="anchor" aria-hidden="true" href="#其他树及森林">#</a></h3>
<h4 id="树的存储结构">树的存储结构<a hidden class="anchor" aria-hidden="true" href="#树的存储结构">#</a></h4>
<ul>
<li>双亲表示法</li>
<li>双亲孩子表示法</li>
<li>孩子兄弟表示法</li>
</ul>
<h4 id="并查集">并查集<a hidden class="anchor" aria-hidden="true" href="#并查集">#</a></h4>
<p>一种不相交的子集所构成的集合 S = {S1, S2, &hellip;, Sn}</p>
<h4 id="平衡二叉树avl树">平衡二叉树（AVL树）<a hidden class="anchor" aria-hidden="true" href="#平衡二叉树avl树">#</a></h4>
<h5 id="性质-1">性质<a hidden class="anchor" aria-hidden="true" href="#性质-1">#</a></h5>
<ul>
<li>| 左子树树高 - 右子树树高 | &lt;= 1</li>
<li>平衡二叉树必定是二叉搜索树，反之则不一定</li>
<li>最小二叉平衡树的节点的公式：<code>F(n)=F(n-1)+F(n-2)+1</code> （1 是根节点，F(n-1) 是左子树的节点数量，F(n-2) 是右子树的节点数量）</li>
</ul>
<p>平衡二叉树图片</p>
<p><img loading="lazy" src="https://gitee.com/huihut/interview/raw/master/images/Self-balancingBinarySearchTree.png" alt=""  />
</p>
<h5 id="最小失衡树">最小失衡树<a hidden class="anchor" aria-hidden="true" href="#最小失衡树">#</a></h5>
<p>平衡二叉树插入新结点导致失衡的子树</p>
<p>调整：</p>
<ul>
<li>LL 型：根的左孩子右旋</li>
<li>RR 型：根的右孩子左旋</li>
<li>LR 型：根的左孩子左旋，再右旋</li>
<li>RL 型：右孩子的左子树，先右旋，再左旋</li>
</ul>
<h4 id="红黑树">红黑树<a hidden class="anchor" aria-hidden="true" href="#红黑树">#</a></h4>
<p><a href="https://github.com/huihut/interview/blob/master/DataStructure/RedBlackTree.cpp">RedBlackTree.cpp</a></p>
<h5 id="红黑树的特征是什么">红黑树的特征是什么？<a hidden class="anchor" aria-hidden="true" href="#红黑树的特征是什么">#</a></h5>
<ol>
<li>节点是红色或黑色。</li>
<li>根是黑色。</li>
<li>所有叶子都是黑色（叶子是 NIL 节点）。</li>
<li>每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）（新增节点的父节点必须相同）</li>
<li>从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。（新增节点必须为红）</li>
</ol>
<h5 id="调整">调整<a hidden class="anchor" aria-hidden="true" href="#调整">#</a></h5>
<ol>
<li>变色</li>
<li>左旋</li>
<li>右旋</li>
</ol>
<h5 id="应用">应用<a hidden class="anchor" aria-hidden="true" href="#应用">#</a></h5>
<ul>
<li>关联数组：如 STL 中的 map、set</li>
</ul>
<h5 id="红黑树b-树b-树的区别">红黑树、B 树、B+ 树的区别？<a hidden class="anchor" aria-hidden="true" href="#红黑树b-树b-树的区别">#</a></h5>
<ul>
<li>红黑树的深度比较大，而 B 树和 B+ 树的深度则相对要小一些</li>
<li>B+ 树则将数据都保存在叶子节点，同时通过链表的形式将他们连接在一起。</li>
</ul>
<h4 id="b-树b-treeb-树b-tree">B 树（B-tree）、B+ 树（B+-tree）<a hidden class="anchor" aria-hidden="true" href="#b-树b-treeb-树b-tree">#</a></h4>
<p>B 树、B+ 树图片</p>
<p><img loading="lazy" src="https://i.stack.imgur.com/l6UyF.png" alt="B 树（B-tree）、B&#43; 树（B&#43;-tree）"  />
</p>
<h5 id="特点">特点<a hidden class="anchor" aria-hidden="true" href="#特点">#</a></h5>
<ul>
<li>一般化的二叉查找树（binary search tree）</li>
<li>“矮胖”，内部（非叶子）节点可以拥有可变数量的子节点（数量范围预先定义好）</li>
</ul>
<h5 id="应用-1">应用<a hidden class="anchor" aria-hidden="true" href="#应用-1">#</a></h5>
<ul>
<li>大部分文件系统、数据库系统都采用B树、B+树作为索引结构</li>
</ul>
<h5 id="区别">区别<a hidden class="anchor" aria-hidden="true" href="#区别">#</a></h5>
<ul>
<li>B+树中只有叶子节点会带有指向记录的指针（ROWID），而B树则所有节点都带有，在内部节点出现的索引项不会再出现在叶子节点中。</li>
<li>B+树中所有叶子节点都是通过指针连接在一起，而B树不会。</li>
</ul>
<h5 id="b树的优点">B树的优点<a hidden class="anchor" aria-hidden="true" href="#b树的优点">#</a></h5>
<p>对于在内部节点的数据，可直接得到，不必根据叶子节点来定位。</p>
<h5 id="b树的优点-1">B+树的优点<a hidden class="anchor" aria-hidden="true" href="#b树的优点-1">#</a></h5>
<ul>
<li>非叶子节点不会带上 ROWID，这样，一个块中可以容纳更多的索引项，一是可以降低树的高度。二是一个内部节点可以定位更多的叶子节点。</li>
<li>叶子节点之间通过指针来连接，范围扫描将十分简单，而对于B树来说，则需要在叶子节点和内部节点不停的往返移动。</li>
</ul>
<blockquote>
<p>B 树、B+ 树区别来自：<a href="https://stackoverflow.com/questions/870218/differences-between-b-trees-and-b-trees">differences-between-b-trees-and-b-trees</a>、<a href="https://www.cnblogs.com/ivictor/p/5849061.html">B树和B+树的区别</a></p>
</blockquote>
<h4 id="八叉树">八叉树<a hidden class="anchor" aria-hidden="true" href="#八叉树">#</a></h4>
<p>八叉树图片</p>
<p><img loading="lazy" src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/35/Octree2.png/400px-Octree2.png" alt=""  />
</p>
<p>八叉树（octree），或称八元树，是一种用于描述三维空间（划分空间）的树状数据结构。八叉树的每个节点表示一个正方体的体积元素，每个节点有八个子节点，这八个子节点所表示的体积元素加在一起就等于父节点的体积。一般中心点作为节点的分叉中心。</p>
<h5 id="用途">用途<a hidden class="anchor" aria-hidden="true" href="#用途">#</a></h5>
<ul>
<li>三维计算机图形</li>
<li>最邻近搜索</li>
</ul>


  </div>

  <footer class="post-footer">
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2022 <a href="/">罗泽勋</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
